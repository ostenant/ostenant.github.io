<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Icarus&#39;s Blog</title>
  
  <subtitle>上善若水任方猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ostenant.coding.me/"/>
  <updated>2018-08-04T02:43:52.468Z</updated>
  <id>https://ostenant.coding.me/</id>
  
  <author>
    <name>Chen Icarus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM系列(六) - JVM垃圾回收器</title>
    <link href="https://ostenant.coding.me/2018/08/03/JVM%E7%B3%BB%E5%88%97(%E5%85%AD)%20-%20JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://ostenant.coding.me/2018/08/03/JVM系列(六) - JVM垃圾回收器/</id>
    <published>2018-08-02T22:58:00.000Z</published>
    <updated>2018-08-04T02:43:52.468Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的几篇博客中，我们大致介绍了，常见的 <strong>垃圾回收算法</strong> 及 <code>JVM</code> 中常见的分类回收算法。这些都是从算法和规范上分析 <code>Java</code> 中的垃圾回收，属于方法论。在 <code>JVM</code> 中，垃圾回收的具体实现是由 <strong>垃圾回收器</strong>（<code>Garbage Collector</code>）负责。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/JVM.jpg" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在了解 <strong>垃圾回收器</strong> 之前，首先得了解一下垃圾回收器的几个名词。</p><h3 id="1-吞吐量"><a href="#1-吞吐量" class="headerlink" title="1. 吞吐量"></a>1. 吞吐量</h3><p><code>CPU</code> 用于运行用户代码的时间与 <code>CPU</code> 总消耗时间的比值。比如说虚拟机总运行了 <code>100</code> 分钟，<strong>用户代码</strong> 时间 <code>99</code> 分钟，<strong>垃圾回收</strong> 时间 <code>1</code> 分钟，那么吞吐量就是 <code>99%</code>。</p><blockquote><p>吞吐量 = 运行用户代码时间/（运行用户代码时间 + 垃圾回收时间）</p></blockquote><h3 id="2-停顿时间"><a href="#2-停顿时间" class="headerlink" title="2. 停顿时间"></a>2. 停顿时间</h3><p><strong>停顿时间</strong> 指垃圾回收器正在运行时，<strong>应用程序</strong> 的 <strong>暂停时间</strong>。对于 <strong>独占回收器</strong> 而言，停顿时间可能会比较长。使用 <strong>并发回收器</strong> 时，由于垃圾回收器和应用程序 <strong>交替运行</strong>，程序的 <strong>停顿时间</strong> 会变短，但是，由于其 <strong>效率</strong> 很可能不如独占垃圾回收器，故系统的 <strong>吞吐量</strong> 可能会较低。</p><h3 id="3-GC的名词"><a href="#3-GC的名词" class="headerlink" title="3. GC的名词"></a>3. GC的名词</h3><h4 id="3-1-新生代GC（Minor-GC）"><a href="#3-1-新生代GC（Minor-GC）" class="headerlink" title="3.1. 新生代GC（Minor GC）"></a>3.1. 新生代GC（Minor GC）</h4><p>指发生在 <strong>新生代</strong> 的垃圾回收动作，因为 <code>Java</code> 对象大多都具备 <strong>朝生夕死</strong> 的特性，所以 <code>Minor GC</code> 通常 <strong>非常频繁</strong>，一般回收速度也比较快。</p><h4 id="3-2-老年代GC（Major-GC）"><a href="#3-2-老年代GC（Major-GC）" class="headerlink" title="3.2. 老年代GC（Major GC）"></a>3.2. 老年代GC（Major GC）</h4><p>指发生在 <strong>老年代</strong> 的垃圾回收动作，出现了 <code>Major GC</code>，经常会伴随至少一次的 <code>Minor GC</code>（发生这种情况，那么 <strong>整个堆</strong> 都 <code>GC</code> 一遍，通常称为 <code>Full GC</code>）。<code>Major GC</code> 的速度一般会比 <code>Minor GC</code> 慢 <code>10</code> 倍以上。</p><h3 id="4-并发与并行"><a href="#4-并发与并行" class="headerlink" title="4. 并发与并行"></a>4. 并发与并行</h3><h4 id="4-1-串行（Parallel）"><a href="#4-1-串行（Parallel）" class="headerlink" title="4.1. 串行（Parallel）"></a>4.1. 串行（Parallel）</h4><p><strong>单线程</strong> 进行垃圾回收工作，但此时 <strong>用户线程</strong> 仍然处于 <strong>等待状态</strong>。</p><h4 id="4-2-并发（Concurrent）"><a href="#4-2-并发（Concurrent）" class="headerlink" title="4.2. 并发（Concurrent）"></a>4.2. 并发（Concurrent）</h4><p>这里的并发指 <strong>用户线程</strong> 与 <strong>垃圾回收线程</strong> 交替执行。</p><h4 id="4-3-并行（Parallel）"><a href="#4-3-并行（Parallel）" class="headerlink" title="4.3. 并行（Parallel）"></a>4.3. 并行（Parallel）</h4><p>这里的并行指 <strong>用户线程</strong> 和多条 <strong>垃圾回收线程</strong> 分别在不同 <code>CPU</code> 上同时工作。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-根搜索算法"><a href="#1-根搜索算法" class="headerlink" title="1. 根搜索算法"></a>1. 根搜索算法</h3><p><strong>根搜索算法</strong> 是从 <strong>离散数学</strong> 中的图论引入的，程序把所有引用关系看作一张图，从一个节点 <code>GC ROOT</code> 开始，寻找对应的 <strong>引用节点</strong>，找到这个节点后，继续寻找 <strong>这个节点</strong> 的 <strong>引用节点</strong>。当所有的引用节点寻找完毕后，<strong>剩余的节点</strong> 则被认为是 <strong>没有被引用到</strong> 的节点，即 <strong>无用</strong> 的节点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b876b28f6?w=720&amp;h=281&amp;f=jpeg&amp;s=24288" alt=""></p><p>上图 <strong>红色</strong> 为无用的节点，可以被 <strong>回收</strong>。目前 <code>Java</code> 中可以作为 <code>GC ROOT</code> 的对象有：</p><ol><li><p><strong>虚拟机栈</strong> 中引用的对象（本地变量表）；</p></li><li><p><strong>方法区</strong> 中 <strong>静态变量</strong> 引用的对象；</p></li><li><p><strong>方法区</strong> 中 <strong>常量</strong> 引用的对象；</p></li><li><p><strong>本地方法栈</strong> 中引用的对象（<code>Native</code> 对象）。</p></li></ol><blockquote><p>基本所有 <code>GC</code> 算法都引用 <strong>根搜索算法</strong> 这种概念。</p></blockquote><h3 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记 - 清除算法"></a>2. 标记 - 清除算法</h3><p><strong>标记-清除算法</strong> 从 <strong>根集合</strong> 进行扫描，对 <strong>存活的对象</strong> 进行 <strong>标记</strong>。标记完毕后，再扫描整个空间中 <strong>未被标记</strong> 的对象进行 <strong>直接回收</strong>，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b87f0e86b?w=720&amp;h=457&amp;f=jpeg&amp;s=40109" alt=""></p><p><strong>标记-清除算法</strong> 不需要进行 <strong>对象的移动</strong>，并且仅对 <strong>不存活</strong> 的对象进行处理，在 <strong>存活</strong> 的对象 <strong>比较多</strong> 的情况下 <strong>极为高效</strong>。但由于 <strong>标记-清除算法</strong> 直接回收不存活的对象，并没有对还存活的对象进行 <strong>整理</strong>，因此会导致 <strong>内存碎片</strong>。</p><h3 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3. 复制算法"></a>3. 复制算法</h3><p><strong>复制算法</strong> 将内存划分为 <strong>两个区间</strong>，使用此算法时，所有 <strong>动态分配</strong> 的对象都只能分配在 <strong>其中一个</strong> 区间（<strong>活动区间</strong>），而 <strong>另外一个</strong> 区间（<strong>空间区间</strong>）则是 <strong>空闲</strong> 的。</p><p><strong>复制算法</strong> 同样从 <strong>根集合</strong> 扫描，将 <strong>存活</strong> 的对象 <strong>复制</strong> 到 <strong>空闲区间</strong>。当扫描完毕活动区间后，会的将 <strong>活动区间</strong> 一次性全部 <strong>回收</strong>。此时原本的 <strong>空闲区间</strong> 变成了 <strong>活动区间</strong>。下次 <code>GC</code> 时候又会重复刚才的操作，以此循环。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b885c24bf?w=720&amp;h=379&amp;f=jpeg&amp;s=31098" alt=""></p><p><strong>复制算法</strong> 在存活对象 <strong>比较少</strong> 的时候，极为高效，但是带来的成本是 <strong>牺牲一半的内存空间</strong> 用于进行 <strong>对象的移动</strong>。所以 <strong>复制算法</strong> 的使用场景，必须是对象的 <strong>存活率非常低</strong> 才行。最重要的是，我们需要克服 <code>50%</code> 的 <strong>内存浪费</strong>。</p><h3 id="4-标记-整理算法"><a href="#4-标记-整理算法" class="headerlink" title="4. 标记 - 整理算法"></a>4. 标记 - 整理算法</h3><p><strong>标记-整理算法</strong> 采用 <strong>标记-清除算法</strong> 一样的方式进行对象的 <strong>标记</strong>，但在回收 <strong>不存活的对象</strong> 占用的空间后，会将所有 <strong>存活的对象</strong> 往 左端空闲空间 <strong>移动</strong>，并更新对应的指针。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb0960af8?w=720&amp;h=539&amp;f=jpeg&amp;s=53137" alt=""></p><p><strong>标记-整理</strong> 是在 <strong>标记-清除</strong> 之上，又进行了 <strong>对象的移动排序整理</strong>，因此 <strong>成本更高</strong>，但却解决了 <strong>内存碎片</strong> 的问题。</p><blockquote><p><code>JVM</code> 为了 <strong>优化内存</strong> 的回收，使用了 <strong>分代回收</strong> 的方式。对于 <strong>新生代内存</strong> 的回收（<code>Minor GC</code>）主要采用 <strong>复制算法</strong>。而对于 <strong>老年代内存</strong> 的回收（<code>Major GC</code>），大多采用 <strong>标记-整理算法</strong>。</p></blockquote><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="1-垃圾回收器分类标准"><a href="#1-垃圾回收器分类标准" class="headerlink" title="1. 垃圾回收器分类标准"></a>1. 垃圾回收器分类标准</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b8a61ea51?w=720&amp;h=299&amp;f=jpeg&amp;s=34991" alt=""></p><h3 id="2-七种垃圾回收器概述"><a href="#2-七种垃圾回收器概述" class="headerlink" title="2. 七种垃圾回收器概述"></a>2. 七种垃圾回收器概述</h3><p>在 <code>JVM</code> 中，具体实现有 <code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>CMS</code>、<code>Serial Old（MSC）</code>、<code>Parallel Old</code>、<code>G1</code> 等。在下图中，你可以看到 <strong>不同垃圾回收器</strong> 适合于 <strong>不同的内存区域</strong>，如果两个垃圾回收器之间 <strong>存在连线</strong>，那么表示两者可以 <strong>配合使用</strong>。</p><p>如果当 <strong>垃圾回收器</strong> 进行垃圾清理时，必须 <strong>暂停</strong> 其他所有的 <strong>工作线程</strong>，直到它完全收集结束。我们称这种需要暂停工作线程才能进行清理的策略为 <code>Stop-the-World</code>。以上回收器中，   <code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Serial Old</code>、<code>Parallel Old</code> 均采用的是 <code>Stop-the-World</code> 的策略。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bd1ebf8c4?w=547&amp;h=374&amp;f=jpeg&amp;s=19750" alt=""></p><p>图中有 <code>7</code> 种不同的 <strong>垃圾回收器</strong>，它们分别用于不同分代的垃圾回收。</p><ul><li><p><strong>新生代回收器</strong>：Serial、ParNew、Parallel Scavenge</p></li><li><p><strong>老年代回收器</strong>：Serial Old、Parallel Old、CMS</p></li><li><p><strong>整堆回收器</strong>：G1</p></li></ul><p>两个 <strong>垃圾回收器</strong> 之间有连线表示它们可以 <strong>搭配使用</strong>，可选的搭配方案如下：</p><table><thead><tr><th style="text-align:left">新生代</th><th style="text-align:left">老年代</th></tr></thead><tbody><tr><td style="text-align:left">Serial</td><td style="text-align:left">Serial Old</td></tr><tr><td style="text-align:left">Serial</td><td style="text-align:left">CMS</td></tr><tr><td style="text-align:left">ParNew</td><td style="text-align:left">Serial Old</td></tr><tr><td style="text-align:left">ParNew</td><td style="text-align:left">CMS</td></tr><tr><td style="text-align:left">Parallel Scavenge</td><td style="text-align:left">Serial Old</td></tr><tr><td style="text-align:left">Parallel Scavenge</td><td style="text-align:left">Parallel Old</td></tr><tr><td style="text-align:left">G1</td><td style="text-align:left">G1</td></tr></tbody></table><h3 id="3-单线程垃圾回收器"><a href="#3-单线程垃圾回收器" class="headerlink" title="3. 单线程垃圾回收器"></a>3. 单线程垃圾回收器</h3><h4 id="3-1-Serial（-XX-UseSerialGC）"><a href="#3-1-Serial（-XX-UseSerialGC）" class="headerlink" title="3.1. Serial（-XX:+UseSerialGC）"></a>3.1. Serial（-XX:+UseSerialGC）</h4><p><code>Serial</code> 回收器是最基本的 <strong>新生代</strong> 垃圾回收器，是 <strong>单线程</strong> 的垃圾回收器。由于垃圾清理时，<code>Serial</code> <strong>回收器</strong> 不存在 <strong>线程间的切换</strong>，因此，特别是在单 <code>CPU</code> 的环境下，它的 <strong>垃圾清除效率</strong> 比较高。对于 <code>Client</code> 运行模式的程序，选择 <code>Serial</code> 回收器是一个不错的选择。</p><p><code>Serial</code> <strong>新生代回收器</strong> 采用的是 <strong>复制算法</strong>。</p><h4 id="3-2-Serial-Old（-XX-UseSerialGC）"><a href="#3-2-Serial-Old（-XX-UseSerialGC）" class="headerlink" title="3.2. Serial Old（-XX:+UseSerialGC）"></a>3.2. Serial Old（-XX:+UseSerialGC）</h4><p><code>Serial Old</code> 回收器是 <code>Serial</code> 回收器的 <strong>老生代版本</strong>，属于 <strong>单线程回收器</strong>，它使用 <strong>标记-整理</strong> 算法。对于 <code>Server</code> 模式下的虚拟机，在 <code>JDK1.5</code> 及其以前，它常与 <code>Parallel Scavenge</code> 回收器配合使用，达到较好的 <strong>吞吐量</strong>，另外它也是 <code>CMS</code> 回收器在 <code>Concurrent Mode Failure</code> 时的 <strong>后备方案</strong>。</p><p><code>Serial</code> 回收器和 <code>Serial Old</code> 回收器的执行效果如下：</p><blockquote><p><code>Serial Old</code> <strong>老年代回收器</strong> 采用的是 <strong>标记 - 整理算法</strong>。</p></blockquote><h3 id="4-多线程垃圾回收器（吞吐量优先）"><a href="#4-多线程垃圾回收器（吞吐量优先）" class="headerlink" title="4. 多线程垃圾回收器（吞吐量优先）"></a>4. 多线程垃圾回收器（吞吐量优先）</h3><h4 id="4-1-ParNew（-XX-UseParNewGC）"><a href="#4-1-ParNew（-XX-UseParNewGC）" class="headerlink" title="4.1. ParNew（-XX:+UseParNewGC）"></a>4.1. ParNew（-XX:+UseParNewGC）</h4><p><code>ParNew</code> 回收器是在 <code>Serial</code> 回收器的基础上演化而来的，属于 <code>Serial</code> 回收器的 <strong>多线程版本</strong>，同样运行在 <strong>新生代区域</strong>。在实现上，两者共用很多代码。在不同运行环境下，根据 <code>CPU</code> 核数，开启 <strong>不同的线程数</strong>，从而达到 <strong>最优</strong> 的垃圾回收效果。对于那些 <code>Server</code> 模式的应用程序，如果考虑采用 <code>CMS</code> 作为 <strong>老生代回收器</strong> 时，<code>ParNew</code> 回收器是一个不错的选择。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b88cda952?w=952&amp;h=343&amp;f=png&amp;s=36670" alt=""></p><blockquote><p><code>ParNew</code> <strong>新生代回收器</strong> 采用的是 <strong>复制算法</strong>。</p></blockquote><h4 id="4-2-Parallel-Scavenge（-XX-UseParallelGC）"><a href="#4-2-Parallel-Scavenge（-XX-UseParallelGC）" class="headerlink" title="4.2. Parallel Scavenge（-XX:+UseParallelGC）"></a>4.2. Parallel Scavenge（-XX:+UseParallelGC）</h4><p>和 <code>ParNew</code> 回收一样，<code>Parallel Scavenge</code> 回收器也是运行在 <strong>新生代区域</strong>，属于 <strong>多线程</strong> 的回收器。但不同的是，<code>ParNew</code> 回收器是通过控制 <strong>垃圾回收</strong> 的 <strong>线程数</strong> 来进行参数调整，而 <code>Parallel Scavenge</code> 回收器更关心的是 <strong>程序运行的吞吐量</strong>。即一段时间内，<strong>用户代码</strong> 运行时间占 <strong>总运行时间</strong> 的百分比。</p><blockquote><p><code>Parallel Scavenge</code> <strong>新生代回收器</strong> 采用的是 <strong>复制算法</strong>。</p></blockquote><h4 id="4-3-Parallel-Old（-XX-UseParallelOldGC）"><a href="#4-3-Parallel-Old（-XX-UseParallelOldGC）" class="headerlink" title="4.3. Parallel Old（-XX:+UseParallelOldGC）"></a>4.3. Parallel Old（-XX:+UseParallelOldGC）</h4><p><code>Parallel Old</code> 回收器是 <code>Parallel Scavenge</code> 回收器的 <strong>老生代版本</strong>，属于 <strong>多线程回收器</strong>，采用 <strong>标记-整理算法</strong>。<code>Parallel Old</code> 回收器和 <code>Parallel Scavenge</code> 回收器同样考虑了 <strong>吞吐量优先</strong> 这一指标，非常适合那些 <strong>注重吞吐量</strong> 和 <code>CPU</code> <strong>资源敏感</strong> 的场合。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b8a60fa35?w=958&amp;h=337&amp;f=png&amp;s=30557" alt=""></p><blockquote><p><code>Parallel Old</code> <strong>老年代回收器</strong> 采用的是 <strong>标记 - 整理算法</strong>。</p></blockquote><h3 id="5-其他的回收器（停顿时间优先）"><a href="#5-其他的回收器（停顿时间优先）" class="headerlink" title="5. 其他的回收器（停顿时间优先）"></a>5. 其他的回收器（停顿时间优先）</h3><h4 id="5-1-CMS（-XX-UseConcMarkSweepGC）"><a href="#5-1-CMS（-XX-UseConcMarkSweepGC）" class="headerlink" title="5.1. CMS（-XX:+UseConcMarkSweepGC）"></a>5.1. CMS（-XX:+UseConcMarkSweepGC）</h4><p><code>CMS（Concurrent Mark Sweep）</code> 回收器是在 <strong>最短回收停顿时间</strong> 为前提的回收器，属于 <strong>多线程回收器</strong>，采用 <strong>标记-清除算法</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb00da43d?w=1038&amp;h=337&amp;f=png&amp;s=38094" alt=""></p><p>相比之前的回收器，<code>CMS</code> 回收器的运作过程比较复杂，分为四步：</p><ol><li><strong>初始标记（CMS initial mark）</strong></li></ol><p><strong>初始标记</strong> 仅仅是标记 <code>GC Roots</code> 内 <strong>直接关联</strong> 的对象。这个阶段 <strong>速度很快</strong>，需要 <code>Stop the World</code>。</p><ol start="2"><li><strong>并发标记（CMS concurrent mark）</strong></li></ol><p><strong>并发标记</strong> 进行的是 <code>GC Tracing</code>，从 <code>GC Roots</code> 开始对堆进行 <strong>可达性分析</strong>，找出 <strong>存活对象</strong>。</p><ol start="3"><li><strong>重新标记（CMS remark）</strong></li></ol><p><strong>重新标记</strong> 阶段为了 <strong>修正</strong> 并发期间由于 <strong>用户进行运作</strong> 导致的 <strong>标记变动</strong> 的那一部分对象的 <strong>标记记录</strong>。这个阶段的 <strong>停顿时间</strong> 一般会比 <strong>初始标记阶段</strong> 稍长一些，但远比 <strong>并发标记</strong> 的时间短，也需要 <code>Stop The World</code>。</p><ol start="4"><li><strong>并发清除（CMS concurrent sweep）</strong></li></ol><p><strong>并发清除</strong> 阶段会清除垃圾对象。</p><blockquote><p><strong>初始标记</strong>（<code>CMS initial mark</code>）和 <strong>重新标记</strong>（<code>CMS remark</code>）会导致 <strong>用户线程</strong> 卡顿，<code>Stop the World</code> 现象发生。</p></blockquote><p>在整个过程中，<code>CMS</code> 回收器的 <strong>内存回收</strong> 基本上和 <strong>用户线程</strong> 并发执行，如下所示：</p><p>由于 <code>CMS</code> 回收器 <strong>并发收集</strong>、<strong>停顿低</strong>，因此有些地方成为 <strong>并发低停顿回收器</strong>（<code>Concurrent Low Pause Sweep Collector</code>）。</p><p><code>CMS</code> 回收器的缺点：</p><ol><li><strong>CMS回收器对CPU资源非常依赖</strong></li></ol><p><code>CMS</code> 回收器过分依赖于 <strong>多线程环境</strong>，默认情况下，开启的 <strong>线程数</strong> 为<code>（CPU 的数量 + 3）/ 4</code>，当 <code>CPU</code> 数量少于 <code>4</code> 个时，<code>CMS</code> 对 <strong>用户查询</strong> 的影响将会很大，因为他们要分出一半的运算能力去 <strong>执行回收器线程</strong>；</p><ol start="2"><li><strong>CMS回收器无法清除浮动垃圾</strong></li></ol><p>由于 <code>CMS</code> 回收器 <strong>清除已标记的垃圾</strong> （处于最后一个阶段）时，<strong>用户线程</strong> 还在运行，因此会有新的垃圾产生。但是这部分垃圾 <strong>未被标记</strong>，在下一次 <code>GC</code> 才能清除，因此被成为 <strong>浮动垃圾</strong>。</p><p>由于 <strong>内存回收</strong> 和 <strong>用户线程</strong> 是同时进行的，内存在被 <strong>回收</strong> 的同时，也在被 <strong>分配</strong>。当 <strong>老生代</strong> 中的内存使用超过一定的比例时，系统将会进行 <strong>垃圾回收</strong>；当 <strong>剩余内存</strong> 不能满足程序运行要求时，系统将会出现 <code>Concurrent Mode Failure</code>，临时采用 <code>Serial Old</code> 算法进行 <strong>清除</strong>，此时的 <strong>性能</strong> 将会降低。</p><ol start="3"><li><strong>垃圾收集结束后残余大量空间碎片</strong></li></ol><p><code>CMS</code> 回收器采用的 <strong>标记清除算法</strong>，本身存在垃圾收集结束后残余 <strong>大量空间碎片</strong> 的缺点。<code>CMS</code> 配合适当的 <strong>内存整理策略</strong>，在一定程度上可以解决这个问题。</p><h4 id="5-2-G1回收器（垃圾区域Region优先）"><a href="#5-2-G1回收器（垃圾区域Region优先）" class="headerlink" title="5.2. G1回收器（垃圾区域Region优先）"></a>5.2. G1回收器（垃圾区域Region优先）</h4><p><code>G1</code> 是 <code>JDK 1.7</code> 中正式投入使用的用于取代 <code>CMS</code> 的 <strong>压缩回收器</strong>。它虽然没有在物理上隔断 <strong>新生代</strong> 与 <strong>老生代</strong>，但是仍然属于 <strong>分代垃圾回收器</strong>。<code>G1</code> 仍然会区分 <strong>年轻代</strong> 与 <strong>老年代</strong>，年轻代依然分有 <code>Eden</code> 区与 <code>Survivor</code> 区。</p><p><code>G1</code> 首先将 <strong>堆</strong> 分为 <strong>大小相等</strong> 的  <code>Region</code>，避免 <strong>全区域</strong> 的垃圾回收。然后追踪每个 <code>Region</code> 垃圾 <strong>堆积的价值大小</strong>，在后台维护一个 <strong>优先列表</strong>，根据允许的回收时间优先回收价值最大的 <code>Region</code>。同时 <code>G1</code>采用 <code>Remembered Set</code> 来存放 <code>Region</code> 之间的 <strong>对象引用</strong> ，其他回收器中的 <strong>新生代</strong> 与 <strong>老年代</strong> 之间的对象引用，从而避免 <strong>全堆扫描</strong>。<code>G1</code> 的分区示例如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb5454a60?w=678&amp;h=380&amp;f=jpeg&amp;s=29106" alt=""></p><p>这种使用 <code>Region</code> 划分 <strong>内存空间</strong> 以及有 <strong>优先级</strong> 的区域回收方式，保证 <code>G1</code> 回收器在有限的时间内可以获得尽可能 <strong>高的回收效率</strong>。</p><p><code>G1</code> 和 <code>CMS</code> 运作过程有很多相似之处，整个过程也分为 <code>4</code> 个步骤：</p><ol><li><strong>初始标记（CMS initial mark）</strong></li></ol><p><strong>初始标记</strong> 仅仅是标记 <code>GC Roots</code> 内 <strong>直接关联</strong> 的对象。这个阶段 <strong>速度很快</strong>，需要 <code>Stop the World</code>。</p><ol start="2"><li><strong>并发标记（CMS concurrent mark）</strong></li></ol><p><strong>并发标记</strong> 进行的是 <code>GC Tracing</code>，从 <code>GC Roots</code> 开始对堆进行 <strong>可达性分析</strong>，找出 <strong>存活对象</strong>。</p><ol start="3"><li><strong>重新标记（CMS remark）</strong></li></ol><p><strong>重新标记</strong> 阶段为了 <strong>修正</strong> 并发期间由于 <strong>用户进行运作</strong> 导致的 <strong>标记变动</strong> 的那一部分对象的 <strong>标记记录</strong>。这个阶段的 <strong>停顿时间</strong> 一般会比 <strong>初始标记阶段</strong> 稍长一些，但远比 <strong>并发标记</strong> 的时间短，也需要 <code>Stop The World</code>。</p><ol start="4"><li><strong>筛选回收</strong></li></ol><p>首先对各个 <code>Region</code> 的 <strong>回收价值</strong> 和 <strong>成本</strong> 进行排序，根据用户所期望的 <code>GC</code> <strong>停顿时间</strong> 来制定回收计划。这个阶段可以与用户程序一起 <strong>并发执行</strong>，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿 <strong>用户线程</strong> 将大幅提高回收效率。</p><blockquote><p>与其它 <code>GC</code> 回收相比，<code>G1</code> 具备如下 <code>4</code> 个特点：</p></blockquote><ul><li><strong>并行与并发</strong></li></ul><p>使用多个 <code>CPU</code> 来缩短 <code>Stop-the-World</code> 的 <strong>停顿时间</strong>，部分其他回收器需要停顿 <code>Java</code> 线程执行的 <code>GC</code> 动作，<code>G1</code> 回收器仍然可以通过 <strong>并发的方式</strong> 让 <code>Java</code> 程序继续执行。</p><ul><li><strong>分代回收</strong></li></ul><p>与其他回收器一样，<strong>分代概念</strong> 在 <code>G1</code> 中依然得以保留。虽然 <code>G1</code> 可以不需要 <strong>其他回收器配合</strong> 就能独立管理 <strong>整个GC堆</strong>，但它能够采用 <strong>不同的策略</strong> 去处理 <strong>新创建的对象</strong> 和 <strong>已经存活</strong> 一段时间、<strong>熬过多次</strong> <code>GC</code> 的旧对象，以获取更好的回收效果。<strong>新生代</strong> 和 <strong>老年代</strong> 不再是 <strong>物理隔离</strong>，是多个 <strong>大小相等</strong> 的独立 <code>Region</code>。</p><ul><li><strong>空间整合</strong></li></ul><p>与 <code>CMS</code> 的 <strong>标记—清理</strong> 算法不同，<code>G1</code> 从 <strong>整体</strong> 来看是基于 <strong>标记—整理</strong> 算法实现的回收器。从 <strong>局部</strong>（两个 <code>Region</code> 之间）上来看是基于 <strong>复制算法</strong> 实现的。</p><p>但无论如何，这 <strong>两种算法</strong> 都意味着 <code>G1</code> 运作期间 <strong>不会产生内存空间碎片</strong>，回收后能提供规整的可用内存。这种特性有利于程序长时间运行，<strong>分配大对象</strong> 时不会因为无法找到 <strong>连续内存空间</strong> 而提前触发 <strong>下一次</strong> <code>GC</code>。</p><ul><li><strong>可预测的停顿</strong></li></ul><p>这是 <code>G1</code> 相对于 <code>CMS</code> 的另一大优势，<strong>降低停顿时间</strong> 是 <code>G1</code> 和 <code>CMS</code> 共同的关注点。<code>G1</code> 除了追求 <strong>低停顿</strong> 外，还能建立 <strong>可预测</strong> 的 <strong>停顿时间模型</strong>，能让使用者明确指定在一个 <strong>长度</strong> 为 <code>M</code> 毫秒的 <strong>时间片段</strong> 内，消耗在 <strong>垃圾回收</strong> 上的时间不得超过 <code>N</code> 毫秒。（后台维护的 <strong>优先列表</strong>，优先回收 <strong>价值大</strong> 的 <code>Region</code>）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社</p><hr><p>欢迎关注技术公众号：零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bd1fd0856?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在之前的几篇博客中，我们大致介绍了，常见的 &lt;strong&gt;垃圾回收算法&lt;/strong&gt; 及 &lt;code&gt;JVM&lt;/code&gt; 中常见的分类回收算法。这些都是从算法和规范上分析 &lt;code&gt;Java&lt;/code&gt; 中的垃圾回收，属于方法论。在 &lt;code&gt;JVM&lt;/code&gt; 中，垃圾回收的具体实现是由 &lt;strong&gt;垃圾回收器&lt;/strong&gt;（&lt;code&gt;Garbage Collector&lt;/code&gt;）负责。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA虚拟机系列" scheme="https://ostenant.coding.me/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JVM" scheme="https://ostenant.coding.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Nginx服务器的内部核心架构设计</title>
    <link href="https://ostenant.coding.me/2018/07/15/%E6%B5%85%E8%B0%88Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://ostenant.coding.me/2018/07/15/浅谈Nginx服务器的内部核心架构设计/</id>
    <published>2018-07-15T10:50:00.000Z</published>
    <updated>2018-07-15T23:47:46.842Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Nginx</code> 是一个 <strong>免费的</strong>，<strong>开源的</strong>，<strong>高性能</strong> 的 <code>HTTP</code> 服务器和 <strong>反向代理</strong>，以及 <code>IMAP</code>/<code>POP3</code> 代理服务器。 <code>Nginx</code> 以其高性能，稳定性，丰富的功能，简单的配置和低资源消耗而闻名。<code>Nginx</code>是一个 <code>Web</code> 服务器，也可以用作 <strong>反向代理</strong>，<strong>负载均衡器</strong> 和 <code>HTTP</code> <strong>缓存</strong>。</p><a id="more"></a><p>很多高知名度的网站都使用 <code>Nginx</code>，如：<code>Netflix</code>，<code>GitHub</code>，<code>SoundCloud</code>，<code>MaxCDN</code> 等。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bd16fbfc9?w=626&amp;h=144&amp;f=png&amp;s=32239" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-Nginx的整体架构"><a href="#1-Nginx的整体架构" class="headerlink" title="1. Nginx的整体架构"></a>1. Nginx的整体架构</h2><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bce75a47b?w=944&amp;h=587&amp;f=png&amp;s=128919" alt=""></p><h3 id="1-1-主进程"><a href="#1-1-主进程" class="headerlink" title="1.1. 主进程"></a>1.1. 主进程</h3><p><code>Nginx</code> 启动时，会生成两种类型的 <strong>进程*</strong>，一个是 <strong>主进程</strong>（<code>master</code>），<strong>一个</strong>（<code>windows</code> 版本的目前只有一个）或 <strong>多个工作进程</strong>（<code>worker</code>）。<strong>主进程</strong> 并不处理网络请求，主要负责 <strong>调度工作进程</strong>，也就是图示的 <code>3</code> 项：<strong>加载配置</strong>、<strong>启动工作进程</strong> 及 <strong>非停升级</strong>。所以，<code>Nginx</code> 启动以后，查看操作系统的进程列表，我们就能看到 <strong>至少有两个</strong> <code>Nginx</code> 进程。</p><h3 id="1-2-工作进程"><a href="#1-2-工作进程" class="headerlink" title="1.2. 工作进程"></a>1.2. 工作进程</h3><p>服务器实际 <strong>处理网络请求</strong> 及 <strong>响应</strong> 的是 <strong>工作进程</strong>（<code>worker</code>），在类 <code>unix</code> 系统上，<code>Nginx</code> 可以配置 <strong>多个</strong> <code>worker</code>，而每个 <code>worker</code> <strong>进程</strong> 都可以同时处理 <strong>数以千计</strong> 的 <strong>网络请求</strong>。</p><h3 id="1-3-模块化设计"><a href="#1-3-模块化设计" class="headerlink" title="1.3. 模块化设计"></a>1.3. 模块化设计</h3><p><code>Nginx</code> 的 <code>worker</code> 进程，包括 <strong>核心</strong> 和 <strong>功能性模块</strong>，<strong>核心模块</strong> 负责维持一个 <strong>运行循环</strong>（<code>run-loop</code>），执行网络请求处理的 <strong>不同阶段</strong> 的模块功能，比如：<strong>网络读写</strong>、<strong>存储读写</strong>、<strong>内容传输</strong>、<strong>外出过滤</strong>，以及 <strong>将请求发往上游服务器</strong> 等。而其代码的 <strong>模块化设计</strong>，也使得我们可以根据需要对 <strong>功能模块</strong> 进行适当的 <strong>选择</strong> 和 <strong>修改</strong>，编译成具有 <strong>特定功能</strong> 的服务器。</p><h3 id="1-4-事件驱动模型"><a href="#1-4-事件驱动模型" class="headerlink" title="1.4. 事件驱动模型"></a>1.4. 事件驱动模型</h3><p>基于 <strong>异步及非阻塞</strong> 的 <strong>事件驱动模型</strong>，可以说是 <code>Nginx</code> 得以获得 <strong>高并发</strong>、<strong>高性能</strong> 的关键因素，同时也得益于对 <code>Linux</code>、<code>Solaris</code> 及类 <code>BSD</code> 等操作系统内核中 <strong>事件通知</strong> 及 <code>I/O</code> <strong>性能增强功能</strong> 的采用，如 <code>kqueue</code>、<code>epoll</code> 及 <code>event ports</code>。</p><h3 id="1-5-代理（proxy）设计"><a href="#1-5-代理（proxy）设计" class="headerlink" title="1.5. 代理（proxy）设计"></a>1.5. 代理（proxy）设计</h3><p><strong>代理设计</strong>，可以说是 <code>Nginx</code> 深入骨髓的设计，无论是对于 <code>HTTP</code>，还是对于 <code>FastCGI</code>、<code>Memcache</code>、<code>Redis</code> 等的网络请求或响应，本质上都采用了 <strong>代理机制</strong>。所以，<code>Nginx</code> 天生就是高性能的 <strong>代理服务器</strong>。</p><h2 id="2-Nginx的模块化设计"><a href="#2-Nginx的模块化设计" class="headerlink" title="2. Nginx的模块化设计"></a>2. Nginx的模块化设计</h2><p><strong>高度模块化</strong> 的设计是 <code>Nginx</code> 的架构基础。<code>Nginx</code> 服务器被分解为 <strong>多个模块</strong>，每个模块就是一个 <strong>功能模块</strong>，只负责自身的功能，模块之间严格遵循 <strong>“高内聚，低耦合”</strong> 的原则。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bd21be9ae?w=640&amp;h=479&amp;f=webp&amp;s=19204" alt=""></p><h3 id="2-1-核心模块"><a href="#2-1-核心模块" class="headerlink" title="2.1. 核心模块"></a>2.1. 核心模块</h3><p><strong>核心模块</strong> 是 <code>Nginx</code> 服务器正常运行 <strong>必不可少</strong> 的模块，提供 <strong>错误日志记录</strong>、<strong>配置文件解析</strong>、<strong>事件驱动机制</strong>、<strong>进程管理</strong> 等核心功能。 </p><h3 id="2-2-标准HTTP模块"><a href="#2-2-标准HTTP模块" class="headerlink" title="2.2. 标准HTTP模块"></a>2.2. 标准HTTP模块</h3><p>标准 <code>HTTP</code> 模块提供 <code>HTTP</code> 协议解析相关的功能，比如：<strong>端口配置</strong>、<strong>网页编码设置</strong>、<code>HTTP</code> <strong>响应头设置</strong> 等等。</p><h3 id="2-3-可选HTTP模块"><a href="#2-3-可选HTTP模块" class="headerlink" title="2.3. 可选HTTP模块"></a>2.3. 可选HTTP模块</h3><p>可选 <code>HTTP</code> 模块主要用于 <strong>扩展</strong> 标准的 <code>HTTP</code> 功能，让  <code>Nginx</code> 能处理一些特殊的服务，比如：<code>Flash</code> <strong>多媒体传输</strong>、解析 <code>GeoIP</code> 请求、<strong>网络传输压缩</strong>、<strong>安全协议</strong> <code>SSL</code> 支持等。</p><h3 id="2-4-邮件服务模块"><a href="#2-4-邮件服务模块" class="headerlink" title="2.4. 邮件服务模块"></a>2.4. 邮件服务模块</h3><p><strong>邮件服务模块</strong> 主要用于支持 <code>Nginx</code> 的 <strong>邮件服务</strong>，包括对 <code>POP3</code> 协议、<code>IMAP</code> 协议和 <code>SMTP</code> 协议的支持。</p><h3 id="2-5-第三方模块"><a href="#2-5-第三方模块" class="headerlink" title="2.5. 第三方模块"></a>2.5. 第三方模块</h3><p><strong>第三方模块</strong> 是为了扩展 <code>Nginx</code> 服务器应用，完成开发者自定义功能，比如：<code>Json</code> 支持、<code>Lua</code> 支持等。</p><h2 id="3-Nginx的请求方式处理"><a href="#3-Nginx的请求方式处理" class="headerlink" title="3. Nginx的请求方式处理"></a>3. Nginx的请求方式处理</h2><p><code>Nginx</code> 是一个 <strong>高性能</strong> 的 <code>Web</code> 服务器，能够同时处理 <strong>大量的并发请求</strong>。它结合 <strong>多进程机制</strong> 和 <strong>异步机制</strong>，异步机制使用的是 <strong>异步非阻塞方式</strong>，接下来就给大家介绍一下  <code>Nginx</code> 的 <strong>多线程机制</strong> 和 <strong>异步非阻塞机制</strong>。 </p><h3 id="3-1-多进程机制"><a href="#3-1-多进程机制" class="headerlink" title="3.1. 多进程机制"></a>3.1. 多进程机制</h3><p>服务器每当收到一个客户端时，就有 <strong>服务器主进程</strong>（<code>master process</code>）生成一个 <strong>子进程</strong>（<code>worker  process</code>）出来和客户端建立连接进行交互，直到连接断开，该子进程就结束了。</p><p>使用 <strong>进程</strong> 的好处是 <strong>各个进程之间相互独立</strong>，<strong>不需要加锁</strong>，减少了使用锁对性能造成影响，同时降低编程的复杂度，降低开发成本。其次，采用独立的进程，可以让 <strong>进程互相之间不会影响</strong>，如果一个进程发生异常退出时，其它进程正常工作，<code>master</code> 进程则很快启动新的 <code>worker</code> 进程，确保服务不会中断，从而将风险降到最低。</p><p>缺点是操作系统生成一个 <strong>子进程</strong> 需要进行 <strong>内存复制</strong> 等操作，在 <strong>资源</strong> 和 <strong>时间</strong> 上会产生一定的开销。当有 <strong>大量请求</strong> 时，会导致 <strong>系统性能下降</strong>。</p><h3 id="3-2-异步非阻塞机制"><a href="#3-2-异步非阻塞机制" class="headerlink" title="3.2. 异步非阻塞机制"></a>3.2. 异步非阻塞机制</h3><p>每个 <strong>工作进程</strong> 使用 <strong>异步非阻塞方式</strong>，可以处理 <strong>多个客户端请求</strong>。</p><p>当某个 <strong>工作进程</strong> 接收到客户端的请求以后，调用 <code>IO</code> 进行处理，如果不能立即得到结果，就去 <strong>处理其他请求</strong>（即为 <strong>非阻塞</strong>）；而 <strong>客户端</strong> 在此期间也 <strong>无需等待响应</strong>，可以去处理其他事情（即为 <strong>异步</strong>）。</p><p>当 <code>IO</code> 返回时，就会通知此 <strong>工作进程</strong>；该进程得到通知，暂时 <strong>挂起</strong> 当前处理的事务去 <strong>响应客户端请求</strong>。</p><h2 id="4-Nginx事件驱动模型"><a href="#4-Nginx事件驱动模型" class="headerlink" title="4. Nginx事件驱动模型"></a>4. Nginx事件驱动模型</h2><p>在 <code>Nginx</code> 的 <strong>异步非阻塞机制</strong> 中，<strong>工作进程</strong> 在调用 <code>IO</code> 后，就去处理其他的请求，当 <code>IO</code> 调用返回后，会 <strong>通知</strong> 该 <strong>工作进程</strong>。对于这样的系统调用，主要使用 <code>Nginx</code> 服务器的 <strong>事件驱动模型</strong> 来实现。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bd23976e0?w=604&amp;h=486&amp;f=webp&amp;s=8094" alt=""></p><p>如上图所示，<code>Nginx</code> 的 <strong>事件驱动模型</strong> 由 <strong>事件收集器</strong>、<strong>事件发送器</strong> 和 <strong>事件处理器</strong> 三部分基本单元组成。</p><ul><li><p>事件收集器：负责收集 <code>worker</code> 进程的各种 <code>IO</code> 请求；</p></li><li><p>事件发送器：负责将 <code>IO</code> 事件发送到 <strong>事件处理器</strong>；</p></li><li><p>事件处理器：负责各种事件的 <strong>响应工作</strong>。</p></li></ul><p><strong>事件发送器</strong> 将每个请求放入一个 <strong>待处理事件列表</strong>，使用非阻塞 <code>I/O</code> 方式调用 <strong>事件处理器</strong> 来处理该请求。其处理方式称为 <strong>“多路 IO 复用方法”</strong>，常见的包括以下三种：<code>select</code> 模型、<code>poll</code> 模型、<code>epoll</code> 模型。</p><h2 id="5-Nginx进程处理模型"><a href="#5-Nginx进程处理模型" class="headerlink" title="5. Nginx进程处理模型"></a>5. Nginx进程处理模型</h2><p><code>Nginx</code> 服务器使用 <code>master/worker</code> <strong>多进程模式</strong>。多线程启动和执行的流程如下：</p><ol><li><p><strong>主程序</strong> <code>Master process</code> 启动后，通过一个 <code>for</code> 循环来 <strong>接收</strong> 和 <strong>处理外部信号</strong>；</p></li><li><p><strong>主进程</strong> 通过 <code>fork()</code> 函数产生 <code>worker</code> <strong>子进程</strong>，每个 <strong>子进程</strong> 执行一个 <code>for</code> 循环来实现 <code>Nginx</code> 服务器 <strong>对事件的接收</strong> 和 <strong>处理</strong>。</p></li></ol><p>一般推荐 <code>worker</code> <strong>进程数</strong> 与 <code>CPU</code> <strong>内核数</strong> 一致，这样一来不存在 <strong>大量的子进程</strong> 生成和管理任务，避免了进程之间 <strong>竞争</strong> <code>CPU</code> <strong>资源</strong> 和 <strong>进程切换</strong> 的开销。而且  <code>Nginx</code> 为了更好的利用 <strong>多核特性</strong>，提供了 <code>CPU</code> <strong>亲缘性</strong> 的绑定选项，我们可以将某 <strong>一个进程绑定在某一个核</strong> 上，这样就不会因为 <strong>进程的切换</strong> 带来 <code>Cache</code> 的失效。</p><p>对于每个请求，有且只有一个 <strong>工作进程</strong> 对其处理。首先，每个 <code>worker</code> 进程都是从 <code>master</code> 进程 <code>fork</code> 过来。在  <code>master</code> 进程里面，先建立好需要 <code>listen</code> 的 <code>socket（listenfd）</code> 之后，然后再 <code>fork</code> 出多个 <code>worker</code> 进程。</p><p>所有 <code>worker</code> 进程的 <code>listenfd</code> 会在 <strong>新连接</strong> 到来时变得 <strong>可读</strong>，为保证只有一个进程处理该连接，所有 <code>worker</code> 进程在注册 <code>listenfd</code> <strong>读事件</strong> 前 <strong>抢占</strong> <code>accept_mutex</code>，抢到 <strong>互斥锁</strong> 的那个进程 <strong>注册</strong> <code>listenfd</code> <strong>读事件</strong>，在 <strong>读事件</strong> 里调用 <code>accept</code> 接受该连接。</p><p>当一个 <code>worker</code> 进程在 <code>accept</code> 这个连接之后，就开始 <strong>读取请求</strong>，<strong>解析请求</strong>，<strong>处理请求</strong>，产生数据后，再 <strong>返回给客户端</strong>，最后才 <strong>断开连接</strong>，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由 <code>worker</code> 进程来处理，而且只在一个 <code>worker</code> 进程中处理。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bd00922f3?w=640&amp;h=458&amp;f=webp&amp;s=9848" alt=""></p><p>在 <code>Nginx</code> 服务器的运行过程中，<strong>主进程</strong> 和 <strong>工作进程</strong> 需要进程交互。交互依赖于 <code>Socket</code> 实现的 <strong>管道</strong> 来实现。</p><h3 id="5-1-主进程与工作进程交互"><a href="#5-1-主进程与工作进程交互" class="headerlink" title="5.1. 主进程与工作进程交互"></a>5.1. 主进程与工作进程交互</h3><p>这条管道与普通的管道不同，它是由 <strong>主进程</strong> 指向 <strong>工作进程</strong> 的 <strong>单向管道</strong>，包含主进程向工作进程发出的 <strong>指令</strong>，<strong>工作进程</strong> <code>ID</code> 等；同时 <strong>主进程</strong> 与外界通过 <strong>信号通信</strong>；每个 <strong>子进程</strong> 具备 <strong>接收信号</strong>，并处理相应的事件的能力。</p><h3 id="5-2-工作进程与工作进程交互"><a href="#5-2-工作进程与工作进程交互" class="headerlink" title="5.2. 工作进程与工作进程交互"></a>5.2. 工作进程与工作进程交互</h3><p>这种交互是和 <strong>主进程-工作进程</strong> 交互是基本一致的，但是会通过 <strong>主进程</strong> 间接完成。<strong>工作进程</strong> 之间是 <strong>相互隔离</strong> 的，所以当工作进程 <code>W1</code> 需要向工作进程 <code>W2</code> 发指令时，首先找到 <code>W2</code> 的 <strong>进程</strong> <code>ID</code>，然后将正确的指令写入指向 <code>W2</code> 的 <strong>通道</strong>。<code>W2</code> 收到信号采取相应的措施。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过这篇文章，我们对 <code>Nginx</code> 服务器的 <strong>整体架构</strong> 有了一个整体的认识。包括其 <strong>模块化的设计</strong>、<strong>多进程</strong> 和 <strong>异步非阻塞</strong> 的请求处理方式、<strong>事件驱动模型</strong> 等。通过这些理论知识，才能更好地领悟  <code>Nginx</code> 的设计思想。对于我们学习 <code>Nginx</code> 来说有很大的帮助。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16494267ed546a0c?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Nginx&lt;/code&gt; 是一个 &lt;strong&gt;免费的&lt;/strong&gt;，&lt;strong&gt;开源的&lt;/strong&gt;，&lt;strong&gt;高性能&lt;/strong&gt; 的 &lt;code&gt;HTTP&lt;/code&gt; 服务器和 &lt;strong&gt;反向代理&lt;/strong&gt;，以及 &lt;code&gt;IMAP&lt;/code&gt;/&lt;code&gt;POP3&lt;/code&gt; 代理服务器。 &lt;code&gt;Nginx&lt;/code&gt; 以其高性能，稳定性，丰富的功能，简单的配置和低资源消耗而闻名。&lt;code&gt;Nginx&lt;/code&gt;是一个 &lt;code&gt;Web&lt;/code&gt; 服务器，也可以用作 &lt;strong&gt;反向代理&lt;/strong&gt;，&lt;strong&gt;负载均衡器&lt;/strong&gt; 和 &lt;code&gt;HTTP&lt;/code&gt; &lt;strong&gt;缓存&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="高并发系统系列" scheme="https://ostenant.coding.me/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Nginx" scheme="https://ostenant.coding.me/tags/Nginx/"/>
    
      <category term="服务器" scheme="https://ostenant.coding.me/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="反向代理" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="负载均衡" scheme="https://ostenant.coding.me/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="高性能" scheme="https://ostenant.coding.me/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>浅谈常见的七种加密算法及实现</title>
    <link href="https://ostenant.coding.me/2018/07/13/%E6%B5%85%E8%B0%88%08%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ostenant.coding.me/2018/07/13/浅谈常见的七种加密算法及实现/</id>
    <published>2018-07-13T12:06:00.000Z</published>
    <updated>2018-07-13T14:02:41.657Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>数字签名</strong>、<strong>信息加密</strong> 是前后端开发都经常需要使用到的技术，应用场景包括了用户登入、交易、信息通讯、<code>oauth</code> 等等，不同的应用场景也会需要使用到不同的签名加密算法，或者需要搭配不一样的 <strong>签名加密算法</strong> 来达到业务目标。这里简单的给大家介绍几种常见的签名加密算法和一些典型场景下的应用。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-数字签名"><a href="#1-数字签名" class="headerlink" title="1. 数字签名"></a>1. 数字签名</h2><p><strong>数字签名</strong>，简单来说就是通过提供 <strong>可鉴别</strong> 的 <strong>数字信息</strong> 验证 <strong>自身身份</strong> 的一种方式。一套 <strong>数字签名</strong> 通常定义两种 <strong>互补</strong> 的运算，一个用于 <strong>签名</strong>，另一个用于 <strong>验证</strong>。分别由 <strong>发送者</strong> 持有能够 <strong>代表自己身份</strong> 的 <strong>私钥</strong> (私钥不可泄露),由 <strong>接受者</strong> 持有与私钥对应的 <strong>公钥</strong> ，能够在 <strong>接受</strong> 到来自发送者信息时用于 <strong>验证</strong> 其身份。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa18df72?w=1024&amp;h=768&amp;f=png&amp;s=77151" alt=""></p><blockquote><p><strong>注意</strong>：图中 <strong>加密过程</strong> 有别于 <strong>公钥加密</strong>，更多 <a href="https://www.zhihu.com/question/25912483" target="_blank" rel="noopener">介绍戳这里</a>。<strong>签名</strong> 最根本的用途是要能够唯一 <strong>证明发送方的身份</strong>，防止 <strong>中间人攻击</strong>、<code>CSRF</code> <strong>跨域身份伪造</strong>。基于这一点在诸如 <strong>设备认证</strong>、<strong>用户认证</strong>、<strong>第三方认证</strong> 等认证体系中都会使用到 <strong>签名算法</strong> (彼此的实现方式可能会有差异)。</p></blockquote><h2 id="2-加密和解密"><a href="#2-加密和解密" class="headerlink" title="2. 加密和解密"></a>2. 加密和解密</h2><h3 id="2-1-加密"><a href="#2-1-加密" class="headerlink" title="2.1. 加密"></a>2.1. 加密</h3><p><strong>数据加密</strong> 的基本过程，就是对原来为 <strong>明文</strong> 的文件或数据按 <strong>某种算法</strong> 进行处理，使其成为 <strong>不可读</strong> 的一段代码，通常称为 <strong>“密文”</strong>。通过这样的途径，来达到 <strong>保护数据</strong> 不被 <strong>非法人窃取</strong>、阅读的目的。</p><h3 id="2-2-解密"><a href="#2-2-解密" class="headerlink" title="2.2. 解密"></a>2.2. 解密</h3><p><strong>加密</strong> 的 <strong>逆过程</strong> 为 <strong>解密</strong>，即将该 <strong>编码信息</strong> 转化为其 <strong>原来数据</strong> 的过程。</p><h2 id="3-对称加密和非对称加密"><a href="#3-对称加密和非对称加密" class="headerlink" title="3. 对称加密和非对称加密"></a>3. 对称加密和非对称加密</h2><p>加密算法分 <strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密 <strong>密钥相同</strong>，非对称加密算法的加密密钥与解密 <strong>密钥不同</strong>，此外，还有一类 <strong>不需要密钥</strong> 的 <strong>散列算法</strong>。</p><blockquote><p>常见的 <strong>对称加密</strong> 算法主要有 <code>DES</code>、<code>3DES</code>、<code>AES</code> 等，常见的 <strong>非对称算法</strong> 主要有 <code>RSA</code>、<code>DSA</code> 等，<strong>散列算法</strong> 主要有 <code>SHA-1</code>、<code>MD5</code> 等。</p></blockquote><h3 id="3-1-对称加密"><a href="#3-1-对称加密" class="headerlink" title="3.1. 对称加密"></a>3.1. 对称加密</h3><p><strong>对称加密算法</strong> 是应用较早的加密算法，又称为 <strong>共享密钥加密算法</strong>。在 <strong>对称加密算法</strong> 中，使用的密钥只有一个，<strong>发送</strong> 和 <strong>接收</strong> 双方都使用这个密钥对数据进行 <strong>加密</strong> 和 <strong>解密</strong>。这就要求加密和解密方事先都必须知道加密的密钥。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa02dbcd?w=727&amp;h=244&amp;f=png&amp;s=36256" alt=""></p><ol><li><p>数据加密过程：在对称加密算法中，<strong>数据发送方</strong> 将 <strong>明文</strong> (原始数据) 和 <strong>加密密钥</strong> 一起经过特殊 <strong>加密处理</strong>，生成复杂的 <strong>加密密文</strong> 进行发送。</p></li><li><p>数据解密过程：<strong>数据接收方</strong> 收到密文后，若想读取原数据，则需要使用 <strong>加密使用的密钥</strong> 及相同算法的 <strong>逆算法</strong> 对加密的密文进行解密，才能使其恢复成 <strong>可读明文</strong>。</p></li></ol><h3 id="3-2-非对称加密"><a href="#3-2-非对称加密" class="headerlink" title="3.2. 非对称加密"></a>3.2. 非对称加密</h3><p><strong>非对称加密算法</strong>，又称为 <strong>公开密钥加密算法</strong>。它需要两个密钥，一个称为 <strong>公开密钥</strong> (<code>public key</code>)，即 <strong>公钥</strong>，另一个称为 <strong>私有密钥</strong> (<code>private key</code>)，即 <strong>私钥</strong>。</p><p>因为 <strong>加密</strong> 和 <strong>解密</strong> 使用的是两个不同的密钥，所以这种算法称为 <strong>非对称加密算法</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa06e955?w=736&amp;h=214&amp;f=png&amp;s=37513" alt=""></p><ol><li><p>如果使用 <strong>公钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>私钥</strong> 才能 <strong>进行解密</strong>。</p></li><li><p>如果使用 <strong>私钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>公钥</strong> 才能 <strong>进行解密</strong>。</p></li></ol><blockquote><p><strong>例子</strong>：甲方生成 <strong>一对密钥</strong> 并将其中的一把作为 <strong>公钥</strong> 向其它人公开，得到该公钥的 <strong>乙方</strong> 使用该密钥对机密信息 <strong>进行加密</strong> 后再发送给甲方，甲方再使用自己保存的另一把 <strong>专用密钥</strong> (<strong>私钥</strong>)，对 <strong>加密</strong> 后的信息 <strong>进行解密</strong>。</p></blockquote><h2 id="4-常见的签名加密算法"><a href="#4-常见的签名加密算法" class="headerlink" title="4. 常见的签名加密算法"></a>4. 常见的签名加密算法</h2><h3 id="4-1-MD5算法"><a href="#4-1-MD5算法" class="headerlink" title="4.1. MD5算法"></a>4.1. MD5算法</h3><p><code>MD5</code> 用的是 <strong>哈希函数</strong>，它的典型应用是对一段信息产生 <strong>信息摘要</strong>，以 <strong>防止被篡改</strong>。严格来说，<code>MD5</code> 不是一种 <strong>加密算法</strong> 而是 <strong>摘要算法</strong>。无论是多长的输入，<code>MD5</code> 都会输出长度为 <code>128bits</code> 的一个串 (通常用 <code>16</code> <strong>进制</strong> 表示为 <code>32</code> 个字符)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] computeMD5(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageDigest md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        <span class="keyword">return</span> md5.digest(content);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-SHA1算法"><a href="#4-2-SHA1算法" class="headerlink" title="4.2. SHA1算法"></a>4.2. SHA1算法</h3><p><code>SHA1</code> 是和 <code>MD5</code> 一样流行的 <strong>消息摘要算法</strong>，然而 <code>SHA1</code> 比 <code>MD5</code> 的 <strong>安全性更强</strong>。对于长度小于 <code>2 ^ 64</code> 位的消息，<code>SHA1</code> 会产生一个 <code>160</code> 位的 <strong>消息摘要</strong>。基于 <code>MD5</code>、<code>SHA1</code> 的信息摘要特性以及 <strong>不可逆</strong> (一般而言)，可以被应用在检查 <strong>文件完整性</strong> 以及 <strong>数字签名</strong> 等场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] computeSHA1(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageDigest sha1 = MessageDigest.getInstance(<span class="string">"SHA1"</span>);</span><br><span class="line">        <span class="keyword">return</span> sha1.digest(content);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-HMAC算法"><a href="#4-3-HMAC算法" class="headerlink" title="4.3. HMAC算法"></a>4.3. HMAC算法</h3><p><code>HMAC</code> 是密钥相关的 <strong>哈希运算消息认证码</strong>（Hash-based Message Authentication Code），<code>HMAC</code> 运算利用 <strong>哈希算法</strong> (<code>MD5</code>、<code>SHA1</code> 等)，以 <strong>一个密钥</strong> 和 <strong>一个消息</strong> 为输入，生成一个 <strong>消息摘要</strong> 作为 <strong>输出</strong>。</p><p><code>HMAC</code> <strong>发送方</strong> 和 <strong>接收方</strong> 都有的 <code>key</code> 进行计算，而没有这把 <code>key</code> 的第三方，则是 <strong>无法计算</strong> 出正确的 <strong>散列值</strong>的，这样就可以 <strong>防止数据被篡改</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.pocrd.util;</span><br><span class="line"><span class="keyword">import</span> net.pocrd.annotation.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> net.pocrd.define.ConstField;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Mac;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HMacHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HMacHelper.class);</span><br><span class="line">    <span class="keyword">private</span> Mac mac;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MAC算法可选以下多种算法</span></span><br><span class="line"><span class="comment">     * HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_MAC = <span class="string">"HmacMD5"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HMacHelper</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecretKey secretKey = <span class="keyword">new</span> SecretKeySpec(key.getBytes(ConstField.UTF8), KEY_MAC);</span><br><span class="line">            mac = Mac.getInstance(secretKey.getAlgorithm());</span><br><span class="line">            mac.init(secretKey);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"create hmac helper failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">return</span> mac.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] signature, <span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = mac.doFinal(content);</span><br><span class="line">            <span class="keyword">return</span> Arrays.equals(signature, result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"verify sig failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>测试结论</strong>：<code>HMAC</code> 算法实例在 <strong>多线程环境</strong> 下是 <strong>不安全的</strong>。但是需要在 <strong>多线程访问</strong> 时，进行同步的辅助类，使用 <code>ThreadLocal</code> 为 <strong>每个线程缓存</strong> 一个实例可以避免进行锁操作。</p></blockquote><h3 id="4-4-AES-DES-3DES算法"><a href="#4-4-AES-DES-3DES算法" class="headerlink" title="4.4. AES/DES/3DES算法"></a>4.4. AES/DES/3DES算法</h3><p><code>AES</code>、<code>DES</code>、<code>3DES</code> 都是 <strong>对称</strong> 的 <strong>块加密算法</strong>，<strong>加解密</strong> 的过程是 <strong>可逆的</strong>。常用的有 <code>AES128</code>、<code>AES192</code>、<code>AES256</code> (默认安装的 <code>JDK</code> 尚不支持 <code>AES256</code>，需要安装对应的 <code>jce</code> 补丁进行升级 <code>jce1.7</code>，<code>jce1.8</code>)。</p><h4 id="4-4-1-DES算法"><a href="#4-4-1-DES算法" class="headerlink" title="4.4.1. DES算法"></a>4.4.1. DES算法</h4><p><code>DES</code> 加密算法是一种 <strong>分组密码</strong>，以 <code>64</code> 位为 <strong>分组对数据</strong> 加密，它的 <strong>密钥长度</strong> 是 <code>56</code> 位，<strong>加密解密</strong> 用 <strong>同一算法</strong>。</p><p><code>DES</code> 加密算法是对 <strong>密钥</strong> 进行保密，而 <strong>公开算法</strong>，包括加密和解密算法。这样，只有掌握了和发送方 <strong>相同密钥</strong> 的人才能解读由 <code>DES</code>加密算法加密的密文数据。因此，破译 <code>DES</code> 加密算法实际上就是 <strong>搜索密钥的编码</strong>。对于 <code>56</code> 位长度的 <strong>密钥</strong> 来说，如果用 <strong>穷举法</strong> 来进行搜索的话，其运算次数为 <code>2 ^ 56</code> 次。</p><h4 id="4-4-2-3DES算法"><a href="#4-4-2-3DES算法" class="headerlink" title="4.4.2. 3DES算法"></a>4.4.2. 3DES算法</h4><p>是基于 <code>DES</code> 的 <strong>对称算法</strong>，对 <strong>一块数据</strong> 用 <strong>三个不同的密钥</strong> 进行 <strong>三次加密</strong>，<strong>强度更高</strong>。</p><h4 id="4-4-3-AES算法"><a href="#4-4-3-AES算法" class="headerlink" title="4.4.3. AES算法"></a>4.4.3. AES算法</h4><p><code>AES</code> 加密算法是密码学中的 <strong>高级加密标准</strong>，该加密算法采用 <strong>对称分组密码体制</strong>，密钥长度的最少支持为 <code>128</code> 位、 <code>192</code> 位、<code>256</code> 位，分组长度 <code>128</code> 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的 <strong>区块加密标准</strong>。</p><p><code>AES</code> 本身就是为了取代 <code>DES</code> 的，<code>AES</code> 具有更好的 <strong>安全性</strong>、<strong>效率</strong> 和 <strong>灵活性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.pocrd.annotation.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AesHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SecretKeySpec keySpec;</span><br><span class="line">    <span class="keyword">private</span> IvParameterSpec iv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AesHelper</span><span class="params">(<span class="keyword">byte</span>[] aesKey, <span class="keyword">byte</span>[] iv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (aesKey == <span class="keyword">null</span> || aesKey.length &lt; <span class="number">16</span> || (iv != <span class="keyword">null</span> &amp;&amp; iv.length &lt; <span class="number">16</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"错误的初始密钥"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iv == <span class="keyword">null</span>) &#123;</span><br><span class="line">            iv = Md5Util.compute(aesKey);</span><br><span class="line">        &#125;</span><br><span class="line">        keySpec = <span class="keyword">new</span> SecretKeySpec(aesKey, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">this</span>.iv = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AesHelper</span><span class="params">(<span class="keyword">byte</span>[] aesKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (aesKey == <span class="keyword">null</span> || aesKey.length &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"错误的初始密钥"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        keySpec = <span class="keyword">new</span> SecretKeySpec(aesKey, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">this</span>.iv = <span class="keyword">new</span> IvParameterSpec(Md5Util.compute(aesKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">null</span>;</span><br><span class="line">        Cipher cipher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cipher = Cipher.getInstance(<span class="string">"AES/CFB/NoPadding"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);</span><br><span class="line">            result = cipher.doFinal(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] secret) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">null</span>;</span><br><span class="line">        Cipher cipher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cipher = Cipher.getInstance(<span class="string">"AES/CFB/NoPadding"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);</span><br><span class="line">            result = cipher.doFinal(secret);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] randomKey(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyGenerator gen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">            gen.init(size, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">            result = gen.generateKey().getEncoded();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-RSA算法"><a href="#4-5-RSA算法" class="headerlink" title="4.5. RSA算法"></a>4.5. RSA算法</h3><p><code>RSA</code> 加密算法是目前最有影响力的 <strong>公钥加密算法</strong>，并且被普遍认为是目前 <strong>最优秀的公钥方案</strong> 之一。<code>RSA</code> 是第一个能同时用于 <strong>加密</strong> 和 <strong>数字签名</strong> 的算法，它能够 <strong>抵抗</strong> 到目前为止已知的 <strong>所有密码攻击</strong>，已被 <code>ISO</code> 推荐为公钥数据加密标准。</p><blockquote><p><code>RSA</code> <strong>加密算法</strong> 基于一个十分简单的数论事实：将两个大 <strong>素数</strong> 相乘十分容易，但想要对其乘积进行 <strong>因式分解</strong> 却极其困难，因此可以将 <strong>乘积</strong> 公开作为 <strong>加密密钥</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.pocrd.annotation.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"><span class="keyword">import</span> java.security.Signature;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.RSAPrivateCrtKey;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.RSAPublicKey;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RsaHelper.class);</span><br><span class="line">    <span class="keyword">private</span> RSAPublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> RSAPrivateCrtKey privateKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider()); <span class="comment">//使用bouncycastle作为加密算法实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RsaHelper</span><span class="params">(String publicKey, String privateKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Base64Util.decode(publicKey), Base64Util.decode(privateKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RsaHelper</span><span class="params">(<span class="keyword">byte</span>[] publicKey, <span class="keyword">byte</span>[] privateKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">            <span class="keyword">if</span> (publicKey != <span class="keyword">null</span> &amp;&amp; publicKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.publicKey = (RSAPublicKey)keyFactory.generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(publicKey));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (privateKey != <span class="keyword">null</span> &amp;&amp; privateKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.privateKey = (RSAPrivateCrtKey)keyFactory.generatePrivate(<span class="keyword">new</span> PKCS8EncodedKeySpec(privateKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RsaHelper</span><span class="params">(String publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Base64Util.decode(publicKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RsaHelper</span><span class="params">(<span class="keyword">byte</span>[] publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">            <span class="keyword">if</span> (publicKey != <span class="keyword">null</span> &amp;&amp; publicKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.publicKey = (RSAPublicKey)keyFactory.generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(publicKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"public key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"RSA/ECB/PKCS1Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            <span class="keyword">int</span> size = publicKey.getModulus().bitLength() / <span class="number">8</span> - <span class="number">11</span>;</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream((content.length + size - <span class="number">1</span>) / size * (size + <span class="number">11</span>));</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; content.length; ) &#123;</span><br><span class="line">                left = content.length - i;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; size) &#123;</span><br><span class="line">                    cipher.update(content, i, size);</span><br><span class="line">                    i += size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cipher.update(content, i, left);</span><br><span class="line">                    i += left;</span><br><span class="line">                &#125;</span><br><span class="line">                baos.write(cipher.doFinal());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] secret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (privateKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"private key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (secret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"RSA/ECB/PKCS1Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            <span class="keyword">int</span> size = privateKey.getModulus().bitLength() / <span class="number">8</span>;</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream((secret.length + size - <span class="number">12</span>) / (size - <span class="number">11</span>) * size);</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length; ) &#123;</span><br><span class="line">                left = secret.length - i;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; size) &#123;</span><br><span class="line">                    cipher.update(secret, i, size);</span><br><span class="line">                    i += size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cipher.update(secret, i, left);</span><br><span class="line">                    i += left;</span><br><span class="line">                &#125;</span><br><span class="line">                baos.write(cipher.doFinal());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"rsa decrypt failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">if</span> (privateKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"private key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Signature signature = Signature.getInstance(<span class="string">"SHA1WithRSA"</span>);</span><br><span class="line">            signature.initSign(privateKey);</span><br><span class="line">            signature.update(content);</span><br><span class="line">            <span class="keyword">return</span> signature.sign();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] sign, <span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (publicKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"public key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="keyword">null</span> || content == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Signature signature = Signature.getInstance(<span class="string">"SHA1WithRSA"</span>);</span><br><span class="line">            signature.initVerify(publicKey);</span><br><span class="line">            signature.update(content);</span><br><span class="line">            <span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"rsa verify failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-ECC算法"><a href="#4-6-ECC算法" class="headerlink" title="4.6. ECC算法"></a>4.6. ECC算法</h3><p><code>ECC</code> 也是一种 <strong>非对称加密算法</strong>，主要优势是在某些情况下，它比其他的方法使用 <strong>更小的密钥</strong>，比如 <code>RSA</code> <strong>加密算法</strong>，提供 <strong>相当的或更高等级</strong> 的安全级别。不过一个缺点是 <strong>加密和解密操作</strong> 的实现比其他机制 <strong>时间长</strong> (相比 <code>RSA</code> 算法，该算法对 <code>CPU</code> 消耗严重)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.pocrd.annotation.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"><span class="keyword">import</span> java.security.Signature;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EccHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(EccHelper.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="keyword">private</span> BCECPublicKey  publicKey;</span><br><span class="line">    <span class="keyword">private</span> BCECPrivateKey privateKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EccHelper</span><span class="params">(String publicKey, String privateKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Base64Util.decode(publicKey), Base64Util.decode(privateKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EccHelper</span><span class="params">(<span class="keyword">byte</span>[] publicKey, <span class="keyword">byte</span>[] privateKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"EC"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            <span class="keyword">if</span> (publicKey != <span class="keyword">null</span> &amp;&amp; publicKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.publicKey = (BCECPublicKey)keyFactory.generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(publicKey));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (privateKey != <span class="keyword">null</span> &amp;&amp; privateKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.privateKey = (BCECPrivateKey)keyFactory.generatePrivate(<span class="keyword">new</span> PKCS8EncodedKeySpec(privateKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EccHelper</span><span class="params">(String publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Base64Util.decode(publicKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EccHelper</span><span class="params">(<span class="keyword">byte</span>[] publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"EC"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            <span class="keyword">if</span> (publicKey != <span class="keyword">null</span> &amp;&amp; publicKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.publicKey = (BCECPublicKey)keyFactory.generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(publicKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"public key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"ECIES"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            <span class="keyword">int</span> size = SIZE;</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream((content.length + size - <span class="number">1</span>) / size * (size + <span class="number">45</span>));</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; content.length; ) &#123;</span><br><span class="line">                left = content.length - i;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; size) &#123;</span><br><span class="line">                    cipher.update(content, i, size);</span><br><span class="line">                    i += size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cipher.update(content, i, left);</span><br><span class="line">                    i += left;</span><br><span class="line">                &#125;</span><br><span class="line">                baos.write(cipher.doFinal());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] secret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (privateKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"private key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"ECIES"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            <span class="keyword">int</span> size = SIZE + <span class="number">45</span>;</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream((secret.length + size + <span class="number">44</span>) / (size + <span class="number">45</span>) * size);</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length; ) &#123;</span><br><span class="line">                left = secret.length - i;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; size) &#123;</span><br><span class="line">                    cipher.update(secret, i, size);</span><br><span class="line">                    i += size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cipher.update(secret, i, left);</span><br><span class="line">                    i += left;</span><br><span class="line">                &#125;</span><br><span class="line">                baos.write(cipher.doFinal());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"ecc decrypt failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">if</span> (privateKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"private key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Signature signature = Signature.getInstance(<span class="string">"SHA1withECDSA"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            signature.initSign(privateKey);</span><br><span class="line">            signature.update(content);</span><br><span class="line">            <span class="keyword">return</span> signature.sign();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] sign, <span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (publicKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"public key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Signature signature = Signature.getInstance(<span class="string">"SHA1withECDSA"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            signature.initVerify(publicKey);</span><br><span class="line">            signature.update(content);</span><br><span class="line">            <span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"ecc verify failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-各种加密算法对比"><a href="#5-各种加密算法对比" class="headerlink" title="5. 各种加密算法对比"></a>5. 各种加密算法对比</h2><h3 id="5-1-散列算法比较"><a href="#5-1-散列算法比较" class="headerlink" title="5.1. 散列算法比较"></a>5.1. 散列算法比较</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">安全性</th><th style="text-align:left">速度</th></tr></thead><tbody><tr><td style="text-align:left">SHA-1</td><td style="text-align:left">高</td><td style="text-align:left">慢</td></tr><tr><td style="text-align:left">MD5</td><td style="text-align:left">中</td><td style="text-align:left">快</td></tr></tbody></table><h3 id="5-2-对称加密算法比较"><a href="#5-2-对称加密算法比较" class="headerlink" title="5.2. 对称加密算法比较"></a>5.2. 对称加密算法比较</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">密钥名称</th><th style="text-align:left">运行速度</th><th style="text-align:left">安全性</th><th style="text-align:left">资源消耗</th></tr></thead><tbody><tr><td style="text-align:left">DES</td><td style="text-align:left">56位</td><td style="text-align:left">较快</td><td style="text-align:left">低</td><td style="text-align:left">中</td></tr><tr><td style="text-align:left">3DES</td><td style="text-align:left">112位或168位</td><td style="text-align:left">慢</td><td style="text-align:left">中</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">AES</td><td style="text-align:left">128、192、256位</td><td style="text-align:left">快</td><td style="text-align:left">高</td><td style="text-align:left">低</td></tr></tbody></table><h3 id="5-3-非对称加密算法比较"><a href="#5-3-非对称加密算法比较" class="headerlink" title="5.3. 非对称加密算法比较"></a>5.3. 非对称加密算法比较</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">成熟度</th><th style="text-align:left">安全性</th><th style="text-align:left">运算速度</th><th style="text-align:left">资源消耗</th></tr></thead><tbody><tr><td style="text-align:left">RSA</td><td style="text-align:left">高</td><td style="text-align:left">高</td><td style="text-align:left">中</td><td style="text-align:left">中</td></tr><tr><td style="text-align:left">ECC</td><td style="text-align:left">高</td><td style="text-align:left">高</td><td style="text-align:left">慢</td><td style="text-align:left">高</td></tr></tbody></table><h3 id="5-4-对称算法与非对称加密算法"><a href="#5-4-对称算法与非对称加密算法" class="headerlink" title="5.4. 对称算法与非对称加密算法"></a>5.4. 对称算法与非对称加密算法</h3><h4 id="5-4-1-对称算法"><a href="#5-4-1-对称算法" class="headerlink" title="5.4.1. 对称算法"></a>5.4.1. 对称算法</h4><ol><li><p><strong>密钥管理</strong>：比较难，不适合互联网，一般用于内部系统</p></li><li><p><strong>安全性</strong>：中</p></li><li><p><strong>加密速度</strong>：快好 <strong>几个数量级</strong> (软件加解密速度至少快 <code>100</code> 倍，每秒可以加解密数 <code>M</code> <strong>比特</strong> 数据)，适合大数据量的加解密处理</p></li></ol><h4 id="5-4-2-非对称算法"><a href="#5-4-2-非对称算法" class="headerlink" title="5.4.2. 非对称算法"></a>5.4.2. 非对称算法</h4><ol><li><p><strong>密钥管理</strong>：密钥容易管理</p></li><li><p><strong>安全性</strong>：高</p></li><li><p><strong>加密速度</strong>：比较慢，适合 <strong>小数据量</strong> 加解密或数据签名</p></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了 <strong>数字签名</strong>，<strong>加密和解密</strong>，<strong>对称加密和非对称加密</strong>，然后详细介绍了 <code>MD5</code>，<code>SHA-1</code>，<code>HMAC</code>，<code>DES/AES</code>，<code>RSA</code> 和 <code>ECC</code> 这几种加密算法和代码示例。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5dcc40392?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;数字签名&lt;/strong&gt;、&lt;strong&gt;信息加密&lt;/strong&gt; 是前后端开发都经常需要使用到的技术，应用场景包括了用户登入、交易、信息通讯、&lt;code&gt;oauth&lt;/code&gt; 等等，不同的应用场景也会需要使用到不同的签名加密算法，或者需要搭配不一样的 &lt;strong&gt;签名加密算法&lt;/strong&gt; 来达到业务目标。这里简单的给大家介绍几种常见的签名加密算法和一些典型场景下的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="加密算法系列" scheme="https://ostenant.coding.me/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MD5" scheme="https://ostenant.coding.me/tags/MD5/"/>
    
      <category term="SHA1" scheme="https://ostenant.coding.me/tags/SHA1/"/>
    
      <category term="DES" scheme="https://ostenant.coding.me/tags/DES/"/>
    
      <category term="AES" scheme="https://ostenant.coding.me/tags/AES/"/>
    
      <category term="RSA" scheme="https://ostenant.coding.me/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>浅谈消息队列及常见的消息中间件</title>
    <link href="https://ostenant.coding.me/2018/07/07/%E6%B5%85%E8%B0%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://ostenant.coding.me/2018/07/07/浅谈消息队列及常见的消息中间件/</id>
    <published>2018-07-07T15:27:00.000Z</published>
    <updated>2018-07-19T09:52:38.717Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>消息队列</strong> 已经逐渐成为企业应用系统 <strong>内部通信</strong> 的核心手段。它具有 <strong>低耦合</strong>、<strong>可靠投递</strong>、<strong>广播</strong>、<strong>流量控制</strong>、<strong>最终一致性</strong> 等一系列功能。</p><p>当前使用较多的 <strong>消息队列</strong> 有 <code>RabbitMQ</code>、<code>RocketMQ</code>、<code>ActiveMQ</code>、<code>Kafka</code>、<code>ZeroMQ</code>、<code>MetaMQ</code> 等，而部分 <strong>数据库</strong> 如 <code>Redis</code>、<code>MySQL</code> 以及 <code>phxsql</code> 也可实现消息队列的功能。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ed095ffed?w=989&amp;h=290&amp;f=webp&amp;s=10430" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-消息队列概述"><a href="#1-消息队列概述" class="headerlink" title="1. 消息队列概述"></a>1. 消息队列概述</h2><p><strong>消息队列</strong> 是指利用 <strong>高效可靠</strong> 的 <strong>消息传递机制</strong> 进行与平台无关的 <strong>数据交流</strong>，并基于 <strong>数据通信</strong> 来进行分布式系统的集成。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7c77109d?w=623&amp;h=242&amp;f=webp&amp;s=6046" alt=""></p><p>通过提供 <strong>消息传递</strong> 和 <strong>消息排队</strong> 模型，它可以在 <strong>分布式环境</strong> 下提供 <strong>应用解耦</strong>、<strong>弹性伸缩</strong>、<strong>冗余存储</strong>、<strong>流量削峰</strong>、<strong>异步通信</strong>、<strong>数据同步</strong> 等等功能，其作为 <strong>分布式系统架构</strong> 中的一个重要组件，有着举足轻重的地位。</p><h2 id="2-消息队列的特点"><a href="#2-消息队列的特点" class="headerlink" title="2. 消息队列的特点"></a>2. 消息队列的特点</h2><h3 id="2-1-采用异步处理模式"><a href="#2-1-采用异步处理模式" class="headerlink" title="2.1. 采用异步处理模式"></a>2.1. 采用异步处理模式</h3><p><strong>消息发送者</strong> 可以发送一个消息而无须等待响应。<strong>消息发送者</strong> 将消息发送到一条 <strong>虚拟的通道</strong>（<strong>主题</strong> 或 <strong>队列</strong>）上，<strong>消息接收者</strong> 则 <strong>订阅</strong> 或是 <strong>监听</strong> 该通道。一条信息可能最终转发给 <strong>一个或多个</strong> 消息接收者，这些接收者都无需对 <strong>消息发送者</strong> 做出 <strong>同步回应</strong>。整个过程都是 <strong>异步的</strong>。</p><h3 id="2-2-应用系统之间解耦合"><a href="#2-2-应用系统之间解耦合" class="headerlink" title="2.2. 应用系统之间解耦合"></a>2.2. 应用系统之间解耦合</h3><p>主要体现在如下两点：</p><ol><li><p>发送者和接受者不必了解对方、只需要 <strong>确认消息</strong>；</p></li><li><p>发送者和接受者 <strong>不必同时在线</strong>。</p></li></ol><p>比如在线交易系统为了保证数据的 <strong>最终一致</strong>，在 <strong>支付系统</strong> 处理完成后会把 <strong>支付结果</strong> 放到 <strong>消息中间件</strong> 里，通知 <strong>订单系统</strong> 修改 <strong>订单支付状态</strong>。两个系统是通过消息中间件解耦的。</p><h2 id="3-消息队列的传递服务模型"><a href="#3-消息队列的传递服务模型" class="headerlink" title="3. 消息队列的传递服务模型"></a>3. 消息队列的传递服务模型</h2><p>消息队列的 <strong>传递服务模型</strong> 如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7c831340?w=653&amp;h=406&amp;f=jpeg&amp;s=51288" alt=""></p><h2 id="4-消息队列的的传输模式"><a href="#4-消息队列的的传输模式" class="headerlink" title="4. 消息队列的的传输模式"></a>4. 消息队列的的传输模式</h2><h3 id="4-1-点对点模型"><a href="#4-1-点对点模型" class="headerlink" title="4.1. 点对点模型"></a>4.1. 点对点模型</h3><p><strong>点对点模型</strong> 用于 <strong>消息生产者</strong> 和 <strong>消息消费者</strong> 之间 <strong>点到点</strong> 的通信。消息生产者将消息发送到由某个名字标识的特定消费者。这个名字实际上对于消费服务中的一个 <strong>队列</strong>（<code>Queue</code>），在消息传递给消费者之前它被 <strong>存储</strong> 在这个队列中。<strong>队列消息</strong> 可以放在 <strong>内存</strong> 中也可以 <strong>持久化</strong>，以保证在消息服务出现故障时仍然能够传递消息。</p><p>传统的点对点消息中间件通常由 <strong>消息队列服务</strong>、<strong>消息传递服务</strong>、<strong>消息队列</strong> 和 <strong>消息应用程序接口</strong> <code>API</code> 组成，其典型的结构如下图所示。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7c97b0c3?w=910&amp;h=408&amp;f=jpeg&amp;s=68819" alt=""></p><p><strong>特点：</strong></p><ol><li>每个消息只用一个消费者；</li><li>发送者和接受者没有时间依赖；</li><li>接受者确认消息接受和处理成功。</li></ol><p><strong>示意图如下所示：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7c89962f?w=832&amp;h=126&amp;f=jpeg&amp;s=14475" alt=""></p><h3 id="4-2-发布-订阅模型（Pub-Sub）"><a href="#4-2-发布-订阅模型（Pub-Sub）" class="headerlink" title="4.2. 发布/订阅模型（Pub/Sub）"></a>4.2. 发布/订阅模型（Pub/Sub）</h3><p><strong>发布者/订阅者</strong> 模型支持向一个特定的 <strong>消息主题</strong> 生产消息。<code>0</code> 或 <strong>多个订阅者</strong> 可能对接收来自 <strong>特定消息主题</strong> 的消息感兴趣。</p><p>在这种模型下，发布者和订阅者彼此不知道对方，就好比是匿名公告板。这种模式被概况为：多个消费者可以获得消息，在 <strong>发布者</strong> 和 <strong>订阅者</strong> 之间存在 <strong>时间依赖性</strong>。发布者需要建立一个 <strong>订阅</strong>（<code>subscription</code>），以便能够消费者订阅。<strong>订阅者</strong> 必须保持 <strong>持续的活动状态</strong> 并 <strong>接收消息</strong>。</p><p>在这种情况下，在订阅者 <strong>未连接时</strong>，发布的消息将在订阅者 <strong>重新连接</strong> 时 <strong>重新发布</strong>，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7faf60a5?w=492&amp;h=268&amp;f=jpeg&amp;s=16077" alt=""></p><p><strong>特性：</strong></p><ol><li>每个消息可以有多个订阅者；</li><li>客户端只有订阅后才能接收到消息；</li><li>持久订阅和非持久订阅。</li></ol><blockquote><p>注意：</p><ol><li>发布者和订阅者有时间依赖：接受者和发布者只有建立订阅关系才能收到消息；</li><li>持久订阅：订阅关系建立后，消息就不会消失，不管订阅者是否都在线；</li><li>非持久订阅：订阅者为了接受消息，必须一直在线。<br>当只有一个订阅者时约等于点对点模式</li></ol></blockquote><h2 id="5-消息队列应用场景"><a href="#5-消息队列应用场景" class="headerlink" title="5. 消息队列应用场景"></a>5. 消息队列应用场景</h2><p>当你需要使用 <strong>消息队列</strong> 时，首先需要考虑它的必要性。可以使用消息队列的场景有很多，最常用的几种，是做 <strong>应用程序松耦合</strong>、<strong>异步处理模式</strong>、<strong>发布与订阅</strong>、<strong>最终一致性</strong>、<strong>错峰流控</strong> 和 <strong>日志缓冲</strong> 等。反之，如果需要 <strong>强一致性</strong>，关注业务逻辑的处理结果，则使用 <code>RPC</code> 显得更为合适。</p><h3 id="5-1-异步处理"><a href="#5-1-异步处理" class="headerlink" title="5.1. 异步处理"></a>5.1. 异步处理</h3><p><strong>非核心</strong> 流程 <strong>异步化</strong>，减少系统 <strong>响应时间</strong>，提高 <strong>吞吐量</strong>。例如：<strong>短信通知</strong>、<strong>终端状态推送</strong>、<code>App</code> <strong>推送</strong>、<strong>用户注册</strong> 等。</p><p><strong>消息队列</strong> 一般都内置了 <strong>高效的通信机制</strong>，因此也可以用于单纯的消息通讯，比如实现 <strong>点对点消息队列</strong> 或者 <strong>聊天室</strong> 等。</p><h4 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h4><p>网站用户注册，注册成功后会过一会发送邮件确认或者短息。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e800ce905?w=541&amp;h=300&amp;f=jpeg&amp;s=16288" alt=""></p><h3 id="5-2-系统解耦"><a href="#5-2-系统解耦" class="headerlink" title="5.2. 系统解耦"></a>5.2. 系统解耦</h3><ul><li><p>系统之间不是 <strong>强耦合的</strong>，<strong>消息接受者</strong> 可以随意增加，而不需要修改 <strong>消息发送者的代码</strong>。<strong>消息发送者</strong> 的成功不依赖 <strong>消息接受者</strong>（比如：有些银行接口不稳定，但调用方并不需要依赖这些接口）。</p></li><li><p><strong>不强依赖</strong> 于非本系统的核心流程，对于 <strong>非核心流程</strong>，可以放到消息队列中让 <strong>消息消费者</strong> 去按需消费，而 <strong>不影响核心主流程</strong>。</p></li></ul><h3 id="5-3-最终一致性"><a href="#5-3-最终一致性" class="headerlink" title="5.3. 最终一致性"></a>5.3. 最终一致性</h3><p><strong>最终一致性</strong> 不是 <strong>消息队列</strong> 的必备特性，但确实可以依靠 <strong>消息队列</strong> 来做 <strong>最终一致性</strong> 的事情。</p><ul><li><p><strong>先写消息再操作</strong>，确保操作完成后再修改消息状态。<strong>定时任务补偿机制</strong> 实现消息 <strong>可靠发送接收</strong>、业务操作的可靠执行，要注意 <strong>消息重复</strong> 与 <strong>幂等设计</strong>。</p></li><li><p>所有不保证 <code>100%</code> <strong>不丢消息</strong> 的消息队列，理论上无法实现 <strong>最终一致性</strong>。</p></li></ul><blockquote><p>像 <code>Kafka</code> 一类的设计，在设计层面上就有 <strong>丢消息</strong> 的可能（比如 <strong>定时刷盘</strong>，如果掉电就会丢消息）。哪怕只丢千分之一的消息，业务也必须用其他的手段来保证结果正确。</p></blockquote><h3 id="5-4-广播"><a href="#5-4-广播" class="headerlink" title="5.4. 广播"></a>5.4. 广播</h3><p><strong>生产者/消费者</strong> 模式，只需要关心消息是否 <strong>送达队列</strong>，至于谁希望订阅和需要消费，是 <strong>下游</strong> 的事情，无疑极大地减少了开发和联调的工作量。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea267f536?w=595&amp;h=346&amp;f=webp&amp;s=10596" alt=""></p><h3 id="5-5-流量削峰和流控"><a href="#5-5-流量削峰和流控" class="headerlink" title="5.5. 流量削峰和流控"></a>5.5. 流量削峰和流控</h3><p>当 <strong>上下游系统</strong> 处理能力存在差距的时候，利用 <strong>消息队列</strong> 做一个通用的 <strong>“漏斗”</strong>，进行 <strong>限流控制</strong>。在下游有能力处理的时候，再进行分发。</p><blockquote><p>举个例子：用户在支付系统成功结账后，订单系统会通过短信系统向用户推送扣费通知。<br><strong>短信系统</strong> 可能由于 <strong>短板效应</strong>，速度卡在 <strong>网关</strong> 上（每秒几百次请求），跟 <strong>前端的并发量</strong> 不是一个数量级。<br>于是，就造成 <strong>支付系统</strong> 和 <strong>短信系统</strong> 的处理能力出现差异化。</p></blockquote><p>然而用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过 <strong>协商</strong>、<strong>滑动窗口</strong> 等复杂的方案也不是说不能实现。但 <strong>系统复杂性</strong> 指数级增长，势必在 <strong>上游</strong> 或者 <strong>下游</strong> 做 <strong>存储</strong>，并且要处理 <strong>定时</strong>、<strong>拥塞</strong> 等一系列问题。而且每当有 <strong>处理能力有差距</strong> 的时候，都需要 <strong>单独</strong> 开发一套逻辑来维护这套逻辑。</p><p>所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。</p><h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h4><ol><li>把消息队列当成可靠的 <strong>消息暂存地</strong>，进行一定程度的 <strong>消息堆积</strong>；</li><li>定时进行消息投递，比如模拟 <strong>用户秒杀</strong> 访问，进行 <strong>系统性能压测</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea3e6231a?w=587&amp;h=401&amp;f=jpeg&amp;s=24739" alt=""></p><h3 id="5-6-日志处理"><a href="#5-6-日志处理" class="headerlink" title="5.6. 日志处理"></a>5.6. 日志处理</h3><p>将消息队列用在 <strong>日志处理</strong> 中，比如 <code>Kafka</code> 的应用，解决 <strong>海量日志</strong> 传输和缓冲的问题。</p><h4 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a>应用案例</h4><p>把日志进行集中收集，用于计算 <code>PV</code>、<strong>用户行为分析</strong> 等等。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea41e864b?w=648&amp;h=247&amp;f=jpeg&amp;s=18958" alt=""></p><h3 id="5-7-消息通讯"><a href="#5-7-消息通讯" class="headerlink" title="5.7. 消息通讯"></a>5.7. 消息通讯</h3><p>消息队列一般都内置了 <strong>高效的通信机制</strong>，因此也可以用于单纯的 <strong>消息通讯</strong>，比如实现 <strong>点对点消息队列</strong> 或者 <strong>聊天室</strong> 等。</p><h2 id="6-消息队列的推拉模型"><a href="#6-消息队列的推拉模型" class="headerlink" title="6. 消息队列的推拉模型"></a>6. 消息队列的推拉模型</h2><h3 id="6-1-Push推消息模型"><a href="#6-1-Push推消息模型" class="headerlink" title="6.1. Push推消息模型"></a>6.1. Push推消息模型</h3><p><strong>消息生产者</strong> 将消息发送给 <strong>消息队列</strong>，<strong>消息队列</strong> 又将消息推给 <strong>消息消费者</strong>。</p><h3 id="6-2-Pull拉消息模型"><a href="#6-2-Pull拉消息模型" class="headerlink" title="6.2. Pull拉消息模型"></a>6.2. Pull拉消息模型</h3><p><strong>消费者</strong> 请求 <strong>消息队列</strong> 接受消息，<strong>消息生产者</strong> 从 <strong>消息队列</strong> 中拉该消息。</p><h3 id="6-3-两种类型的区别"><a href="#6-3-两种类型的区别" class="headerlink" title="6.3. 两种类型的区别"></a>6.3. 两种类型的区别</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea4b19ea9?w=581&amp;h=574&amp;f=jpeg&amp;s=120422" alt=""></p><h2 id="7-消息队列技术对比"><a href="#7-消息队列技术对比" class="headerlink" title="7. 消息队列技术对比"></a>7. 消息队列技术对比</h2><p>本部分主要介绍四种常用的消息队列（<code>ActiveMQ</code> / <code>RabbitMQ</code> / <code>RocketMQ</code> / <code>Kafka</code>）的主要特性、优点、缺点。</p><h3 id="7-1-ActiveMQ"><a href="#7-1-ActiveMQ" class="headerlink" title="7.1. ActiveMQ"></a>7.1. ActiveMQ</h3><p><code>ActiveMQ</code> 是由 <code>Apache</code> 出品，<code>ActiveMQ</code> 是一个完全支持<code>JMS1.1</code> 和 <code>J2EE 1.4</code> 规范的 <code>JMS Provider</code> 实现。它非常快速，支持 <strong>多种语言的客户端</strong> 和 <strong>协议</strong>，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea7cdc2c0?w=568&amp;h=552&amp;f=png&amp;s=41834" alt=""></p><h4 id="a-主要特性"><a href="#a-主要特性" class="headerlink" title="(a) 主要特性"></a>(a) 主要特性</h4><ol><li><p><strong>服从JMS规范</strong>：<code>JMS</code> 规范提供了良好的标准和保证，包括：<strong>同步</strong> 或 <strong>异步</strong> 的消息分发，一次和仅一次的消息分发，<strong>消息接收</strong> 和 <strong>订阅</strong> 等等。遵从 <code>JMS</code> 规范的好处在于，不论使用什么 <code>JMS</code> 实现提供者，这些基础特性都是可用的；</p></li><li><p><strong>连接灵活性</strong>：<code>ActiveMQ</code> 提供了广泛的 <strong>连接协议</strong>，支持的协议有：<code>HTTP/S</code>，<code>IP</code> <strong>多播</strong>，<code>SSL</code>，<code>TCP</code>，<code>UDP</code> 等等。对众多协议的支持让 <code>ActiveMQ</code> 拥有了很好的灵活性；</p></li><li><p><strong>支持的协议种类多</strong>：<code>OpenWire</code>、<code>STOMP</code>、<code>REST</code>、<code>XMPP</code>、<code>AMQP</code>；</p></li><li><p><strong>持久化插件和安全插件</strong>：<code>ActiveMQ</code> 提供了 <strong>多种持久化</strong> 选择。而且，<code>ActiveMQ</code> 的安全性也可以完全依据用户需求进行 <strong>自定义鉴权</strong> 和 <strong>授权</strong>；</p></li><li><p><strong>支持的客户端语言种类多</strong>：除了 <code>Java</code> 之外，还有：<code>C/C++</code>，<code>.NET</code>，<code>Perl</code>，<code>PHP</code>，<code>Python</code>，<code>Ruby</code>；</p></li><li><p><strong>代理集群</strong>：多个 <code>ActiveMQ</code> <strong>代理</strong> 可以组成一个 <strong>集群</strong> 来提供服务；</p></li><li><p><strong>异常简单的管理</strong>：<code>ActiveMQ</code> 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以 <strong>监控</strong> <code>ActiveMQ</code> 不同层面的数据，包括使用在 <code>JConsole</code> 或者在 <code>ActiveMQ</code> 的 <code>Web Console</code> 中使用 <code>JMX</code>。通过处理 <code>JMX</code> 的告警消息，通过使用 <strong>命令行脚本</strong>，甚至可以通过监控各种类型的 <strong>日志</strong>。</p></li></ol><h4 id="b-部署环境"><a href="#b-部署环境" class="headerlink" title="(b) 部署环境"></a>(b) 部署环境</h4><p><code>ActiveMQ</code> 可以运行在 <code>Java</code> 语言所支持的平台之上。使用 <code>ActiveMQ</code> 需要：</p><ul><li><code>Java JDK</code></li><li><code>ActiveMQ</code> 安装包</li></ul><h4 id="c-优点"><a href="#c-优点" class="headerlink" title="(c) 优点"></a>(c) 优点</h4><ol><li><p><strong>跨平台</strong> (<code>JAVA</code> 编写与平台无关，<code>ActiveMQ</code> 几乎可以运行在任何的 <code>JVM</code> 上)；</p></li><li><p>可以用 <code>JDBC</code>：可以将 <strong>数据持久化</strong> 到数据库。虽然使用 <code>JDBC</code> 会降低 <code>ActiveMQ</code> 的性能，但是数据库一直都是开发人员最熟悉的存储介质；</p></li><li><p>支持 <code>JMS</code> 规范：支持 <code>JMS</code> 规范提供的 <strong>统一接口</strong>;</p></li><li><p>支持 <strong>自动重连</strong> 和 <strong>错误重试机制</strong>；</p></li><li><p>有安全机制：支持基于 <code>shiro</code>，<code>jaas</code> 等多种 <strong>安全配置机制</strong>，可以对 <code>Queue/Topic</code> 进行 <strong>认证和授权</strong>；</p></li><li><p>监控完善：拥有完善的 <strong>监控</strong>，包括 <code>Web Console</code>，<code>JMX</code>，<code>Shell</code> 命令行，<code>Jolokia</code> 的 <code>RESTful API</code>；</p></li><li><p>界面友善：提供的 <code>Web Console</code> 可以满足大部分情况，还有很多 <strong>第三方的组件</strong> 可以使用，比如 <code>hawtio</code>；</p></li></ol><h4 id="d-缺点"><a href="#d-缺点" class="headerlink" title="(d) 缺点"></a>(d) 缺点</h4><ol><li><p>社区活跃度不及 <code>RabbitMQ</code> 高；</p></li><li><p>根据其他用户反馈，会出莫名其妙的问题，会 <strong>丢失消息</strong>；</p></li><li><p>目前重心放到 <code>activemq 6.0</code> 产品 <code>Apollo</code>，对 <code>5.x</code> 的维护较少；</p></li><li><p>不适合用于 <strong>上千个队列</strong> 的应用场景；</p></li></ol><h3 id="7-2-RabbitMQ"><a href="#7-2-RabbitMQ" class="headerlink" title="7.2. RabbitMQ"></a>7.2. RabbitMQ</h3><p><code>RabbitMQ</code> 于 <code>2007</code> 年发布，是一个在 <code>AMQP</code> (<strong>高级消息队列协议</strong>)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ece3b5d7a?w=635&amp;h=298&amp;f=png&amp;s=36428" alt=""></p><h4 id="a-主要特性-1"><a href="#a-主要特性-1" class="headerlink" title="(a) 主要特性"></a>(a) 主要特性</h4><ol><li><p><strong>可靠性</strong>：提供了多种技术可以让你在 <strong>性能</strong> 和 <strong>可靠性</strong> 之间进行 <strong>权衡</strong>。这些技术包括 <strong>持久性机制</strong>、<strong>投递确认</strong>、<strong>发布者证实</strong> 和 <strong>高可用性机制</strong>；</p></li><li><p><strong>灵活的路由</strong>：消息在到达队列前是通过 <strong>交换机</strong> 进行 <strong>路由</strong> 的。<code>RabbitMQ</code> 为典型的路由逻辑提供了 <strong>多种内置交换机</strong> 类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做 <code>RabbitMQ</code> 的 <strong>插件</strong> 来使用；</p></li><li><p><strong>消息集群</strong>：在相同局域网中的多个 <code>RabbitMQ</code> 服务器可以 <strong>聚合</strong> 在一起，作为一个独立的逻辑代理来使用；</p></li><li><p><strong>队列高可用</strong>：队列可以在集群中的机器上 <strong>进行镜像</strong>，以确保在硬件问题下还保证 <strong>消息安全</strong>；</p></li><li><p><strong>支持多种协议</strong>：支持 <strong>多种消息队列协议</strong>；</p></li><li><p><strong>支持多种语言</strong>：用 <code>Erlang</code> 语言编写，支持只要是你能想到的 <strong>所有编程语言</strong>；</p></li><li><p><strong>管理界面</strong>： <code>RabbitMQ</code> 有一个易用的 <strong>用户界面</strong>，使得用户可以 <strong>监控</strong> 和 <strong>管理</strong> 消息 <code>Broker</code> 的许多方面；</p></li><li><p><strong>跟踪机制</strong>：如果 <strong>消息异常</strong>，<code>RabbitMQ</code> 提供消息跟踪机制，使用者可以找出发生了什么；</p></li><li><p><strong>插件机制</strong>：提供了许多 <strong>插件</strong>，来从多方面进行扩展，也可以编写自己的插件。</p></li></ol><h4 id="b-部署环境-1"><a href="#b-部署环境-1" class="headerlink" title="(b) 部署环境"></a>(b) 部署环境</h4><p><code>RabbitMQ</code> 可以运行在 <code>Erlang</code> 语言所支持的平台之上，包括 <code>Solaris</code>，<code>BSD</code>，<code>Linux</code>，<code>MacOSX</code>，<code>TRU64</code>，<code>Windows</code> 等。使用 <code>RabbitMQ</code> 需要：</p><ul><li><code>ErLang</code> 语言包</li><li><code>RabbitMQ</code> 安装包</li></ul><h4 id="c-优点-1"><a href="#c-优点-1" class="headerlink" title="(c) 优点"></a>(c) 优点</h4><ol><li><p>由于 <code>Erlang</code> 语言的特性，消息队列性能较好，支持 <strong>高并发</strong>；</p></li><li><p>健壮、稳定、易用、<strong>跨平台</strong>、支持 <strong>多种语言</strong>、文档齐全；</p></li><li><p>有消息 <strong>确认机制</strong> 和 <strong>持久化机制</strong>，可靠性高；</p></li><li><p>高度可定制的 <strong>路由</strong>；</p></li><li><p><strong>管理界面</strong> 较丰富，在互联网公司也有较大规模的应用，社区活跃度高。</p></li></ol><h4 id="d-缺点-1"><a href="#d-缺点-1" class="headerlink" title="(d) 缺点"></a>(d) 缺点</h4><ol><li><p>尽管结合 <code>Erlang</code> 语言本身的并发优势，性能较好，但是不利于做 <strong>二次开发和维护</strong>；</p></li><li><p>实现了 <strong>代理架构</strong>，意味着消息在发送到客户端之前可以在 <strong>中央节点</strong> 上排队。此特性使得 <code>RabbitMQ</code> 易于使用和部署，但是使得其 <strong>运行速度较慢</strong>，因为中央节点 <strong>增加了延迟</strong>，<strong>消息封装后</strong> 也比较大；</p></li><li><p>需要学习 <strong>比较复杂</strong> 的 <strong>接口和协议</strong>，学习和维护成本较高。</p></li></ol><h3 id="7-3-RocketMQ"><a href="#7-3-RocketMQ" class="headerlink" title="7.3. RocketMQ"></a>7.3. RocketMQ</h3><p><code>RocketMQ</code> 出自 <strong>阿里</strong> 的开源产品，用 <code>Java</code> 语言实现，在设计时参考了 <code>Kafka</code>，并做出了自己的一些改进，<strong>消息可靠性上</strong> 比 <code>Kafka</code> 更好。<code>RocketMQ</code> 在阿里内部被广泛应用在 <strong>订单</strong>，<strong>交易</strong>，<strong>充值</strong>，<strong>流计算</strong>，<strong>消息推送</strong>，<strong>日志流式处理</strong>，<code>binglog</code> <strong>分发</strong> 等场景。</p><h4 id="a-主要特性-2"><a href="#a-主要特性-2" class="headerlink" title="(a) 主要特性"></a>(a) 主要特性</h4><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ec333c809" alt=""></p><ol><li><p>基于 <strong>队列模型</strong>：具有 <strong>高性能</strong>、<strong>高可靠</strong>、<strong>高实时</strong>、<strong>分布式</strong> 等特点；</p></li><li><p><code>Producer</code>、<code>Consumer</code>、<strong>队列</strong> 都支持 <strong>分布式</strong>；</p></li><li><p><code>Producer</code> 向一些队列轮流发送消息，<strong>队列集合</strong> 称为 <code>Topic</code>。<code>Consumer</code> 如果做 <strong>广播消费</strong>，则一个 <code>Consumer</code> 实例消费这个 <code>Topic</code> 对应的 <strong>所有队列</strong>；如果做 <strong>集群消费</strong>，则 <strong>多个</strong> <code>Consumer</code> 实例 <strong>平均消费</strong> 这个 <code>Topic</code> 对应的队列集合；</p></li><li><p>能够保证 <strong>严格的消息顺序</strong>；</p></li><li><p>提供丰富的 <strong>消息拉取模式</strong>；</p></li><li><p>高效的订阅者 <strong>水平扩展</strong>能力；</p></li><li><p><strong>实时</strong> 的 <strong>消息订阅机制</strong>；</p></li><li><p>亿级 <strong>消息堆积</strong> 能力；</p></li><li><p>较少的外部依赖。</p></li></ol><h4 id="b-部署环境-2"><a href="#b-部署环境-2" class="headerlink" title="(b) 部署环境"></a>(b) 部署环境</h4><p><code>RocketMQ</code> 可以运行在 <code>Java</code> 语言所支持的平台之上。使用 <code>RocketMQ</code> 需要：</p><ul><li><code>Java JDK</code></li><li>安装 <code>git</code>、<code>Maven</code></li><li><code>RocketMQ</code> 安装包</li></ul><h4 id="c-优点-2"><a href="#c-优点-2" class="headerlink" title="(c) 优点"></a>(c) 优点</h4><ol><li><p><strong>单机</strong> 支持 <code>1</code> 万以上 <strong>持久化队列</strong>；</p></li><li><p><code>RocketMQ</code> 的所有消息都是 <strong>持久化的</strong>，先写入系统  <code>PAGECACHE</code>，然后 <strong>刷盘</strong>，可以保证 <strong>内存</strong> 与 <strong>磁盘</strong> 都有一份数据，而 <strong>访问</strong> 时，直接 <strong>从内存读取</strong>。</p></li><li><p>模型简单，接口易用（<code>JMS</code> 的接口很多场合并不太实用）；</p></li><li><p><strong>性能非常好</strong>，可以允许 <strong>大量堆积消息</strong> 在 <code>Broker</code> 中；</p></li><li><p>支持 <strong>多种消费模式</strong>，包括 <strong>集群消费</strong>、<strong>广播消费</strong>等；</p></li><li><p>各个环节 <strong>分布式扩展设计</strong>，支持 <strong>主从</strong> 和 <strong>高可用</strong>；</p></li><li><p>开发度较活跃，版本更新很快。</p></li></ol><h4 id="d-缺点-2"><a href="#d-缺点-2" class="headerlink" title="(d) 缺点"></a>(d) 缺点</h4><ol><li><p>支持的 <strong>客户端语言</strong> 不多，目前是 <code>Java</code> 及 <code>C++</code>，其中 <code>C++</code> 还不成熟；</p></li><li><p><code>RocketMQ</code> 社区关注度及成熟度也不及前两者；</p></li><li><p>没有 <code>Web</code> 管理界面，提供了一个 <code>CLI</code> (命令行界面) 管理工具带来 <strong>查询</strong>、<strong>管理</strong> 和 <strong>诊断各种问题</strong>；</p></li><li><p>没有在 <code>MQ</code> 核心里实现 <code>JMS</code> 等接口；</p></li></ol><h3 id="7-4-Kafka"><a href="#7-4-Kafka" class="headerlink" title="7.4. Kafka"></a>7.4. Kafka</h3><p><code>Apache Kafka</code> 是一个 <strong>分布式消息发布订阅</strong> 系统。它最初由 <code>LinkedIn</code> 公司基于独特的设计实现为一个 <strong>分布式的日志提交系统</strong> (<code>a distributed commit log</code>)，之后成为 <code>Apache</code> 项目的一部分。<code>Kafka</code> <strong>性能高效</strong>、<strong>可扩展良好</strong> 并且 <strong>可持久化</strong>。它的 <strong>分区特性</strong>，<strong>可复制</strong> 和 <strong>可容错</strong> 都是其不错的特性。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ec4ba760a?w=708&amp;h=364&amp;f=png&amp;s=55959" alt=""></p><h4 id="a-主要特性-3"><a href="#a-主要特性-3" class="headerlink" title="(a) 主要特性"></a>(a) 主要特性</h4><ol><li><p><strong>快速持久化</strong>：可以在 <code>O(1)</code> 的系统开销下进行 <strong>消息持久化</strong>；</p></li><li><p><strong>高吞吐</strong>：在一台普通的服务器上既可以达到 <code>10W/s</code> 的 <strong>吞吐速率</strong>；</p></li><li><p><strong>完全的分布式系统</strong>：<code>Broker</code>、<code>Producer</code> 和 <code>Consumer</code> 都原生自动支持 <strong>分布式</strong>，自动实现 <strong>负载均衡</strong>；</p></li><li><p>支持 <strong>同步</strong> 和 <strong>异步</strong> 复制两种 <strong>高可用机制</strong>；</p></li><li><p>支持 <strong>数据批量发送</strong> 和 <strong>拉取</strong>；</p></li><li><p><strong>零拷贝技术(zero-copy)</strong>：减少 <code>IO</code> 操作步骤，提高 <strong>系统吞吐量</strong>；</p></li><li><p><strong>数据迁移</strong>、<strong>扩容</strong> 对用户透明；</p></li><li><p><strong>无需停机</strong> 即可扩展机器；</p></li><li><p><strong>其他特性</strong>：丰富的 <strong>消息拉取模型</strong>、高效 <strong>订阅者水平扩展</strong>、实时的 <strong>消息订阅</strong>、亿级的 <strong>消息堆积能力</strong>、定期删除机制；</p></li></ol><h4 id="b-部署环境-3"><a href="#b-部署环境-3" class="headerlink" title="(b) 部署环境"></a>(b) 部署环境</h4><p>使用 <code>Kafka</code> 需要：</p><ul><li><code>Java JDK</code></li><li><code>Kafka</code> 安装包</li></ul><h4 id="c-优点-3"><a href="#c-优点-3" class="headerlink" title="(c) 优点"></a>(c) 优点</h4><ol><li><p><strong>客户端语言丰富</strong>：支持 <code>Java</code>、<code>.Net</code>、<code>PHP</code>、<code>Ruby</code>、<code>Python</code>、<code>Go</code> 等多种语言；</p></li><li><p><strong>高性能</strong>：单机写入 <code>TPS</code> 约在 <code>100</code> 万条/秒，消息大小 <code>10</code> 个字节；</p></li><li><p>提供 <strong>完全分布式架构</strong>，并有 <code>replica</code> 机制，拥有较高的 <strong>可用性</strong> 和 <strong>可靠性</strong>，理论上支持 <strong>消息无限堆积</strong>；</p></li><li><p>支持批量操作；</p></li><li><p><strong>消费者</strong> 采用 <code>Pull</code> 方式获取消息。<strong>消息有序</strong>，<strong>通过控制</strong> 能够保证所有消息被消费且仅被消费 <strong>一次</strong>；</p></li><li><p>有优秀的第三方 <code>Kafka Web</code> 管理界面 <code>Kafka-Manager</code>；</p></li><li><p>在 <strong>日志领域</strong> 比较成熟，被多家公司和多个开源项目使用。</p></li></ol><h4 id="d-缺点-3"><a href="#d-缺点-3" class="headerlink" title="(d) 缺点"></a>(d) 缺点</h4><ol><li><p><code>Kafka</code> 单机超过 <code>64</code> 个 <strong>队列/分区</strong> 时，<code>Load</code> 时会发生明显的飙高现象。<strong>队列</strong> 越多，<strong>负载</strong> 越高，发送消息 <strong>响应时间变长</strong>；</p></li><li><p>使用 <strong>短轮询方式</strong>，<strong>实时性</strong> 取决于 <strong>轮询间隔时间</strong>；</p></li><li><p>消费失败 <strong>不支持重试</strong>；</p></li><li><p>支持 <strong>消息顺序</strong>，但是 <strong>一台代理宕机</strong> 后，就会产生 <strong>消息乱序</strong>；</p></li><li><p>社区更新较慢。</p></li></ol><h3 id="7-5-几种消息队列对比"><a href="#7-5-几种消息队列对比" class="headerlink" title="7.5. 几种消息队列对比"></a>7.5. 几种消息队列对比</h3><p>这里列举了上述四种消息队列的差异对比：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ecf7ad3ef?w=793&amp;h=812&amp;f=png&amp;s=61730" alt=""></p><p><code>Kafka</code> 在于 <strong>分布式架构</strong>，<code>RabbitMQ</code> 基于 <code>AMQP</code> <strong>协议</strong> 来实现，<code>RocketMQ</code> 的思路来源于 <code>Kafka</code>，改成了 <strong>主从结构</strong>，在 <strong>事务性</strong> 和 <strong>可靠性</strong> 方面做了优化。广泛来说，<strong>电商</strong>、<strong>金融</strong> 等对 <strong>事务一致性</strong> 要求很高的，可以考虑 <code>RabbitMQ</code> 和 <code>RocketMQ</code>，对 <strong>性能要求高</strong> 的可考虑 <code>Kafka</code>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了消息队列的特点，消息队列的 <strong>传递服务模型</strong>，消息的 <strong>传输方式</strong>，消息的 <strong>推拉模式</strong>。然后介绍了 <code>ActiveMQ</code>，<code>RabbitMQ</code>，<code>RocketMQ</code> 和 <code>Kafka</code> 几种常见的消息队列，阐述了 <strong>各种消息队列</strong> 的 <strong>主要特点</strong> 和 <strong>优缺点</strong>。通过本文，对于消息队列及相关技术选型，相信你会有了更深入的理解和认识。更多细节和原理性的东西，还需在实践中见真知！</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5dcc40392?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt; 已经逐渐成为企业应用系统 &lt;strong&gt;内部通信&lt;/strong&gt; 的核心手段。它具有 &lt;strong&gt;低耦合&lt;/strong&gt;、&lt;strong&gt;可靠投递&lt;/strong&gt;、&lt;strong&gt;广播&lt;/strong&gt;、&lt;strong&gt;流量控制&lt;/strong&gt;、&lt;strong&gt;最终一致性&lt;/strong&gt; 等一系列功能。&lt;/p&gt;
&lt;p&gt;当前使用较多的 &lt;strong&gt;消息队列&lt;/strong&gt; 有 &lt;code&gt;RabbitMQ&lt;/code&gt;、&lt;code&gt;RocketMQ&lt;/code&gt;、&lt;code&gt;ActiveMQ&lt;/code&gt;、&lt;code&gt;Kafka&lt;/code&gt;、&lt;code&gt;ZeroMQ&lt;/code&gt;、&lt;code&gt;MetaMQ&lt;/code&gt; 等，而部分 &lt;strong&gt;数据库&lt;/strong&gt; 如 &lt;code&gt;Redis&lt;/code&gt;、&lt;code&gt;MySQL&lt;/code&gt; 以及 &lt;code&gt;phxsql&lt;/code&gt; 也可实现消息队列的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="消息队列系列" scheme="https://ostenant.coding.me/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="消息队列" scheme="https://ostenant.coding.me/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="ActiveMQ" scheme="https://ostenant.coding.me/tags/ActiveMQ/"/>
    
      <category term="RabbitMQ" scheme="https://ostenant.coding.me/tags/RabbitMQ/"/>
    
      <category term="RocketMQ" scheme="https://ostenant.coding.me/tags/RocketMQ/"/>
    
      <category term="Kafka" scheme="https://ostenant.coding.me/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>浅谈SAML, OAuth, OpenID和SSO, JWT和Session</title>
    <link href="https://ostenant.coding.me/2018/07/05/%E6%B5%85%E8%B0%88SAML,%20OAuth,%20OpenID%E5%92%8CSSO,%20JWT%E5%92%8CSession/"/>
    <id>https://ostenant.coding.me/2018/07/05/浅谈SAML, OAuth, OpenID和SSO, JWT和Session/</id>
    <published>2018-07-05T05:50:00.000Z</published>
    <updated>2018-07-05T14:27:53.562Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常为了弄清楚一个概念，我们需要掌握十个概念。在判断 <code>JWT(JsonWebToken)</code> 是否能代替 <code>session</code> 管理之前，我们要了解什么是 <code>token</code>，以及 <code>access token</code> 和 <code>refresh token</code> 的区别。</p><a id="more"></a><p>了解什么是 <code>OAuth</code>，什么是 <code>SSO</code>，<code>SSO</code> 下不同策略 <code>OAuth</code> 和 <code>SAML</code> 的不同，以及 <code>OAuth</code> 与 <code>OpenID</code> 的不同，更重要的是区分 <code>authorisation</code> 和 <code>authentication</code>。</p><p>最后我们引出 <code>JSON WEB TOKEN</code>，聊聊 <code>JWT</code> 在 <code>Session</code> 管理方面的优势和劣势，同时尝试解决这些劣势，看看成本和代价有多少。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/OAuth_logo.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文关于 <code>OAuth</code> <strong>授权</strong> 和 <code>API</code> 调用实例都来自 <code>Google API</code>。</p><h2 id="关于Token"><a href="#关于Token" class="headerlink" title="关于Token"></a>关于Token</h2><p><code>Token</code> 即使是在计算机领域中也有不同的定义，这里我们说的 <code>token</code>，是指 <strong>访问资源</strong> 的凭据。例如当你调用 <code>Google API</code> 时，需要带上有效 <code>token</code> 来表明你请求的 <strong>合法性</strong>。这个 <code>Token</code> 是 <code>Google</code> 给你的，这代表 <code>Google</code> 给你的 <strong>授权</strong> 使得你有能力访问 <code>API</code> 背后的 <strong>资源</strong>。</p><p>请求 <code>API</code> 时携带 <code>token</code> 的方式也有很多种，通过 <code>HTTP Header</code> 或者 <code>url</code> 参数或者 <code>google</code> 提供的类库都可以：</p><ul><li><strong>HTTP Header</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /drive/v2/files HTTP/1.1</span><br><span class="line"></span><br><span class="line">Authorization: Bearer &lt;token&gt;</span><br><span class="line">Host: www.googleapis.com/</span><br></pre></td></tr></table></figure><ul><li><strong>URL参数</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://www.googleapis.com/drive/v2/files?token=&lt;token&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>Python函数库</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> googleapiclient.discovery <span class="keyword">import</span> build</span><br><span class="line">drive = build(<span class="string">'drive'</span>, <span class="string">'v2'</span>, credentials=credentials)</span><br></pre></td></tr></table></figure><p>更具体的说，上面用于调用 <code>API</code> 的 <code>token</code>，我们称为细分为 <code>access token</code>。通常 <code>access token</code> 是有 <strong>有效期限</strong> 的，如果 <strong>过期</strong> 就需要 <strong>重新获取</strong>。那么如何重新获取？先看看第一次获取 <code>token</code> 的流程是怎样的:</p><ol><li><p>首先需要向 <code>Google API</code> 注册一个应用程序，注册完毕之后就会拿到 <strong>认证信息</strong>（<code>credentials</code>）包括 <code>ID</code> 和 <code>secret</code>。不是所有的程序类型都有 <code>secret</code>。</p></li><li><p>接下来就要向 <code>Google</code> 请求 <code>access token</code>。这里先忽略一些细节，例如请求参数（当然需要上面申请到的 <code>secret</code>）。重要的是，如果你想访问的是 <strong>用户资源</strong>，这里就会提醒用户进行 <strong>授权</strong>。</p></li><li><p>如果 <strong>用户授权</strong> 完毕。<code>Google</code> 就会返回 <code>access token</code>。又或者是返回 <strong>授权代码</strong>（<code>authorization code</code>），再通过代码取得 <code>access token</code>。</p></li></ol><p><code>token</code> 获取到之后，就能够带上 <code>token</code> 访问 <code>API</code> 了。</p><p>流程如下图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Token_flow.webp" alt=""></p><blockquote><p>注意：在第三步通过 <code>authorization code</code> 兑换 <code>access token</code> 的过程中，<code>Google</code> 并不会仅仅返回 <code>access token</code>，还会返回额外的信息，这其中和之后更新相关的就是 <code>refresh token</code>。</p></blockquote><p>一旦 <code>access token</code> 过期，你就可以通过 <code>refresh token</code> 再次请求 <code>access token</code>。</p><p>以上只是大致的流程，并且故意省略了一些额外的概念。比如更新 <code>access token</code> 当然也可以不需要 <code>refresh token</code>，这要根据你的 <strong>请求方式</strong> 和访问的 <strong>资源类型</strong> 而定。</p><p>这里又会引起另外的两个问题：</p><ol><li><p>如果 <code>refesh token</code> 也过期了怎么办？这时就需要用户 <strong>重新登陆授权</strong>。</p></li><li><p>为什么要区分 <code>refresh token</code> 和 <code>access token</code>？如果合并成一个 <code>token</code> 然后把 <strong>过期时间</strong> 调整的 <strong>更长</strong>，并且每次 <strong>失效</strong> 之后用户 <strong>重新登陆授权</strong> 就好了？这个问题会和后面谈的相关概念有关，后面会给予解释说明。</p></li></ol><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>从获取 <code>token</code> 到使用 <code>token</code> 访问接口。这其实是标准的 <code>OAuth2.0</code> 机制下访问 <code>API</code> 的流程。这里介绍一下 <code>OAuth</code> 里外相关的概念，更深入的理解 <code>token</code> 的作用。</p><h3 id="SSO-Single-sign-on"><a href="#SSO-Single-sign-on" class="headerlink" title="SSO (Single sign-on)"></a>SSO (Single sign-on)</h3><p>通常公司内部会有非常多的平台供大家使用，比如人力资源，代码管理，日志监控，预算申请等等。如果每一个平台都实现自己的用户体系的话无疑是巨大的浪费，所以公司内部会有一套 <strong>公用的用户体系</strong>，用户只要登陆之后，就能够 <strong>访问所有的系统</strong>。这就是 <strong>单点登录</strong>。</p><p><code>SSO</code> 是一类 <strong>解决方案</strong> 的统称，而在具体的实施方面，我们有两种策略可供选择：</p><ul><li><p><strong>SAML 2.0</strong></p></li><li><p><strong>OAuth 2.0</strong></p></li></ul><p>接下来我们区别这 <strong>两种授权方式</strong> 有什么不同。但是在描述 <strong>不同的策略</strong> 之前，我们先叙述几个 <strong>共有的特性</strong>，并且相当重要的概念。</p><h4 id="Authentication-VS-Authorisation"><a href="#Authentication-VS-Authorisation" class="headerlink" title="Authentication VS Authorisation"></a>Authentication VS Authorisation</h4><ul><li><p><strong>Authentication:</strong> 身份鉴别，以下简称 <strong>认证</strong>；</p></li><li><p><strong>Authorisation:</strong> 资源访问 <strong>授权</strong>。</p></li></ul><p><strong>认证</strong> 的作用在于 <strong>认可</strong> 你能够访问系统，用于 <strong>鉴别访问者</strong> 是否是 <strong>合法用户</strong>；而 <strong>授权</strong> 用于决定你有访问 <strong>哪些资源的权限</strong>。</p><p>大多数人不会区分这两者的区别，因为站在用户的立场上。而作为系统的设计者来说，这两者是有差别的，这是不同的两个工作职责。我们可以只需要 <strong>认证功能</strong>，而不需要 <strong>授权功能</strong>，甚至不需要自己实现 <strong>认证功能</strong>。而借助 <code>Google</code> 的认证系统，即用户可以用 <code>Google</code> 的账号进行登陆。</p><h4 id="Authorization-Server-Identity-Provider-IdP"><a href="#Authorization-Server-Identity-Provider-IdP" class="headerlink" title="Authorization Server/Identity Provider(IdP)"></a>Authorization Server/Identity Provider(IdP)</h4><p>把负责 <strong>认证的服务</strong> 称为 <code>AuthorizationServer</code> 或者 <code>IdentityProvider</code>，以下简称 <code>IDP</code>。</p><h4 id="Service-Provider-SP-Resource-Server"><a href="#Service-Provider-SP-Resource-Server" class="headerlink" title="Service Provider(SP)/Resource Server"></a>Service Provider(SP)/Resource Server</h4><p>把负责 <strong>提供资源</strong>（<code>API</code> 调用）的服务称为 <code>ResourceServer</code> 或者 <code>ServiceProvider</code>，以下简称 <code>SP</code>。</p><h3 id="SAML-2-0"><a href="#SAML-2-0" class="headerlink" title="SAML 2.0"></a>SAML 2.0</h3><p>下图是 <code>SAML2.0</code> 的流程图，看图说话：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/SAML_2" alt=""></p><ol><li><p>还 <strong>未登陆</strong> 的用户 <strong>打开浏览器</strong> 访问你的网站（<code>SP</code>），网站 <strong>提供服务</strong> 但是并 <strong>不负责用户认证</strong>。</p></li><li><p>于是 <code>SP</code> 向 <code>IDP</code> 发送了一个 <code>SAML</code> 认证请求，同时 <code>SP</code> 将 <strong>用户浏览器</strong> 重定向到 <code>IDP</code>。</p></li><li><p><code>IDP</code> 在验证完来自 <code>SP</code> 的 <strong>请求无误</strong> 之后，在浏览器中呈现 <strong>登陆表单</strong> 让用户填写 <strong>用户名</strong> 和 <strong>密码</strong> 进行登陆。</p></li><li><p>一旦用户登陆成功， <code>IDP</code> 会生成一个包含 <strong>用户信息</strong>（<strong>用户名</strong> 或者 <strong>密码</strong>）的 <code>SAML token</code>（<code>SAML token</code> 又称为 <code>SAML Assertion</code>，本质上是 <code>XML</code> 节点）。<code>IDP</code> 向 <code>SP</code> 返回 <code>token</code>，并且将 <strong>用户重定向</strong> 到 <code>SP</code> (<code>token</code> 的返回是在 <strong>重定向步骤</strong> 中实现的，下面会详细说明)。</p></li><li><p><code>SP</code> 对拿到的 <code>token</code> 进行验证，并从中解析出 <strong>用户信息</strong>，例如 <strong>用户是谁</strong> 以及 <strong>用户的权限</strong> 有哪些。此时就能够根据这些信息允许用户访问我们网站的内容。</p></li></ol><p>当用户在 <code>IDP</code> 登陆成功之后，<code>IDP</code> 需要将用户 <strong>再次重定向</strong> 到 <code>SP</code> 站点，这一步通常有两个办法：</p><ul><li><p><code>HTTP</code> 重定向：这并不推荐，因为 <strong>重定向</strong> 的 <code>URL</code> 长度 <strong>有限制</strong>，无法携带更长的信息，比如 <code>SAML Token</code>。</p></li><li><p><code>HTTP POST</code> 请求：这个是更常规的做法，当用户登陆完毕之后渲染出一个表单，用户点击后向 <code>SP</code> 提交 <code>POST</code> 请求。又或者可以使用 <code>JavaScript</code> 向 <code>SP</code> 发出一个 <code>POST</code> 请求。</p></li></ul><p>如果你的应用是基于 <code>Web</code>，那么以上的方案没有任何问题。但如果你开发的是一个 <code>iOS</code> 或者 <code>Android</code> 的手机应用，那么问题就来了：</p><ol><li><p>用户在 <code>iPhone</code> 上打开应用，此时用户需要通过 <code>IDP</code> 进行认证。</p></li><li><p>应用跳转至 <code>Safari</code> 浏览器，在登陆认证完毕之后，需要通过 <code>HTTP POST</code> 的形式将 <code>token</code> 返回至 <strong>手机应用</strong>。</p></li></ol><p>虽然 <code>POST</code> 的 <code>url</code> 可以 <strong>拉起应用</strong>，但是 <strong>手机应用</strong> 无法解析 <code>POST</code> 的内容，我们也就无法读取 <code>SAML Token</code>。</p><blockquote><p>当然还是有办法的，比如在 <code>IDP</code> <strong>授权阶段</strong> 不跳转至系统的 <code>Safari</code> 浏览器，在 <strong>内嵌</strong> 的 <code>Webview</code> 中解决，在想方设法从 <code>Webview</code> 中提取 <code>token</code>，或者利用 <strong>代理服务器</strong>。</p></blockquote><p>无论如何，<code>SAML 2.0</code> 并 <strong>不适用</strong> 于当下 <strong>跨平台</strong> 的场景，这也许与它产生的年代也有关系，它诞生于 <code>2005</code> 年，在那个时刻 <code>HTTP POST</code> 确实是最好的选择方案。</p><h3 id="OAuth-2-0-1"><a href="#OAuth-2-0-1" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>我们先简单了解 <code>SSO</code> 下的 <code>OAuth2.0</code> 的流程。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Oauth_process" alt=""></p><ol><li><p>用户通过 <strong>客户端</strong>（可以是 <strong>浏览器</strong> 也可以是 <strong>手机应用</strong>）想要访问 <code>SP</code> 上的资源，但是 <code>SP</code> 告诉用户需要进行 <strong>认证</strong>，将用户 <strong>重定向</strong> 至 <code>IDP</code>。</p></li><li><p><code>IDP</code> 向 <strong>用户</strong> 询问 <code>SP</code> 是否可以访问 <strong>用户信息</strong>。如果用户同意，<code>IDP</code> 向 <strong>客户端</strong> 返回 <code>authorization code</code>。</p></li><li><p>客户端拿到 <code>authorization code</code> 向 <code>IDP</code> 交换 <code>access token</code>，并拿着 <code>access token</code> 向 <code>SP</code> 请求资源。</p></li><li><p><code>SP</code> 接受到请求之后，拿着附带的 <code>token</code> 向 <code>IDP</code> 验证 <strong>用户的身份</strong>。确认身份无误后，<code>SP</code> 向 <strong>客户端</strong> 发放相关资源。</p></li></ol><p>那么 <code>OAuth</code> 是如何避免 <code>SAML</code> 流程下 <strong>无法解析</strong> <code>POST</code> 内容的信息的呢？</p><ul><li><p>一方面是用户从 <code>IDP</code> 返回 <strong>客户端</strong> 的方式，也是通过 <code>URL</code> 重定向，这里的 <code>URL</code> 允许 <strong>自定义</strong> <code>schema</code>，所以即使在 <strong>手机</strong> 上也能 <strong>拉起应用</strong>；</p></li><li><p>另一方面因为 <code>IDP</code> 向 <strong>客户端</strong> 传递的是 <code>authorization code</code>，而不是 <code>XML</code> 信息，所以 <code>code</code> 可以很轻易的附着在 <strong>重定向</strong> <code>URL</code> 上进行传递。</p></li></ul><p>但以上的 <code>SSO</code> 流程体现不出 <code>OAuth</code> 的本意。<code>OAuth</code> 的本意是 <strong>一个应用</strong> 允许 <strong>另一个应用</strong> 在 <strong>用户授权</strong> 的情况下 <strong>访问自己的数据</strong>。</p><p><code>OAuth</code> 的设计本意更倾向于 <strong>授权而非认证</strong>（当然授权用户信息就间接实现了认证），虽然 <code>Google</code> 的 <code>OAuth 2.0 API</code> 同时支持 <strong>授权</strong> 和 <strong>认证</strong>。所以你在使用 <code>Facebook</code> 或者 <code>Gmail</code> 账号登陆第三方站点时，会出现 <strong>授权对话框</strong>，告诉你 <strong>第三方站点</strong> 可以访问你的哪些信息，需要征得你的同意。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Google_gmail" alt=""></p><p>在上面 <code>SSO</code> 的 <code>OAuth</code> 流程中涉及三方角色: <code>SP</code>, <code>IDP</code> 以及 <code>Client</code>。但在实际工作中 <code>Client</code> 可以是不存在的，例如你编写了一个 <strong>后端程序</strong> 定时的通过 <code>Google API</code> 从 <code>Youtube</code> 拉取最新的节目数据，那么你的 <strong>后端程序</strong> 需要得到 <code>Youtube</code> 的 <code>OAuth</code> <strong>授权</strong> 即可。</p><h3 id="OAuth-VS-OpenId"><a href="#OAuth-VS-OpenId" class="headerlink" title="OAuth VS OpenId"></a>OAuth VS OpenId</h3><p>如果你有留心的话，你会在某些站点看到允许以 <code>OpenID</code> 的方式登陆，其实也就是以 <code>Facebook</code> 账号或者 <code>Google</code> 账号登陆站点：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/OpenID" alt=""></p><p><code>OpenID</code> 和 <code>OAuth</code> 很像。但本质上来说它们是截然不同的两个东西：</p><ul><li><p><strong>OpenID:</strong> 只用于 <strong>身份认证</strong>（<code>Authentication</code>），允许你以 <strong>同一个账户</strong> 在 <strong>多个网站登陆</strong>。它仅仅是为你的 <strong>合法身份</strong> 背书，当你以 <code>Facebook</code> 账号登陆某个站点之后，该站点 <strong>无权访问</strong> 你的在 <code>Facebook</code> 上的 <strong>数据</strong>。</p></li><li><p><strong>OAuth:</strong> 用于 <strong>授权</strong>（<code>Authorisation</code>），允许 <strong>被授权方</strong> 访问 <strong>授权方</strong> 的 <strong>用户数据</strong>。</p></li></ul><h4 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h4><p>现在可以回答上面的问题了，为什么我们需要 <code>refresh token</code>？</p><p>这样的处理是为了 <strong>职责的分离</strong>：</p><ul><li><p><strong>refresh token:</strong> 负责 <strong>身份认证</strong>；</p></li><li><p><strong>access token:</strong> 负责 <strong>请求资源</strong>。</p></li></ul><p>虽然 <code>refresh token</code> 和 <code>access token</code> 都由 <code>IDP</code> 发出，但是 <code>access token</code> 还要和 <code>SP</code> 进行 <strong>数据交换</strong>，如果 <strong>公用的话</strong> 这样就会有 <strong>身份泄露</strong> 的可能。并且 <code>IDP</code> 和 <code>SP</code> 可能是 <strong>完全不同</strong> 的 <strong>服务提供</strong> 的。而在上文，我们之所以没有这样的顾虑是因为 <code>IDP</code> 和 <code>SP</code> 都是 <code>Google</code>。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><h4 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h4><p>本质上来说 <code>JWT</code> 也是 <code>token</code>，正如我们在上文提到的，它是 <strong>访问资源</strong> 的 <strong>凭证</strong>。</p><p><code>Google</code> 的一些 <code>API</code> 诸如 <code>Prediction API</code> 或者 <code>Google Cloud Storage</code>，是不需要 <strong>访问</strong> 用户的 <strong>个人数据</strong> 的。因而不需要经过 <strong>用户的授权</strong> 这一步骤，应用程序可以直接访问。就像上面 <code>OAuth</code> 中没有 <code>Client</code> 没有参与的流程类似。这就要借助 <code>JWT</code> 完成访问了, 具体流程如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Auth_Resource" alt=""></p><ol><li><p>首先需要在 <code>Google API</code> 上创建一个服务账号（<code>service account</code>）。</p></li><li><p>获取 <strong>服务账号</strong> 的 <strong>认证信息</strong>（<code>credential</code>），包括 <strong>邮箱地址</strong>，<code>client ID</code>，以及一对 <strong>公钥/私钥</strong>。</p></li><li><p>使用 <code>Client ID</code> 和 <strong>私钥</strong> 创一个 <strong>签名</strong> 的 <code>JWT</code>，然后将这个 <code>JWT</code> 发送给 <code>Google</code> 交换 <code>access token</code>。</p></li><li><p><code>Google</code> 返回 <code>access token</code>。</p></li><li><p>程序通过 <code>access token</code> 访问 <code>API</code>。</p></li></ol><p>甚至你可以不需要向 <code>Google</code> 索要 <code>access token</code>，而是携带 <code>JWT</code> 作为 <code>HTTP header</code> 里的 <code>bearer token</code> 直接访问 <code>API</code> 也是可以的。这才是 <code>JWT</code> 的最大魅力。</p><h4 id="理性认识"><a href="#理性认识" class="headerlink" title="理性认识"></a>理性认识</h4><p><code>JWT</code> 顾名思义，它是 <code>JSON</code> 结构的 <code>token</code>，由三部分组成：</p><ul><li><p><strong>header</strong></p></li><li><p><strong>payload</strong></p></li><li><p><strong>signature</strong></p></li></ul><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p><code>header</code> 用于描述 <strong>元信息</strong>，例如产生 <code>signature</code> 的算法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">    <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>alg</code> 关键字就指定了使用哪一种 <strong>哈希算法</strong> 来创建 <code>signature</code>。</p><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p><code>payload</code> 用于携带你希望 <strong>向服务端传递</strong> 的信息。你既可以往里添加 <strong>官方字段</strong>，例如：<code>iss(Issuer)</code>, <code>sub(Subject)</code>, <code>exp(Expirationtime)</code>，也可以塞入 <strong>自定义的字段</strong>，比如 <code>userId</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p><code>signature</code> 译为 <strong>签名</strong>，创建签名要分以下几个步骤：</p><ol><li><p>从 <strong>接口服务端</strong> 拿到 <strong>密钥</strong>，假设为 <code>secret</code>。</p></li><li><p>对 <code>header</code> 进行 <code>base64</code> 编码，假设结果为 <code>headerStr</code>。</p></li><li><p>将 <code>payload</code> 进行 <code>base64</code> 编码，假设结果为 <code>payloadStr</code>。</p></li><li><p>将 <code>headerStr</code> 和 <code>payloadStr</code> 用 <code>.</code> <strong>字符</strong> 拼装起来成为字符 <code>data</code>。</p></li><li><p>以 <code>data</code> 和 <code>secret</code> 作为参数，使用 <strong>哈希算法</strong> 计算出 <strong>签名</strong>。</p></li></ol><p>如果上述描述还不直观，用 <strong>伪代码</strong> 表示就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Signature algorithm</span><br><span class="line">data = base64urlEncode( header ) + “.” + base64urlEncode( payload )</span><br><span class="line">signature = Hash( data, secret );</span><br></pre></td></tr></table></figure><p>假设我们的原始 <code>JSON</code> 结构是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Header</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">    <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Payload</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <strong>密钥</strong> 是字符串 <code>secret</code> 的话，那么最终 <code>JWT</code> 的结果就是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM</span><br></pre></td></tr></table></figure><blockquote><p>可以在 <code>jwt.io</code> 上 <strong>验证</strong> 这个结果。</p></blockquote><h3 id="JWT究竟带来了什么"><a href="#JWT究竟带来了什么" class="headerlink" title="JWT究竟带来了什么"></a>JWT究竟带来了什么</h3><h4 id="确保数据完整性"><a href="#确保数据完整性" class="headerlink" title="确保数据完整性"></a>确保数据完整性</h4><p><code>JWT</code> 的目的不是为了 <strong>隐藏</strong> 或者 <strong>保密数据</strong>，而是为了确保 <strong>数据</strong> 确实来自被 <strong>授权的人</strong> 创建的，以防止 <strong>中途篡改</strong>。</p><p>回想一下，当你拿到 <code>JWT</code> 时候，你完全可以在没有 <code>secret</code> 的情况下解码出 <code>header</code> 和 <code>payload</code>，因为 <code>header</code> 和 <code>payload</code> 只是经过了 <code>base64</code> 编码（<code>encode</code>）而已，编码的目的在于 <strong>利于数据结构的传输</strong>。</p><p>虽然创建 <code>signature</code> 的过程近似于 <strong>加密</strong> (<code>encrypt</code>)，但本质其实是一种 <strong>签名</strong> (<code>sign</code>) 的行为，用于保证 <strong>数据的完整性</strong>，实际上也并且并 <strong>没有加密任何数据</strong>。</p><h4 id="用于接口调用"><a href="#用于接口调用" class="headerlink" title="用于接口调用"></a>用于接口调用</h4><p>接下来在 <code>API</code> 调用中就可以附上 <code>JWT</code>（通常是在 <code>HTTP Header</code> 中）。又因为 <code>SP</code> 会与程序 <strong>共享</strong> 一个 <code>secret</code>，所以 <strong>程序</strong> 可以通过 <code>header</code> 提供的相同的 <code>hash</code> 算法来 <strong>验证签名</strong> 是否正确，从而判断应用是否有权力调用 <code>API</code>。</p><h3 id="有状态的对话Session"><a href="#有状态的对话Session" class="headerlink" title="有状态的对话Session"></a>有状态的对话Session</h3><p>因为 <code>HTTP</code> 是 <strong>无状态</strong> 的，所以 <strong>客户端</strong> 和 <strong>服务端</strong> 需要解决的问题是，如何让它们之间的对话变得有状态。例如只有是 <strong>登陆状态</strong> 的 <strong>用户</strong> 才有权限调用某些接口，那么在 <strong>用户登陆</strong> 之后，需要记住该用户是 <strong>已经登陆</strong> 的状态。常见的方法是使用 <code>session</code> 机制。</p><p>常见的 <code>session</code> 模型是这样工作的：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Session_Flow" alt=""></p><ol><li><p>用户在浏览器 <strong>登陆</strong> 之后，服务端为用户生成 <strong>唯一</strong> 的 <code>session id</code>，存储在 <strong>服务端</strong> 的 <strong>存储服务</strong>（例如 <code>MySQL</code>, <code>Redis</code>）中。</p></li><li><p>该 <code>session id</code> 也同时 <strong>返回给浏览器</strong>，以 <code>SESSION_ID</code> 为 <code>KEY</code> 存储在浏览器的 <code>cookie</code> 中。</p></li><li><p>如果用户再次访问该网站，<code>cookie</code> 里的 <code>SESSION_ID</code> 会随着 <strong>请求</strong> 一同发往 <strong>服务端</strong>。</p></li><li><p>服务端通过判断 <code>SESSION_ID</code> 是否已经在 <code>Redis</code> 中判断用户是否处于 <strong>登陆状态</strong>。</p></li></ol><p>相信你已经察觉了，理论上来说，<code>JWT</code> 机制可以取代 <code>session</code> 机制。用户不需要提前进行登陆，后端也不需要 <code>Redis</code> 记录用户的登陆信息。客户端的本地保存一份合法的 <code>JWT</code>，当用户需要调用接口时，附带上该合法的 <code>JWT</code>，每一次调用接口，后端都使用请求中附带的 <code>JWT</code> 做一次 <strong>合法性的验证</strong>。这样也间接达到了 <strong>认证用户</strong> 的目的。</p><p>然而 <code>JWT</code> 真的能取代 <code>session</code> 机制吗？这么做有哪些好处和坏处？这些问题将留在下一篇再讨论。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通常为了弄清楚一个概念，我们需要掌握十个概念。在判断 &lt;code&gt;JWT(JsonWebToken)&lt;/code&gt; 是否能代替 &lt;code&gt;session&lt;/code&gt; 管理之前，我们要了解什么是 &lt;code&gt;token&lt;/code&gt;，以及 &lt;code&gt;access token&lt;/code&gt; 和 &lt;code&gt;refresh token&lt;/code&gt; 的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="认证与授权系列" scheme="https://ostenant.coding.me/categories/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SAML" scheme="https://ostenant.coding.me/tags/SAML/"/>
    
      <category term="OAuth" scheme="https://ostenant.coding.me/tags/OAuth/"/>
    
      <category term="SSO" scheme="https://ostenant.coding.me/tags/SSO/"/>
    
      <category term="JWT" scheme="https://ostenant.coding.me/tags/JWT/"/>
    
      <category term="Session" scheme="https://ostenant.coding.me/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>浅谈分布式存储系统的数据分布算法</title>
    <link href="https://ostenant.coding.me/2018/07/01/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%08%E6%8D%AE%E5%88%86%E5%B8%83%E7%AE%97%E6%B3%95/"/>
    <id>https://ostenant.coding.me/2018/07/01/浅谈分布式存储系统的数据分布算法/</id>
    <published>2018-07-01T09:43:00.000Z</published>
    <updated>2018-07-01T13:01:25.154Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>分布式存储系统</strong> 面临着的首要问题，就是如何将 <strong>大量的数据</strong> 分布在 <strong>不同的存储节点</strong> 上。无论上层接口是 <code>KV</code> <strong>存储</strong>、<strong>对象存储</strong>、<strong>块存储</strong>、亦或是 <strong>列存储</strong>，在这个问题上大体是一致的。本文将介绍如何 <strong>分布式存储系统</strong> 中 <strong>做数据分布目标</strong> 及可选的 <strong>方案</strong>，并试着总结和权衡他们之间的关系及。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一-指标"><a href="#一-指标" class="headerlink" title="(一) 指标"></a>(一) 指标</h2><p>这里假设 <strong>目标数据</strong> 是以 <code>key</code> 标识的 <strong>数据块</strong> 或 <strong>对象</strong>。在一个包含 <strong>多个存储节点</strong> 的集群中，<strong>数据分布算法</strong> 需要为每一个给定的 <code>key</code> 指定 <strong>一个</strong> 或 <strong>多个</strong> 对应的 <strong>存储节点</strong> 负责，<strong>数据分布算法</strong> 有两个基本目标：</p><ul><li><p><strong>均匀性(Uniformity)</strong>：不同存储节点的 <strong>负载</strong> 应该 <strong>均衡</strong>；</p></li><li><p><strong>稳定性(Consistency)</strong>：每次一个 <code>key</code> 通过 <strong>数据分布算法</strong> 得到的 <strong>分布结果</strong> 应该保持 <strong>基本稳定</strong>，即使再有存储节点发生变化的情况下。</p></li></ul><p>可以看出，这两个目标在一定程度上是 <strong>相互矛盾</strong> 的。当有 <strong>存储节点增加或删除</strong> 时，为了保持稳定应该 <strong>尽量少</strong> 的进行 <strong>数据的移动</strong> 和 <strong>重新分配</strong>，而这样又势必会带来 <strong>负载不均衡</strong>。同样追求 <strong>极致均匀</strong> 也会导致较多的 <strong>数据迁移</strong>。</p><p>所以我们希望在这两个极端之间，找到一个点以获得合适的均匀性和稳定性。除了上述两个基本目标外，工程中还需要从以下几个方面考虑数据分布算法的优劣：</p><ol><li><p><strong>性能可扩展性</strong>：这个主要考虑的是算法相对于 <strong>存储节点规模</strong> 的 <strong>时间复杂度</strong>。为了整个系统的可扩展性，数据分布算法不应该在集群规模扩大后显著的增加运行时间。</p></li><li><p><strong>考虑节点异构</strong>：实际工程中，不同 <strong>存储节点</strong> 之间可能会有很大的 <strong>性能</strong> 或 <strong>容量差异</strong>，好的数据分布算法应该能很好的应对这种 <strong>异构</strong>，提供 <strong>加权的数据均匀</strong>。</p></li><li><p><strong>隔离故障域</strong>：为了 <strong>数据的高可用</strong>，数据分布算法应该为每个 <code>key</code> 找到 <strong>一组存储节点</strong>，这些节点可能提供的是 <strong>数据的镜像副本</strong>，也可能是类似 <strong>擦除码</strong> 的副本方式。数据分布算法应该尽量 <strong>隔离</strong> 这些副本的故障域，如 <strong>不同机房</strong>、<strong>不同机架</strong>、<strong>不同交换机</strong>、<strong>不同机器</strong>。</p></li></ol><h2 id="二-演进"><a href="#二-演进" class="headerlink" title="(二) 演进"></a>(二) 演进</h2><p>看完算法的评价指标后，接下来介绍一些可能的方案演进，并分析他们的优劣。这里假设 <code>key</code> 的值足够分散。</p><h3 id="1-Hash"><a href="#1-Hash" class="headerlink" title="1. Hash"></a>1. Hash</h3><p>一个简单直观的想法是直接用 <code>Hash</code> 来计算，简单的以 <code>Key</code> 做 <strong>哈希</strong> 后 <strong>对节点数取模</strong>。可以看出，在 <code>key</code> 足够分散的情况下，<strong>均匀性</strong> 可以获得，但一旦有 <strong>节点加入</strong> 或 <strong>退出</strong> 时，所有的原有节点都会受到影响。<strong>稳定性</strong> 无从谈起。</p><h3 id="2-一致性Hash"><a href="#2-一致性Hash" class="headerlink" title="2. 一致性Hash"></a>2. 一致性Hash</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b670a4be?w=576&amp;h=412&amp;f=png&amp;s=38351" alt=""></p><p>一致性 <code>Hash</code> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在收尾相接的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到先遇到的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。但这有带来 <strong>均匀性</strong> 的问题，即使可以将存储节点等距排列，也会在 <strong>存储节点个数</strong> 变化时带来 <strong>数据的不均匀</strong>。而这种可能 <strong>成倍数的不均匀</strong> 在实际工程中是不可接受的。</p><h3 id="3-带负载上限的一致性Hash"><a href="#3-带负载上限的一致性Hash" class="headerlink" title="3. 带负载上限的一致性Hash"></a>3. 带负载上限的一致性Hash</h3><p>一致性 <code>Hash</code> 有 <strong>节点变化时不均匀</strong>的问题。<code>Google</code> 在 <code>2017</code> 年提出了 Consistent Hashing with Bounded Loads 来控制这种 <strong>不均匀的程度</strong>。简单的说，该算法给 <code>Hash</code> 环上的每个节点一个 <strong>负载上限</strong> 为 <code>1 + e</code> 倍的 <strong>平均负载</strong>，这个 <code>e</code>可以自定义。当 <code>key</code> 在 <code>Hash</code> 环上 <strong>顺时针</strong> 找到合适的节点后，会判断这个节点的 <strong>负载</strong> 是否已经 <strong>到达上限</strong>，如果 <strong>已达上限</strong>，则需要继续找 <strong>之后的节点</strong> 进行分配。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b6ac1b85?w=431&amp;h=397&amp;f=png&amp;s=46890" alt=""></p><p>如上图所示，假设每个桶 <strong>当前上限</strong> 是 <code>2</code>，红色的小球按序号访问，当编号为 <code>6</code> 的红色小球到达时，发现顺时针首先遇到的 <code>B（3，4）</code>，<code>C（1，5）</code>都已经 <strong>达到上限</strong>，因此最终放置在桶 <code>A</code> 里。</p><p>这个算法最吸引人的地方在于 <strong>当有节点变化</strong> 时，需要迁移的数据量是 <code>1/e^2</code> 相关，而与 <strong>节点数</strong> 或 <strong>数据数量</strong> 均无关。</p><p>也就是说当 <strong>集群规模扩大</strong> 时，<strong>数据迁移量</strong> 并不会随着显著增加。另外，使用者可以通过调整 <code>e</code> 的值来控制 <strong>均匀性</strong> 和 <strong>稳定性</strong> 之间的权衡，就是一种 <strong>以时间换空间</strong> 的算法。总体来说，无论是 <strong>一致性</strong> <code>Hash</code> 还是 <strong>带负载限制</strong> 的 <strong>一致性</strong> <code>Hash</code>，都无法解决 <strong>节点异构</strong> 的问题。</p><h3 id="4-带虚拟节点的一致性Hash"><a href="#4-带虚拟节点的一致性Hash" class="headerlink" title="4. 带虚拟节点的一致性Hash"></a>4. 带虚拟节点的一致性Hash</h3><p>为了解决 <strong>负载不均匀</strong> 和 <strong>异构</strong> 的问题，可以在 <strong>一致性</strong> <code>Hash</code> 的基础上引入 <strong>虚拟节点</strong>。即 <code>hash</code> 环上的 <strong>每个节点</strong> 并不是 <strong>实际</strong> 的 <strong>存储节点</strong>，而是一个 <strong>虚拟节点</strong>。实际的 <strong>存储节点</strong> 根据其 <strong>不同的权重</strong>，对应 <strong>一个</strong> 或 <strong>多个虚拟节点</strong>，所有落到相应虚拟节点上的 <code>key</code> 都由该 <strong>存储节点负责</strong>。</p><p>如下图所示，存储节点 <code>A</code> 负责 <code>(1,3]</code>，<code>(4,8]</code>，<code>(10, 14]</code>，存储节点 <code>B</code> 负责 <code>(14,1]</code>，<code>(8,10]</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b6940588?w=700&amp;h=338&amp;f=png&amp;s=64488" alt=""></p><p>这个算法的问题在于，一个 <strong>实际存储节点</strong> 的 <strong>加入</strong> 或 <strong>退出</strong>，会影响 <strong>多个虚拟节点</strong>的重新分配，进而引起 <strong>很多节点</strong> 参与到 <strong>数据迁移</strong> 中来。</p><p>另外，实践中将一个 <strong>虚拟节点</strong> 重新分配给 <strong>新的实际节点</strong> 时，需要将这部分数据 <strong>遍历</strong> 出来 <strong>发送给新节点</strong>。我们需要一个更合适的 <strong>虚拟节点切分</strong> 和 <strong>分配方式</strong>，那就是 <strong>分片</strong>。</p><h3 id="5-分片"><a href="#5-分片" class="headerlink" title="5. 分片"></a>5. 分片</h3><p><strong>分片</strong> 将 <strong>哈希环</strong> 切割为 <strong>相同大小的分片</strong>，然后将这些 <strong>分片</strong> 交给 <strong>不同的节点</strong> 负责。</p><p>注意这里跟上面提到的 <strong>虚拟节点</strong> 有着很 <strong>本质的区别</strong>：<strong>分片的划分和分片的分配被解耦</strong>。</p><p>一个 <strong>节点退出</strong> 时，其所负责的 <strong>分片</strong> 并不需要 <strong>顺时针合并</strong> 给之后节点，而是可以更灵活的 <strong>将整个分片</strong> 作为一个 <strong>整体</strong> 交给 <strong>任意节点</strong>。在实践中，一个 <strong>分片</strong> 多作为 <strong>最小的数据迁移</strong> 和 <strong>备份单位</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b68eee2d?w=546&amp;h=462&amp;f=png&amp;s=34445" alt=""></p><p>而也正是由于上面提到的 <strong>解耦</strong>，相当于将原先的 <code>key</code> 到 <strong>节点</strong> 的 <strong>映射</strong> 拆成了两层。需要一个 <strong>新的机制</strong> 来进行 <strong>分片</strong> 到 <strong>存储节点</strong> 的 <strong>映射</strong>。由于 <strong>分片数</strong> 相对 <code>key</code> 空间已经很小并且 <strong>数量确定</strong>，可以更精确地初始设置，并引入 <strong>中心目录服务</strong> 来根据 <strong>节点存活</strong> 修改 <strong>分片的映射关系</strong>。同时将这个 <strong>映射信息</strong> 通知给所有的 <strong>存储节点</strong> 和 <strong>客户端</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b9a03c5b?w=700&amp;h=388&amp;f=png&amp;s=49049" alt=""></p><p>上图是 <strong>分布式KV存储</strong> <code>Zeppelin</code>中的 <strong>分片方式</strong>，<code>Key Space</code> 通过 <code>Hash</code> 到 <strong>分片</strong>，<strong>分片及其副本</strong> 又通过一层映射到 <strong>最终的存储节点</strong> <code>Node Server</code>。</p><h3 id="6-CRUSH算法"><a href="#6-CRUSH算法" class="headerlink" title="6. CRUSH算法"></a>6. CRUSH算法</h3><p><code>CRUSH</code> 算法本质上也是一种 <strong>基于分片</strong> 的数据分布方式，其试图在以下几个方面进行优化：</p><ul><li><p><strong>分片映射信息量</strong>：避免 <strong>中心目录服务</strong> 和 <strong>存储节点</strong> 及 <strong>客户端之间</strong> 交互大量的 <strong>分片映射信息</strong>，而改由 <strong>存储节点</strong> 或 <strong>客户端</strong> 自己根据 <strong>少量</strong> 且 <strong>稳定</strong> 的集群节点拓扑和确定的规则自己计算分片映射。</p></li><li><p><strong>完善的故障域划分</strong>：支持 <strong>层级</strong> 的 <strong>故障域控制</strong>，将 <strong>同一分片</strong> 的 <strong>不同副本</strong> 按照配置划分到 <strong>不同层级</strong> 的 <strong>故障域中</strong>。</p></li></ul><p><strong>客户端</strong> 或 <strong>存储节点</strong> 利用 <code>key</code>、<strong>存储节点</strong> 的 <strong>拓扑结构</strong> 和 <strong>分配算法</strong>，独立的进行 <strong>分片位置</strong> 的计算，得到一组负责对应 <strong>分片</strong> 及 <strong>副本</strong> 的 <strong>存储位置</strong>。</p><p>如图所示是 <strong>一次定位</strong> 的过程，最终选择了一个 <code>row</code> 下的 <code>cab21</code>，<code>cab23</code>，<code>cab24</code> 三个机柜下的三个存储节点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b6abde68?w=700&amp;h=254&amp;f=png&amp;s=72421" alt=""></p><p>当 <strong>节点变化</strong> 时，由于 <strong>节点拓扑</strong> 的变化，会影响 <strong>少量分片</strong> 数据进行迁移，如下图是加入 <strong>新节点</strong> 引起的 <strong>数据迁移</strong>。通过良好的 <strong>分配算法</strong>，可以得到很好的 <strong>负载均衡</strong> 和 <strong>稳定性</strong>，<code>CRUSH</code> 提供了 <code>Uniform</code>、<code>List</code>、<code>Tree</code>、<code>Straw</code> 四种分配算法。</p><h2 id="三-应用案例"><a href="#三-应用案例" class="headerlink" title="(三) 应用案例"></a>(三) 应用案例</h2><p>常见的 <strong>分布式存储系统</strong> 大多采用类似于 <strong>分片</strong> 的 <strong>数据分布和定位方式</strong>：</p><ol><li><p><strong>Cassandra/Dynamo</strong>：采用 <strong>分片</strong> 的方式并通过 <code>Gossip</code> 协议在对等节点间通信；</p></li><li><p><strong>Redis Cluster</strong>：将 <code>key Space</code> 划分为 <code>slots</code>，同样利用 <code>Gossip</code> 协议通信；</p></li><li><p><strong>Zeppelin</strong>：将数据分片为 <code>Partition</code>，通过 <code>Meta</code> 集群提供 <strong>中心目录服务</strong>；</p></li><li><p><strong>Bigtable</strong>：将数据切割为 <code>Tablet</code>，类似于可变的分片，<code>Tablet Server</code> 可以进行分片的切割，最终分片信息记录在 <code>Chubby</code> 中；</p></li><li><p><strong>Ceph</strong>：采用 <code>CRUSH</code> 方式，由 <strong>中心集群</strong> <code>Monitor</code> 提供并维护 <strong>集群拓扑</strong> 的变化。</p></li></ol><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5dcc40392?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分布式存储系统&lt;/strong&gt; 面临着的首要问题，就是如何将 &lt;strong&gt;大量的数据&lt;/strong&gt; 分布在 &lt;strong&gt;不同的存储节点&lt;/strong&gt; 上。无论上层接口是 &lt;code&gt;KV&lt;/code&gt; &lt;strong&gt;存储&lt;/strong&gt;、&lt;strong&gt;对象存储&lt;/strong&gt;、&lt;strong&gt;块存储&lt;/strong&gt;、亦或是 &lt;strong&gt;列存储&lt;/strong&gt;，在这个问题上大体是一致的。本文将介绍如何 &lt;strong&gt;分布式存储系统&lt;/strong&gt; 中 &lt;strong&gt;做数据分布目标&lt;/strong&gt; 及可选的 &lt;strong&gt;方案&lt;/strong&gt;，并试着总结和权衡他们之间的关系及。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式存储" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="一致性哈希" scheme="https://ostenant.coding.me/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
      <category term="分片" scheme="https://ostenant.coding.me/tags/%E5%88%86%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习Quartz任务调度框架</title>
    <link href="https://ostenant.coding.me/2018/06/27/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Quartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/"/>
    <id>https://ostenant.coding.me/2018/06/27/从零开始学习Quartz任务调度框架/</id>
    <published>2018-06-27T04:17:00.000Z</published>
    <updated>2018-06-29T04:50:45.047Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Quartz</code> 是个 <strong>任务调度工具</strong>，就是 <strong>定时</strong> 执行指定的任务。<code>Quartz</code> 提供了极为广泛的特性如 <strong>持久化任务</strong>，<strong>集群</strong> 和 <strong>分布式任务</strong> 等。<code>Quartz</code> 是用 <code>Java</code> 构建的，与 <code>Spring</code> 集成方便，<strong>伸缩性</strong>，<strong>负载均衡</strong>，<strong>高可用性</strong>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/Quartz_Logo_large.jpg" alt=""></p><p>本文只关注基于 <strong>数据库</strong> 的 <code>Quartz</code> 集群，基于 <code>Quartz 2.2.x</code> 来说明。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Quartz的核心组件"><a href="#Quartz的核心组件" class="headerlink" title="Quartz的核心组件"></a>Quartz的核心组件</h2><p><code>Quartz</code> 大致有三个核心的组件：</p><h3 id="1-调度器Scheduler"><a href="#1-调度器Scheduler" class="headerlink" title="1. 调度器Scheduler"></a>1. 调度器Scheduler</h3><p>一个 <strong>计划调度器容器</strong>，容器里面可以装载众多的 <code>JobDetail</code> 和 <code>Trigger</code>。当容器启动后，里面的每个 <code>JobDetail</code> 都会根据 <code>Trigger</code> 按部就班地 <strong>自动</strong> 去执行.</p><h3 id="2-任务Job"><a href="#2-任务Job" class="headerlink" title="2. 任务Job"></a>2. 任务Job</h3><p><code>Job</code> 表示要执行的 <strong>具体内容</strong>。<code>JobDetail</code> 表示具体的、可执行的调度程序，包含了这个任务的 <strong>调度方案</strong> 和 <strong>策略</strong>。</p><h3 id="3-触发器Trigger"><a href="#3-触发器Trigger" class="headerlink" title="3. 触发器Trigger"></a>3. 触发器Trigger</h3><p><strong>调度参数</strong> 的配置，配置任务执行触发的 <strong>时间间隔</strong>。</p><blockquote><p>几者的关系：<strong>调度器</strong> 就相当于一个 <strong>容器</strong>，装载着 <strong>任务</strong> 和 <strong>触发器</strong>。任务和触发器又是绑定在一起的，然而一个任务可以对应多个触发器，但一个触发器却只能对应一个任务。当 <code>JobDetail</code> 和 <code>Trigger</code> 在 <code>Scheduler</code> 容器上 <strong>注册</strong> 后，形成了装配好的 <strong>任务作业</strong>（<code>JobDetail</code> 和 <code>Trigger</code> 所组成的一对），伴随 <strong>容器启动</strong> 而调度执行。</p></blockquote><h2 id="Quartz的核心类"><a href="#Quartz的核心类" class="headerlink" title="Quartz的核心类"></a>Quartz的核心类</h2><h3 id="1-Scheduler"><a href="#1-Scheduler" class="headerlink" title="1. Scheduler"></a>1. Scheduler</h3><p><code>Quartz</code> 中 <strong>独立运行</strong> 的容器，<code>Trigger</code> 和 <code>JobDetail</code> 可以注册到 <code>Scheduler</code> 上。<code>Scheduler</code> 定义了多个 <strong>接口方法</strong>，允许外部通过 <strong>组及名称</strong> 访问和控制 <strong>容器</strong> 中 <code>Trigger</code> 和 <code>JobDetail</code>。</p><h3 id="2-Job"><a href="#2-Job" class="headerlink" title="2. Job"></a>2. Job</h3><p>任务接口，<strong>任务类</strong> 代表要调度执行的 <strong>业务逻辑实现</strong>，<strong>任务</strong> 必须实现该接口。</p><p>如果任务不允许 <strong>并发执行</strong>，则 <strong>任务类</strong> 必须添加注解 <code>@DisallowConcurrentExecution</code>。</p><p>该接口只定义了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException</span>;</span><br></pre></td></tr></table></figure><p>通过 <code>context</code> 可以访问配置给任务的 <strong>数据</strong> <code>context.getJobDetail().getJobDataMap()</code>，如果这个 <code>JobDataMap</code> 需要在修改后 <strong>持久化</strong> 到 <strong>数据库</strong> 里，则需要给 <strong>任务类</strong> 加上注解 <code>@PersistJobDataAfterExecution</code>。<code>Quartz</code> 在下次调度执行这个任务时，会把 <strong>持久化</strong> 的数据 <strong>反序列化</strong> 成 <code>JobDataMap</code> 供应用使用。</p><blockquote><p>不建议通过 <code>Quartz</code> 的这个机制 <strong>持久化</strong> 任何与 <strong>业务有关</strong> 的数据。因为 <strong>业务数据</strong> 应该由 <strong>应用</strong> 来存储，<code>Quartz</code> 只关注于调度执行。</p></blockquote><h3 id="3-JobDetail"><a href="#3-JobDetail" class="headerlink" title="3. JobDetail"></a>3. JobDetail</h3><p>任务在 <strong>内存</strong> 的标示。表示 <strong>任务详细信息</strong> 的接口，如 <code>Job</code> <strong>名字</strong>、<strong>描述信息</strong>、<strong>关联监听器</strong> 等信息。任务用调度器名称、任务名称和任务所归属的组名来作为 <strong>唯一标识</strong>。</p><h3 id="4-Trigger"><a href="#4-Trigger" class="headerlink" title="4. Trigger"></a>4. Trigger</h3><p><strong>触发器</strong>，用调度器名称、触发器名称和触发器所归属的组名来做 <strong>唯一标识</strong>。用于定义在什么情况、什么时间点执行任务。最常用的触发器类型就是基于 <code>cron</code> <strong>表达式</strong> 的触发器。</p><h3 id="5-JobStore"><a href="#5-JobStore" class="headerlink" title="5. JobStore"></a>5. JobStore</h3><p><strong>数据存储抽象</strong>，该接口定义了 <strong>任务</strong>、<strong>触发器</strong> 的 <strong>存储</strong>、<strong>检索</strong>、<strong>更新</strong> 的钩子函数，该接口还定义了任务执行完成后的 <strong>回调方法</strong>。</p><p><code>Quartz</code> 内建支持把 <strong>任务</strong>、<strong>触发器</strong> 等数据存储在 <code>JVM</code> <strong>内存</strong>、<strong>文件</strong>、<strong>数据库</strong> 中。通过这个接口，就隔离了 <strong>底层存储机制</strong> 的差异。可以在配置文件里通过 <code>org.quartz.JobStore.class</code> 属性来指定该接口的实现，比如基于 <code>Redis</code> 做 <strong>数据存储</strong> 的实现。</p><h4 id="5-1-RAMJobStore"><a href="#5-1-RAMJobStore" class="headerlink" title="5.1. RAMJobStore"></a>5.1. RAMJobStore</h4><ul><li><strong>优点</strong>：不依赖 <strong>外部数据库</strong>，配置容易，运行速度快。</li><li><strong>缺点</strong>：程序停止运行时，所有 <strong>调度信息</strong> 丢失。调度信息的 <strong>存储容量</strong> 也会被限制。</li></ul><h4 id="5-2-JDBCJobStore"><a href="#5-2-JDBCJobStore" class="headerlink" title="5.2. JDBCJobStore"></a>5.2. JDBCJobStore</h4><ul><li><strong>优点</strong>：支持 <strong>集群模式</strong>，所有的任务信息都会保存到 <strong>数据库</strong> 中。</li><li><strong>缺点</strong>：配置复杂。运行速度的快慢，取决于连接数据库的快慢。</li></ul><h3 id="6-JobFactory"><a href="#6-JobFactory" class="headerlink" title="6. JobFactory"></a>6. JobFactory</h3><p><strong>任务工厂</strong>，接口抽象了如何生成 <strong>任务实例</strong>，以便让应用来决定如何实例化任务类。</p><h3 id="7-JobStoreSupport"><a href="#7-JobStoreSupport" class="headerlink" title="7. JobStoreSupport"></a>7. JobStoreSupport</h3><p>提供了 <strong>基于数据库</strong> 的 <code>JobStore</code> 实现，通过 <code>MisfireHandler</code> 来检查错过发射的 <strong>触发器</strong>。如果是以 <strong>集群方式部署</strong>，还会通过内部类 <code>ClusterManager</code> 提供 <strong>集群健康检查</strong> 与 <strong>恢复</strong>。</p><h3 id="8-MisfireHandler"><a href="#8-MisfireHandler" class="headerlink" title="8. MisfireHandler"></a>8. MisfireHandler</h3><p><code>JobStoreSupport</code> 有个内部类 <code>MisfireHandler</code>，用于检查是否有 <strong>触发器</strong> 错过发射，它是用 <strong>单独的线程</strong> 执行。</p><p>但检测到有触发器 <strong>错过发射</strong> 时，该处理器只是 <strong>更新</strong> 触发器的状态为 <code>WAITING</code>，然后通知 <strong>监听器</strong>、通知 <strong>调度器</strong> 去处理。</p><h3 id="9-ClusterManager"><a href="#9-ClusterManager" class="headerlink" title="9. ClusterManager"></a>9. ClusterManager</h3><p>用于 <strong>管理集群</strong> 的 <strong>线程</strong>。<code>JobStoreSupport</code> 有个 <strong>内部类</strong> <code>ClusterManager</code> 用于进行 <strong>集群管理</strong>，它也是用 <strong>单独的线程</strong> 来执行，以防止 <strong>任务阻塞</strong>，其核心逻辑有：</p><ol><li>签入，向其他节点传达它所在的 <strong>调度器实例</strong> 还处于存活状态。</li><li>检查失败的节点，进行 <strong>恢复</strong>。<code>Quartz</code> 认为在一定时间后 <strong>没有签入</strong> 的节点是失败的，需要恢复。</li></ol><h3 id="10-Calendar"><a href="#10-Calendar" class="headerlink" title="10. Calendar"></a>10. Calendar</h3><p><code>org.quartz.Calendar</code> 和 <code>java.util.Calendar</code> 不同，它是一些 <strong>特定时间点</strong> 的 <strong>集合</strong>。一个 <code>Trigger</code> 可以和 <strong>多个</strong> <code>Calendar</code> 关联，以便 <strong>排除</strong> 或包含 <strong>某些时间点</strong>。</p><blockquote><p><code>Quartz</code> 在 <code>org.quartz.impl.calendar</code> 包下提供了若干个 <code>Calendar</code> 的 <strong>实现类</strong>，比如: <code>AnnualCalendar</code>、<code>MonthlyCalendar</code>、<code>WeeklyCalendar</code> 分别针对每年、每月和每周进行定义。</p></blockquote><h3 id="11-工作线程池"><a href="#11-工作线程池" class="headerlink" title="11. 工作线程池"></a>11. 工作线程池</h3><p><code>Quartz</code> 可以配置一个 <strong>线程池</strong> 来执行任务，线程池里的 <strong>线程用完</strong> 后，后续到期需要执行的任务就会 <strong>被阻塞</strong>。</p><h3 id="12-调度器线程"><a href="#12-调度器线程" class="headerlink" title="12. 调度器线程"></a>12. 调度器线程</h3><p>每个 <strong>调度器</strong> 都有自己的名称，对应一个 <code>org.quartz.core.QuartzSchedulerThread</code> <strong>调度器线程实例</strong>，调度逻辑就在这个线程类的 <code>run()</code> 方法里。</p><h2 id="Quartz的核心表"><a href="#Quartz的核心表" class="headerlink" title="Quartz的核心表"></a>Quartz的核心表</h2><h3 id="1-job-details"><a href="#1-job-details" class="headerlink" title="1. job_details"></a>1. job_details</h3><p>存储 <strong>任务</strong> 的信息，每一条记录表示一个任务。</p><h3 id="2-triggers"><a href="#2-triggers" class="headerlink" title="2. triggers"></a>2. triggers</h3><p>存储 <strong>触发器</strong> 的信息，<code>TRIGGER_STATE</code> 字段表示 <strong>触发器状态</strong>，用来控制这个 <strong>触发器</strong> 能不能被调度器 <strong>处理</strong>。</p><h3 id="3-fired-triggers"><a href="#3-fired-triggers" class="headerlink" title="3. fired_triggers"></a>3. fired_triggers</h3><p><strong>已发射触发器</strong> 的记录表，<code>STATE</code> 列用来表示任务的 <strong>执行状态</strong>。该表的作用是 <strong>跟踪任务</strong> 的 <strong>执行进度</strong>，用于 <strong>失败处理</strong>。</p><h3 id="4-locks"><a href="#4-locks" class="headerlink" title="4. locks"></a>4. locks</h3><p><code>locks</code> 表里的每条记录作为一个 <strong>悲观锁</strong>，要 <strong>加锁</strong> 时，用 <code>for update</code> 语句锁住对应的记录。</p><h3 id="5-scheduler-state"><a href="#5-scheduler-state" class="headerlink" title="5. scheduler_state"></a>5. scheduler_state</h3><p><strong>调度器状态表</strong>，集群的节点通过这个表来检查 <strong>其他节点</strong> 是否存活。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Quartz&lt;/code&gt; 是个 &lt;strong&gt;任务调度工具&lt;/strong&gt;，就是 &lt;strong&gt;定时&lt;/strong&gt; 执行指定的任务。&lt;code&gt;Quartz&lt;/code&gt; 提供了极为广泛的特性如 &lt;strong&gt;持久化任务&lt;/strong&gt;，&lt;strong&gt;集群&lt;/strong&gt; 和 &lt;strong&gt;分布式任务&lt;/strong&gt; 等。&lt;code&gt;Quartz&lt;/code&gt; 是用 &lt;code&gt;Java&lt;/code&gt; 构建的，与 &lt;code&gt;Spring&lt;/code&gt; 集成方便，&lt;strong&gt;伸缩性&lt;/strong&gt;，&lt;strong&gt;负载均衡&lt;/strong&gt;，&lt;strong&gt;高可用性&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="任务调度框架系列" scheme="https://ostenant.coding.me/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Quartz" scheme="https://ostenant.coding.me/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(六) - 单机定时任务的几种实现</title>
    <link href="https://ostenant.coding.me/2018/06/25/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E5%85%AD)%20-%20%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ostenant.coding.me/2018/06/25/实战Spring Boot 2.0系列(六) - 单机定时任务的几种实现/</id>
    <published>2018-06-25T10:20:00.000Z</published>
    <updated>2018-06-26T06:09:32.482Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>定时任务</strong> 一般会存在 <strong>中大型企业级</strong> 项目中，为了减少 <strong>服务器</strong>、<strong>数据库</strong> 的压力，往往会以 <strong>定时任务</strong> 的方式去完成某些业务逻辑。</p><a id="more"></a><p>常见的就是 <strong>金融服务系统</strong> 推送回调，一般支付系统订单在没有收到成功的回调返回内容时会 <strong>持续性的回调</strong>，这种回调一般都是 <strong>定时任务</strong> 来完成。</p><p>还有就是 <strong>报表的生成</strong>，我们一般会在客户 <strong>访问量小</strong> 时完成这个操作，也可以采用 <strong>定时任务</strong> 来完成。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413255f98b30e7?w=620&amp;h=595&amp;f=png&amp;s=81732" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="定时任务的几种方式"><a href="#定时任务的几种方式" class="headerlink" title="定时任务的几种方式"></a>定时任务的几种方式</h2><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>这是 <code>Java</code> 自带的 <code>java.util.Timer</code> 类，这个类允许调度一个名为 <code>java.util.TimerTask</code> 任务。使用这种方式可以让你的程序按照某一个 <strong>频度</strong> 执行，但不能在 <strong>指定时间</strong> 运行。现在一般用的较少。</p><h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h4><p><code>JDK</code> 自带的一个类，是基于 <strong>线程池</strong> 设计的定时任务类，每个 <strong>调度任务</strong> 都会分配到 <strong>线程池</strong> 中的一个 <strong>线程</strong> 去执行。也就是说，任务是 <strong>并发执行</strong>，互不影响的。</p><h4 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h4><p><code>Spring 3.0</code> 以后自带的 <code>Task</code>，支持 <strong>多线程</strong> 调度，可以将它看成一个 <strong>轻量级</strong> 的 <code>Quartz</code>，而且使用起来比 <code>Quartz</code> 简单许多，但是适用于 <strong>单节点</strong> 的 <strong>定时任务调度</strong>。</p><h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>这是一个 <strong>功能比较强大</strong> 的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来 <strong>稍显复杂</strong>。<code>Quartz</code> 功能强大，可以结合 <strong>数据库</strong> 做 <strong>持久化</strong>，进行 <strong>分布式</strong> 的 <strong>任务延时调度</strong>。</p><h2 id="Cron表达式简介"><a href="#Cron表达式简介" class="headerlink" title="Cron表达式简介"></a>Cron表达式简介</h2><p><code>Cron</code> 表达式是一个字符串，字符串以 <code>5</code> 或 <code>6</code> 个 <strong>空格</strong> 隔开，分为 <code>6</code> 或 <code>7</code> 个 <strong>域</strong>，每一个域代表一个含义，<code>Cron</code> 有如下两种语法格式：</p><blockquote><ol><li>Seconds Minutes Hours DayofMonth Month DayofWeek Year</li><li>Seconds Minutes Hours DayofMonth Month DayofWeek</li></ol></blockquote><p>每个域对应的含义、域值范围和特殊表示符，从左到右依次如下：</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">允许值</th><th style="text-align:left">允许的特殊字符</th></tr></thead><tbody><tr><td style="text-align:left">秒</td><td style="text-align:left">0-59</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">分</td><td style="text-align:left">0-59</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">小时</td><td style="text-align:left">0-23</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">日期</td><td style="text-align:left">1-31</td><td style="text-align:left">, - * / L W C</td></tr><tr><td style="text-align:left">月份</td><td style="text-align:left">1-12 或者 JAN-DEC</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">星期</td><td style="text-align:left">1-7 或者 SUN-SAT</td><td style="text-align:left">, - * / L C #</td></tr><tr><td style="text-align:left">年（可选）</td><td style="text-align:left">留空, 1970-2099</td><td style="text-align:left">, - * /</td></tr></tbody></table><p>如上面的表达式所示:</p><ul><li><p><strong>“”字符:</strong> 被用来指定所有的值。如：在分钟的字段域里表示”每分钟”。</p></li><li><p><strong>“-“字符:</strong> 被用来指定一个范围。如：”10-12” 在小时域意味着 “10点、11点、12点”。</p></li><li><p><strong>“,”字符:</strong> 被用来指定另外的值。如：”MON,WED,FRI” 在星期域里表示 “星期一、星期三、星期五”。</p></li><li><p><strong>“?”字符:</strong> 只在日期域和星期域中使用。它被用来指定”非明确的值”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。</p></li><li><p><strong>“L”字符:</strong> 指定在月或者星期中的某天（最后一天）。即 “Last” 的缩写。但是在星期和月中 “Ｌ” 表示不同的意思，如：在月子段中 “L” 指月份的最后一天 - 1月31日，2月28日。</p><ul><li>如果在星期字段中则简单的表示为 “7” 或者 “SAT” 字符。</li><li>如果在星期字段中在某个 value 值得后面，则表示 “某月的最后一个星期value”，如 “6L” 表示某月的最后一个星期五。</li></ul></li><li><p><strong>“W”字符:</strong> 只能用在月份字段中，该字段指定了离指定日期最近的那个星期日。</p></li><li><p><strong>“#”字符:</strong> 只能用在星期字段，该字段指定了第几个星期 value 在某月中</p></li></ul><p>每一个元素都可以显式地规定一个值（如 <code>6</code>），一个区间（如 <code>9-12</code>），一个列表（如 <code>9，11，13</code>）或一个通配符（如 <code>*</code>）。<strong>“月份中的日期”</strong> 和 <strong>“星期中的日期”</strong> 这两个元素是 <strong>互斥的</strong>，因此应该通过设置一个 <strong>问号</strong>（<code>?</code>）来表明你不想设置的那个字段。下表显示了一些 <code>cron</code> 表达式的 <strong>例子</strong> 和它们的意义：</p><table><thead><tr><th>表达式</th><th>意义</th></tr></thead><tbody><tr><td>“0 0 12 <em> </em> ?”</td><td>每天中午12点触发</td></tr><tr><td>“0 15 10 ? <em> </em>“</td><td>每天上午10:15触发</td></tr><tr><td>“0 15 10 <em> </em> ?”</td><td>每天上午10:15触发</td></tr><tr><td>“0 15 10 <em> </em> ? *”</td><td>每天上午10:15触发</td></tr><tr><td>“0 15 10 <em> </em> ? 2005”</td><td>2005年的每天上午10:15触发</td></tr><tr><td>“0 <em> 14 </em> * ?”</td><td>在每天下午2点到下午2:59期间的每1分钟触发</td></tr><tr><td>“0 0/5 14 <em> </em> ?”</td><td>在每天下午2点到下午2:55期间的每5分钟触发</td></tr><tr><td>“0 0/5 14,18 <em> </em> ?”</td><td>在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</td></tr><tr><td>“0 0-5 14 <em> </em> ?”</td><td>在每天下午2点到下午2:05期间的每1分钟触发</td></tr><tr><td>“0 10,44 14 ? 3 WED”</td><td>每年三月的星期三的下午2:10和2:44触发</td></tr><tr><td>“0 15 10 ? * MON-FRI”</td><td>周一至周五的上午10:15触发</td></tr><tr><td>“0 15 10 15 * ?”</td><td>每月15日上午10:15触发</td></tr><tr><td>“0 15 10 L * ?”</td><td>每月最后一日的上午10:15触发</td></tr><tr><td>“0 15 10 ? * 6L”</td><td>每月的最后一个星期五上午10:15触发</td></tr><tr><td>“0 15 10 ? * 6L 2002-2005”</td><td>2002年至2005年的每月的最后一个星期五上午10:15触发</td></tr><tr><td>“0 15 10 ? * 6#3”</td><td>每月的第三个星期五上午10:15触发</td></tr><tr><td>0 6 <em> </em> *</td><td>每天早上6点</td></tr><tr><td>0 /2 <em> </em></td><td>每两个小时</td></tr><tr><td>0 23-7/2，8 <em> </em> *</td><td>晚上11点到早上8点之间每两个小时，早上八点</td></tr><tr><td>0 11 4 * 1-3</td><td>每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点</td></tr><tr><td>0 4 1 1 *</td><td>1月1日早上4点</td></tr></tbody></table><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="配置gradle依赖"><a href="#配置gradle依赖" class="headerlink" title="配置gradle依赖"></a>配置gradle依赖</h3><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-scheduler-task-management</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter'</span>)</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Spring Boot</code> 入口类上配置 <code>@EnableScheduling</code> 注解开启 <code>Spring</code> 自带的定时处理功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置Timer任务"><a href="#配置Timer任务" class="headerlink" title="配置Timer任务"></a>配置Timer任务</h2><p>这个 <code>API</code> 目前在项目中很少用，直接给出示例代码。具体的介绍可以查看 <code>API</code>。<code>Timer</code> 的内部只有 <strong>一个线程</strong>，如果有 <strong>多个任务</strong> 的话就会 <strong>顺序执行</strong>，这样任务的 <strong>延迟时间</strong> 和 <strong>循环时间</strong> 就会出现问题。</p><p>TimerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TimerService.class);</span><br><span class="line">    <span class="keyword">private</span> AtomicLong counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">                LOGGER.info(<span class="string">"Schedule timerTask &#123;&#125; times"</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000L</span>, <span class="number">10</span> * <span class="number">1000L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个 <code>TimerTask</code>，在 <code>TimerTask</code> 中累加 <strong>执行次数</strong>，并通过 <code>slf4j</code> 进行打印 (自带执行时间)。然后通过 <code>Timer</code> 调度工具类调度 <code>TimerTask</code> 任务，设置 <strong>初始化延迟时间</strong> 为 <code>1s</code>，<strong>定时执行间隔</strong> 为 <code>10s</code>，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TimerService timerService = <span class="keyword">new</span> TimerService();</span><br><span class="line">    timerService.schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察测试结果，能够发现 <code>TimerTask</code> 配置的任务每隔 <code>10s</code> 被执行了一次，执行线程默认都是 <code>Timer-0</code> 这个线程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17:48:18.731 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 1 <span class="built_in">times</span></span><br><span class="line">17:48:28.730 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 2 <span class="built_in">times</span></span><br><span class="line">17:48:38.736 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 3 <span class="built_in">times</span></span><br><span class="line">17:48:48.738 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 4 <span class="built_in">times</span></span><br><span class="line">17:48:58.743 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 5 <span class="built_in">times</span></span><br></pre></td></tr></table></figure><h2 id="配置ScheduledExecutorService任务"><a href="#配置ScheduledExecutorService任务" class="headerlink" title="配置ScheduledExecutorService任务"></a>配置ScheduledExecutorService任务</h2><p><code>ScheduledExecutorService</code> 是 <strong>延时执行</strong> 的线程池，对于 <strong>多线程</strong> 环境下的 <strong>定时任务</strong>，推荐用 <code>ScheduledExecutorService</code> 代替 <code>Timer</code> 定时器。</p><p>创建一个线程数量为 <code>4</code> 的 <strong>任务线程池</strong>，同一时刻并向它提交 <code>4</code> 个定时任务，用于测试延时任务的 <strong>并发处理</strong>。执行 <code>ScheduledExecutorService</code> 的 <code>scheduleWithFixedDelay()</code> 方法，设置任务线程池的 <strong>初始任务延迟时间</strong> 为 <code>2</code> 秒，并在上一次 <strong>执行完毕时间点</strong> 之后 <code>10</code> 秒再执行下一次任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        scheduledExecutor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">            LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">        &#125;, <span class="number">2000L</span>, <span class="number">10</span> * <span class="number">1000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">"Start to schedule"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下，我们可以发现每隔 <code>20</code> 秒的时间间隔，就会有 <code>4</code> 个定时任务同时执行。因为在任务线程池初始化时，我们同时向线程池提交了 <code>4</code> 个任务，这 <strong>四个任务</strong> 会完全利用线程池中的 <code>4</code> 个线程进行任务执行。</p><p><code>20</code> 秒是怎么来的？首先每个任务的 <strong>时间间隔</strong> 设置为 <code>10</code> 秒。其次因为采用的是 <code>withFixedDelay</code> 策略，即当前任务执行的 <strong>结束时间</strong>，作为下次延时任务的 <strong>开始计时节点</strong>，并且每个任务在执行过程中睡眠了 <code>10</code> 秒的时间，累计起来就是 <code>20</code> 秒的时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">19:42:02.444 [main] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Start to schedule</span><br><span class="line">19:42:14.449 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 3 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:14.449 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 1 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:14.449 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 2 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:14.449 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 4 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 7 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 5 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 8 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 6 <span class="built_in">times</span> with fixed delay</span><br></pre></td></tr></table></figure><p>创建一个线程数量为 <code>4</code> 的 <strong>任务线程池</strong>，同一时刻并向它提交 <code>4</code> 个定时任务，用于测试延时任务的 <strong>并发处理</strong>。每个任务分别执行 <code>ScheduledExecutorService</code> 的 <code>scheduleAtFixedRate()</code> 方法，设置任务线程池的 <strong>初始任务延迟时间</strong> 为 <code>2</code> 秒，并在上一次 <strong>开始执行时间点</strong> 之后 <code>10</code> 秒再执行下一次任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        scheduledExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">            LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times at fixed rate"</span>, count);</span><br><span class="line">        &#125;, <span class="number">2000L</span>, <span class="number">10</span> * <span class="number">1000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">"Start to schedule"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下，我们可以发现每隔 <code>10</code> 秒的时间间隔，就会有 <code>4</code> 个定时任务同时执行，因为在任务线程池初始化时，我们同时向线程池提交了 <code>4</code> 个任务，这 <strong>四个任务</strong> 会完全利用线程池中的 <code>4</code> 个线程进行任务执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">19:31:46.837 [main] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Start to schedule</span><br><span class="line">19:31:48.840 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 1 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:48.840 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 3 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:48.840 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 2 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:48.840 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 4 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.839 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 6 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.840 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 8 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.839 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 7 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.839 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 5 <span class="built_in">times</span> at fixed rate</span><br></pre></td></tr></table></figure><h2 id="配置Spring-Task任务"><a href="#配置Spring-Task任务" class="headerlink" title="配置Spring Task任务"></a>配置Spring Task任务</h2><p><code>Spring</code> 提供了 <code>@Scheduled</code> 注解来实现 <strong>定时任务</strong>，<code>@Scheduled</code> 参数可以接受 <strong>两种</strong> 定时的设置，一种是我们常用的 <strong>格林时间表达式</strong> <code>cron = &quot;*/10 * * * * *&quot;</code>，另一种是 <code>fixedRate = 10 * 1000L</code>，两种都表示每隔 <code>10</code> 秒执行一次目标任务。</p><p>参数说明：</p><ul><li>@Scheduled(fixedRate = 10 * 1000L)：上一次 <strong>开始执行时间点</strong> 之后 <code>10</code> 秒再执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times at fixed rate"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Scheduled(fixedDelay = 10 * 1000L)：上一次 <strong>执行完毕时间点</strong> 之后 <code>10</code> 秒再执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Scheduled(initialDelay = 2000L, fixedRate = 10 * 1000L)：第一次延迟 <code>2</code> 秒后执行，之后按 <code>fixedRate</code> 的规则每 <code>10</code> 秒执行一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(initialDelay = <span class="number">2000L</span>, fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithinitialDelayAndFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Scheduled(cron = “0/10 <em> </em> <em> </em> *”)：根据 <code>cron</code> 表达式定义，每隔 <code>10</code> 秒执行一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/10 * * * * *"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithCronExpression</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with "</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><p>SpringTaskService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTaskService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SpringTaskService.class);</span><br><span class="line">    <span class="keyword">private</span> AtomicLong counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(initialDelay = <span class="number">2000L</span>, fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithinitialDelayAndFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times at fixed rate"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/10 * * * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithCronExpression</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with "</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看日志，任务每 <code>20</code> 秒的时间间隔执行一次。每次定时任务在上次 <strong>执行完毕时间点</strong> 之后 <code>10</code> 秒再执行，在任务中设置 <strong>睡眠时间</strong> 为 <code>10</code> 秒。这里只验证了 @Scheduled(initialDelay = 2000L, fixedDelay = 10 * 1000L)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-06-25 18:00:53.051  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 1 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:01:13.056  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 2 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:01:33.061  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 3 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:01:53.071  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 4 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:02:13.079  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 5 <span class="built_in">times</span> with fixed delay</span><br></pre></td></tr></table></figure><h3 id="配置任务线程池"><a href="#配置任务线程池" class="headerlink" title="配置任务线程池"></a>配置任务线程池</h3><p>上述配置都是基于 <strong>单线程</strong> 的任务调度，如何引入 <strong>多线程</strong> 提高 <strong>延时任务</strong> 的 <strong>并发处理</strong> 能力？</p><p><code>Spring Boot</code> 提供了一个 <code>SchedulingConfigurer</code> 配置接口。我们通过 <code>ScheduleConfig</code> 配置文件实现 <code>ScheduleConfiguration</code> 接口，并重写 <code>configureTasks()</code> 方法，向 <code>ScheduledTaskRegistrar</code> 注册一个 <code>ThreadPoolTaskScheduler</code> 任务线程对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleConfiguration</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ScheduleConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        taskRegistrar.setTaskScheduler(taskScheduler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">taskScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskScheduler taskScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">        taskScheduler.setPoolSize(<span class="number">4</span>);</span><br><span class="line">        taskScheduler.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(<span class="string">"schedule"</span>);</span><br><span class="line">        taskScheduler.setRemoveOnCancelPolicy(<span class="keyword">true</span>);</span><br><span class="line">        taskScheduler.setErrorHandler(t -&gt; LOGGER.error(<span class="string">"Error occurs"</span>, t));</span><br><span class="line">        <span class="keyword">return</span> taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 引用，上面 <code>SpringTaskService</code> 配置的 <code>4</code> 个定时任务会同时生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2018-06-20 20:37:50.746  INFO 8142 --- [      schedule1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 1 <span class="built_in">times</span> at fixed rate</span><br><span class="line">2018-06-20 20:38:00.001  INFO 8142 --- [      schedule3] i.o.s.sample.spring.SpringTaskService    : Schedule executor 2 <span class="built_in">times</span> with </span><br><span class="line">2018-06-20 20:38:00.751  INFO 8142 --- [      schedule1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 3 <span class="built_in">times</span> at fixed rate</span><br><span class="line">2018-06-20 20:38:02.748  INFO 8142 --- [      schedule2] i.o.s.sample.spring.SpringTaskService    : Schedule executor 4 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-20 20:38:10.005  INFO 8142 --- [      schedule4] i.o.s.sample.spring.SpringTaskService    : Schedule executor 5 <span class="built_in">times</span> with </span><br><span class="line">2018-06-20 20:38:10.747  INFO 8142 --- [      schedule3] i.o.s.sample.spring.SpringTaskService    : Schedule executor 6 <span class="built_in">times</span> at fixed rate</span><br><span class="line">2018-06-20 20:38:20.002  INFO 8142 --- [      schedule2] i.o.s.sample.spring.SpringTaskService    : Schedule executor 7 <span class="built_in">times</span> with </span><br><span class="line">2018-06-20 20:38:20.747  INFO 8142 --- [      schedule4] i.o.s.sample.spring.SpringTaskService    : Schedule executor 8 <span class="built_in">times</span> at fixed rate</span><br></pre></td></tr></table></figure><p>观察日志，<strong>线程名前缀</strong> 为 <code>schedule</code>，可以发现 <code>Spring Task</code> 将 <code>@Scheduled</code> 注解配置的 <code>4</code> 个任务，分发给我们配置的 <code>ThreadPoolTaskScheduler</code> 中的 <code>4</code> 个线程并发执行。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了基于单节点的定时任务调度及实现，包括 <code>JDK</code> 原生的 <code>Timer</code> 和 <code>ScheduledExecutorService</code>，以及 <code>Spring 3.0</code> 以后自带的基于注解的 <code>Spring Task</code> 任务调度方式。除此之外，重点阐述了基于 <strong>固定延时</strong>、<strong>固定频率</strong> 和 <code>cron</code> <strong>表达式</strong> 的不同之处，并对 <code>ScheduledExecutorService</code> 和 <code>Spring Scheduler</code> 的 <strong>线程池并发处理</strong> 进行了测试。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/1640df3c27eedf87?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定时任务&lt;/strong&gt; 一般会存在 &lt;strong&gt;中大型企业级&lt;/strong&gt; 项目中，为了减少 &lt;strong&gt;服务器&lt;/strong&gt;、&lt;strong&gt;数据库&lt;/strong&gt; 的压力，往往会以 &lt;strong&gt;定时任务&lt;/strong&gt; 的方式去完成某些业务逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Quartz" scheme="https://ostenant.coding.me/tags/Quartz/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
      <category term="定时任务" scheme="https://ostenant.coding.me/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="Spring Task" scheme="https://ostenant.coding.me/tags/Spring-Task/"/>
    
      <category term="Timer" scheme="https://ostenant.coding.me/tags/Timer/"/>
    
      <category term="ScheduledExecutorService" scheme="https://ostenant.coding.me/tags/ScheduledExecutorService/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(五) - Listener, Servlet和Filter, Controller和Interceptor</title>
    <link href="https://ostenant.coding.me/2018/06/20/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%BA%94)%20-%20Listener,%20Servlet%E5%92%8CFilter,%20Controller%E5%92%8CInterceptor/"/>
    <id>https://ostenant.coding.me/2018/06/20/实战Spring Boot 2.0系列(五) - Listener, Servlet和Filter, Controller和Interceptor/</id>
    <published>2018-06-20T11:20:00.000Z</published>
    <updated>2018-07-05T12:46:15.992Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用户认证授权、日志记录 <code>MDC</code>、编码解码、<code>UA</code> 检查、多端对应等都需要通过 <strong>拦截请求</strong> 来进行处理。这时就需要 <code>Servlet</code>、<code>Filter</code>、<code>Listener</code>、<code>Interceptor</code> 这几种组件。而把非 <code>Spring Boot</code> 项目转换成 <code>Spring Boot</code> 项目，需要沿用以前的这些代码，所以有必要了解这它们的 <strong>用法</strong> 和 <strong>生命周期</strong>。 </p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413255f98b30e7?w=620&amp;h=595&amp;f=png&amp;s=81732" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-几种组件介绍"><a href="#1-几种组件介绍" class="headerlink" title="1. 几种组件介绍"></a>1. 几种组件介绍</h2><h3 id="1-1-监听器Listener"><a href="#1-1-监听器Listener" class="headerlink" title="1.1. 监听器Listener"></a>1.1. 监听器Listener</h3><p><code>Listener</code> 可以监听 <code>web</code> 服务器中某一个 <strong>事件操作</strong>，并触发注册的 <strong>回调函数</strong>。通俗的语言就是在 <code>application</code>，<code>session</code>，<code>request</code> 三个对象 <strong>创建/消亡</strong> 或者 <strong>增删改</strong> 属性时，自动执行代码的功能组件。</p><h3 id="1-2-Servlet"><a href="#1-2-Servlet" class="headerlink" title="1.2. Servlet"></a>1.2. Servlet</h3><p><code>Servlet</code> 是一种运行 <strong>服务器端</strong> 的 <code>java</code> 应用程序，具有 <strong>独立于平台和协议</strong> 的特性，并且可以动态的生成 <code>web</code> 页面，它工作在 <strong>客户端请求</strong> 与 <strong>服务器响应</strong> 的中间层。</p><h3 id="1-3-过滤器Filter"><a href="#1-3-过滤器Filter" class="headerlink" title="1.3. 过滤器Filter"></a>1.3. 过滤器Filter</h3><p><code>Filter</code> 对 <strong>用户请求</strong> 进行 <strong>预处理</strong>，接着将请求交给 <code>Servlet</code> 进行 <strong>处理</strong> 并 <strong>生成响应</strong>，最后 <code>Filter</code> 再对 <strong>服务器响应</strong> 进行 <strong>后处理</strong>。<code>Filter</code> 是可以复用的代码片段，常用来转换 <code>HTTP</code> <strong>请求</strong>、<strong>响应</strong> 和 <strong>头信息</strong>。<code>Filter</code> 不像 <code>Servlet</code>，它不能产生 <strong>响应</strong>，而是只 <strong>修改</strong> 对某一资源的 <strong>请求</strong> 或者 <strong>响应</strong>。</p><h3 id="1-4-拦截器Interceptor"><a href="#1-4-拦截器Interceptor" class="headerlink" title="1.4. 拦截器Interceptor"></a>1.4. 拦截器Interceptor</h3><p>类似 <strong>面向切面编程</strong> 中的 <strong>切面</strong> 和 <strong>通知</strong>，我们通过 <strong>动态代理</strong> 对一个 <code>service()</code> 方法添加 <strong>通知</strong> 进行功能增强。比如说在方法执行前进行 <strong>初始化处理</strong>，在方法执行后进行 <strong>后置处理</strong>。<strong>拦截器</strong> 的思想和 <code>AOP</code> 类似，区别就是 <strong>拦截器</strong> 只能对 <code>Controller</code> 的 <code>HTTP</code> 请求进行拦截。</p><h2 id="2-过滤器-VS-拦截器"><a href="#2-过滤器-VS-拦截器" class="headerlink" title="2. 过滤器 VS 拦截器"></a>2. 过滤器 VS 拦截器</h2><h3 id="2-1-两者的区别"><a href="#2-1-两者的区别" class="headerlink" title="2.1. 两者的区别"></a>2.1. 两者的区别</h3><ol><li><p><code>Filter</code> 是基于 <strong>函数回调</strong>的，而 <code>Interceptor</code> 则是基于 <code>Java</code> <strong>反射</strong> 和 <strong>动态代理</strong>。</p></li><li><p><code>Filter</code> 依赖于 <code>Servlet</code> 容器，而 <code>Interceptor</code> 不依赖于 <code>Servlet</code> 容器。</p></li><li><p><code>Filter</code> 对几乎 <strong>所有的请求</strong> 起作用，而 <code>Interceptor</code> 只对 <code>Controller</code> 对请求起作用。</p></li></ol><h3 id="2-2-执行顺序"><a href="#2-2-执行顺序" class="headerlink" title="2.2. 执行顺序"></a>2.2. 执行顺序</h3><p>对于自定义 <code>Servlet</code> 对请求分发流程：</p><ol><li><code>Filter</code> 过滤请求处理；</li><li><code>Servlet</code> 处理请求；</li><li><code>Filter</code> 过滤响应处理。</li></ol><p>对于自定义 <code>Controller</code> 的请求分发流程：</p><ol><li><code>Filter</code> 过滤请求处理；</li><li><code>Interceptor</code> 拦截请求处理；</li><li>对应的 <code>HandlerAdapter</code> 处理请求；</li><li><code>Interceptor</code> 拦截响应处理；</li><li><code>Interceptor</code> 的最终处理；</li><li><code>Filter</code> 过滤响应处理。</li></ol><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3. 环境准备"></a>3. 环境准备</h2><h3 id="配置gradle依赖"><a href="#配置gradle依赖" class="headerlink" title="配置gradle依赖"></a>配置gradle依赖</h3><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-web-async-task</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置启动入口类"><a href="#配置启动入口类" class="headerlink" title="配置启动入口类"></a>配置启动入口类</h3><p>配置一个 <code>Spring Boot</code> 启动入口类，这里需要配置两个注解。</p><ul><li><p>@ServletComponentScan: 允许 <code>Spring Boot</code> 扫描和装载当前 <strong>包路径</strong> 和 <strong>子路径</strong> 下配置的 <code>Servlet</code>。</p></li><li><p>@EnableWvc: 允许 <code>Spring Boot</code> 配置 <code>Spring MVC</code> 相关自定义的属性，比如：拦截器、资源处理器、消息转换器等。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-配置监听器Listener"><a href="#4-配置监听器Listener" class="headerlink" title="4. 配置监听器Listener"></a>4. 配置监听器Listener</h2><p>配置一个 <code>ServletContext</code> 监听器，使用 <code>@WebListener</code> 标示即可。在 <code>Servlet</code> 容器 <strong>初始化</strong> 过程中，<code>contextInitialized()</code> 方法会被调用，在容器 <strong>销毁</strong> 时会调用 <code>contextDestroyed()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexServletContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(IndexServletContextListener.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INITIAL_CONTENT = <span class="string">"Content created in servlet Context"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Start to initialize servlet context"</span>);</span><br><span class="line">        ServletContext servletContext = sce.getServletContext();</span><br><span class="line">        servletContext.setAttribute(<span class="string">"content"</span>, INITIAL_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Destroy servlet context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在容器初始化时，往 <code>ServletContext</code> 上下文设置了参数名称为 <code>INITIAL_CONTENT</code>，可以全局直接访问。</p><h2 id="5-配置Servlet"><a href="#5-配置Servlet" class="headerlink" title="5. 配置Servlet"></a>5. 配置Servlet</h2><p>配置 <code>IndexHttpServlet</code>，重写 <code>HttpServlet</code> 的 <code>doGet()</code> 方法，直接输出 <code>IndexHttpServlet</code> 定义的 <strong>初始化参数</strong> 和在 <code>IndexServletContextListener</code> 设置的 <code>ServletContext</code> 上下文参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"IndexHttpServlet"</span>,</span><br><span class="line">        displayName = <span class="string">"indexHttpServlet"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"/index/IndexHttpServlet"</span>&#125;,</span><br><span class="line">        initParams = &#123;</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"createdBy"</span>, value = <span class="string">"Icarus"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"createdOn"</span>, value = <span class="string">"2018-06-20"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexHttpServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        resp.getWriter().println(format(<span class="string">"Created by %s"</span>, getInitParameter(<span class="string">"createdBy"</span>)));</span><br><span class="line">        resp.getWriter().println(format(<span class="string">"Created on %s"</span>, getInitParameter(<span class="string">"createdOn"</span>)));</span><br><span class="line">        resp.getWriter().println(format(<span class="string">"Servlet context param: %s"</span>,</span><br><span class="line">                req.getServletContext().getAttribute(<span class="string">"content"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 <code>@WebServlet</code> 注解用于注册这个 <code>Servlet</code>，<code>@WebServlet</code> 注解的 <strong>各个参数</strong> 分别对应 <code>web.xml</code> 中的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>IndexHttpServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index/IndexHttpServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>IndexHttpServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>io.ostenant.springboot.sample.servlet.IndexHttpServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>createdBy<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Icarus<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>createdOn<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2018-06-20<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-配置过滤器Filter"><a href="#6-配置过滤器Filter" class="headerlink" title="6. 配置过滤器Filter"></a>6. 配置过滤器Filter</h2><p>一个 <code>Servlet</code> 请求可以经由多个 <code>Filter</code> 进行过滤，最终由 <code>Servlet</code> 处理并响应客户端。这里配置两个过滤器示例：</p><p>FirstIndexFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"firstIndexFilter"</span>,</span><br><span class="line">        displayName = <span class="string">"firstIndexFilter"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"/index/*"</span>&#125;,</span><br><span class="line">        initParams = <span class="meta">@WebInitParam</span>(</span><br><span class="line">                name = <span class="string">"firstIndexFilterInitParam"</span>,</span><br><span class="line">                value = <span class="string">"io.ostenant.springboot.sample.filter.FirstIndexFilter"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstIndexFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FirstIndexFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Register a new filter &#123;&#125;"</span>, filterConfig.getFilterName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexFilter pre filter the request"</span>);</span><br><span class="line">        String filter = request.getParameter(<span class="string">"filter1"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(filter)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by firstIndexFilter, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"filter1\""</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexFilter post filter the response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Destroy filter &#123;&#125;"</span>, getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 <code>@WebFilter</code> 相关的配置属性，对应于 <code>web.xml</code> 的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>firstIndexFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>io.ostenant.springboot.sample.filter.FirstIndexFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>firstIndexFilterInitParam<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>io.ostenant.springboot.sample.filter.FirstIndexFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 <code>FirstIndexFilter</code>，使用 <code>@WebFilter</code> 注解进行标示。当 <code>FirstIndexFilter</code> 初始化时，会执行 <code>init()</code> 方法。每次请求路径匹配 <code>urlPatterns</code> 配置的路径时，就会进入 <code>doFilter()</code> 方法进行具体的 <strong>请求</strong> 和 <strong>响应过滤</strong>。</p><p>当 <code>HTTP</code> 请求携带 <code>filter1</code> 参数时，请求会被放行；否则，直接 <strong>过滤中断</strong>，结束请求处理。</p><p>SecondIndexFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"secondIndexFilter"</span>,</span><br><span class="line">        displayName = <span class="string">"secondIndexFilter"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"/index/*"</span>&#125;,</span><br><span class="line">        initParams = <span class="meta">@WebInitParam</span>(</span><br><span class="line">                name = <span class="string">"secondIndexFilterInitParam"</span>,</span><br><span class="line">                value = <span class="string">"io.ostenant.springboot.sample.filter.SecondIndexFilter"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondIndexFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SecondIndexFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Register a new filter &#123;&#125;"</span>, filterConfig.getFilterName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexFilter pre filter the request"</span>);</span><br><span class="line">        String filter = request.getParameter(<span class="string">"filter2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(filter)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by firstIndexFilter, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"filter2\""</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexFilter post filter the response"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Destroy filter &#123;&#125;"</span>, getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 <code>@WebFilter</code> 相关的配置属性，对应于 <code>web.xml</code> 的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>secondIndexFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>io.ostenant.springboot.sample.filter.SecondIndexFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>secondIndexFilterInitParam<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>io.ostenant.springboot.sample.filter.SecondIndexFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 <code>SecondIndexFilter</code>，使用 <code>@WebFilter</code> 注解进行标示。当 <code>SecondIndexFilter</code> 初始化时，会执行 <code>init()</code> 方法。每次请求路径匹配 <code>urlPatterns</code> 配置的路径时，就会进入 <code>doFilter()</code> 方法进行具体的 <strong>请求</strong> 和 <strong>响应过滤</strong>。</p><p>当 <code>HTTP</code> 请求携带 <code>filter2</code> 参数时，请求会被放行；否则，直接 <strong>过滤中断</strong>，结束请求处理。</p><p>来看看 <code>doFilter()</code> 最核心的三个参数：</p><ul><li>ServletRequest: 未到达 <code>Servlet</code> 的 <code>HTTP</code> 请求； </li><li>ServletResponse: 由 <code>Servlet</code> 处理并生成的 <code>HTTP</code> 响应；</li><li>FilterChain: <strong>过滤器链</strong> 对象，可以按顺序注册多个 <strong>过滤器</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterChain.doFilter(request, response);</span><br></pre></td></tr></table></figure><blockquote><p><strong>解释：</strong> 一个 <strong>过滤器链</strong> 对象可以按顺序注册多个 <strong>过滤器</strong>。符合当前过滤器过滤条件，即请求 <strong>过滤成功</strong> 直接放行，则交由下一个 <strong>过滤器</strong> 进行处理。所有请求过滤完成以后，由 <code>IndexHttpServlet</code> 处理并生成 <strong>响应</strong>，然后在 <strong>过滤器链</strong> 以相反的方向对 <strong>响应</strong> 进行后置过滤处理。</p></blockquote><h3 id="配置控制器Controller"><a href="#配置控制器Controller" class="headerlink" title="配置控制器Controller"></a>配置控制器Controller</h3><p>配置 <code>IndexController</code>，用于测试 <code>/index/IndexController</code> 路径是否会被 <code>Filter</code> 过滤和 <code>Interceptor</code> 拦截，并验证两者的先后顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"IndexController"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"IndexController"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-配置拦截器Interceptor"><a href="#7-配置拦截器Interceptor" class="headerlink" title="7. 配置拦截器Interceptor"></a>7. 配置拦截器Interceptor</h2><p>拦截器 <code>Interceptor</code> 只对 <code>Handler</code> 生效。<code>Spring MVC</code> 会为 <code>Controller</code> 中的每个 <strong>请求方法</strong> 实例化为一个 <code>Handler</code>对象，由 <code>HandlerMapping</code> 对象路由请求到具体的 <code>Handler</code>，然后由 <code>HandlerAdapter</code> 通过反射进行请求 <strong>处理</strong> 和 <strong>响应</strong>，这中间就穿插着 <strong>拦截处理</strong>。</p><h4 id="编写拦截器"><a href="#编写拦截器" class="headerlink" title="编写拦截器"></a>编写拦截器</h4><p>为了区分日志，下面同样对 <code>IndexController</code> 配置两个拦截器类：</p><p>FirstIndexInterceptor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstIndexInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FirstIndexInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexInterceptor pre intercepted the request"</span>);</span><br><span class="line">        String interceptor = request.getParameter(<span class="string">"interceptor1"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(interceptor)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by FirstIndexFilter, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"interceptor1\""</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexInterceptor post intercepted the response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexInterceptor do something after request completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecondIndexInterceptor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondIndexInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SecondIndexInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexInterceptor pre intercepted the request"</span>);</span><br><span class="line">        String interceptor = request.getParameter(<span class="string">"interceptor2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(interceptor)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by SecondIndexInterceptor, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"interceptor2\""</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexInterceptor post intercepted the response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexInterceptor do something after request completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h4><p>在 <code>Spring Boot</code> 中 <strong>配置拦截器</strong> 很简单，只需要实现 <code>WebMvcConfigurer</code> 接口，在 <code>addInterceptors()</code> 方法中通过 <code>InterceptorRegistry</code> 添加 <strong>拦截器</strong> 和 <strong>匹配路径</strong> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(WebConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> FirstIndexInterceptor()).addPathPatterns(<span class="string">"/index/**"</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> SecondIndexInterceptor()).addPathPatterns(<span class="string">"/index/**"</span>);</span><br><span class="line">        LOGGER.info(<span class="string">"Register FirstIndexInterceptor and SecondIndexInterceptor onto InterceptorRegistry"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>Spring XML</code> 配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"firstIndexInterceptor"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"io.ostenant.springboot.sample.interceptor.FirstIndexInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"secondIndexInterceptor"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"io.ostenant.springboot.sample.interceptor.SecondIndexInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/index/**"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"firstIndexInterceptor"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/index/**"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"secondIndexInterceptor"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h4><p>我们通过实现 <code>HandlerInterceptor</code> 接口来开发一个 <strong>拦截器</strong>，来看看 <code>HandlerInterceptor</code> 接口的三个重要的方法：</p><ul><li><p>preHandle(): 在 <code>controller</code> 接收请求、处理 <code>request</code> 之前执行，返回值为 <code>boolean</code>，返回值为 <code>true</code> 时接着执行 <code>postHandle()</code> 和 <code>afterCompletion()</code> 方法；如果返回 <code>false</code> 则 <strong>中断</strong> 执行。</p></li><li><p>postHandle(): 在 <code>controller</code> 处理请求之后， <code>ModelAndView</code> 处理前执行，可以对 <strong>响应结果</strong> 进行修改。</p></li><li><p>afterCompletion(): 在 <code>DispatchServlet</code> 对本次请求处理完成，即生成 <code>ModelAndView</code> 之后执行。</p></li></ul><p>下面简单的看一下 <code>Spring MVC</code> 中心调度器 <code>DispatcherServlet</code> 的 <code>doDispatch()</code> 方法的原理，重点关注 <strong>拦截器</strong> 的以上三个方法的执行顺序。</p><ul><li>doDispatch(): <code>DispatchServlet</code> 处理请求分发的核心方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 按从前往后的顺序调用各个拦截器preHandle()方法</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. HandlerAdapter开始真正的请求处理并生产响应视图对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 按照从后往前的顺序依次调用各个拦截器的postHandle()方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 4. 最终会调用拦截器的afterCompletion()方法</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        <span class="comment">// 4. 最终会调用拦截器的afterCompletion()方法</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面注释的几个 <code>HandlerExecutionChain</code> 的方法: <code>applyPreHandle()</code>、<code>applyPostHandle()</code> 和 <code>triggerAfterCompletion()</code>。 </p></blockquote><ul><li>applyPreHandle(): 按 <strong>从前往后</strong> 的顺序调用各个拦截器的 <code>preHandle()</code> 方法。任意一个 <code>HandlerInterceptor</code> 拦截返回 <code>false</code> ，则 <code>preHandle()</code> 返回 <code>false</code>，记录拦截器的位置 <code>interceptorIndex</code>，然后中断拦截处理，最终触发 <code>AfterCompletion()</code> 方法并返回 <code>false</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</span><br><span class="line">                triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.interceptorIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>applyPostHandle(): 按照 <strong>从后往前</strong> 的顺序依次调用各个拦截器的 <code>postHandle()</code> 方法。只有当所有 <code>HandlerInterceptor</code> 的 <code>preHandle()</code> 方法返回 <code>true</code> 时，才有机会执行到 <code>applyPostHandle()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>triggerAfterCompletion: <code>triggerAfterCompletion()</code> 只在 <code>preHandle()</code> 方法返回 <code>false</code> 和 <strong>程序抛出异常</strong> 时执行。在 <code>preHandle()</code> 方法中，通过 <code>interceptorIndex</code> 记录了返回 <code>false</code> 的 <strong>拦截器索引</strong>。一旦 <code>applyPreHandle()</code> 方法返回 <code>false</code>，则从当前返回 <code>false</code> 的拦截器 <strong>从后往前</strong> 的执行 <code>afterCompletion()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interceptor.afterCompletion(request, response, <span class="keyword">this</span>.handler, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">"HandlerInterceptor.afterCompletion threw exception"</span>, ex2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-开始测试"><a href="#8-开始测试" class="headerlink" title="8. 开始测试"></a>8. 开始测试</h2><h3 id="生命周期测试"><a href="#生命周期测试" class="headerlink" title="生命周期测试"></a>生命周期测试</h3><p>启动 <code>Spring Boot</code> 应用程序，观察启动时的程序日志，下面我按照 <strong>顺序</strong> 来分析启动过程中完成了哪些事情。</p><ul><li>注册 <code>Spring MVC</code> 的 <code>dispatcherServlet</code> 和自定义的 <code>IndexHttpServlet</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.400  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Servlet dispatcherServlet mapped to [/]</span><br><span class="line">2018-06-23 09:39:55.404  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Servlet IndexHttpServlet mapped to [/index/IndexHttpServlet]</span><br></pre></td></tr></table></figure><blockquote><p>注意: <code>dispatcherServlet</code> 的 <code>load-up-onstartup</code> 为 <code>1</code>，会优先于其他 <code>Servlet</code> 进行加载。</p></blockquote><ul><li>按照先后顺序，将所有的过滤器 <code>Filter</code> 对象与路径进行映射，其中 <code>characterEncodingFilter</code> 是 <code>Spring MVC</code> 自带的解决乱码的 <code>Filter</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.408  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: <span class="string">'characterEncodingFilter'</span> to: [/*]</span><br><span class="line">2018-06-23 09:39:55.409  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: <span class="string">'firstIndexFilter'</span> to urls: [/index/*]</span><br><span class="line">2018-06-23 09:39:55.409  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: <span class="string">'secondIndexFilter'</span> to urls: [/index/*]</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>IndexServletContextListener</code>，并执行 <code>contextInitialized()</code> 方法进行上下文初始化操作。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.429  INFO 12301 --- [ost-startStop-1] i.o.s.s.l.IndexServletContextListener    : Start to initialize servlet context</span><br></pre></td></tr></table></figure><ul><li>依次执行 <code>Filter</code> 的 <code>init()</code> 方法进行初始化处理。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.432  INFO 12301 --- [ost-startStop-1] i.o.s.sample.filter.SecondIndexFilter     : Register a new filter secondIndexFilter</span><br><span class="line">2018-06-23 09:39:55.434  INFO 12301 --- [ost-startStop-1] i.o.s.sample.filter.FirstIndexFilter      : Register a new filter firstIndexFilter</span><br></pre></td></tr></table></figure><ul><li>创建、初始化拦截器，并统一注册到 <code>InterceptorRegistry</code> 上。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.502  INFO 13150 --- [           main] i.o.s.s.interceptor.WebConfiguration     : Register FirstIndexInterceptor and SecondIndexInterceptor onto InterceptorRegistry</span><br></pre></td></tr></table></figure><ul><li>对 <code>IndexController</code> 进行处理，把 <strong>请求</strong> <code>URI</code> 和 <strong>处理方法</strong> 映射到 <code>HandlerMapping</code> 上并进行缓存。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.541  INFO 12301 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped <span class="string">"&#123;[/index/IndexController],methods=[GET]&#125;"</span> onto public java.lang.String io.ostenant.springboot.sample.controller.IndexController.index() throws java.lang.Exception</span><br></pre></td></tr></table></figure><p>关闭 <code>Spring Boot</code> 应用程序时，观察输出日志如下: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 10:07:03.294  INFO 12301 --- [ost-startStop-2] i.o.s.sample.filter.FirstIndexFilter     : Destroy filter io.ostenant.springboot.sample.filter.SecondIndexFilter</span><br><span class="line">2018-06-23 10:07:03.294  INFO 12301 --- [ost-startStop-2] i.o.s.sample.filter.FirstIndexFilter     : Destroy filter io.ostenant.springboot.sample.filter.FirstIndexFilter</span><br><span class="line">2018-06-23 10:07:03.294  INFO 12301 --- [ost-startStop-2] i.o.s.s.l.IndexServletContextListener    : Destroy servlet context</span><br></pre></td></tr></table></figure><p>可以看到上面配置的过滤器的 <code>destroy()</code> 方法和 <code>IndexServletContextListener</code> 的 <code>contextDestroyed()</code> 方法都被调用了。</p><h3 id="访问控制测试"><a href="#访问控制测试" class="headerlink" title="访问控制测试"></a>访问控制测试</h3><h4 id="Servlet测试"><a href="#Servlet测试" class="headerlink" title="Servlet测试"></a>Servlet测试</h4><p>访问 <a href="http://localhost:8080/index/IndexHttpServlet" target="_blank" rel="noopener">http://localhost:8080/index/IndexHttpServlet</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b22951f75288?w=2056&amp;h=132&amp;f=png&amp;s=36514" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexHttpServlet?filter1=filter1" target="_blank" rel="noopener">http://localhost:8080/index/IndexHttpServlet?filter1=filter1</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b2294f07adf2?w=2052&amp;h=130&amp;f=png&amp;s=38121" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexHttpServlet?filter1=filter1&amp;filter2=filter2" target="_blank" rel="noopener">http://localhost:8080/index/IndexHttpServlet?filter1=filter1&amp;filter2=filter2</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b22951104958?w=2048&amp;h=196&amp;f=png&amp;s=52106" alt=""></p><p>观察控制台输出日志，验证 <strong>过滤器</strong> 的过滤顺序正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter post filter the response</span><br><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter post filter the response</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong> 自定义的 <strong>过滤器</strong> 对 <code>IndexHttpServlet</code> 生效， 而 <strong>自定义</strong> 的拦截器生效。</p></blockquote><h4 id="controller测试"><a href="#controller测试" class="headerlink" title="controller测试"></a>controller测试</h4><p>访问 <a href="http://localhost:8080/index/IndexController" target="_blank" rel="noopener">http://localhost:8080/index/IndexController</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b2294fc8a36c?w=2052&amp;h=132&amp;f=png&amp;s=35303" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b2294fecf208?w=2042&amp;h=138&amp;f=png&amp;s=37551" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b229509d83f4?w=2052&amp;h=144&amp;f=png&amp;s=40857" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b229770dcdc4?w=2048&amp;h=142&amp;f=png&amp;s=45156" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1&amp;interceptor2=interceptor2" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1&amp;interceptor2=interceptor2</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b22976f450d8?w=2050&amp;h=144&amp;f=png&amp;s=36973" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 10:21:42.533  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:21:42.533  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:21:42.534  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.FirstIndexInterceptor          : FirstIndexInterceptor pre intercepted the request</span><br><span class="line">2018-06-23 10:21:42.534  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.SecondIndexInterceptor         : SecondIndexInterceptor pre intercepted the request</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.SecondIndexInterceptor         : SecondIndexInterceptor post intercepted the response</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.FirstIndexInterceptor          : FirstIndexInterceptor post intercepted the response</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.SecondIndexInterceptor         : SecondIndexInterceptor <span class="keyword">do</span> something after request completed</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.FirstIndexInterceptor          : FirstIndexInterceptor <span class="keyword">do</span> something after request completed</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter post filter the response</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter post filter the response</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong> 自定义的 <strong>过滤器</strong> 和 <strong>拦截器</strong> 对 <strong>控制器</strong> <code>Controller</code> 生效。而 <strong>过滤器</strong> 的优先级高于 <strong>拦截器</strong>。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文详细介绍了 <code>Listener</code>，<code>Servlet</code>，<code>Filter</code>，<code>Controller</code> 和 <code>Interceptor</code> 等 <code>Web</code> 多种组件的功能、方法、顺序、作用域和生命周期。给出了详细的示例代码，结合 <strong>源码</strong> 分析了流程，结合 <strong>测试</strong> 验证了结论。长篇大论，希望大家对 <code>Servlet</code> 组件和 <code>Spring MVC</code> 的框架组件有了更清晰的认识。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/1640df3c27eedf87?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;用户认证授权、日志记录 &lt;code&gt;MDC&lt;/code&gt;、编码解码、&lt;code&gt;UA&lt;/code&gt; 检查、多端对应等都需要通过 &lt;strong&gt;拦截请求&lt;/strong&gt; 来进行处理。这时就需要 &lt;code&gt;Servlet&lt;/code&gt;、&lt;code&gt;Filter&lt;/code&gt;、&lt;code&gt;Listener&lt;/code&gt;、&lt;code&gt;Interceptor&lt;/code&gt; 这几种组件。而把非 &lt;code&gt;Spring Boot&lt;/code&gt; 项目转换成 &lt;code&gt;Spring Boot&lt;/code&gt; 项目，需要沿用以前的这些代码，所以有必要了解这它们的 &lt;strong&gt;用法&lt;/strong&gt; 和 &lt;strong&gt;生命周期&lt;/strong&gt;。 &lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
      <category term="Listener" scheme="https://ostenant.coding.me/tags/Listener/"/>
    
      <category term="Servlet" scheme="https://ostenant.coding.me/tags/Servlet/"/>
    
      <category term="Filter" scheme="https://ostenant.coding.me/tags/Filter/"/>
    
      <category term="Interceptor" scheme="https://ostenant.coding.me/tags/Interceptor/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(四) - 使用WebAsyncTask处理异步任务</title>
    <link href="https://ostenant.coding.me/2018/06/18/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E5%9B%9B)%20-%20%E4%BD%BF%E7%94%A8WebAsyncTask%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>https://ostenant.coding.me/2018/06/18/实战Spring Boot 2.0系列(四) - 使用WebAsyncTask处理异步任务/</id>
    <published>2018-06-18T00:20:00.000Z</published>
    <updated>2018-06-18T14:08:49.695Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文介绍了基于 <code>@Async</code> 注解的 <strong>异步调用编程</strong>，本文将继续引入 <code>Spring Boot</code> 的 <code>WebAsyncTask</code> 进行更灵活异步任务处理，包括 <strong>异步回调</strong>，<strong>超时处理</strong> 和 <strong>异常处理</strong>。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413255f98b30e7?w=620&amp;h=595&amp;f=png&amp;s=81732" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-处理线程和异步线程"><a href="#1-处理线程和异步线程" class="headerlink" title="1. 处理线程和异步线程"></a>1. 处理线程和异步线程</h2><p>在开始下面的讲解之前，在这里先区别下两个概念：</p><ol><li><p>处理线程：<strong>处理线程</strong> 属于 <code>web</code> 服务器线程，负责 <strong>处理用户请求</strong>，采用 <strong>线程池</strong> 管理。</p></li><li><p>异步线程：<strong>异步线程</strong> 属于 <strong>用户自定义的线程</strong>，可采用 <strong>线程池管理</strong>。</p></li></ol><p><code>Spring</code> 提供了对 <strong>异步任务</strong> <code>API</code>，采用 <code>WebAsyncTask</code> 类即可实现 <strong>异步任务</strong>。对异步任务设置相应的 <strong>回调处理</strong>，如当 <strong>任务超时</strong>、<strong>异常抛出</strong> 等。异步任务通常非常实用，比如：当一笔订单支付完成之后，开启异步任务查询订单的支付结果。</p><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h2><h3 id="配置gradle依赖"><a href="#配置gradle依赖" class="headerlink" title="配置gradle依赖"></a>配置gradle依赖</h3><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-web-async-task</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置服务类"><a href="#配置服务类" class="headerlink" title="配置服务类"></a>配置服务类</h3><p>配置一个用于异步任务调度的 <code>Mock</code>   服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置异步处理控制器并注入以上服务 <code>Bean</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAsyncController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebAsyncService asyncService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ERROR_MESSAGE = <span class="string">"Task error"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TIME_MESSAGE = <span class="string">"Task timeout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebAsyncController</span><span class="params">(WebAsyncService asyncService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.asyncService = asyncService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-正常异步任务"><a href="#3-正常异步任务" class="headerlink" title="3. 正常异步任务"></a>3. 正常异步任务</h2><p>配置一个正常的 <code>WebAsyncTask</code> 任务对象，设置任务 <strong>超时时间</strong> 为 <code>10s</code>。异步任务执行采用 <code>Thread.sleep(long)</code> 模拟，这里设置 <strong>异步线程</strong> 睡眠时间为 <code>5s</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/completion"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印处理线程名</span></span><br><span class="line">    out.println(format(<span class="string">"请求处理线程：%s"</span>, currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟开启一个异步任务，超时时间为10s</span></span><br><span class="line">    WebAsyncTask&lt;String&gt; asyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, () -&gt; &#123;</span><br><span class="line">        out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">        <span class="comment">// 任务处理时间5s，不超时</span></span><br><span class="line">        sleep(<span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">return</span> asyncService.generateUUID();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行完成时调用该方法</span></span><br><span class="line">    asyncTask.onCompletion(() -&gt; out.println(<span class="string">"任务执行完成"</span>));</span><br><span class="line">    out.println(<span class="string">"继续处理其他事情"</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 项目，访问 <a href="http://localhost:8080/completion" target="_blank" rel="noopener">http://localhost:8080/completion</a> ，发起 <strong>正常</strong> 的异步任务请求。</p><p>观察控制台输出，可以验证 <code>WebAsyncTask</code> 的异步处理流程正常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求处理线程：http-nio-8080-exec-2</span><br><span class="line">继续处理其他事情</span><br><span class="line">异步工作线程：MvcAsync1</span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure><p><code>Web</code> 页面正常响应，页面响应消息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413283f62bb949?w=2052&amp;h=152&amp;f=png&amp;s=32271" alt=""></p><blockquote><p>注意：WebAsyncTask.onCompletion(Runnable) ：在当前任务执行结束以后，无论是执行成功还是异常中止，onCompletion的回调最终都会被调用。</p></blockquote><h2 id="4-抛出异常异步任务"><a href="#4-抛出异常异步任务" class="headerlink" title="4. 抛出异常异步任务"></a>4. 抛出异常异步任务</h2><p>配置一个 <strong>错误</strong> 的 <code>WebAsyncTask</code> 任务对象，设置任务 <strong>超时时间</strong> 为 <code>10s</code>。在异步任务执行方法中 <strong>抛出异常</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/exception"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印处理线程名</span></span><br><span class="line">    out.println(format(<span class="string">"请求处理线程：%s"</span>, currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟开启一个异步任务，超时时间为10s</span></span><br><span class="line">    WebAsyncTask&lt;String&gt; asyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, () -&gt; &#123;</span><br><span class="line">        out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">        <span class="comment">// 任务处理时间5s，不超时</span></span><br><span class="line">        sleep(<span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(ERROR_MESSAGE);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行完成时调用该方法</span></span><br><span class="line">    asyncTask.onCompletion(() -&gt; out.println(<span class="string">"任务执行完成"</span>));</span><br><span class="line">    asyncTask.onError(() -&gt; &#123;</span><br><span class="line">        out.println(<span class="string">"任务执行异常"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR_MESSAGE;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">"继续处理其他事情"</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 项目，访问 <a href="http://localhost:8080/exception" target="_blank" rel="noopener">http://localhost:8080/exception</a> ，发起 <strong>异常</strong> 的异步任务请求。</p><p><code>Web</code> 页面响应异常信息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413283fa3d4c0d?w=2050&amp;h=370&amp;f=png&amp;s=80643" alt=""></p><p>观察控制台输出，可以验证 <code>WebAsyncTask</code> 对于 <strong>异常请求</strong> 的异步处理过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">请求处理线程：http-nio-8080-exec-1</span><br><span class="line">继续处理其他事情</span><br><span class="line">异步工作线程：MvcAsync2</span><br><span class="line">2018-06-18 21:12:10.110 ERROR 89875 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] threw exception</span><br><span class="line"></span><br><span class="line">java.lang.Exception: Task error</span><br><span class="line">at io.ostenant.springboot.sample.controller.WebAsyncController.lambda<span class="variable">$asyncTaskException</span><span class="variable">$2</span>(WebAsyncController.java:55) ~[classes/:na]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.lambda<span class="variable">$startCallableProcessing</span><span class="variable">$4</span>(WebAsyncManager.java:317) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511) ~[na:1.8.0_172]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_172]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]</span><br><span class="line"></span><br><span class="line">2018-06-18 21:12:10.111 ERROR 89875 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] <span class="keyword">in</span> context with path [] threw exception [Request processing failed; nested exception is java.lang.Exception: Task error] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.Exception: Task error</span><br><span class="line">at io.ostenant.springboot.sample.controller.WebAsyncController.lambda<span class="variable">$asyncTaskException</span><span class="variable">$2</span>(WebAsyncController.java:55) ~[classes/:na]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.lambda<span class="variable">$startCallableProcessing</span><span class="variable">$4</span>(WebAsyncManager.java:317) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511) ~[na:1.8.0_172]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_172]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]</span><br><span class="line"></span><br><span class="line">任务执行异常</span><br><span class="line">2018-06-18 21:12:10.144  WARN 89875 --- [nio-8080-exec-2] o.apache.catalina.core.AsyncContextImpl  : onError() failed <span class="keyword">for</span> listener of <span class="built_in">type</span> [org.apache.catalina.core.AsyncListenerWrapper]</span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException: Cannot dispatch without an AsyncContext</span><br><span class="line">at org.springframework.util.Assert.notNull(Assert.java:193) ~[spring-core-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.dispatch(StandardServletAsyncWebRequest.java:131) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.setConcurrentResultAndDispatch(WebAsyncManager.java:353) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.lambda<span class="variable">$startCallableProcessing</span><span class="variable">$2</span>(WebAsyncManager.java:304) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.lambda<span class="variable">$onError</span><span class="variable">$0</span>(StandardServletAsyncWebRequest.java:146) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at java.util.ArrayList.forEach(ArrayList.java:1257) ~[na:1.8.0_172]</span><br><span class="line">at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.onError(StandardServletAsyncWebRequest.java:146) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.apache.catalina.core.AsyncListenerWrapper.fireOnError(AsyncListenerWrapper.java:49) ~[tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.catalina.core.AsyncContextImpl.setErrorState(AsyncContextImpl.java:397) ~[tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:239) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.coyote.AbstractProcessor.dispatch(AbstractProcessor.java:232) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:53) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.coyote.AbstractProtocol<span class="variable">$ConnectionHandler</span>.process(AbstractProtocol.java:790) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint<span class="variable">$SocketProcessor</span>.doRun(NioEndpoint.java:1468) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_172]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624) [na:1.8.0_172]</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread<span class="variable">$WrappingRunnable</span>.run(TaskThread.java:61) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]</span><br><span class="line"></span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure><blockquote><p>注意：WebAsyncTask.onError(Callable&lt;?&gt;) ：当异步任务抛出异常的时候，onError()方法即会被调用。</p></blockquote><h2 id="5-超时异步任务"><a href="#5-超时异步任务" class="headerlink" title="5. 超时异步任务"></a>5. 超时异步任务</h2><p>配置一个正常的 <code>WebAsyncTask</code> 任务对象，设置任务 <strong>超时时间</strong> 为 <code>10s</code>。异步任务执行采用 <code>Thread.sleep(long)</code> 模拟，这里设置 <strong>异步线程</strong> 睡眠时间为 <code>15s</code>，引发异步任务超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/timeout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印处理线程名</span></span><br><span class="line">    out.println(format(<span class="string">"请求处理线程：%s"</span>, currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟开启一个异步任务，超时时间为10s</span></span><br><span class="line">    WebAsyncTask&lt;String&gt; asyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, () -&gt; &#123;</span><br><span class="line">        out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">        <span class="comment">// 任务处理时间5s，不超时</span></span><br><span class="line">        sleep(<span class="number">15</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">return</span> TIME_MESSAGE;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行完成时调用该方法</span></span><br><span class="line">    asyncTask.onCompletion(() -&gt; out.println(<span class="string">"任务执行完成"</span>));</span><br><span class="line">    asyncTask.onTimeout(() -&gt; &#123;</span><br><span class="line">        out.println(<span class="string">"任务执行超时"</span>);</span><br><span class="line">        <span class="keyword">return</span> TIME_MESSAGE;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">"继续处理其他事情"</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 项目，访问 <a href="http://localhost:8080/timeout" target="_blank" rel="noopener">http://localhost:8080/timeout</a> ，发起 <strong>超时</strong> 的异步任务请求。</p><p>观察控制台输出，可以验证 <code>WebAsyncTask</code> 的异步超时处理的过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求处理线程：http-nio-8080-exec-1</span><br><span class="line">继续处理其他事情</span><br><span class="line">异步工作线程：MvcAsync3</span><br><span class="line">任务执行超时</span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure><p><code>Web</code> 页面常响应超时提示信息，页面响应消息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413283fdc0eed4?w=2052&amp;h=150&amp;f=png&amp;s=25521" alt=""></p><blockquote><p>注意：WebAsyncTask.onTimeout(Callable&lt;?&gt;) ：当异步任务发生超时的时候，onTimeout()方法即会被调用。</p></blockquote><h2 id="6-线程池异步任务"><a href="#6-线程池异步任务" class="headerlink" title="6. 线程池异步任务"></a>6. 线程池异步任务</h2><p>上面的三种情况中的 <strong>异步任务</strong> 默认不是采用 <strong>线程池机制</strong> 进行管理的。</p><p>也就是说，一个请求进来，虽然释放了处理线程，但是系统依旧会为每个请求创建一个 <strong>异步任务线程</strong>，也就是上面看到的 <code>MvcAsync</code> 开头的 <strong>异步任务线程</strong>。</p><p>后果就是开销严重，所以通常采用 <strong>线程池</strong> 进行统一的管理，直接在 <code>WebAsyncTask</code> 类构造器传入一个 <code>ThreadPoolTaskExecutor</code> 对象实例即可。</p><p>构造一个线程池 <code>Bean</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">"asyncTask"</span>);</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器中注入 <code>ThreadPoolTaskExecutor</code> 对象，重新配置基于 <strong>线程池</strong> 的 <strong>异步任务处理</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/threadPool"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, executor,</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">                <span class="keyword">return</span> asyncService.generateUUID();</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发地请求 <a href="http://localhost:8080/threadPool" target="_blank" rel="noopener">http://localhost:8080/threadPool</a> ，观察控制台输出的 <strong>异步线程</strong> 信息，可以发现 <strong>异步任务</strong> 直接从 <strong>线程池</strong> 中获取 <strong>异步线程</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">异步工作线程：asyncTask1</span><br><span class="line">异步工作线程：asyncTask2</span><br><span class="line">异步工作线程：asyncTask3</span><br><span class="line">异步工作线程：asyncTask4</span><br><span class="line">异步工作线程：asyncTask5</span><br><span class="line">异步工作线程：asyncTask1</span><br><span class="line">异步工作线程：asyncTask2</span><br><span class="line">异步工作线程：asyncTask3</span><br><span class="line">异步工作线程：asyncTask4</span><br><span class="line">异步工作线程：asyncTask5</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了 <code>Spring Boot</code> 提供的 <code>WebAsyncTask</code> 的异步编程 <code>API</code>。相比上问介绍的 <code>@Async</code> 注解，<code>WebAsyncTask</code> 提供更加健全的 <strong>超时处理</strong> 和 <strong>异常处理</strong> 支持。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/1640df3c27eedf87?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上文介绍了基于 &lt;code&gt;@Async&lt;/code&gt; 注解的 &lt;strong&gt;异步调用编程&lt;/strong&gt;，本文将继续引入 &lt;code&gt;Spring Boot&lt;/code&gt; 的 &lt;code&gt;WebAsyncTask&lt;/code&gt; 进行更灵活异步任务处理，包括 &lt;strong&gt;异步回调&lt;/strong&gt;，&lt;strong&gt;超时处理&lt;/strong&gt; 和 &lt;strong&gt;异常处理&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="异步" scheme="https://ostenant.coding.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(三) - 使用@Async进行异步调用详解</title>
    <link href="https://ostenant.coding.me/2018/06/17/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%B8%89)%20-%20%E4%BD%BF%E7%94%A8@Async%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ostenant.coding.me/2018/06/17/实战Spring Boot 2.0系列(三) - 使用@Async进行异步调用详解/</id>
    <published>2018-06-17T01:40:00.000Z</published>
    <updated>2018-06-18T01:57:16.309Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>异步调用</strong> 对应的是 <strong>同步调用</strong>，<strong>同步调用</strong> 指程序按照 <strong>定义顺序</strong> 依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行；<strong>异步调用</strong> 指程序在顺序执行时，<strong>不等待</strong> 异步调用的语句 <strong>返回结果</strong> 就执行后面的程序。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBootAll.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-async-task</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    compileOnly(<span class="string">'org.projectlombok:lombok'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Spring Boot</code> 入口类上配置 <code>@EnableAsync</code> 注解开启异步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建任务抽象类 <code>AbstractTask</code>，并分别配置三个任务方法 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.println(<span class="string">"开始做任务一"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"完成任务一，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.println(<span class="string">"开始做任务二"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"完成任务二，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.println(<span class="string">"开始做任务三"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"完成任务三，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-同步调用"><a href="#2-同步调用" class="headerlink" title="2. 同步调用"></a>2. 同步调用</h2><p>下面通过一个简单示例来直观的理解什么是同步调用：</p><ul><li>定义 <code>Task</code> 类，继承 <code>AbstractTask</code>，三个处理函数分别模拟三个执行任务的操作，操作消耗时间随机取（<code>10</code> 秒内）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>Task</code> 对象，并在测试用例中执行 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Task task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSyncTasks</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        task.doTaskOne();</span><br><span class="line">        task.doTaskTwo();</span><br><span class="line">        task.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行单元测试，可以看到类似如下输出：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">完成任务一，耗时：4059毫秒</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：6316毫秒</span><br><span class="line">开始做任务三</span><br><span class="line">完成任务三，耗时：1973毫秒</span><br></pre></td></tr></table></figure><p>任务一、任务二、任务三顺序的执行完了，换言之 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法顺序的执行完成。</p><h2 id="3-异步调用"><a href="#3-异步调用" class="headerlink" title="3. 异步调用"></a>3. 异步调用</h2><p>上述的 <strong>同步调用</strong> 虽然顺利的执行完了三个任务，但是可以看到 <strong>执行时间比较长</strong>，若这三个任务本身之间 <strong>不存在依赖关系</strong>，可以 <strong>并发执行</strong> 的话，同步调用在 <strong>执行效率</strong> 方面就比较差，可以考虑通过 <strong>异步调用</strong> 的方式来 <strong>并发执行</strong>。</p><ul><li>创建 <code>AsyncTask</code>类，分别在方法上配置 <code>@Async</code> 注解，将原来的 <strong>同步方法</strong> 变为 <strong>异步方法</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskTwo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>AsyncTask</code> 对象，并在测试用例中执行 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTask task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncTasks</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        task.doTaskOne();</span><br><span class="line">        task.doTaskTwo();</span><br><span class="line">        task.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行单元测试，可以看到类似如下输出：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始做任务三</span><br><span class="line">开始做任务一</span><br><span class="line">开始做任务二</span><br></pre></td></tr></table></figure><p>如果反复执行单元测试，可能会遇到各种不同的结果，比如：</p><ol><li>没有任何任务相关的输出</li><li>有部分任务相关的输出</li><li>乱序的任务相关的输出</li></ol><p>原因是目前 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 这三个方法已经 <strong>异步执行</strong> 了。主程序在 <strong>异步调用</strong> 之后，主程序并不会理会这三个函数是否执行完成了，由于没有其他需要执行的内容，所以程序就 <strong>自动结束</strong> 了，导致了 <strong>不完整</strong> 或是 <strong>没有输出任务</strong> 相关内容的情况。</p><blockquote><p>注意：@Async所修饰的函数不要定义为static类型，这样异步调用不会生效。</p></blockquote><h3 id="4-异步回调"><a href="#4-异步回调" class="headerlink" title="4. 异步回调"></a>4. 异步回调</h3><p>为了让 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 能正常结束，假设我们需要统计一下三个任务 <strong>并发执行</strong> 共耗时多少，这就需要等到上述三个函数都完成动用之后记录时间，并计算结果。</p><p>那么我们如何判断上述三个 <strong>异步调用</strong> 是否已经执行完成呢？我们需要使用 <code>Future&lt;T&gt;</code> 来返回 <strong>异步调用</strong> 的 <strong>结果</strong>。</p><ul><li>创建 <code>AsyncCallBackTask</code> 类，声明 <code>doTaskOneCallback()</code>，<code>doTaskTwoCallback()</code>，<code>doTaskThreeCallback()</code> 三个方法，对原有的三个方法进行包装。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCallBackTask</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">doTaskOneCallback</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskOne();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务一完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">doTaskTwoCallback</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskTwo();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务二完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">doTaskThreeCallback</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskThree();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务三完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>AsyncCallBackTask</code> 对象，并在测试用例中执行 <code>doTaskOneCallback()</code>，<code>doTaskTwoCallback()</code>，<code>doTaskThreeCallback()</code> 三个方法。循环调用 <code>Future</code> 的 <code>isDone()</code> 方法等待三个 <strong>并发任务</strong> 执行完成，记录最终执行时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCallBackTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncCallBackTask task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncCallbackTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        Future&lt;String&gt; task1 = task.doTaskOneCallback();</span><br><span class="line">        Future&lt;String&gt; task2 = task.doTaskTwoCallback();</span><br><span class="line">        Future&lt;String&gt; task3 = task.doTaskThreeCallback();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三个任务都调用完成，退出循环等待</span></span><br><span class="line">        <span class="keyword">while</span> (!task1.isDone() || !task2.isDone() || !task3.isDone()) &#123;</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"任务全部完成，总耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看都做了哪些改变：</p><ul><li>在测试用例一开始记录开始时间；</li><li>在调用三个异步函数的时候，返回Future<string>类型的结果对象；</string></li><li>在调用完三个异步函数之后，开启一个循环，根据返回的Future<string>对象来判断三个异步函数是否都结束了。若都结束，就结束循环；若没有都结束，就等1秒后再判断。</string></li><li>跳出循环之后，根据结束时间 - 开始时间，计算出三个任务并发执行的总耗时。</li></ul><p>执行一下上述的单元测试，可以看到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">开始做任务三</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：4882毫秒</span><br><span class="line">完成任务三，耗时：6484毫秒</span><br><span class="line">完成任务一，耗时：8748毫秒</span><br><span class="line">任务全部完成，总耗时：9043毫秒</span><br></pre></td></tr></table></figure><p>可以看到，通过 <strong>异步调用</strong>，让任务一、任务二、任务三 <strong>并发执行</strong>，有效的 <strong>减少</strong> 了程序的 <strong>运行总时间</strong>。</p><h2 id="5-定义线程池"><a href="#5-定义线程池" class="headerlink" title="5. 定义线程池"></a>5. 定义线程池</h2><p>在上述操作中，创建一个 <strong>线程池配置类</strong> <code>TaskConfiguration</code> ，并配置一个 <strong>任务线程池对象</strong> <code>taskExecutor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"taskExecutor-"</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们通过使用 <code>ThreadPoolTaskExecutor</code> 创建了一个 <strong>线程池</strong>，同时设置了以下这些参数：</p><table><thead><tr><th style="text-align:left">线程池属性</th><th style="text-align:left">属性的作用</th><th style="text-align:center">设置初始值</th></tr></thead><tbody><tr><td style="text-align:left">核心线程数</td><td style="text-align:left">线程池创建时候初始化的线程数</td><td style="text-align:center">10</td></tr><tr><td style="text-align:left">最大线程数</td><td style="text-align:left">线程池最大的线程数，只有在缓冲队列满了之后，才会申请超过核心线程数的线程</td><td style="text-align:center">20</td></tr><tr><td style="text-align:left">缓冲队列</td><td style="text-align:left">用来缓冲执行任务的队列</td><td style="text-align:center">200</td></tr><tr><td style="text-align:left">允许线程的空闲时间</td><td style="text-align:left">当超过了核心线程之外的线程，在空闲时间到达之后会被销毁</td><td style="text-align:center">60秒</td></tr><tr><td style="text-align:left">线程池名的前缀</td><td style="text-align:left">可以用于定位处理任务所在的线程池</td><td style="text-align:center">taskExecutor-</td></tr><tr><td style="text-align:left">线程池对拒绝任务的处理策略</td><td style="text-align:left">这里采用CallerRunsPolicy策略，当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务</td><td style="text-align:center">CallerRunsPolicy</td></tr></tbody></table><ul><li>创建 <code>AsyncExecutorTask</code>类，三个任务的配置和 <code>AsyncTask</code> 一样，不同的是 <code>@Async</code> 注解需要指定前面配置的 <strong>线程池的名称</strong> <code>taskExecutor</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExecutorTask</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskOne();</span><br><span class="line">        out.println(<span class="string">"任务一，当前线程："</span> + currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskTwo();</span><br><span class="line">        out.println(<span class="string">"任务二，当前线程："</span> + currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskThree();</span><br><span class="line">        out.println(<span class="string">"任务三，当前线程："</span> + currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>AsyncExecutorTask</code> 对象，并在测试用例中执行 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExecutorTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncExecutorTask task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncExecutorTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        task.doTaskOne();</span><br><span class="line">        task.doTaskTwo();</span><br><span class="line">        task.doTaskThree();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">30</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下上述的 <strong>单元测试</strong>，可以看到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">开始做任务三</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：3905毫秒</span><br><span class="line">任务二，当前线程：taskExecutor-2</span><br><span class="line">完成任务一，耗时：6184毫秒</span><br><span class="line">任务一，当前线程：taskExecutor-1</span><br><span class="line">完成任务三，耗时：9737毫秒</span><br><span class="line">任务三，当前线程：taskExecutor-3</span><br></pre></td></tr></table></figure><p>执行上面的单元测试，观察到 <strong>任务线程池</strong> 的 <strong>线程池名的前缀</strong> 被打印，说明 <strong>线程池</strong> 成功执行 <strong>异步任务</strong>！</p><h2 id="6-优雅地关闭线程池"><a href="#6-优雅地关闭线程池" class="headerlink" title="6. 优雅地关闭线程池"></a>6. 优雅地关闭线程池</h2><blockquote><p>由于在应用关闭的时候异步任务还在执行，导致类似 <strong>数据库连接池</strong> 这样的对象一并被 <strong>销毁了</strong>，当 <strong>异步任务</strong> 中对 <strong>数据库</strong> 进行操作就会出错。</p></blockquote><p>解决方案如下，重新设置线程池配置对象，新增线程池 <code>setWaitForTasksToCompleteOnShutdown()</code> 和 <code>setAwaitTerminationSeconds()</code> 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadPoolTaskScheduler executor = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">    executor.setPoolSize(<span class="number">20</span>);</span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">"taskExecutor-"</span>);</span><br><span class="line">    executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">    executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>setWaitForTasksToCompleteOnShutdown(true):</strong> 该方法用来设置 <strong>线程池关闭</strong> 的时候 <strong>等待</strong> 所有任务都完成后，再继续 <strong>销毁</strong> 其他的 <code>Bean</code>，这样这些 <strong>异步任务</strong> 的 <strong>销毁</strong> 就会先于 <strong>数据库连接池对象</strong> 的销毁。</p></li><li><p><strong>setAwaitTerminationSeconds(60):</strong> 该方法用来设置线程池中 <strong>任务的等待时间</strong>，如果超过这个时间还没有销毁就 <strong>强制销毁</strong>，以确保应用最后能够被关闭，而不是阻塞住。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了在 <code>Spring Boot</code> 中如何使用 <code>@Async</code> 注解配置 <strong>异步任务</strong>、<strong>异步回调任务</strong>，包括结合 <strong>任务线程池</strong> 的使用，以及如何 <strong>正确</strong> 并 <strong>优雅</strong> 地关闭 <strong>任务线程池</strong>。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;异步调用&lt;/strong&gt; 对应的是 &lt;strong&gt;同步调用&lt;/strong&gt;，&lt;strong&gt;同步调用&lt;/strong&gt; 指程序按照 &lt;strong&gt;定义顺序&lt;/strong&gt; 依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行；&lt;strong&gt;异步调用&lt;/strong&gt; 指程序在顺序执行时，&lt;strong&gt;不等待&lt;/strong&gt; 异步调用的语句 &lt;strong&gt;返回结果&lt;/strong&gt; 就执行后面的程序。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="异步" scheme="https://ostenant.coding.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(二) - 全局异常处理和测试</title>
    <link href="https://ostenant.coding.me/2018/06/16/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%BA%8C)%20-%20%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%92%8C%E6%B5%8B%E8%AF%95/"/>
    <id>https://ostenant.coding.me/2018/06/16/实战Spring Boot 2.0系列(二) - 全局异常处理和测试/</id>
    <published>2018-06-16T07:35:00.000Z</published>
    <updated>2018-06-18T01:57:50.010Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常 <code>web</code> 开发中发生了异常，往往需要通过一个统一的 <strong>异常处理</strong>，来保证客户端能够收到友好的提示。本文将会介绍 <code>Spring Boot</code> 中的 <strong>全局统一异常处理</strong>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBootAll.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-global-exception-handle</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    compile(<span class="string">'org.projectlombok:lombok'</span>)</span><br><span class="line">    compile(<span class="string">'org.apache.commons:commons-lang3:3.1'</span>)</span><br><span class="line">    compile(<span class="string">'com.google.guava:guava:19.0'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-配置入口类"><a href="#2-配置入口类" class="headerlink" title="2. 配置入口类"></a>2. 配置入口类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-配置实体类"><a href="#3-配置实体类" class="headerlink" title="3. 配置实体类"></a>3. 配置实体类</h2><p>首先安装 <code>Intellij Idea</code> 的 <code>lombok</code> 插件，这里不做详细的介绍。切记，需要在设置中将 <code>Enable annotation processing</code> 勾选上，否则 <strong>测试代码</strong> 在 <strong>编译时</strong> 会无法对 <code>lombok</code> 插件配置的 <strong>注解</strong> 进行处理。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Annotation_Process.png" alt=""></p><p>使用 <code>lombok</code> 工具提供的 <strong>注解</strong> 配置一个实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String accountName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-配置异常响应实体"><a href="#4-配置异常响应实体" class="headerlink" title="4. 配置异常响应实体"></a>4. 配置异常响应实体</h2><p><code>ErrorMessage</code> 实体用于记录具体的 <strong>异常信息</strong>，并响应 <strong>客户端</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorMessage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer OK = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ERROR = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-配置相关异常类"><a href="#5-配置相关异常类" class="headerlink" title="5. 配置相关异常类"></a>5. 配置相关异常类</h2><p>SessionNotFoundException.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionNotFoundException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionNotFoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setMessage(<span class="string">"Session is not found!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionNotFoundException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NullOrEmptyException.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullOrEmptyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullOrEmptyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setMessage(<span class="string">"Parameter is null or empty!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullOrEmptyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IllegalPropertiesException.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IllegalPropertiesException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalPropertiesException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setMessage(<span class="string">"Prop is illegal!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalPropertiesException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        setMessage(String.format(<span class="string">"Prop: %s is illegal!"</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-配置全局异常通知"><a href="#6-配置全局异常通知" class="headerlink" title="6. 配置全局异常通知"></a>6. 配置全局异常通知</h2><p>从 <code>spring 3.2</code> 开始，新增了 <code>@ControllerAdvice</code> 注解，可以用于定义 <code>@ExceptionHandler</code>，并应用到配置了 <code>@RequestMapping</code> 的控制器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(SessionNotFoundException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">sessionNotFoundExceptionHandler</span><span class="params">(HttpServletRequest request, SessionNotFoundException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullOrEmptyException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">nullOrEmptyExceptionHandler</span><span class="params">(HttpServletRequest request, NullOrEmptyException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(IllegalPropertiesException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">illegalPropExceptionHandler</span><span class="params">(HttpServletRequest request, IllegalPropertiesException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">exceptionHandler</span><span class="params">(HttpServletRequest request, Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ErrorMessage&lt;String&gt; <span class="title">handleErrorInfo</span><span class="params">(HttpServletRequest request, String message, Exception exception)</span> </span>&#123;</span><br><span class="line">        ErrorMessage&lt;String&gt; errorMessage = <span class="keyword">new</span> ErrorMessage&lt;&gt;();</span><br><span class="line">        errorMessage.setMessage(message);</span><br><span class="line">        errorMessage.setCode(ErrorMessage.ERROR);</span><br><span class="line">        errorMessage.setData(message);</span><br><span class="line">        errorMessage.setUrl(request.getRequestURL().toString());</span><br><span class="line">        <span class="keyword">return</span> errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码指定了 <code>3</code> 个 <strong>特定</strong> 的异常处理器和 <code>1</code> 个 <strong>默认</strong> 的异常处理器。当请求处理出现异常时，会根据 <strong>异常处理器</strong> 的 <strong>配置顺序</strong> 依次尝试 <strong>异常匹配</strong> 和 <strong>处理</strong>。</p><p>当异常不在 SessionNotFoundException、NullOrEmptyException、IllegalPropertiesException 中时，<code>Spring</code> 会委托 <strong>默认</strong> 的 <code>exceptionHandler</code> 进行处理。</p><h2 id="7-配置控制器"><a href="#7-配置控制器" class="headerlink" title="7. 配置控制器"></a>7. 配置控制器</h2><p>根据请求数据的差异，控制器能覆盖以上 <code>3</code> 种异常处理路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; save(HttpServletRequest request, HttpSession session) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String sessionId = (String) session.getAttribute(<span class="string">"sessionId"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sessionId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SessionNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String userPlainText = request.getParameter(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(userPlainText) || StringUtils.equalsIgnoreCase(<span class="string">"&#123;&#125;"</span>, userPlainText)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullOrEmptyException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        User user = objectMapper.readValue(userPlainText, User.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalPropertiesException(<span class="string">"username"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getAccountName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalPropertiesException(<span class="string">"accountName"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">"Successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-配置Mock测试类"><a href="#8-配置Mock测试类" class="headerlink" title="8. 配置Mock测试类"></a>8. 配置Mock测试类</h2><p><code>Spring Mock</code> 的相关配置这里就不详细介绍了，以下测试类覆盖了 <code>UserController</code> 的所有执行路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"UserControllerTester"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    <span class="keyword">private</span> MockHttpSession session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImmutableMap&lt;Long, Pair&lt;String, String&gt;&gt; map = <span class="keyword">new</span> ImmutableMap.Builder&lt;Long, Pair&lt;String, String&gt;&gt;()</span><br><span class="line">            .put(<span class="number">0x00001L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">""</span>))</span><br><span class="line">            .put(<span class="number">0x00002L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;&#125;"</span>))</span><br><span class="line">            .put(<span class="number">0x00003L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;\"username\": \"\", \"accountName\": \"\"&#125;"</span>))</span><br><span class="line">            .put(<span class="number">0x00004L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;\"username\": \"Harrison\", \"accountName\": \"\"&#125;"</span>))</span><br><span class="line">            .put(<span class="number">0x00005L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;\"username\": \"Harrison\", \"accountName\": \"ostenant\"&#125;"</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> singleRunner = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (singleRunner) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mockMvc = MockMvcBuilders.standaloneSetup(userController).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">        &#125;</span><br><span class="line">        session = <span class="keyword">new</span> MockHttpSession();</span><br><span class="line">        session.setAttribute(<span class="string">"sessionId"</span>, StringUtils.replace(UUID.randomUUID().toString(), <span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">        log.debug(<span class="string">"sessionId: &#123;&#125;"</span>, session.getAttribute(<span class="string">"sessionId"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试SessionNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSessionNotFoundException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        session.clearAttributes();</span><br><span class="line">        <span class="comment">// 模拟发送请求</span></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00005L</span>).getKey(), map.get(<span class="number">0x00005L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试NullOrEmptyException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNullOrEmptyException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00001L</span>).getKey(), map.get(<span class="number">0x00001L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00002L</span>).getKey(), map.get(<span class="number">0x00002L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试IllegalPropException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIllegalPropException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00003L</span>).getKey(), map.get(<span class="number">0x00003L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00004L</span>).getKey(), map.get(<span class="number">0x00004L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试正常运行的情况</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNormal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00005L</span>).getKey(), map.get(<span class="number">0x00005L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-测试结果"><a href="#9-测试结果" class="headerlink" title="9. 测试结果"></a>9. 测试结果</h2><p>批量运行测试，测试结果如下，所有的测试用例全部通过。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Spring_Boot_Exception_Handler_Result.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>使用 <code>@ControllerAdvice</code> 处理异常也有一定的 <strong>局限性</strong>。只有进入 <code>Controller</code> 层的错误，才会由 <code>@ControllerAdvice</code> 处理。<strong>拦截器</strong> 抛出的错误，以及 <strong>访问错误地址</strong> 的情况 <code>@ControllerAdvice</code> 处理不了，由 <code>Spring Boot</code> 默认的 <strong>异常处理机制</strong> 处理。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在日常 &lt;code&gt;web&lt;/code&gt; 开发中发生了异常，往往需要通过一个统一的 &lt;strong&gt;异常处理&lt;/strong&gt;，来保证客户端能够收到友好的提示。本文将会介绍 &lt;code&gt;Spring Boot&lt;/code&gt; 中的 &lt;strong&gt;全局统一异常处理&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(一) - 使用Gradle构建Docker镜像</title>
    <link href="https://ostenant.coding.me/2018/06/14/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%B8%80)%20-%20%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F/"/>
    <id>https://ostenant.coding.me/2018/06/14/实战Spring Boot 2.0系列(一) - 使用Gradle构建Docker镜像/</id>
    <published>2018-06-14T11:35:00.000Z</published>
    <updated>2018-06-21T05:42:28.292Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常我们使用 <code>Dockerfile</code> 来构建项目的 <code>Docker</code> 镜像。但是也有使用 <code>gradle</code> 在编译项目的时候一起把镜像给 <strong>构建</strong> 并 <strong>上传</strong> 的需求。本文将会讲解如何使用 <code>gradle</code> 编写并配置 <code>Dockerfile</code> 并生成 <strong>镜像</strong>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBootAll.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-gradle-for-docker</code>，创建时添加一个 <code>web</code> 依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'1.0'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-配置入口类"><a href="#2-配置入口类" class="headerlink" title="2. 配置入口类"></a>2. 配置入口类</h2><p>为了方便容器部署的测试，在 <code>Spring Boot</code> 启动类上配置一个控制器，响应当前的系统时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd hh:mm:ss"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">retrieveTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-添加插件"><a href="#3-添加插件" class="headerlink" title="3. 添加插件"></a>3. 添加插件</h2><p>这里使用 <a href="https://github.com/Transmode/gradle-docker" target="_blank" rel="noopener"><code>gradle-docker</code></a> <strong>插件</strong> 来实现 <code>docker</code> 镜像构建。这样，我们就可以直接在 <code>Gradle</code> 的脚本里配置 <code>Dockerfile</code> 达到 <strong>构建镜像</strong> 功能的目的。</p><p><code>gradle-docker</code> 插件已经被上传到 <code>jCenter</code> 和 <code>MavenCentral</code> 上。所以只需要在 <code>dependencies</code> 添加依赖 <code>se.transmode.gradle:gradle-docker:1.2</code> 就能使用 <code>docker</code> 插件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">        classpath(<span class="string">"se.transmode.gradle:gradle-docker:1.2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-应用插件"><a href="#4-应用插件" class="headerlink" title="4. 应用插件"></a>4. 应用插件</h2><p>添加以下代码到 <code>build.gradle</code>中</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'docker'</span></span><br></pre></td></tr></table></figure><p>如果添加了 <code>application</code> 插件的话，默认 <code>gradle-docker</code> 插件会添加一个 <code>distDocker</code> 的 <code>gradle task</code>，用来构建一个 <strong>包含所有程序文件</strong> 的 <code>docker</code> 镜像。</p><h2 id="5-配置镜像构建信息"><a href="#5-配置镜像构建信息" class="headerlink" title="5. 配置镜像构建信息"></a>5. 配置镜像构建信息</h2><h3 id="5-1-配置group"><a href="#5-1-配置group" class="headerlink" title="5.1. 配置group"></a>5.1. 配置group</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br></pre></td></tr></table></figure><h3 id="5-2-配置镜像名称和版本号"><a href="#5-2-配置镜像名称和版本号" class="headerlink" title="5.2. 配置镜像名称和版本号"></a>5.2. 配置镜像名称和版本号</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    baseName = <span class="string">"spring-boot-gradle-for-docker"</span></span><br><span class="line">    version = <span class="number">1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中镜像的 <code>tag</code> 默认的构成为：<strong>项目组/应用名称:版本号</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag = <span class="string">"$&#123;project.group&#125;/$&#123;applicationName&#125;:$&#123;tagVersion&#125;"</span></span><br></pre></td></tr></table></figure><ul><li><p>project.group：标准的 <code>gradle</code> 属性，如果不进行定义，插件默认会 <strong>省略</strong> <code>${project.group}</code> 这个属性。</p></li><li><p>applicationName：应用被容器化时的 <strong>名称</strong>。</p></li><li><p>tagVersion：可选属性，会作为镜像的 <strong>标签</strong>。默认值为 <code>project.version</code>，如果未指定 <code>project.version</code>，则使用 <code>latest</code> 作为标记。</p></li></ul><h3 id="5-3-配置docker构建基础信息"><a href="#5-3-配置docker构建基础信息" class="headerlink" title="5.3. 配置docker构建基础信息"></a>5.3. 配置docker构建基础信息</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">distDocker &#123;</span><br><span class="line">    baseImage = <span class="string">"openjdk"</span></span><br><span class="line">    maintainer = <span class="string">"harrison"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>baseImage</code> 相当于 <code>Dockerfile</code> 中声明的 <code>FROM</code>。声明了在 <strong>构建镜像</strong> 是基于的 <code>Image</code>，<code>maintainer</code> 相当于 <code>MAINTAINER</code> ，声明了 <strong>镜像作者</strong>。如果声明了 <code>registry</code> 地址，插件在 <strong>镜像射生成后</strong> 可以自动 <code>push</code> 到该地址。其他的配置还包括 <code>docker hub</code> 的 <strong>地址</strong>、<strong>用户名</strong> 和 <strong>密码</strong>。</p><p>更详细的配置案例如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker &#123;</span><br><span class="line">    baseImage <span class="string">'openjdk'</span></span><br><span class="line">    maintainer <span class="string">'harrison'</span></span><br><span class="line">    useApi <span class="literal">true</span></span><br><span class="line">    hostUrl <span class="string">'http://myserver:4243'</span></span><br><span class="line">    apiUsername <span class="string">'user'</span></span><br><span class="line">    apiPassword <span class="string">'password'</span></span><br><span class="line">    apiEmail <span class="string">'me@mycompany.com'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-添加task任务"><a href="#6-添加task任务" class="headerlink" title="6. 添加task任务"></a>6. 添加task任务</h2><p>完成了基本的配置，我们还需要添加一个 <code>task</code> 用来在 <code>gradle</code> 编译的时候 <strong>执行镜像构建</strong>。</p><p>插件提供了一些 <strong>转换方法</strong>，用来指代 <code>Dockerfile</code> 中的 <strong>关键词语法</strong>，如下表，可以按照需求对照着来：</p><table><thead><tr><th style="text-align:left">Dockerfile关键词</th><th style="text-align:left">gradle task方法</th></tr></thead><tbody><tr><td style="text-align:left">ADD</td><td style="text-align:left">addFile(Closure copySpec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">addFile(String source, String dest)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">addFile(File source, String dest)</td></tr><tr><td style="text-align:left">CMD</td><td style="text-align:left">defaultCommand(List cmd)</td></tr><tr><td style="text-align:left">ENTRYPOINT</td><td style="text-align:left">entryPoint(List entryPoint)</td></tr><tr><td style="text-align:left">ENV</td><td style="text-align:left">setEnvironment(String key, String val)</td></tr><tr><td style="text-align:left">EXPOSE</td><td style="text-align:left">exposePort(Integer port)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">exposePort(String port)</td></tr><tr><td style="text-align:left">RUN</td><td style="text-align:left">runCommand(String cmd)</td></tr><tr><td style="text-align:left">USER</td><td style="text-align:left">switchUser(String userNameOrUid)</td></tr><tr><td style="text-align:left">VOLUME</td><td style="text-align:left">volume(String… paths)</td></tr><tr><td style="text-align:left">WORKDIR</td><td style="text-align:left">workingDir(String dir)</td></tr></tbody></table><p>下面是本项目的 <code>taskBuilder</code> 的任务配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task dockerBuilder(<span class="string">type:</span> Docker) &#123;</span><br><span class="line">    applicationName = jar.baseName</span><br><span class="line">    tagVersion = jar.version</span><br><span class="line">    volume(<span class="string">'/tmp'</span>)</span><br><span class="line">    addFile(<span class="string">"$&#123;jar.baseName&#125;-$&#123;jar.version&#125;.jar"</span>, <span class="string">"app.jar"</span>)</span><br><span class="line">    entryPoint([<span class="string">"java"</span>, <span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>, <span class="string">"-jar"</span>, <span class="string">'app.jar'</span>])</span><br><span class="line">    exposePort(<span class="number">8080</span>)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from jar</span><br><span class="line">            into stageDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建完成y以后，项目根目录的 <code>build/docker</code> 文件夹下面会出现 <code>Dockerfile</code> 和 <code>spring-boot-gradle-for-docker-1.0.jar</code> 文件。其中，以上的 <code>task</code> 等同于以下的 <code>Dockerfile</code>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> aglover/java8-pier</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/tmp"</span>]</span></span><br><span class="line"><span class="bash">ADD spring-boot-gradle-for-docker-1.0.jar app.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>, <span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>, <span class="string">"-jar"</span>, <span class="string">"app.jar"</span>]</span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br></pre></td></tr></table></figure><p>如果觉的在 <code>task</code> 中编写 <code>Dockerfile</code> <strong>替换脚本</strong> 非常别扭，也可以直接在 <code>task</code> 中指定 <code>Dockfile</code> 的 <strong>文件路径</strong>，直接使用已有的文件来生成镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task buildDocker(type: Docker) &#123;</span><br><span class="line">    applicationName = jar.baseName</span><br><span class="line">    tagVersion = jar.version</span><br><span class="line">    dockerfile = file(<span class="string">'Dockerfile'</span>)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        <span class="keyword">copy</span><span class="bash"> &#123;</span></span><br><span class="line"><span class="bash">            from jar</span></span><br><span class="line"><span class="bash">            into stageDir</span></span><br><span class="line"><span class="bash">        &#125;</span></span><br><span class="line"><span class="bash">    &#125;</span></span><br><span class="line"><span class="bash">&#125;</span></span><br></pre></td></tr></table></figure><p>通过 <code>file()</code> 指定 <code>task</code> 使用位于 <strong>项目根目录</strong> 的 <code>Dockerfile</code> 来生产镜像。</p><h2 id="7-编译并构建Docker镜像"><a href="#7-编译并构建Docker镜像" class="headerlink" title="7. 编译并构建Docker镜像"></a>7. 编译并构建Docker镜像</h2><p>进入项目根目录，运行 <code>gradle</code> 命令进行打包构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew clean build dockerBuilder --info</span><br></pre></td></tr></table></figure><p><code>gradle</code> 首先会运行 <strong>本地测试</strong>，然后进行 <strong>项目打包</strong>，进一步根据 <code>docker-gradle</code> 插件进行 <strong>镜像构建</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/gradle_build_docker_image_2.png" alt=""></p><p>等待出现 <code>BUILD SUCCESSFUL</code> 就表明任务运行成功。可以观察到镜像的名称为</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.ostenant.springboot.sample/spring-boot-gradle-<span class="keyword">for</span>-<span class="string">docker:</span><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>运行 <code>docker images</code> 查看本地镜像，进一步验证镜像构建成功。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/gradle_bulld_docker_images.png" alt=""></p><p>下面给出 <code>build.gradle</code> <strong>完整的</strong> 配置文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">        classpath(<span class="string">"se.transmode.gradle:gradle-docker:1.2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'docker'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'1.0'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line">targetCompatibility = <span class="number">1.8</span></span><br><span class="line">mainClassName = <span class="string">"io.ostenant.springboot.sample.Application"</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    baseName <span class="string">'spring-boot-gradle-for-docker'</span></span><br><span class="line">    version <span class="string">'1.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">distDocker &#123;</span><br><span class="line">    baseImage <span class="string">'openjdk'</span></span><br><span class="line">    maintainer <span class="string">'harrison'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task dockerBuilder(<span class="string">type:</span> Docker) &#123;</span><br><span class="line">    applicationName = jar.baseName</span><br><span class="line">    tagVersion = jar.version</span><br><span class="line">    volume(<span class="string">'/tmp'</span>)</span><br><span class="line">    addFile(<span class="string">"$&#123;jar.baseName&#125;-$&#123;jar.version&#125;.jar"</span>, <span class="string">"app.jar"</span>)</span><br><span class="line">    entryPoint([<span class="string">"java"</span>, <span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>, <span class="string">"-jar"</span>, <span class="string">'app.jar'</span>])</span><br><span class="line">    exposePort(<span class="number">8080</span>)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from jar</span><br><span class="line">            into stageDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-使用镜像启动容器"><a href="#8-使用镜像启动容器" class="headerlink" title="8. 使用镜像启动容器"></a>8. 使用镜像启动容器</h2><p>运行如下命令，根据镜像启动容器，对外暴露 <code>8080</code> 访问端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name gradle-boot -p 8080:8080 io.ostenant.springboot.sample/spring-boot-gradle-for-docker:1.0</span><br></pre></td></tr></table></figure><p>访问 <code>http://127.0.0.1:8080/</code> ，页面会输出当前系统时间，如图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/gradle_build_docker_image_2_web.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>gradle-docker</code> 插件还提供了配置 <strong>镜像仓库地址</strong>、配置使用 <code>Docker Remote Api</code> 和 <code>Docker Hub</code> 等用法，可以参考该项目的 <code>GitHub</code> 地址来进行配置使用：<br><a href="https://github.com/Transmode/gradle-docker" target="_blank" rel="noopener">https://github.com/Transmode/gradle-docker</a>。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通常我们使用 &lt;code&gt;Dockerfile&lt;/code&gt; 来构建项目的 &lt;code&gt;Docker&lt;/code&gt; 镜像。但是也有使用 &lt;code&gt;gradle&lt;/code&gt; 在编译项目的时候一起把镜像给 &lt;strong&gt;构建&lt;/strong&gt; 并 &lt;strong&gt;上传&lt;/strong&gt; 的需求。本文将会讲解如何使用 &lt;code&gt;gradle&lt;/code&gt; 编写并配置 &lt;code&gt;Dockerfile&lt;/code&gt; 并生成 &lt;strong&gt;镜像&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
      <category term="Gradle" scheme="https://ostenant.coding.me/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>微服务的反模式和陷阱(三) - 共享反模式</title>
    <link href="https://ostenant.coding.me/2018/06/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%99%B7%E9%98%B1(%E4%B8%89)%20-%20%E5%85%B1%E4%BA%AB%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ostenant.coding.me/2018/06/12/微服务的反模式和陷阱(三) - 共享反模式/</id>
    <published>2018-06-12T11:40:00.000Z</published>
    <updated>2018-06-18T01:58:34.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微服务是一种 <strong>无共享的架构</strong>，另一层意思是 <strong>“尽量不共享”</strong> 模式(<code>share-as-little-as-possible</code>)， 因为总有一些 <strong>代码</strong> 会在微服务之间共享。然后如果太过频繁的使用 <strong>共享代码</strong> 最终会出现 <strong>依赖噩梦</strong>，这就是共享反模式。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="共享反模式"><a href="#共享反模式" class="headerlink" title="共享反模式"></a>共享反模式</h2><p>微服务是一种 <strong>无共享的架构</strong>，另一层意思是 <strong>“尽量不共享”</strong> 模式(<code>share-as-little-as-possible</code>)， 因为总有一些 <strong>代码</strong> 会在微服务之间共享。比如 <strong>不提供一个身份验证的微服务</strong>，而是将身份验证的代码打包成一个 <code>jar</code> 文件：<code>security.jar</code>，保证其它服务都能使用。如果安全检查是 <strong>服务级别</strong> 的功能，每个服务接收到请求都会检查安全性，这种方式可以很好的提高性能。</p><p>然后如果太过频繁的使用最终会出现 <strong>依赖噩梦</strong>，如图 <code>1-1</code> 所示，其中每个服务都依赖于 <strong>多个自定义共享库</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Non_Share1.png" alt=""></p><p>这种共享级别不仅破坏了每个 <strong>服务的限界上下文</strong>，而且还引入了几个问题，包括整体 <strong>可靠性</strong>、<strong>变更控制</strong>、<strong>可测试性</strong> 和 <strong>部署能力</strong>。</p><h3 id="1-过多依赖"><a href="#1-过多依赖" class="headerlink" title="1. 过多依赖"></a>1. 过多依赖</h3><p>在面向对象的软件开发过程中，经常会遇到 <strong>共享</strong> 的问题，特别是从 <strong>单一分层</strong> 结构迁移到 <strong>微服务结构</strong> 时，图 <code>1-2</code> 展示 <strong>抽象类和共享</strong>，它们最终在多数单块分层体系结构中共享。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Non_Share2.png" alt=""></p><p><strong>微服务架构</strong> 的主要目标就是共享要尽可能的少，这有助于维护服务的 <strong>限界上下文</strong>，使我们能够快速的 <strong>测试</strong> 和 <strong>布署</strong>。服务之间 <strong>依赖越强</strong>，<strong>服务隔离</strong> 也就 <strong>越困难</strong>，因此也就越难单独进行 <strong>测试</strong> 和 <strong>布署</strong>。</p><p>创建 <strong>抽象类</strong> 和 <strong>接口</strong> 是 <strong>面向对象编程</strong> 的最重要做法，那我们如何来处理数百个服务共享的代码？</p><h3 id="2-共享代码的技术"><a href="#2-共享代码的技术" class="headerlink" title="2. 共享代码的技术"></a>2. 共享代码的技术</h3><p>要避免这个 <strong>反模式</strong> 的最好办法就是 <strong>代码不共享</strong>，但是实际工作中总会有一些代码需要进行共享，那这些共享代码应该放到哪里呢？</p><p>图 <code>1-3</code> 给了四个最基本的技术：</p><ul><li>共享项目</li><li>共享库</li><li>复制</li><li>服务合并</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Non_Share3.png" alt=""></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="">微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</a></li><li><a href="">微服务的反模式和陷阱(二) - 超时反模式</a></li><li><a href="">微服务的反模式和陷阱(三) - 共享反模式</a></li><li><a href="">微服务的反模式和陷阱(四) - 到达报告反模式</a></li><li><a href="">微服务的反模式和陷阱(五) - 沙粒陷阱</a></li><li><a href="">微服务的反模式和陷阱(六) - 无因的开发者陷阱</a></li><li><a href="">微服务的反模式和陷阱(七) - 随大流陷阱</a></li><li><a href="">微服务的反模式和陷阱(八) - 其它架构模式</a></li><li><a href="">微服务的反模式和陷阱(九) - 静态契约陷阱</a></li><li><a href="">微服务的反模式和陷阱(十) - 通信协议使用的陷阱</a></li></ol><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;微服务是一种 &lt;strong&gt;无共享的架构&lt;/strong&gt;，另一层意思是 &lt;strong&gt;“尽量不共享”&lt;/strong&gt; 模式(&lt;code&gt;share-as-little-as-possible&lt;/code&gt;)， 因为总有一些 &lt;strong&gt;代码&lt;/strong&gt; 会在微服务之间共享。然后如果太过频繁的使用 &lt;strong&gt;共享代码&lt;/strong&gt; 最终会出现 &lt;strong&gt;依赖噩梦&lt;/strong&gt;，这就是共享反模式。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="微服务" scheme="https://ostenant.coding.me/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="反模式" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微服务的反模式和陷阱(二) - 超时反模式</title>
    <link href="https://ostenant.coding.me/2018/06/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%99%B7%E9%98%B1(%E4%BA%8C)%20-%20%E8%B6%85%E6%97%B6%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ostenant.coding.me/2018/06/11/微服务的反模式和陷阱(二) - 超时反模式/</id>
    <published>2018-06-11T11:40:00.000Z</published>
    <updated>2018-07-05T12:46:16.012Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分布式应用的挑战之一就是如何管理 <strong>远程服务</strong> 的 <strong>可用性</strong> 和它们的 <strong>响应</strong>。虽然服务可用性和服务响应都涉及到服务的通信，但它们是两个完全不同的东西。<strong>服务可用性</strong> 是服务消费者 <strong>连接服务</strong> 并能够 <strong>发送请求</strong> 的能力，<strong>服务响应</strong> 则关注服务的 <strong>响应时间</strong>。这里就涉及微服务中的 <strong>超时反模式</strong>。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="超时反模式"><a href="#超时反模式" class="headerlink" title="超时反模式"></a>超时反模式</h2><p>微服务是一种 <strong>分布式的架构</strong>，它所有的组件（也就是服务）会被部署为单独的应用程序，并通过某种 <strong>远程访问协议</strong> 进行通讯。分布式应用的挑战之一就是如何管理 <strong>远程服务</strong> 的 <strong>可用性</strong> 和它们的 <strong>响应</strong>。虽然服务可用性和服务响应都涉及到服务的通信，但它们是两个完全不同的东西。<strong>服务可用性</strong> 是服务消费者 <strong>连接服务</strong> 并能够 <strong>发送请求</strong> 的能力，<strong>服务响应</strong> 则关注服务的 <strong>响应时间</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Timeout1.png" alt="图1-1"></p><p>如图 <code>1-1</code> 的所示，如果此时服务消费者 <strong>无法连接</strong> 到服务提供者的时候，通过会在毫秒级的时间里得到通知和反馈。这时候 <strong>服务消费者</strong> 可以选择是 <strong>直接返回错误信息</strong> 还是 <strong>进行重试</strong>。但是如果服务提供者接收了请求却 <strong>不进行响应</strong> 该怎么办？在这种情况下服务消费者可以选择 <strong>无限期等待</strong> 或者 <strong>设置超时时间</strong>，使用超时时间看起来是个好办法，但是它会导致 <strong>超时反模式</strong>。</p><h3 id="1-使用超时"><a href="#1-使用超时" class="headerlink" title="1. 使用超时"></a>1. 使用超时</h3><p>你可能感觉非常困惑，难道设置一个超时时间不是一件好事吗？在大部分的情况下超时时间的错误设置都会带来问题。比如当你上网购物的时候，你提交了订单，服务一直在处理没有返回，你在超时的时候再提交订单，显然服务器需要更复杂的逻辑来处理重复提交订单的问题。</p><p>那么超时时间设置多少合适呢？</p><ul><li>第一种是基于 <strong>数据库的超时</strong> 来计算服务的超时时间。</li><li>第二种是计算 <strong>负载下最长的处理时间</strong>，把它乘以 <code>2</code> 作为 <strong>超时时间</strong>。</li></ul><p>在图 <code>2-2</code> 中，通常的情况下 <strong>平均响应时间</strong> 是 <code>2</code> 秒，在 <strong>高并发</strong> 的情况下 <strong>最长时间</strong> 是 <code>5</code> 秒，因为可以使用加倍技术服务的超时时间设置为 <code>10</code> 秒。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_timeout2.png" alt="图1-2"></p><p>图 <code>1-2</code> 的解决方案似乎看起来很完美，它使每一个服务消费者必须等待 <code>10</code> 秒，其实只是为了 <strong>判断服务没有响应</strong>。在大多数情况下，用户在等待提交按钮或放弃和关闭屏幕之前不会等待超过 <code>2</code> 到 <code>3</code> 秒。那就必须要有更好的办法来解决。</p><h2 id="2-使用断路器模式"><a href="#2-使用断路器模式" class="headerlink" title="2. 使用断路器模式"></a>2. 使用断路器模式</h2><p>与上面 <strong>超时</strong> 的方法相比，使用 <strong>断路器</strong> 的方式更为稳妥。这种设计模式就像家里的电器的保险丝一样，当负载过大，或者电路发生故障或异常时，电流会不断升高，为防止升高的电流有可能损坏电路中的某些重要器件或贵重器件，烧毁电路甚至造成火灾。保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，从而起到保护电路安全运行的作用。</p><p>图 <code>1-3</code> 说明了 <strong>断路器模式</strong> 是如何工作的。当服务保持响应时，断路器将关闭，允许通过请求。如果远程服务突然变得不能响应，断路器就会打开，从而阻止请求通过，直到服务再次响应。当然这并不像你家中的保险丝，<strong>断路器</strong> 本身可以 <strong>持续监测服务</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_timeout3.png" alt="图1-3"></p><p><strong>断路器模式</strong> 相比 <strong>设置超时</strong> 的优点是，使用者可以 <strong>立即</strong> 知道服务已变得不响应，而不必等待超时，使用者将在 <strong>毫秒内</strong> 服务不响应，而不是等待 <code>10</code> 秒获得相同的信息。</p><p>另外断路器可以通过几种方式进行 <strong>监控</strong>。最简单的方法是 <strong>对远程服务</strong> 进行简单的 <strong>心跳检查</strong>，这种方式只是告诉断路器服务是活的，但是要想获取服务存活的详细信息，就需要 <strong>定期</strong>（比如 <code>10</code> 秒）获取一次服务的详细信息。还有一种方式是 <strong>实时用户监控</strong>，这种方式可以 <strong>动态调整</strong>，一旦达到 <strong>阈值</strong>，断路器可以进入 <strong>半开放状态</strong>，可以设置 <strong>一定数量的请求是通过</strong>（说 <code>10</code> 个请求中有 <code>8</code> 个通过）。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="">微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</a></li><li><a href="">微服务的反模式和陷阱(二) - 超时反模式</a></li><li><a href="">微服务的反模式和陷阱(三) - 共享反模式</a></li><li><a href="">微服务的反模式和陷阱(四) - 到达报告反模式</a></li><li><a href="">微服务的反模式和陷阱(五) - 沙粒陷阱</a></li><li><a href="">微服务的反模式和陷阱(六) - 无因的开发者陷阱</a></li><li><a href="">微服务的反模式和陷阱(七) - 随大流陷阱</a></li><li><a href="">微服务的反模式和陷阱(八) - 其它架构模式</a></li><li><a href="">微服务的反模式和陷阱(九) - 静态契约陷阱</a></li><li><a href="">微服务的反模式和陷阱(十) - 通信协议使用的陷阱</a></li></ol><hr><p>欢迎关注技术公众号： <strong>零壹技术栈</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;分布式应用的挑战之一就是如何管理 &lt;strong&gt;远程服务&lt;/strong&gt; 的 &lt;strong&gt;可用性&lt;/strong&gt; 和它们的 &lt;strong&gt;响应&lt;/strong&gt;。虽然服务可用性和服务响应都涉及到服务的通信，但它们是两个完全不同的东西。&lt;strong&gt;服务可用性&lt;/strong&gt; 是服务消费者 &lt;strong&gt;连接服务&lt;/strong&gt; 并能够 &lt;strong&gt;发送请求&lt;/strong&gt; 的能力，&lt;strong&gt;服务响应&lt;/strong&gt; 则关注服务的 &lt;strong&gt;响应时间&lt;/strong&gt;。这里就涉及微服务中的 &lt;strong&gt;超时反模式&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="微服务" scheme="https://ostenant.coding.me/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="反模式" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</title>
    <link href="https://ostenant.coding.me/2018/06/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%99%B7%E9%98%B1(%E4%B8%80)%20-%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%BF%81%E7%A7%BB%E5%8F%8D%E6%A8%A1%E5%BC%8F%08/"/>
    <id>https://ostenant.coding.me/2018/06/10/微服务的反模式和陷阱(一) - 数据驱动的迁移反模式/</id>
    <published>2018-06-10T10:20:00.000Z</published>
    <updated>2018-06-18T01:58:16.876Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>采用 <strong>数据驱动迁移反模式</strong> 主要发生在当你从一个 <strong>单体应用</strong> 向 <strong>微服务架构</strong> 做迁移的时候。之所以称之为反模式主要原因是，刚开始我们觉得创建微服务是一个不错的主意，<strong>服务和相应的数据</strong> 都独立成 <strong>微服务</strong>，但这可能会将你带向一个错误的道路上，导致高风险、过剩成本和额外的迁移工作。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="数据驱动的迁移反模式"><a href="#数据驱动的迁移反模式" class="headerlink" title="数据驱动的迁移反模式"></a>数据驱动的迁移反模式</h2><p>微服务会创建 <strong>大量小的</strong>、<strong>分布式的</strong>、<strong>单一用途</strong> 的服务，每个服务拥有自己的数据。这种 <strong>服务和数据耦合</strong> 支持一个 <strong>有界的上下文</strong> 和 <strong>一个无共享数据</strong> 的架构。其中，每个服务及其对应的数据是独立一块，完全独立于所有其他服务。服务只暴露了一个明确的接口（服务契约）。有界的上下文可以允许开发者以最小的依赖快速轻松地开发，测试和部署。</p><p>采用 <strong>数据驱动迁移反模式</strong> 主要发生在当你从一个 <strong>单体应用</strong> 向 <strong>微服务架构</strong> 做迁移的时候。我们之所以称之为反模式主要原因是，刚开始我们觉得创建微服务是一个不错的主意，<strong>服务和相应的数据</strong> 都独立成 <strong>微服务</strong>，但这可能会将你带向一个错误的道路上，导致高风险、过剩成本和额外的迁移工作。</p><p>单体应用迁移到微服务架构有两个主要目标：</p><ol><li><p>第一个目标是单体应用程序的 <strong>功能</strong> 分割成 <strong>小的</strong>，<strong>单一用途</strong> 的服务。</p></li><li><p>第二个目标是单体应用的 <strong>数据</strong> 迁移到每个服务自己 <strong>独占的小数据库</strong>（或独立的服务）。</p></li></ol><p>下图展示了一个典型的迁移，看起来像服务代码和相应的数据同时进行迁移。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/data_driven_back_pattern.png" alt="图1-1"></p><p>上图中有三个服务是从单体应用中划分而来，并且还划分独立的三个数据库，这是一个自然演变的过程，因为在每个 <strong>服务</strong> 和 <strong>数据库</strong> 之间都使用了最为关键的 <strong>限界上下文</strong>，然而我们遇到的问题也正是基于这一过程将带领我们进入 <strong>数据迁移的反模式</strong>。</p><h3 id="1-太多的数据迁移"><a href="#1-太多的数据迁移" class="headerlink" title="1. 太多的数据迁移"></a>1. 太多的数据迁移</h3><p>这种迁移路径的主要问题是，我们很难在一次就能够划分清楚每个服务的粒度。从一个 <strong>更粗粒度</strong> 的服务开始着手，一步步的进行 <strong>细化工作</strong>，并且要多了解相关业务知识，不断的 <strong>对服务的粒度进行调整</strong>。</p><p>我们来看图 <code>1-1</code> 发现最左边的 <strong>服务粒度太粗</strong>，需要再 <strong>拆分</strong> 成二个小的服务，或者你发现左边的二个 <strong>服务粒度划分的太细</strong>，需要进行 <strong>合并</strong>。而 <strong>数据迁移</strong> 要比 <strong>源代码迁移</strong> 更复杂，更容易出错，我们最好只为数据进行一次迁移工作，因为数据迁移是一个 <strong>高风险</strong> 的工作。</p><p>我们的微服务划分也就是应用代码的迁移和数据的迁移。如图 <code>1-2</code> 所示。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/data_drive_back_pattern2.png" alt="图1-2"></p><h3 id="2-功能分割优先，数据迁移最后"><a href="#2-功能分割优先，数据迁移最后" class="headerlink" title="2. 功能分割优先，数据迁移最后"></a>2. 功能分割优先，数据迁移最后</h3><p>此模式主要采用的是一种避免的手段，以 <strong>迁移服务的功能</strong> 为第一，同时也需要注意服务和数据之间的 <strong>限界上下文</strong>。我们可以通过 <strong>合并</strong> 与 <strong>拆分</strong> 的手段对服务进行调整直到满意为止，这时候就可以进行 <strong>数据迁移</strong>。</p><p>如图 <code>1-3</code> 所示，左边所有三个服务都已经进行了 <strong>迁移</strong> 和 <strong>拆分</strong>，但是所有服务仍然使用的是 <strong>同一个数据库</strong>。如果这是一个临时中间方案还可以作为一个选择，这时候我们就需要更多的了解服务如何使用，以及接受什么类型的请求数据等。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/data_driven_back_pattern3.png" alt=""></p><p>在图 <code>1-3</code> 中，我们要注意最左边的服务是如何发现 <strong>粒度太粗</strong> 而 <strong>拆分</strong> 成两个服务的。服务粒度最终确定完成之后，下一步就开始 <strong>迁移数据</strong> 了，采用这种方式可以避免重复的数据迁移。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="">微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</a></li><li><a href="">微服务的反模式和陷阱(二) - 超时反模式</a></li><li><a href="">微服务的反模式和陷阱(三) - 共享反模式</a></li><li><a href="">微服务的反模式和陷阱(四) - 到达报告反模式</a></li><li><a href="">微服务的反模式和陷阱(五) - 沙粒陷阱</a></li><li><a href="">微服务的反模式和陷阱(六) - 无因的开发者陷阱</a></li><li><a href="">微服务的反模式和陷阱(七) - 随大流陷阱</a></li><li><a href="">微服务的反模式和陷阱(八) - 其它架构模式</a></li><li><a href="">微服务的反模式和陷阱(九) - 静态契约陷阱</a></li><li><a href="">微服务的反模式和陷阱(十) - 通信协议使用的陷阱</a></li></ol><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;采用 &lt;strong&gt;数据驱动迁移反模式&lt;/strong&gt; 主要发生在当你从一个 &lt;strong&gt;单体应用&lt;/strong&gt; 向 &lt;strong&gt;微服务架构&lt;/strong&gt; 做迁移的时候。之所以称之为反模式主要原因是，刚开始我们觉得创建微服务是一个不错的主意，&lt;strong&gt;服务和相应的数据&lt;/strong&gt; 都独立成 &lt;strong&gt;微服务&lt;/strong&gt;，但这可能会将你带向一个错误的道路上，导致高风险、过剩成本和额外的迁移工作。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="微服务" scheme="https://ostenant.coding.me/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="反模式" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose搭建MySQL主从复制集群</title>
    <link href="https://ostenant.coding.me/2018/06/10/Docker%20Compose%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/"/>
    <id>https://ostenant.coding.me/2018/06/10/Docker Compose搭建MySQL主从集群/</id>
    <published>2018-06-10T02:33:00.000Z</published>
    <updated>2018-06-18T01:46:07.184Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着应用业务数据不断的增大，应用的 <strong>响应速度不断下降</strong>，在检测过程中我们不难发现大多数的请求都是 <strong>查询操作</strong>。此时，我们可以将数据库扩展成 <strong>主从复制模式</strong>，将 <strong>读操作</strong> 和 <strong>写操作</strong> 分离开来，多台数据库 <strong>分摊请求</strong>，从而 <strong>减少单库</strong> 的 <strong>访问压力</strong>，进而应用得到优化。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="主从复制的方式"><a href="#主从复制的方式" class="headerlink" title="主从复制的方式"></a>主从复制的方式</h2><p><code>MySQL 5.6</code> 开始主从复制有两种方式：<strong>基于日志</strong>（<code>binlog</code>）和 <strong>基于</strong> <code>GTID</code>（<strong>全局事务标示符</strong>）。 </p><p>本文只涉及基于日志 <code>binlog</code> 的 <strong>主从配置</strong>。</p><h2 id="主从复制的流程"><a href="#主从复制的流程" class="headerlink" title="主从复制的流程"></a>主从复制的流程</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/MySQL_Master_Slave.png" alt=""></p><p><code>MySQL</code> 同步操作通过 <code>3</code> 个线程实现，其基本步骤如下：</p><ol><li><p><strong>主服务器</strong> 将数据的更新记录到 <strong>二进制日志</strong>（<code>Binary log</code>）中，用于记录二进制日志事件，这一步由 <strong>主库线程</strong> 完成；</p></li><li><p><strong>从库</strong> 将 <strong>主库</strong> 的 <strong>二进制日志</strong> 复制到本地的 <strong>中继日志</strong>（<code>Relay log</code>），这一步由 <strong>从库</strong> <code>I/O</code> <strong>线程</strong> 完成；</p></li><li><p><strong>从库</strong> 读取 <strong>中继日志</strong> 中的 <strong>事件</strong>，将其重放到数据中，这一步由 <strong>从库</strong> <code>SQL</code> <strong>线程</strong> 完成。</p></li></ol><h2 id="主从模式的优点"><a href="#主从模式的优点" class="headerlink" title="主从模式的优点"></a>主从模式的优点</h2><h4 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1. 负载均衡"></a>1. 负载均衡</h4><p>通常情况下，会使用 <strong>主服务器</strong> 对数据进行 <strong>更新</strong>、<strong>删除</strong> 和 <strong>新建</strong> 等操作，而将 <strong>查询</strong> 工作落到 <strong>从库</strong> 头上。</p><h4 id="2-异地容灾备份"><a href="#2-异地容灾备份" class="headerlink" title="2. 异地容灾备份"></a>2. 异地容灾备份</h4><p>可以将主服务器上的数据同步到 <strong>异地从服务器</strong> 上，极大地提高了 <strong>数据安全性</strong>。</p><h4 id="3-高可用"><a href="#3-高可用" class="headerlink" title="3. 高可用"></a>3. 高可用</h4><p>数据库的复制功能实现了 <strong>主服务器</strong> 与 <strong>从服务器间</strong> 的数据同步，一旦主服务器出了 <strong>故障</strong>，从服务器立即担当起主服务器的角色，保障系统持续稳定运作。</p><h4 id="4-高扩展性"><a href="#4-高扩展性" class="headerlink" title="4. 高扩展性"></a>4. 高扩展性</h4><p><strong>主从复制</strong> 模式支持 <code>2</code> 种扩展方式: </p><ul><li><strong>scale-up</strong></li></ul><p>向上扩展或者 <strong>纵向扩展</strong>，主要是提供比现在服务器 <strong>性能更好</strong> 的服务器，比如 <strong>增加</strong> <code>CPU</code> 和 <strong>内存</strong> 以及 <strong>磁盘阵列</strong>等，因为有多台服务器，所以可扩展性比单台更大。</p><ul><li><strong>scale-out</strong></li></ul><p>向外扩展或者 <strong>横向扩展</strong>，是指增加 <strong>服务器数量</strong> 的扩展，这样主要能分散各个服务器的压力。</p><h2 id="主从模式的缺点"><a href="#主从模式的缺点" class="headerlink" title="主从模式的缺点"></a>主从模式的缺点</h2><h4 id="1-成本增加"><a href="#1-成本增加" class="headerlink" title="1. 成本增加"></a>1. 成本增加</h4><p>搭建主从肯定会增加成本，毕竟一台服务器和两台服务器的成本完全不同，另外由于主从必须要开启 <strong>二进制日志</strong>，所以也会造成额外的 <strong>性能消耗</strong>。</p><h4 id="2-数据延迟"><a href="#2-数据延迟" class="headerlink" title="2. 数据延迟"></a>2. 数据延迟</h4><p><strong>从库</strong> 从 <strong>主库</strong> 复制数据肯定是会有一定的 <strong>数据延迟</strong> 的。所以当刚插入就出现查询的情况，可能查询不出来。当然如果是插入者自己查询，那么可以直接从 <strong>主库</strong> 中查询出来，当然这个也是需要用代码来控制的。</p><h4 id="3-写入更慢"><a href="#3-写入更慢" class="headerlink" title="3. 写入更慢"></a>3. 写入更慢</h4><p><strong>主从复制</strong> 主要是针对 <strong>读远大于写</strong> 或者对 <strong>数据备份实时性</strong> 要求较高的系统中。因为 <strong>主服务器</strong> 在写中需要更多操作，而且 <strong>只有一台</strong> 可以写入的 <strong>主库</strong>，所以写入的压力并不能被分散。</p><h2 id="主从复制的前提条件"><a href="#主从复制的前提条件" class="headerlink" title="主从复制的前提条件"></a>主从复制的前提条件</h2><ol><li><p>主从服务器 <strong>操作系统版本</strong> 和 <strong>位数</strong> 一致。</p></li><li><p>主数据库和从数据库的 <strong>版本</strong> 要一致。</p></li><li><p>主数据库和从数据库中的 <strong>数据</strong> 要一致。</p></li><li><p><strong>主数据库</strong> 开启 <strong>二进制日志</strong>，主数据库和从数据库的 <code>server_id</code> 在局域网内必须 <strong>唯一</strong>。</p></li></ol><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">版本号</th></tr></thead><tbody><tr><td style="text-align:left">Docker</td><td style="text-align:left">18.03.1-ce</td></tr><tr><td style="text-align:left">Docker Compose</td><td style="text-align:left">1.21.1</td></tr><tr><td style="text-align:left">MySQL</td><td style="text-align:left">5.7.17</td></tr></tbody></table><h3 id="2-配置docker-compose-yml"><a href="#2-配置docker-compose-yml" class="headerlink" title="2. 配置docker-compose.yml"></a>2. 配置docker-compose.yml</h3><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  mysql-master:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">master/Dockerfile</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql-slave</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"33065:3306"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">mysql-master</span></span><br><span class="line"><span class="attr">  mysql-slave:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">slave/Dockerfile</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"33066:3306"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">mysql-slave</span></span><br></pre></td></tr></table></figure><h3 id="3-主数据库配置"><a href="#3-主数据库配置" class="headerlink" title="3. 主数据库配置"></a>3. 主数据库配置</h3><h4 id="3-1-配置Dockerfile"><a href="#3-1-配置Dockerfile" class="headerlink" title="3.1. 配置Dockerfile"></a>3.1. 配置Dockerfile</h4><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> harrison</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./master/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure><h4 id="3-2-配置my-cnf文件"><a href="#3-2-配置my-cnf文件" class="headerlink" title="3.2. 配置my.cnf文件"></a>3.2. 配置my.cnf文件</h4><p>my.cnf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，一般设置为IP，注意要唯一</span></span><br><span class="line">server_id=100  </span><br><span class="line"><span class="comment">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）</span></span><br><span class="line"><span class="built_in">log</span>-bin=replicas-mysql-bin  </span><br><span class="line"><span class="comment">## 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="comment">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure><h3 id="4-从数据库配置"><a href="#4-从数据库配置" class="headerlink" title="4. 从数据库配置"></a>4. 从数据库配置</h3><h4 id="4-1-配置Dockerfile"><a href="#4-1-配置Dockerfile" class="headerlink" title="4.1. 配置Dockerfile"></a>4.1. 配置Dockerfile</h4><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> harrison</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./slave/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure><h4 id="4-2-配置my-cnf文件"><a href="#4-2-配置my-cnf文件" class="headerlink" title="4.2. 配置my.cnf文件"></a>4.2. 配置my.cnf文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，一般设置为IP，注意要唯一</span></span><br><span class="line">server_id=101  </span><br><span class="line"><span class="comment">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span></span><br><span class="line"><span class="built_in">log</span>-bin=replicas-mysql-slave1-bin  </span><br><span class="line"><span class="comment">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="comment">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line"><span class="comment">## relay_log配置中继日志</span></span><br><span class="line">relay_log=replicas-mysql-relay-bin  </span><br><span class="line"><span class="comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span><br><span class="line">log_slave_updates=1  </span><br><span class="line"><span class="comment">## 防止改变数据(除了特殊的线程)</span></span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure><h3 id="5-创建容器"><a href="#5-创建容器" class="headerlink" title="5. 创建容器"></a>5. 创建容器</h3><p>进入 <code>docker</code> 目录，运行 <code>docker-compose</code> 启动命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure><p>如图所示，<code>MySQL</code> <strong>主数据库</strong> 和 <strong>从数据库</strong> 的容器创建成功。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Docker_Compose_MySQL.png" alt=""></p><p>分别配置 <strong>主数据库</strong> 和 <strong>从数据库</strong> 的连接信息如下：</p><ul><li>主数据库</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/MySQL_Master.png" alt=""></p><ul><li>从数据库</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/MySQL_Slave.png" alt=""><br></p><h3 id="6-配置从数据库"><a href="#6-配置从数据库" class="headerlink" title="6. 配置从数据库"></a>6. 配置从数据库</h3><h4 id="检查从库的起始状态"><a href="#检查从库的起始状态" class="headerlink" title="检查从库的起始状态"></a>检查从库的起始状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show master status;</span><br></pre></td></tr></table></figure><p>如图所示，从数据库处于 <strong>未同步复制状态</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Slave_Status.png" alt=""></p><h4 id="检查主库的状态"><a href="#检查主库的状态" class="headerlink" title="检查主库的状态"></a>检查主库的状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show master status;</span><br></pre></td></tr></table></figure><p>记录 <strong>主数据库</strong> <code>binary-log</code> 的 <strong>文件名称</strong> 和 <strong>数据同步起始位置</strong>。</p><ul><li>File: replicas-mysql-bin.000003</li><li>Position: 154</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/Master_Status.png" alt=""></p><h4 id="从库配置主库信息"><a href="#从库配置主库信息" class="headerlink" title="从库配置主库信息"></a>从库配置主库信息</h4><p>在 <strong>从数据库</strong> 上运行 <strong>主数据库</strong> 的相关配置 <code>sql</code> 进行主从关联</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">    MASTER_HOST=<span class="string">'mysql-master'</span>,</span><br><span class="line">    MASTER_USER=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_PASSWORD=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_LOG_FILE=<span class="string">'replicas-mysql-bin.000003'</span>,</span><br><span class="line">    MASTER_LOG_POS=<span class="number">154</span>;</span><br></pre></td></tr></table></figure><p>重新启动 <code>slave</code> 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ stop slave</span><br><span class="line">$ start slave</span><br></pre></td></tr></table></figure><p>进一步检查 <strong>从数据库</strong> 的状态信息，两者已经进行 <strong>数据同步</strong> 关联。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Slave_Status3.png" alt=""></p><h3 id="7-创建目标表"><a href="#7-创建目标表" class="headerlink" title="7. 创建目标表"></a>7. 创建目标表</h3><p>在 <strong>主数据库</strong> 中创建一张测试数据表 <code>course</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for course</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`course`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lesson_period`</span> <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span> <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p><strong>主数据库</strong> 和 <strong>从数据库</strong> 的 数据处于 <strong>同步状态</strong>，主从复制集群搭建完成。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Master_Slave_Sync.png" alt=""></p><h2 id="MySQL的复制类型"><a href="#MySQL的复制类型" class="headerlink" title="MySQL的复制类型"></a>MySQL的复制类型</h2><h3 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h3><p>主服务器上面执行的语句在从服务器上面再执行一遍，在 <code>MySQL-3.23</code> 版本以后支持。</p><blockquote><p>问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户。</p></blockquote><h3 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h3><p>把主服务器上面改变后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在 <code>MySQL-5.0</code> 版本以后引入。</p><blockquote><p>问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。</p></blockquote><h3 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h3><p><code>MySQL</code> 默认使用 <strong>基于语句的复制</strong>，当 <strong>基于语句的复制</strong> 会引发问题的时候就会使用 <strong>基于行的复制</strong>，<code>MySQL</code> 会自动进行选择。</p><hr><p>欢迎关注公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着应用业务数据不断的增大，应用的 &lt;strong&gt;响应速度不断下降&lt;/strong&gt;，在检测过程中我们不难发现大多数的请求都是 &lt;strong&gt;查询操作&lt;/strong&gt;。此时，我们可以将数据库扩展成 &lt;strong&gt;主从复制模式&lt;/strong&gt;，将 &lt;strong&gt;读操作&lt;/strong&gt; 和 &lt;strong&gt;写操作&lt;/strong&gt; 分离开来，多台数据库 &lt;strong&gt;分摊请求&lt;/strong&gt;，从而 &lt;strong&gt;减少单库&lt;/strong&gt; 的 &lt;strong&gt;访问压力&lt;/strong&gt;，进而应用得到优化。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL学习系列" scheme="https://ostenant.coding.me/categories/MySQL%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Docker Compose" scheme="https://ostenant.coding.me/tags/Docker-Compose/"/>
    
      <category term="MySQL" scheme="https://ostenant.coding.me/tags/MySQL/"/>
    
      <category term="主从复制" scheme="https://ostenant.coding.me/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>并发三剑客之限流方案总结</title>
    <link href="https://ostenant.coding.me/2018/06/09/%E5%B9%B6%E5%8F%91%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8B%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
    <id>https://ostenant.coding.me/2018/06/09/并发三剑客之限流方案总结/</id>
    <published>2018-06-09T00:20:00.000Z</published>
    <updated>2018-06-18T01:58:05.210Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于高并发的系统，有三把利器用来保护系统：<strong>缓存</strong>、<strong>降级</strong> 和 <strong>限流</strong>。限流常见的应用场景是秒杀、下单和评论等 <strong>突发性</strong> 并发问题。</p><a id="more"></a><ol><li><p><strong>缓存</strong> 的目的是提升 <strong>系统访问速度</strong> 和 <strong>系统吞吐量</strong>。</p></li><li><p><strong>降级</strong> 是当服务 <strong>出问题</strong> 或者影响到核心流程的性能，则需要 <strong>暂时屏蔽掉</strong>，待 <strong>高峰</strong> 或者 <strong>问题解决后</strong> 再打开。</p></li><li><p>有些场景并不能用 <strong>缓存</strong> 和 <strong>降级</strong> 来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（最新的评论）。因此需有一种手段来限制这些场景的 <strong>并发/请求量</strong>，即 <strong>限流</strong>。</p></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="限流的目的"><a href="#限流的目的" class="headerlink" title="限流的目的"></a>限流的目的</h2><p>限流的目的是通过对 <strong>并发访问/请求进行</strong> 限速，或者一个 <strong>时间窗口</strong> 内的的请求进行限速来 <strong>保护系统</strong>，一旦达到限制速率则可以 <strong>拒绝服务</strong>（定向到错误页或告知资源没有了）、<strong>排队</strong> 或 <strong>等待</strong>（比如秒杀、评论、下单）、降级（返回托底数据或默认数据，如商品详情页库存默认有货）。</p><h2 id="限流的方式"><a href="#限流的方式" class="headerlink" title="限流的方式"></a>限流的方式</h2><ol><li><p>限制 <strong>总并发数</strong>（比如 <strong>数据库连接池</strong>、<strong>线程池</strong>）</p></li><li><p>限制 <strong>瞬时并发数</strong>（如 <code>nginx</code> 的 <code>limit_conn</code> 模块，用来限制 <strong>瞬时并发连接数</strong>）</p></li><li><p>限制 <strong>时间窗口内的平均速率</strong>（如 <code>Guava</code> 的 <code>RateLimiter</code>、<code>nginx</code> 的 <code>limit_req</code> 模块，限制每秒的平均速率）</p></li><li><p>限制 <strong>远程接口</strong> 调用速率</p></li><li><p>限制 <code>MQ</code> 的消费速率</p></li><li><p>可以根据 <strong>网络连接数</strong>、<strong>网络流量</strong>、<code>CPU</code> 或 <strong>内存负载</strong> 等来限流</p></li></ol><h2 id="限流的算法"><a href="#限流的算法" class="headerlink" title="限流的算法"></a>限流的算法</h2><h3 id="1-令牌桶"><a href="#1-令牌桶" class="headerlink" title="1. 令牌桶"></a>1. 令牌桶</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/token_bucket.png" alt=""></p><h3 id="2-漏桶"><a href="#2-漏桶" class="headerlink" title="2. 漏桶"></a>2. 漏桶</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/bucket.jpg" alt=""></p><h3 id="3-计数器"><a href="#3-计数器" class="headerlink" title="3. 计数器"></a>3. 计数器</h3><p>有时候还可以使用 <strong>计数器</strong> 来进行限流，主要用来限制 <strong>总并发数</strong>，比如 <strong>数据库连接池</strong>、<strong>线程池</strong>、<strong>秒杀的并发数</strong>。通过 <strong>全局总请求数</strong> 或者 <strong>一定时间段的总请求数</strong> 设定的 <strong>阀值</strong> 来限流。这是一种 <strong>简单粗暴</strong> 的限流方式，而不是 <strong>平均速率限流</strong>。</p><h3 id="令牌桶-vs-漏桶"><a href="#令牌桶-vs-漏桶" class="headerlink" title="令牌桶 vs 漏桶"></a>令牌桶 vs 漏桶</h3><p>令牌桶限制的是 <strong>平均流入速率</strong>，允许突发请求，并允许一定程度 <strong>突发流量</strong>。</p><p>漏桶限制的是 <strong>常量流出速率</strong>，从而平滑 <strong>突发流入速率</strong>。</p><h2 id="应用级别限流"><a href="#应用级别限流" class="headerlink" title="应用级别限流"></a>应用级别限流</h2><h3 id="1-限流总资源数"><a href="#1-限流总资源数" class="headerlink" title="1. 限流总资源数"></a>1. 限流总资源数</h3><p>可以使用池化技术来限制总资源数：<strong>连接池</strong>、<strong>线程池</strong>。比如分配给每个应用的数据库连接是 <code>100</code>，那么本应用最多可以使用 <code>100</code> 个资源，超出了可以 <strong>等待</strong> 或者 <strong>抛异常</strong>。</p><h3 id="2-限流总并发-连接-请求数"><a href="#2-限流总并发-连接-请求数" class="headerlink" title="2. 限流总并发/连接/请求数"></a>2. 限流总并发/连接/请求数</h3><p>如果你使用过 <code>Tomcat</code>，其 <code>Connector</code> 其中一种配置有如下几个参数:</p><ul><li><p>maxThreads: <code>Tomcat</code> 能启动用来处理请求的 <strong>最大线程数</strong>，如果请求处理量一直远远大于最大线程数，可能会僵死。</p></li><li><p>maxConnections: <strong>瞬时最大连接数</strong>，超出的会 <strong>排队等待</strong>。</p></li><li><p>acceptCount: 如果 <code>Tomcat</code> 的线程都忙于响应，新来的连接会进入 <strong>队列排队</strong>，如果 <strong>超出排队大小</strong>，则 <strong>拒绝连接</strong>。</p></li></ul><h3 id="3-限流某个接口的总并发-请求数"><a href="#3-限流某个接口的总并发-请求数" class="headerlink" title="3. 限流某个接口的总并发/请求数"></a>3. 限流某个接口的总并发/请求数</h3><p>使用 <code>Java</code> 中的 <code>AtomicLong</code>，示意代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(atomic.incrementAndGet() &gt; 限流数) &#123;</span><br><span class="line">        <span class="comment">//拒绝请求</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//处理请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    atomic.decrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-限流某个接口的时间窗请求数"><a href="#4-限流某个接口的时间窗请求数" class="headerlink" title="4. 限流某个接口的时间窗请求数"></a>4. 限流某个接口的时间窗请求数</h3><p>使用 <code>Guava</code> 的 <code>Cache</code>，示意代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache counter = CacheBuilder.newBuilder()</span><br><span class="line">    .expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">    .build(newCacheLoader() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AtomicLong <span class="title">load</span><span class="params">(Long seconds)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newAtomicLong(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">longlimit =<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 得到当前秒</span></span><br><span class="line">    <span class="keyword">long</span> currentSeconds = System.currentTimeMillis() /<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span>(counter.get(currentSeconds).incrementAndGet() &gt; limit) &#123;</span><br><span class="line">        System.out.println(<span class="string">"限流了: "</span> + currentSeconds);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-平滑限流某个接口的请求数"><a href="#5-平滑限流某个接口的请求数" class="headerlink" title="5. 平滑限流某个接口的请求数"></a>5. 平滑限流某个接口的请求数</h3><p>之前的限流方式都不能很好地应对 <strong>突发请求</strong>，即 <strong>瞬间请求</strong> 可能都被允许从而导致一些问题。因此在一些场景中需要对突发请求进行改造，改造为 <strong>平均速率</strong> 请求处理。</p><p><code>Guava RateLimiter</code> 提供了 <strong>令牌桶算法实现</strong>：</p><ol><li><p>平滑突发限流 (<code>SmoothBursty</code>)</p></li><li><p>平滑预热限流 (<code>SmoothWarmingUp</code>) 实现</p></li></ol><h4 id="平滑突发限流-SmoothBursty"><a href="#平滑突发限流-SmoothBursty" class="headerlink" title="平滑突发限流(SmoothBursty)"></a>平滑突发限流(SmoothBursty)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter limiter = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br></pre></td></tr></table></figure><p>将得到类似如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br><span class="line">0.198239</span><br><span class="line">0.196083</span><br><span class="line">0.200609</span><br><span class="line">0.199599</span><br><span class="line">0.19961</span><br></pre></td></tr></table></figure><h4 id="平滑预热限流-SmoothWarmingUp"><a href="#平滑预热限流-SmoothWarmingUp" class="headerlink" title="平滑预热限流(SmoothWarmingUp)"></a>平滑预热限流(SmoothWarmingUp)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter limiter = RateLimiter.create(<span class="number">5</span>, <span class="number">1000</span>,  TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">for</span>(inti = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(limiter.acquire());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"><span class="keyword">for</span>(inti = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(limiter.acquire());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将得到类似如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br><span class="line">0.51767</span><br><span class="line">0.357814</span><br><span class="line">0.219992</span><br><span class="line">0.199984</span><br><span class="line">0.0</span><br><span class="line">0.360826</span><br><span class="line">0.220166</span><br><span class="line">0.199723</span><br><span class="line">0.199555</span><br></pre></td></tr></table></figure><p><code>SmoothWarmingUp</code> 的创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter.create(doublepermitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit);</span><br></pre></td></tr></table></figure><ul><li>permitsPerSecond: 表示 <strong>每秒新增</strong> 的令牌数</li><li>warmupPeriod: 表示在从 <strong>冷启动速率</strong> 过渡到 <strong>平均速率</strong> 的时间间隔</li></ul><p>速率是 <strong>梯形上升</strong> 速率的，也就是说 <strong>冷启动</strong> 时会以一个比较大的速率慢慢到平均速率；然后趋于 <strong>平均速率</strong>（梯形下降到平均速率）。可以通过调节 <code>warmupPeriod</code> 参数实现一开始就是平滑固定速率。</p><h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><p>分布式限流最关键的是要将 <strong>限流服务</strong> 做成 <strong>原子化</strong>，而解决方案可以使用 <code>redis + lua</code> 或者 <code>nginx + lua</code> 技术进行实现。</p><h2 id="接入层限流"><a href="#接入层限流" class="headerlink" title="接入层限流"></a>接入层限流</h2><p><strong>接入层</strong> 通常指请求流量的入口，该层的主要目的有：</p><ul><li>负载均衡</li><li>非法请求过滤</li><li>请求聚合</li><li>缓存、降级、限流</li><li>A/B测试</li><li>服务质量监控</li></ul><p>对于 <code>Nginx</code> <strong>接入层限流</strong> 可以使用 <code>Nginx</code> 自带了两个模块：<strong>连接数限流模块</strong> <code>ngx_http_limit_conn_module</code> 和 <strong>漏桶</strong> 算法实现的 <strong>请求限流模块</strong> <code>ngx_http_limit_req_module</code>。还可以使用 <code>OpenResty</code> 提供的 <code>Lua</code> 限流模块 <code>lua-resty-limit-traffic</code> 进行 <strong>更复杂的</strong> 限流场景。</p><ul><li><p>limit_conn: 用来对某个 <code>KEY</code> 对应的 <strong>总的网络连接数</strong> 进行限流，可以按照如 <code>IP</code>、<strong>域名维度</strong> 进行限流。</p></li><li><p>limit_req: 用来对某个 <code>KEY</code> 对应的 <strong>请求的平均速率</strong> 进行限流，并有两种用法：<strong>平滑模式</strong>（<code>delay</code>）和 <strong>允许突发模式</strong> (<code>nodelay</code>)。</p></li></ul><p><code>OpenResty</code> 提供的 <code>Lua</code> 限流模块 <code>lua-resty-limit-traffic</code> 可以进行更复杂的限流场景。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于高并发的系统，有三把利器用来保护系统：&lt;strong&gt;缓存&lt;/strong&gt;、&lt;strong&gt;降级&lt;/strong&gt; 和 &lt;strong&gt;限流&lt;/strong&gt;。限流常见的应用场景是秒杀、下单和评论等 &lt;strong&gt;突发性&lt;/strong&gt; 并发问题。&lt;/p&gt;
    
    </summary>
    
      <category term="高并发系统系列" scheme="https://ostenant.coding.me/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="高并发" scheme="https://ostenant.coding.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="限流" scheme="https://ostenant.coding.me/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(六) - 一致性协议Raft</title>
    <link href="https://ostenant.coding.me/2018/06/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E5%85%AD)%20-%20%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AERaft/"/>
    <id>https://ostenant.coding.me/2018/06/05/分布式理论(六) - 一致性协议Raft/</id>
    <published>2018-06-05T13:20:00.000Z</published>
    <updated>2018-06-18T01:54:52.119Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Raft</code> 也是一个 <strong>一致性算法</strong>，和 <code>Paxos</code> 目标相同。但它还有另一个名字 - <strong>易于理解的一致性算法</strong>。<code>Paxos</code> 和 <code>Raft</code> 都是为了实现 <strong>一致性</strong> 产生的。这个过程如同选举一样，<strong>参选者</strong> 需要说服 <strong>大多数选民</strong> (服务器) 投票给他，一旦选定后就跟随其操作。<code>Paxos</code> 和 <code>Raft</code> 的区别在于选举的 <strong>具体过程</strong> 不同。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>在进入正题前，给大家分享一个《数学发散思维》中的一个故事，站在不同思维角度上，了解对一个问题理解的差异性。</p><blockquote><p>问题: 甲乙两人轮流在一张圆桌上平放黑白围棋子，每次放一子，棋子不许重叠，谁先没有地方放就输。请问怎样放才能赢？</p></blockquote><p>这个问题有两层意思，第一，有没有一种放法保证必赢？第二，如果有怎么证明？</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_prepare.png" alt=""></p><p>上图回答了这个问题，那就是先行者必胜，这里使用了三种不同的思维方式来阐述: </p><ol><li><p>假如桌子只有一个围棋子那么大。</p></li><li><p>假如桌子无限大，先行者先占住圆心。由于圆是对称图形，所以只要对手还能找到位置放，你总能在对称的另一面找到位置放。</p></li><li><p>一个圆中可画单数个直径相等且互切的小圆。</p></li></ol><p>三种不同的思维方式在可理解性难度上逐渐加深。</p><ol><li><p>第一种是 <strong>极简化思维</strong>，但数学上是 <strong>不严谨</strong> 的。</p></li><li><p>第二种是 <strong>极限思维</strong>，和第一种结合起来就是 <strong>数学归纳法</strong>，在数学上是 <strong>严谨</strong> 的。</p></li><li><p>第三种是 <strong>形象思维</strong>，使用了 <strong>几何学概念</strong>，但对于没有几何学基础知识的人就很难理解了。</p></li></ol><h2 id="什么是Raft协议"><a href="#什么是Raft协议" class="headerlink" title="什么是Raft协议"></a>什么是Raft协议</h2><p><code>Raft</code> 协议将 <code>Server</code> 进程分成三类，分别是 <code>Leader</code>，<code>Candidate</code>，<code>Follower</code>。一个 <code>Server</code> 进程在某一时刻，只能是其中 <strong>一种类型</strong>，但这不是固定的。不同的时刻，它可能拥有不同的类型，一个 <code>Server</code> 进程的类型是如何改变的，后面会有解释。</p><p>在一个由 <code>Raft</code> 协议组织的集群中有三类角色：</p><ul><li><strong>Leader（领袖）</strong></li><li><strong>Follower（群众）</strong></li><li><strong>Candidate（候选人）</strong></li></ul><p>就像一个民主社会，领袖由民众投票选出。刚开始没有 <strong>领袖</strong>，所有集群中的 <strong>参与者</strong> 都是 <strong>群众</strong>，那么首先开启一轮大选。在大选期间 <strong>所有群众</strong> 都能参与竞选，这时所有群众的角色就变成了 <strong>候选人</strong>，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除 <strong>领袖</strong> 的 <strong>候选人</strong> 又变回 <strong>群众角色</strong> 服从领袖领导。</p><p>这里提到一个概念 <strong>「任期」</strong>，用术语 <code>Term</code> 表达。关于 <code>Raft</code> 协议的核心概念和术语就这么多，而且和现实民主制度非常匹配，所以很容易理解。</p><p>三类角色的变迁图如下，结合后面的选举过程来看很容易理解。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_workflow.png" alt=""></p><h2 id="Leader选举过程"><a href="#Leader选举过程" class="headerlink" title="Leader选举过程"></a>Leader选举过程</h2><p>在极简的思维下，一个最小的 <code>Raft</code> 民主集群需要 <strong>三个参与者</strong>（如下图：<code>A</code>、<code>B</code>、<code>C</code>），这样才可能投出多数票。</p><p>初始状态 <code>ABC</code> 都是 <code>Follower</code>，然后发起选举这时有 <strong>三种</strong> 可能的情形发生。下图中前二种都能选出 <code>Leader</code>，第三种则表明 <strong>本轮投票无效</strong>（<code>Split Votes</code>）。对于第三种，每方都投给了自己，结果没有任何一方获得多数票。之后 <strong>每个参与方</strong> 随机休息一阵（<code>Election Timeout</code>）重新发起投票直到一方获得多数票。这里的关键就是随机 <code>timeout</code>，最先从 <code>timeout</code> 中恢复发起投票的一方，向还在 <code>timeout</code> 中的另外两方 <strong>请求投票</strong>，这时它就只能投给自己，导致很快达成一致。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_election.png" alt=""></p><p>选出 <code>Leader</code> 后，<code>Leader</code> 通过 <strong>定期</strong> 向所有 <code>Follower</code> 发送 <strong>心跳信息</strong> 维持其统治。若 <code>Follower</code> 一段时间未收到 <code>Leader</code> 的 <strong>心跳</strong>，则认为 <code>Leader</code> 可能已经挂了，然后再次发起 <strong>选举</strong> 过程。</p><h2 id="Leader对一致性的影响"><a href="#Leader对一致性的影响" class="headerlink" title="Leader对一致性的影响"></a>Leader对一致性的影响</h2><p><code>Raft</code> 协议 <strong>强依赖</strong> <code>Leader</code> 节点的 <strong>可用性</strong>，以确保集群 <strong>数据的一致性</strong>。<strong>数据的流向</strong> 只能从 <code>Leader</code> 节点向 <code>Follower</code> 节点转移。具体过程如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_leader_consistence.png" alt=""></p><ol><li><p>当 <code>Client</code> 向集群 <code>Leader</code> 节点 <strong>提交数据</strong> 后，<code>Leader</code> 节点 <strong>接收到的数据</strong> 处于 <strong>未提交状态</strong>（<code>Uncommitted</code>）。</p></li><li><p>接着 <code>Leader</code> 节点会 <strong>并发地</strong> 向所有 <code>Follower</code> 节点 <strong>复制数据</strong> 并 <strong>等待接收响应</strong>。</p></li><li><p>集群中至少 <strong>超过半数</strong> 的节点 <strong>已接收</strong> 到数据后， <code>Leader</code> 再向 <code>Client</code> 确认数据 <strong>已接收</strong>。</p></li><li><p>一旦向 <code>Client</code> 发出数据接收 <code>Ack</code> 响应后，表明此时 <strong>数据状态</strong> 进入 <strong>已提交</strong>（<code>Committed</code>），<code>Leader</code> 节点再向 <code>Follower</code> 节点发通知告知该 <strong>数据状态已提交</strong>。</p></li></ol><p>在这个过程中，<strong>主节点</strong> 可能在 <strong>任意阶段</strong> 挂掉，看下 <code>Raft</code> 协议如何针对不同阶段保障 <strong>数据一致性</strong> 的。</p><h3 id="1-情形1"><a href="#1-情形1" class="headerlink" title="1. 情形1"></a>1. 情形1</h3><blockquote><p>数据到达 Leader 节点前，这个阶段 Leader 挂掉不影响一致性，不用多说。</p></blockquote><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_1.png" alt=""></p><h3 id="2-情形2"><a href="#2-情形2" class="headerlink" title="2. 情形2"></a>2. 情形2</h3><blockquote><p>数据到达 Leader 节点，但未复制到 Follower 节点。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，数据属于 <strong>未提交状态</strong>，<code>Client</code> 不会收到 <code>Ack</code> 会认为 <strong>超时失败</strong> 可安全发起 <strong>重试</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_2.png" alt=""></p><p><code>Follower</code> 节点上没有该数据，<strong>重新选主</strong> 后 <code>Client</code> 重试 <strong>重新提交</strong> 可成功。原来的 <code>Leader</code> 节点 <strong>恢复</strong> 后作为 <code>Follower</code> 加入集群，重新从 <strong>当前任期</strong> 的新 <code>Leader</code> 处 <strong>同步数据</strong>，强制保持和 <code>Leader</code> <strong>数据一致</strong>。</p><h3 id="3-情形3"><a href="#3-情形3" class="headerlink" title="3. 情形3"></a>3. 情形3</h3><blockquote><p>数据到达 Leader 节点，成功复制到 Follower 所有节点，但 Follower 还未向 Leader 响应接收。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，虽然数据在 <code>Follower</code> 节点处于 <strong>未提交状态</strong>（<code>Uncommitted</code>），但是 <strong>保持一致</strong> 的。重新选出 <code>Leader</code> 后可完成 <strong>数据提交</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_3.png" alt=""></p><p>此时 <code>Client</code> 由于不知到底提交成功没有，可重试提交。针对这种情况 <code>Raft</code> 要求 <code>RPC</code> 请求实现 <strong>幂等性</strong>，也就是要实现 <strong>内部去重机制</strong>。</p><h3 id="4-情形4"><a href="#4-情形4" class="headerlink" title="4. 情形4"></a>4. 情形4</h3><blockquote><p>数据到达 Leader 节点，成功复制到 Follower 的部分节点，但这部分 Follower 节点还未向 Leader 响应接收。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，数据在 <code>Follower</code> 节点处于 <strong>未提交状态</strong>（<code>Uncommitted</code>）且 <strong>不一致</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_4.png" alt=""></p><p><code>Raft</code> 协议要求投票只能投给拥有 <strong>最新数据</strong> 的节点。所以拥有最新数据的节点会被选为 <code>Leader</code>，然后再 <strong>强制同步数据</strong> 到其他 <code>Follower</code>，保证 <strong>数据不会丢失</strong>并 <strong>最终一致</strong>。</p><h3 id="5-情形5"><a href="#5-情形5" class="headerlink" title="5. 情形5"></a>5. 情形5</h3><blockquote><p>数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在 Leader 处于已提交状态，但在 Follower 处于未提交状态。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，<strong>重新选出</strong> 新的 <code>Leader</code> 后的处理流程和阶段 <code>3</code> 一样。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_5.png" alt=""></p><h3 id="6-情形6"><a href="#6-情形6" class="headerlink" title="6. 情形6"></a>6. 情形6</h3><blockquote><p>数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，集群内部数据其实已经是 <strong>一致的</strong>，<code>Client</code> 重复重试基于幂等策略对 <strong>一致性无影响</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_6.png" alt=""></p><h3 id="7-情形7"><a href="#7-情形7" class="headerlink" title="7. 情形7"></a>7. 情形7</h3><blockquote><p>网络分区导致的脑裂情况，出现双 Leader 的现象。</p></blockquote><p><strong>网络分区</strong> 将原先的 <code>Leader</code> 节点和 <code>Follower</code> 节点分隔开，<code>Follower</code> 收不到 <code>Leader</code> 的 <strong>心跳</strong> 将 <strong>重新</strong> 发起选举产生新的 <code>Leader</code>，这时就产生了 <strong>双Leader</strong> 现象。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_7.png" alt=""></p><p>原先的 <code>Leader</code> 独自在一个区，向它提交数据不可能复制到多数节点所以永远提交不成功。向新的 <code>Leader</code> 提交数据可以提交成功。</p><p><strong>网络恢复</strong> 后，旧的 <code>Leader</code> 发现集群中有 <strong>更新任期</strong>（<code>Term</code>）的新 <code>Leader</code> ，则 <strong>自动降级</strong> 为 <code>Follower</code> 并从新 <code>Leader</code> 处 <strong>同步数据</strong> 达成集群 <strong>数据一致</strong>。</p><h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><p>综上穷举分析了 <strong>最小集群</strong>（<code>3</code> 节点）面临的所有情况，可以看出 <code>Raft</code> 协议都能很好的应对 <strong>一致性问题</strong>，并且很容易理解。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>Paxos</code> 算法是 <code>Leslie Lamport</code> 在 <code>1990</code> 年就公开发表在了自己的网站上，想想我们是什么时候才听说的？什么时候才有一个可用的实现？而 <code>Raft</code> 算法是 <code>2013</code> 年发表的，大家在参考 <a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">Raft开源实现库</a>，可以看到有很多基于不同语言的 <strong>开源实现库</strong>，这就是 <strong>可理解性</strong> 的重要性。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Raft&lt;/code&gt; 也是一个 &lt;strong&gt;一致性算法&lt;/strong&gt;，和 &lt;code&gt;Paxos&lt;/code&gt; 目标相同。但它还有另一个名字 - &lt;strong&gt;易于理解的一致性算法&lt;/strong&gt;。&lt;code&gt;Paxos&lt;/code&gt; 和 &lt;code&gt;Raft&lt;/code&gt; 都是为了实现 &lt;strong&gt;一致性&lt;/strong&gt; 产生的。这个过程如同选举一样，&lt;strong&gt;参选者&lt;/strong&gt; 需要说服 &lt;strong&gt;大多数选民&lt;/strong&gt; (服务器) 投票给他，一旦选定后就跟随其操作。&lt;code&gt;Paxos&lt;/code&gt; 和 &lt;code&gt;Raft&lt;/code&gt; 的区别在于选举的 &lt;strong&gt;具体过程&lt;/strong&gt; 不同。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Raft" scheme="https://ostenant.coding.me/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(五) - 一致性算法Paxos</title>
    <link href="https://ostenant.coding.me/2018/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%BA%94)%20-%20%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos/"/>
    <id>https://ostenant.coding.me/2018/06/03/分布式理论(五) - 一致性算法Paxos/</id>
    <published>2018-06-03T13:30:00.000Z</published>
    <updated>2018-06-18T01:54:36.736Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>世界上只有一种一致性算法，就是 <code>Paxos</code>。出自一位 <code>Google</code> 大神之口。<code>Paxos</code> 也是出名的 <strong>晦涩难懂</strong>，推理过程极其复杂。</p><a id="more"></a><p><code>Paxos</code> 有点类似之前说的 <code>2PC</code>，<code>3PC</code>，但是解决了这两种算法各种硬伤。该算法在很多大厂都得到了工程实践，比如阿里的 <code>OceanBase</code> 的 <strong>分布式数据库</strong>，底层就是使用的 <code>Paxos</code> 算法。再比如 <code>Google</code> 的 <code>chubby</code> <strong>分布式锁</strong> 也是用的这个算法。可见该算法在分布式系统中的地位，甚至于，<code>Paxos</code> 就是 <strong>分布式一致性</strong> 的代名词。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-Paxos算法是什么"><a href="#1-Paxos算法是什么" class="headerlink" title="1. Paxos算法是什么"></a>1. Paxos算法是什么</h2><p><code>Paxos</code> 算法是 <strong>基于消息传递</strong> 且具有 <strong>高效容错特性</strong> 的一致性算法，目前公认的解决 <strong>分布式一致性问题</strong> 最有效的算法之一.</p><h2 id="2-Paxos算法产生背景"><a href="#2-Paxos算法产生背景" class="headerlink" title="2. Paxos算法产生背景"></a>2. Paxos算法产生背景</h2><h3 id="2-1-拜占庭将军问题"><a href="#2-1-拜占庭将军问题" class="headerlink" title="2.1. 拜占庭将军问题"></a>2.1. 拜占庭将军问题</h3><p>拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于信使中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。</p><h3 id="2-2-Paxos算法由来"><a href="#2-2-Paxos算法由来" class="headerlink" title="2.2. Paxos算法由来"></a>2.2. Paxos算法由来</h3><p>故事背景是古希腊 <code>Paxos</code> 岛上的多个法官在一个大厅内对一个议案进行表决，如何达成统一的结果。他们之间通过服务人员来传递纸条，但法官可能离开或进入大厅，服务人员可能偷懒去睡觉。</p><h3 id="2-3-产生背景"><a href="#2-3-产生背景" class="headerlink" title="2.3 产生背景"></a>2.3 产生背景</h3><p>在常见的 <strong>分布式系统</strong> 中，总会发生 <strong>节点宕机</strong> 或 <strong>网络异常</strong> (包括消息的 <strong>重复</strong>、<strong>丢失</strong>、<strong>延迟</strong>、<strong>乱序</strong>、<strong>网络分区</strong>) 等情况。</p><p><code>Paxos</code> 算法主要就是解决如何在一个 <strong>发生如上故障</strong> 的分布式系统中，快速正确的在集群内 <strong>对某个值达成一致</strong>，并且保证 <strong>整个系统的一致性</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/paxos_background.png" alt=""></p><h2 id="3-算法详解"><a href="#3-算法详解" class="headerlink" title="3. 算法详解"></a>3. 算法详解</h2><h3 id="3-1-角色-amp-提案"><a href="#3-1-角色-amp-提案" class="headerlink" title="3.1 角色 &amp; 提案"></a>3.1 角色 &amp; 提案</h3><h4 id="提案-Proposal"><a href="#提案-Proposal" class="headerlink" title="提案 (Proposal)"></a>提案 (Proposal)</h4><blockquote><p>注意：提案的范围&gt;value.后面会讲到，[提案=编号+Value].也可表示为[M,V].<br>以下描述中暂定: 提案=P，Value=V.</p></blockquote><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ol><li><p><strong>Proposer</strong> : <code>Proposer</code> 可以 <strong>提出提案</strong> (<code>Proposal</code>)。</p></li><li><p><strong>Accecptor</strong> : <code>Acceptor</code> 可以 <strong>接受提案</strong>。一旦接受提案，<strong>提案</strong> 里面的 <code>value</code> 值就被选定了。</p></li><li><p><strong>Learner</strong> : <code>Acceptor</code> 告诉 <code>Learner</code> 哪个提案被选定了，那么 <code>Learner</code> 就学习这个被选择的 <code>value</code>。</p></li></ol><p><img src="http://ols3fdyll.bkt.clouddn.com/propose_acceptor_learner.png" alt=""></p><blockquote><p>在具体的实现中，一个进程即可能是Proposer,也可能是Acceptor，也可能是Learner。</p></blockquote><h3 id="3-2-问题描述"><a href="#3-2-问题描述" class="headerlink" title="3.2. 问题描述"></a>3.2. 问题描述</h3><p><code>Paxos</code> 算法的核心是 <strong>一致性</strong>。所以将从一致性问题的描述来讲解该算法怎么解决实际问题。</p><h4 id="3-2-1-一致性算法的前置条件"><a href="#3-2-1-一致性算法的前置条件" class="headerlink" title="3.2.1. 一致性算法的前置条件"></a>3.2.1. 一致性算法的前置条件</h4><ol><li>在被提出的 <code>P</code> 中，只有一个 <code>V</code> 被选中。</li><li>如果没有 <code>P</code> 被提出，就没有 <code>V</code> 被选中。</li><li>在 <code>P</code> 被选定后，进程都可以学习被选中的 <code>P</code>。</li></ol><h4 id="3-2-2-不同角色通过发送消息进行通信"><a href="#3-2-2-不同角色通过发送消息进行通信" class="headerlink" title="3.2.2. 不同角色通过发送消息进行通信"></a>3.2.2. 不同角色通过发送消息进行通信</h4><ol><li><p>每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个 <code>value</code> 被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值。</p></li><li><p>消息在传递过程中可能出现 <strong>任意时长的延迟</strong>，可能会 <strong>重复</strong>，也可能 <strong>丢失</strong>，但是消息不会被 <strong>损坏</strong>。</p></li></ol><h3 id="3-3-推导过程"><a href="#3-3-推导过程" class="headerlink" title="3.3. 推导过程"></a>3.3. 推导过程</h3><h4 id="3-3-1-只有一个Acceptor"><a href="#3-3-1-只有一个Acceptor" class="headerlink" title="3.3.1. 只有一个Acceptor"></a>3.3.1. 只有一个Acceptor</h4><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_1.png" alt=""></p><p>一个 <code>Acceptor</code> 接受一个 <code>P</code>，那么只有一个 <code>V</code> 被选定。</p><blockquote><p>问题：如果这个 Acceptor 宕机，那么整个系统服务不可用。</p></blockquote><h3 id="3-3-2-多个Acceptor"><a href="#3-3-2-多个Acceptor" class="headerlink" title="3.3.2. 多个Acceptor"></a>3.3.2. 多个Acceptor</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/Multi_Acceptor.png" alt=""></p><blockquote><p>问题：如何在多 Proposer 和多 Acceptor 情况下，选定一个 value？</p></blockquote><p>讲解步骤分两阶段：<strong>约定</strong> <code>P1</code> 和 <strong>约定</strong> <code>P2</code>。</p><h4 id="3-3-2-1-约定P1"><a href="#3-3-2-1-约定P1" class="headerlink" title="3.3.2.1. 约定P1"></a>3.3.2.1. 约定P1</h4><blockquote><p><strong>P1</strong> ：一个 Acceptor 必须接受一个它收到的第一个 P。</p></blockquote><p>如果每个 Proposer 会产生不同的 P，那么多个 Proposer 必定产生多个 P，发给多个 Acceptor。根据 <strong>约定</strong> <code>P1</code>，<code>Acceptor</code> 分别接受到 <code>P</code>，就会导致不同的 <code>V</code> 被选定，如下图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_2.png" alt=""></p><p>如上图所示，<code>P1</code> 会产生的问题: <code>v1</code>、<code>v2</code>、<code>v3</code> 都没有被选定，因为他们只有被一个 <code>Acceptor</code> 接受。</p><p>对于上述问题，我们需要一个额外的约定: </p><blockquote><p><strong>P1a</strong> : 一个提案 P 被选定，需要被半数以上 Acceptor 接受.</p></blockquote><p>对于 <code>P1a</code>，其实就意味着 <strong>一个Acceptor必须接受不止一个提案</strong>。</p><p>显然，这与 <code>P1</code> 相矛盾，所以需要重新设计提案。原来的设计是: <code>[提案P = value]</code>，现在重新设计 <code>[提案P = 提案编号 + value]</code>，可表示为 <code>[M，V]</code>。</p><blockquote><p>新问题：多提案被选定，如何保证被选定的提案 P 具有相同的value?</p></blockquote><h4 id="3-3-2-2-约定P2"><a href="#3-3-2-2-约定P2" class="headerlink" title="3.3.2.2. 约定P2"></a>3.3.2.2. 约定P2</h4><blockquote><p><strong>P2</strong> : 如果提案 P[M0,V0] 被选定了，那么所有比 M0 编号更高的，且被选定的 P，其 value 的值也是 V0。</p></blockquote><p>对于 <code>P2</code> 中的 “<strong>被选定</strong>”：一个提案要被选定，首先至少要被一个 <code>Acceptor</code> 批准。因此，可以理解 <code>P2</code> 为：</p><blockquote><p><strong>P2a</strong> : 如果提案 P[M0,V0] 被选定了，那么所有比 M0 编号更高的，且 [被Acceptor批准] 的P，其 value 值也是 V0。</p></blockquote><p>只要满足 <code>P2a</code>，就能满足 <code>P2</code>。<strong>多提案被选择</strong> 的问题解决了，但是由于 <strong>网络不稳定</strong> 或者 <strong>宕机</strong> 的原因（不可避免），会产生新问题：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_4.png" alt=""></p><p>假设有 <code>5</code> 个 <code>Acceptor</code>。<code>Proposer2</code> 提出 <code>[M1,V1]</code>的提案，<code>Acceptor2~5</code>（<strong>半数以上</strong>）均接受了该提案，于是对于 <code>Acceptor2~5</code> 和 <code>Proposer2</code> 来讲，它们都认为 <code>V1</code> 被选定。<code>Acceptor1</code> 刚刚从 <strong>宕机状态</strong> 恢复过来（之前 <code>Acceptor1</code> 没有收到过任何提案），此时 <code>Proposer1</code> 向 <code>Acceptor1</code> 发送了 <code>[M2,V2]</code> 的提案 <strong>（V2≠V1且M2&gt;M1）</strong>。对于 <code>Acceptor1</code> 来讲，这是它收到的 <strong>第一个提案</strong>。根据 <code>P1</code>（一个 <code>Acceptor</code> 必须接受它收到的 <strong>第一个提案</strong>），<code>Acceptor1</code> 必须接受该提案。同时 <code>Acceptor1</code> 认为 <code>V2</code> 被选定。</p><p>这就出现了两个问题：</p><ol><li><p><code>Acceptor1</code> 认为 <code>V2</code> 被选定，<code>Acceptor2~5</code> 和<code>Proposer2</code> 认为 <code>V1</code> 被选定。出现了<strong>不一致</strong>。</p></li><li><p><code>V1</code> 被选定了，但是 <strong>编号更高</strong> 的被 <code>Acceptor1</code> 接受的提案 <code>[M2,V2]</code> 的 <code>value</code> 为 <code>V2</code>，且 <strong>V2≠V1</strong>。这就跟 <code>P2a</code>（如果某个 <code>value</code> 为 <code>v</code>的提案被选定了，那么每个 <strong>编号更高</strong> 的被 <code>Acceptor</code> 接受的提案的 <code>value</code> 必须也是 <code>v</code>）<strong>矛盾</strong>了。</p></li></ol><p>基于以上问题，所有就有了 <code>P2b</code>:</p><blockquote><p><strong>P2b</strong> : 如果 P[M0,V0] 被选定后，任何 Proposer 产生的 P，其值也是 V0。</p></blockquote><p>对于 <code>P2b</code> 中的描述，怎样保证 <strong>任何Proposer产生的P，其值也是V0</strong> ？只要满足 <code>P2c</code> 即可：</p><blockquote><p><strong>P2c</strong>: 对于任意的 M、V，如果 [M,V] 被提出，那么存在一个半数以上的 Acceptor 组成的组合 S，满足以下两个条件中的任何一个：<br>① S 中没有一个接受过编号小于 M 的提案。<br>② S 中的 Acceptor 接受过的最大编号的提案的 value 为 V。</p></blockquote><p>推导完毕。。。</p><h3 id="3-4-算法流程"><a href="#3-4-算法流程" class="headerlink" title="3.4. 算法流程"></a>3.4. 算法流程</h3><h4 id="3-4-1-Proposer提出提案"><a href="#3-4-1-Proposer提出提案" class="headerlink" title="3.4.1. Proposer提出提案"></a>3.4.1. Proposer提出提案</h4><p>总体思路如下：</p><h5 id="一-学习阶段：Prepare请求"><a href="#一-学习阶段：Prepare请求" class="headerlink" title="(一). 学习阶段：Prepare请求"></a>(一). 学习阶段：Prepare请求</h5><p><code>Proposer</code> 选择一个新的提案 <code>P[MN,?]</code> 向 <code>Acceptor</code> 集合 <code>S</code>（数目在<strong>半数以上</strong>）发送请求，要求 <code>S</code> 中的每一个 <code>Acceptor</code> 做出如下响应：</p><ol><li><p>如果 <code>Acceptor</code> 没有接受过提案，则向 <code>Proposer</code> 保证 <strong>不再接受编号小于N的提案</strong>。</p></li><li><p>如果 <code>Acceptor</code> 接受过请求，则向 <code>Proposer</code> 返回 <strong>已经接受过的编号小于N的编号最大的提案</strong>。</p></li></ol><h5 id="二-接受阶段：Acceptor请求"><a href="#二-接受阶段：Acceptor请求" class="headerlink" title="(二). 接受阶段：Acceptor请求"></a>(二). 接受阶段：Acceptor请求</h5><ol><li><p>如果 <code>Proposer</code> 收到 <strong>半数以上</strong> 的 <code>Acceptor</code> 响应，则 <strong>生成编号为</strong> <code>N</code>，<code>value</code> 为 <code>V</code> 的提案 <code>[MN,V]</code>，<code>V</code> 为所有响应中 <strong>编号最大</strong> 的提案的 <code>value</code>。</p></li><li><p>如果 <code>Proposer</code> 收到的响应中 <strong>没有提案</strong>，那么 <code>value</code> 由 <code>Proposer</code> <strong>自己生成</strong>，生成后将此提案发给 <code>S</code>，并期望 <code>Acceptor</code> 能接受此提案。</p></li></ol><h4 id="3-4-2-Acceptor接受提案"><a href="#3-4-2-Acceptor接受提案" class="headerlink" title="3.4.2. Acceptor接受提案"></a>3.4.2. Acceptor接受提案</h4><p><code>Acceptor</code> 可以忽略任何请求（包括 <code>Prepare</code> 请求和 <code>Accept</code> 请求）而不用担心破坏 <strong>算法的安全性</strong>。因此，我们这里要讨论的是什么时候 <code>Acceptor</code> 可以响应一个请求。</p><p>对 <code>Acceptor</code> 接受提案给出如下约束：</p><blockquote><p><strong>P1b</strong>：一个 Acceptor 只要尚未响应过任何编号大于 N 的 Prepare 请求，那么就可以接受这个编号为 N 的提案。</p></blockquote><p>如果 <code>Acceptor</code> 收到一个编号为 <code>N</code> 的 <code>Prepare</code> 请求，在此之前它已经 <strong>响应过</strong> 编号大于 <code>N</code> 的 <code>Prepare</code> 请求。根据 <code>P1b</code>，该 <code>Acceptor</code> 不可能接受编号为 <code>N</code> 的提案。因此，该 <code>Acceptor</code> 可以 <strong>忽略</strong> 编号为 <code>N</code> 的 <code>Prepare</code> 请求。当然，也可以回复一个 <code>error</code>，让 <code>Proposer</code> 尽早知道自己的提案 <strong>不会被接受</strong>。</p><p>因此，一个 <code>Acceptor</code> 只需记住：</p><ol><li>已接受的编号最大的提案；</li><li>已响应的请求的最大编号。</li></ol><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_5.png" alt=""></p><h2 id="4-Paxos算法描述"><a href="#4-Paxos算法描述" class="headerlink" title="4. Paxos算法描述"></a>4. Paxos算法描述</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_6.png" alt=""></p><h2 id="5-Learner学习提案"><a href="#5-Learner学习提案" class="headerlink" title="5. Learner学习提案"></a>5. Learner学习提案</h2><p><code>Learner</code> 学习（获取）被选定的 <code>value</code> 有如下三种方案:</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_7.png" alt=""></p><h2 id="6-如何保证Paxos算法的活性"><a href="#6-如何保证Paxos算法的活性" class="headerlink" title="6. 如何保证Paxos算法的活性"></a>6. 如何保证Paxos算法的活性</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_8.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>Paxos</code> 在 <strong>节点宕机恢复</strong>、<strong>消息无序或丢失</strong>、<strong>网络分化</strong> 的场景下能保证 <strong>数据的一致性</strong>。而 <code>Paxos</code> 的描述侧重于 <strong>理论</strong>，在实际项目应用中，处理了 <code>N</code> 多实际细节后，可能已经变成了另外一种算法，这时候正确性已经无法得到理论的保证。</p><p>要证明分布式一致性算法的正确性通常比实现算法还困难。所以很多系统实际中使用的都是以 <code>Paxos</code> <strong>理论</strong> 为基础而 <strong>衍生</strong> 出来的变种和简化版。例如 <code>Google</code> 的 <code>Chubby</code>、<code>MegaStore</code>、<code>Spanner</code> 等系统，<code>ZooKeeper</code> 的 <code>ZAB</code> 协议，还有更加容易理解的 <code>Raft</code> 协议。</p><p>大部分系统都是靠在实践中运行很长一段时间，经过验证发现系统已可以基本运行，没有发现大的问题才能上生产环境。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;世界上只有一种一致性算法，就是 &lt;code&gt;Paxos&lt;/code&gt;。出自一位 &lt;code&gt;Google&lt;/code&gt; 大神之口。&lt;code&gt;Paxos&lt;/code&gt; 也是出名的 &lt;strong&gt;晦涩难懂&lt;/strong&gt;，推理过程极其复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Paxos" scheme="https://ostenant.coding.me/tags/Paxos/"/>
    
  </entry>
  
</feed>
