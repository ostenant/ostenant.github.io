<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding | Harrison&#39;s Blog</title>
  
  <subtitle>上善若水任方猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ostenant.coding.me/"/>
  <updated>2018-05-08T02:49:46.097Z</updated>
  <id>https://ostenant.coding.me/</id>
  
  <author>
    <name>Chen Harrison</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蚂蚁金服RPC框架SOFA-RPC(一) - 初体验</title>
    <link href="https://ostenant.coding.me/2018/04/29/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8DRPC%E6%A1%86%E6%9E%B6SOFA-RPC(%E4%B8%80)%20-%20%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://ostenant.coding.me/2018/04/29/蚂蚁金服RPC框架SOFA-RPC(一) - 初体验/</id>
    <published>2018-04-29T09:59:00.000Z</published>
    <updated>2018-05-08T02:49:46.097Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SOFARPC 最早源于阿里内部的 HSF，是近期蚂蚁金服开源的一个高可扩展性、高性能、生产级的 Java RPC 框架。SOFA-RPC 在蚂蚁金服已经历了十多年的发展，致力于简化应用之间的 RPC 调用。为应用提供方便透明、稳定高效的点对点远程服务调用方案。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SOFA.JPG" alt=""></p><p>为了用户和开发者方便的进行功能扩展，SOFA-RPC 提供了丰富的模型抽象和可扩展接口，包括过滤器、路由、负载均衡等。同时围绕 SOFA-RPC 框架及其周边组件提供丰富的微服务治理方案。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-功能特性"><a href="#1-功能特性" class="headerlink" title="1. 功能特性"></a>1. 功能特性</h2><ul><li>透明化、高性能的远程服务调用</li><li>支持多种服务路由及负载均衡策略</li><li>支持多种注册中心的集成</li><li>支持 bolt、rest、dubbo 等多种通信协议  </li><li>支持同步、单向、回调、泛化等多种调用方式</li><li>支持集群容错、服务预热、自动故障隔离</li><li>强大的扩展功能，可以按需扩展各个功能组件</li></ul><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/sofa-rpc-quckstart.png" alt=""></p><p>a. 服务发布</p><blockquote><p>当一个 SOFARPC 的应用启动的时候，如果发现当前应用需要发布 RPC 服务的话，那么 SOFARPC 会将这些服务注册到服务注册中心上。如图中 Service 指向 Registry。</p></blockquote><p>b. 服务订阅</p><blockquote><p>当引用这个服务的 SOFARPC 应用启动时，会从服务注册中心订阅到相应服务的元数据信息。服务注册中心收到订阅请求后，会将发布方的元数据列表实时推送给服务引用方。如图中 Registry 指向 Reference。</p></blockquote><p>c. 服务调用</p><blockquote><p>当服务引用方拿到地址以后，就可以从中选取地址发起调用了。如图中 Reference 指向 Service。</p></blockquote><h2 id="3-快速开始"><a href="#3-快速开始" class="headerlink" title="3. 快速开始"></a>3. 快速开始</h2><h3 id="3-1-引入sofa-rpc依赖"><a href="#3-1-引入sofa-rpc依赖" class="headerlink" title="3.1. 引入sofa-rpc依赖"></a>3.1. 引入sofa-rpc依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-rpc-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-编写服务接口和服务实现类"><a href="#3-2-编写服务接口和服务实现类" class="headerlink" title="3.2. 编写服务接口和服务实现类"></a>3.2. 编写服务接口和服务实现类</h3><p>HelloService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String string)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Server receive: "</span> + string);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + string + <span class="string">" ！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-编写服务提供者启动类"><a href="#3-3-编写服务提供者启动类" class="headerlink" title="3.3. 编写服务提供者启动类"></a>3.3. 编写服务提供者启动类</h3><p>QuickStartServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerConfig serverConfig = <span class="keyword">new</span> ServerConfig()</span><br><span class="line">                .setProtocol(<span class="string">"bolt"</span>) <span class="comment">// 设置一个协议，默认bolt</span></span><br><span class="line">                .setPort(<span class="number">9696</span>) <span class="comment">// 设置一个端口，默认12200</span></span><br><span class="line">                .setDaemon(<span class="keyword">false</span>); <span class="comment">// 非守护线程</span></span><br><span class="line"></span><br><span class="line">        ProviderConfig&lt;HelloService&gt; providerConfig = <span class="keyword">new</span> ProviderConfig&lt;HelloService&gt;()</span><br><span class="line">                .setInterfaceId(HelloService.class.getName()) <span class="comment">// 指定接口</span></span><br><span class="line">                .setRef(<span class="keyword">new</span> HelloServiceImpl()) <span class="comment">// 指定实现</span></span><br><span class="line">                .setServer(serverConfig); <span class="comment">// 指定服务端</span></span><br><span class="line"></span><br><span class="line">        providerConfig.export(); <span class="comment">// 发布服务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行服务端提供方，日志输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sofa-Middleware-Log SLF4J Warn : No <span class="built_in">log</span> util is usable, Default app logger will be used.</span><br><span class="line">SLF4J: Failed to load class <span class="string">"org.slf4j.impl.StaticLoggerBinder"</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html<span class="comment">#StaticLoggerBinder for further details.</span></span><br><span class="line">Sofa-Middleware-Log SLF4J Warn : No <span class="built_in">log</span> util is usable, Default app logger will be used.</span><br></pre></td></tr></table></figure><h3 id="3-4-编写服务消费者启动类"><a href="#3-4-编写服务消费者启动类" class="headerlink" title="3.4. 编写服务消费者启动类"></a>3.4. 编写服务消费者启动类</h3><p>QuickStartClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConsumerConfig&lt;HelloService&gt; consumerConfig = <span class="keyword">new</span> ConsumerConfig&lt;HelloService&gt;()</span><br><span class="line">                .setInterfaceId(HelloService.class.getName()) <span class="comment">// 指定接口</span></span><br><span class="line">                .setProtocol(<span class="string">"bolt"</span>) <span class="comment">// 指定协议</span></span><br><span class="line">                .setDirectUrl(<span class="string">"bolt://127.0.0.1:9696"</span>); <span class="comment">// 指定直连地址</span></span><br><span class="line"></span><br><span class="line">        HelloService helloService = consumerConfig.refer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(helloService.sayHello(<span class="string">"world"</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行服务端消费方，调用服务提供方：</p><ul><li>服务提供方日志输出如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server receive: world</span><br><span class="line">Server receive: world</span><br><span class="line">Server receive: world</span><br><span class="line">Server receive: world</span><br></pre></td></tr></table></figure><ul><li>服务消费方日志输出如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">"org.slf4j.impl.StaticLoggerBinder"</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html<span class="comment">#StaticLoggerBinder for further details.</span></span><br><span class="line">Sofa-Middleware-Log SLF4J Warn : No <span class="built_in">log</span> util is usable, Default app logger will be used.</span><br><span class="line">Sofa-Middleware-Log SLF4J Warn : No <span class="built_in">log</span> util is usable, Default app logger will be used.</span><br><span class="line">hello world ！</span><br><span class="line">hello world ！</span><br><span class="line">hello world ！</span><br><span class="line">hello world ！</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这是一个快速入门的例子！</p><p>可以发现，在使用上，SOFA-RPC 与淘宝的 Dubbo，微博的 Motan 并无太大的区别。Dubbo 作为整套服务治理而存在，而 SOFA-RPC 只是一款轻量级的 RPC 框架，基于 HSF 框架改造，提供更加完善、强大的、多样化 RPC 编程 API。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SOFARPC 最早源于阿里内部的 HSF，是近期蚂蚁金服开源的一个高可扩展性、高性能、生产级的 Java RPC 框架。SOFA-RPC 在蚂蚁金服已经历了十多年的发展，致力于简化应用之间的 RPC 调用。为应用提供方便透明、稳定高效的点对点远程服务调用方案。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
      <category term="SOFA-RPC" scheme="https://ostenant.coding.me/tags/SOFA-RPC/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(四) - 3PC协议</title>
    <link href="https://ostenant.coding.me/2018/04/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E5%9B%9B)%20-%203PC%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ostenant.coding.me/2018/04/28/分布式理论(四) - 3PC协议/</id>
    <published>2018-04-28T13:26:00.000Z</published>
    <updated>2018-05-08T02:49:46.095Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷。所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/3PC.png" alt=""></p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><ol><li>引入超时机制 - 同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-三阶段提交的定义"><a href="#1-三阶段提交的定义" class="headerlink" title="1. 三阶段提交的定义"></a>1. 三阶段提交的定义</h2><p>三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p><p>所谓的三个阶段分别是：询问，然后再锁资源，最后真正提交。</p><ul><li>第一阶段：CanCommit</li><li>第二阶段：PreCommit</li><li>第三阶段：Do Commit</li></ul><h2 id="2-三阶段提交的过程"><a href="#2-三阶段提交的过程" class="headerlink" title="2. 三阶段提交的过程"></a>2. 三阶段提交的过程</h2><h3 id="2-1-阶段一：CanCommit"><a href="#2-1-阶段一：CanCommit" class="headerlink" title="2.1. 阶段一：CanCommit"></a>2.1. 阶段一：CanCommit</h3><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><p>a. 事务询问</p><blockquote><p>协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p></blockquote><p>b. 响应反馈</p><blockquote><p>参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态；否则反馈No。</p></blockquote><h3 id="2-2-阶段二：PreCommit"><a href="#2-2-阶段二：PreCommit" class="headerlink" title="2.2. 阶段二：PreCommit"></a>2.2. 阶段二：PreCommit</h3><p>协调者在得到所有参与者的响应之后，会根据结果执行2种操作：执行事务预提交，或者中断事务。</p><h4 id="2-2-1-执行事务预提交"><a href="#2-2-1-执行事务预提交" class="headerlink" title="2.2.1. 执行事务预提交"></a>2.2.1. 执行事务预提交</h4><p>a. 发送预提交请求</p><blockquote><p>协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态。</p></blockquote><p>b. 事务预提交</p><blockquote><p>参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 准备阶段中的 “执行事务”，也会 Undo 和 Redo 信息记录到事务日志中。</p></blockquote><p>c. 各参与者响应反馈</p><blockquote><p>如果参与者成功执行了事务，就反馈 ACK 响应，同时等待指令：提交（commit） 或终止（abort）。</p></blockquote><h4 id="2-2-2-中断事务"><a href="#2-2-2-中断事务" class="headerlink" title="2.2.2. 中断事务"></a>2.2.2. 中断事务</h4><p>a. 发送中断请求</p><blockquote><p>协调者向所有参与者节点发出 abort 请求 。</p></blockquote><p>b. 中断事务</p><blockquote><p>参与者如果收到 abort 请求或者超时了，都会中断事务。</p></blockquote><h3 id="2-3-阶段三：Do-Commit"><a href="#2-3-阶段三：Do-Commit" class="headerlink" title="2.3. 阶段三：Do Commit"></a>2.3. 阶段三：Do Commit</h3><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p><h4 id="2-3-1-执行提交"><a href="#2-3-1-执行提交" class="headerlink" title="2.3.1. 执行提交"></a>2.3.1. 执行提交</h4><p>a. 发送提交请求</p><blockquote><p>协调者接收到各参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。</p></blockquote><p>b. 事务提交</p><blockquote><p>参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p></blockquote><p>c. 响应反馈</p><blockquote><p>事务提交完之后，向协调者发送 ACK 响应。</p></blockquote><p>d. 完成事务</p><blockquote><p>协调者接收到所有参与者的 ACK 响应之后，完成事务。</p></blockquote><h4 id="2-3-2-中断事务"><a href="#2-3-2-中断事务" class="headerlink" title="2.3.2. 中断事务"></a>2.3.2. 中断事务</h4><p>协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><p>a. 发送中断请求</p><blockquote><p>协调者向所有参与者发送 abort 请求。</p></blockquote><p>b. 事务回滚</p><blockquote><p>参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></blockquote><p>c. 反馈结果</p><blockquote><p>参与者完成事务回滚之后，向协调者发送 ACK 消息。</p></blockquote><p>d. 中断事务</p><blockquote><p>协调者接收到参与者反馈的 ACK 消息之后，完成事务的中断。</p></blockquote><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h1><h2 id="3-1-三阶段提交的优点"><a href="#3-1-三阶段提交的优点" class="headerlink" title="3.1. 三阶段提交的优点"></a>3.1. 三阶段提交的优点</h2><p>相对于二阶段提交，三阶段提交主要解决的单点故障问题，并减少了阻塞的时间。</p><p>因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。</p><h3 id="3-2-三阶段提交的缺点"><a href="#3-2-三阶段提交的缺点" class="headerlink" title="3.2. 三阶段提交的缺点"></a>3.2. 三阶段提交的缺点</h3><p>三阶段提交也会导致数据一致性问题。由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。</p><p>这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。</p><hr><p>欢迎扫码关注公众号：零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷。所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="3PC" scheme="https://ostenant.coding.me/tags/3PC/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(三) - 2PC协议</title>
    <link href="https://ostenant.coding.me/2018/04/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%B8%89)%20-%202PC%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ostenant.coding.me/2018/04/25/分布式理论(三) - 2PC协议/</id>
    <published>2018-04-25T14:22:00.000Z</published>
    <updated>2018-05-08T02:49:46.095Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于BASE理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法和协议。其中比较著名的有二阶提交协议（2 Phase Commitment Protocol），三阶提交协议（3 Phase Commitment Protocol）和Paxos算法。</p><a id="more"></a><p>本文要介绍的2PC协议，分为两个阶段提交一个事务。并通过协调者和各个参与者的配合，实现分布式一致性。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/2PC.png" alt=""></p><p>两个阶段事务提交协议，由协调者和参与者共同完成。</p><table><thead><tr><th style="text-align:left">角色</th><th style="text-align:left">XA概念</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">协调者</td><td style="text-align:left">事务管理器</td><td style="text-align:left">协调各个参与者，对分布式事务进行提交或回滚</td></tr><tr><td style="text-align:left">参与者</td><td style="text-align:left">资源管理器</td><td style="text-align:left">分布式集群中的节点</td></tr></tbody></table><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1. 分布式事务"></a>1. 分布式事务</h2><p>分布式事务是指会涉及到操作多个数据库的事务，其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。</p><p>分布式事务处理的关键是：</p><ol><li>需要记录事务在任何节点所做的所有动作；</li><li>事务进行的所有操作要么全部提交，要么全部回滚。</li></ol><h2 id="2-XA规范"><a href="#2-XA规范" class="headerlink" title="2. XA规范"></a>2. XA规范</h2><h3 id="2-1-XA规范的组成"><a href="#2-1-XA规范的组成" class="headerlink" title="2.1. XA规范的组成"></a>2.1. XA规范的组成</h3><p>XA规范是由 X/Open组织（即现在的 Open Group ）定义的分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括：</p><ul><li>应用程序（ AP ）</li><li>事务管理器（ TM ）：交易中间件等</li><li>资源管理器（ RM ）：关系型数据库等</li><li>通信资源管理器（ CRM ）：消息中间件等</li></ul><h3 id="2-2-XA规范的定义"><a href="#2-2-XA规范的定义" class="headerlink" title="2.2. XA规范的定义"></a>2.2. XA规范的定义</h3><p>XA规范定义了交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。而XA接口函数由数据库厂商提供。</p><blockquote><p>二阶提交协议和三阶提交协议就是基于XA规范提出的其中，二阶段提交就是实现XA分布式事务的关键。</p></blockquote><h3 id="2-3-XA规范编程规范"><a href="#2-3-XA规范编程规范" class="headerlink" title="2.3. XA规范编程规范"></a>2.3. XA规范编程规范</h3><ol><li><p>配置TM，给TM注册RM作为数据源。其中，一个TM可以注册多个RM。</p></li><li><p>AP向TM发起一个全局事务。这时，TM会发送一个XID（全局事务ID）通知各个RM。</p></li><li><p>AP从TM获取资源管理器的代理（例如：使用JTA接口，从TM管理的上下文中，获取出这个TM所管理的RM的JDBC连接或JMS连接）。</p></li><li><p>AP通过从TM中获取的连接，间接操作RM进行业务操作。TM在每次AP操作时把XID传递给RM，RM正是通过这个XID关联来操作和事务的关系的。</p></li><li><p>AP结束全局事务时，TM会通知RM全局事务结束。开始二段提交，也就是prepare - commit的过程。</p></li></ol><p>XA规范的流程，大致如图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/XA_SEQ.png" alt=""></p><h2 id="3-二阶段提交（2PC）"><a href="#3-二阶段提交（2PC）" class="headerlink" title="3. 二阶段提交（2PC）"></a>3. 二阶段提交（2PC）</h2><h3 id="3-1-二阶段提交的定义"><a href="#3-1-二阶段提交的定义" class="headerlink" title="3.1. 二阶段提交的定义"></a>3.1. 二阶段提交的定义</h3><p>二阶段提交的算法思路可以概括为：每个参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报，决定各参与者是否要提交操作还是中止操作。</p><p>所谓的两个阶段分别是：</p><ul><li>第一阶段：准备阶段（投票阶段）</li><li>第二阶段：提交阶段（执行阶段）</li></ul><h4 id="3-1-1-准备阶段"><a href="#3-1-1-准备阶段" class="headerlink" title="3.1.1. 准备阶段"></a>3.1.1. 准备阶段</h4><p>准备阶段分为三个步骤：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/2PC_1.png" alt=""></p><p>a. 事务询问</p><blockquote><p>协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。</p></blockquote><p>b. 执行事务</p><blockquote><p>各参与者节点执行事务操作。如果本地事务成功，将Undo和Redo信息记入事务日志中，但不提交；否则，直接返回失败，退出执行。</p></blockquote><p>c. 各参与者向协调者反馈事务询问的响应</p><blockquote><p>如果参与者成功执行了事务操作，那么就反馈给协调者 Yes响应，表示事务可以执行提交；如果参与者没有成功执行事务，就返回No给协调者，表示事务不可以执行提交。</p></blockquote><h4 id="3-1-2-提交阶段"><a href="#3-1-2-提交阶段" class="headerlink" title="3.1.2. 提交阶段"></a>3.1.2. 提交阶段</h4><p>在提交阶段中，会根据准备阶段的投票结果执行2种操作：执行事务提交，中断事务。</p><p><strong>提交事务过程如下：</strong></p><p><img src="http://ols3fdyll.bkt.clouddn.com/2PC_21.png" alt=""></p><p>a. 发送提交请求</p><blockquote><p>协调者向所有参与者发出commit请求。</p></blockquote><p>b. 事务提交</p><blockquote><p>参与者收到commit请求后，会正式执行事务提交操作，并在完成提交之后，释放整个事务执行期间占用的事务资源。</p></blockquote><p>c. 反馈事务提交结果</p><blockquote><p>参与者在完成事务提交之后，向协调者发送Ack信息。</p></blockquote><p>d. 事务提交确认</p><blockquote><p>协调者接收到所有参与者反馈的Ack信息后，完成事务。</p></blockquote><p><strong>中断事务过程如下：</strong></p><p><img src="http://ols3fdyll.bkt.clouddn.com/2PC_22.png" alt=""></p><p>a. 发送回滚请求</p><blockquote><p>协调者向所有参与者发出Rollback请求。</p></blockquote><p>b. 事务回滚</p><blockquote><p>参与者接收到Rollback请求后，会利用其在提交阶段种记录的Undo信息，来执行事务回滚操作。在完成回滚之后，释放在整个事务执行期间占用的资源。</p></blockquote><p>c. 反馈事务回滚结果</p><blockquote><p>参与者在完成事务回滚之后，想协调者发送Ack信息。</p></blockquote><p>d. 事务中断确认</p><blockquote><p>协调者接收到所有参与者反馈的Ack信息后，完成事务中断。</p></blockquote><h3 id="3-1-二阶段提交的优缺点"><a href="#3-1-二阶段提交的优缺点" class="headerlink" title="3.1. 二阶段提交的优缺点"></a>3.1. 二阶段提交的优缺点</h3><ul><li>优点：原理简单，实现方便。</li><li>缺点：同步阻塞，单点问题，数据不一致，容错性不好。</li></ul><h4 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h4><p>在二阶段提交的过程中，所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。</p><h4 id="单点问题"><a href="#单点问题" class="headerlink" title="单点问题"></a>单点问题</h4><p>协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转。更重要的是，其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。</p><h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><p>假设当协调者向所有的参与者发送commit请求之后，发生了局部网络异常，或者是协调者在尚未发送完所有 commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了commit请求。这将导致严重的数据不一致问题。</p><h4 id="容错性不好"><a href="#容错性不好" class="headerlink" title="容错性不好"></a>容错性不好</h4><p>如果在二阶段提交的提交询问阶段中，参与者出现故障，导致协调者始终无法获取到所有参与者的确认信息，这时协调者只能依靠其自身的超时机制，判断是否需要中断事务。显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>对于2PC协议存在的同步阻塞、单点问题，将在下一篇文章的3PC协议中引入解决方案。</p><hr><p>欢迎扫码关注公众号：零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于BASE理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法和协议。其中比较著名的有二阶提交协议（2 Phase Commitment Protocol），三阶提交协议（3 Phase Commitment Protocol）和Paxos算法。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="2PC" scheme="https://ostenant.coding.me/tags/2PC/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(二) - BASE理论</title>
    <link href="https://ostenant.coding.me/2018/04/24/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%BA%8C)%20-%20BASE%E7%90%86%E8%AE%BA/"/>
    <id>https://ostenant.coding.me/2018/04/24/分布式理论(二) - BASE理论/</id>
    <published>2018-04-24T12:41:00.000Z</published>
    <updated>2018-05-08T02:49:46.095Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，才用适当的方式来使系统打到最终一致性。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-CAP的3选2伪命题"><a href="#1-CAP的3选2伪命题" class="headerlink" title="1. CAP的3选2伪命题"></a>1. CAP的3选2伪命题</h2><p>实际上，不是为了P（分区容错性），必须在C（一致性）和A（可用性）之间任选其一。分区的情况很少出现，CAP在大多时间能够同时满足C和A。</p><p>对于分区存在或者探知其影响的情况下，需要提供一种预备策略做出处理：</p><ul><li>探知分区的发生；</li><li>进入显示的分区模式，限制某些操作；</li><li>启动恢复过程，恢复数据一致性，补偿分区发生期间的错误。</li></ul><h2 id="2-BASE理论简介"><a href="#2-BASE理论简介" class="headerlink" title="2. BASE理论简介"></a>2. BASE理论简介</h2><p>BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p><p>其核心思想是：</p><blockquote><p>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p></blockquote><h2 id="3-BASE理论的内容"><a href="#3-BASE理论的内容" class="headerlink" title="3. BASE理论的内容"></a>3. BASE理论的内容</h2><ul><li>基本可用（Basically Available）</li><li>软状态（Soft State）</li><li>最终一致性（Eventually Consistent）</li></ul><p>下面展开讨论：</p><h3 id="3-1-基本可用"><a href="#3-1-基本可用" class="headerlink" title="3.1. 基本可用"></a>3.1. 基本可用</h3><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p><ol><li><p><strong>响应时间上的损失</strong>：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。</p></li><li><p><strong>功能上的损失</strong>：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p></li></ol><h3 id="3-2-软状态"><a href="#3-2-软状态" class="headerlink" title="3.2. 软状态"></a>3.2. 软状态</h3><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p><p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><h3 id="3-3-最终一致性"><a href="#3-3-最终一致性" class="headerlink" title="3.3. 最终一致性"></a>3.3. 最终一致性</h3><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p><p>而在实际工程实践中，最终一致性分为5种：</p><h4 id="3-3-1-因果一致性（Causal-consistency）"><a href="#3-3-1-因果一致性（Causal-consistency）" class="headerlink" title="3.3.1. 因果一致性（Causal consistency）"></a>3.3.1. 因果一致性（Causal consistency）</h4><p>因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。</p><h4 id="3-3-2-读己之所写（Read-your-writes）"><a href="#3-3-2-读己之所写（Read-your-writes）" class="headerlink" title="3.3.2. 读己之所写（Read your writes）"></a>3.3.2. 读己之所写（Read your writes）</h4><p>读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p><h4 id="3-3-3-会话一致性（Session-consistency）"><a href="#3-3-3-会话一致性（Session-consistency）" class="headerlink" title="3.3.3. 会话一致性（Session consistency）"></a>3.3.3. 会话一致性（Session consistency）</h4><p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p><h4 id="3-3-4-单调读一致性（Monotonic-read-consistency）"><a href="#3-3-4-单调读一致性（Monotonic-read-consistency）" class="headerlink" title="3.3.4. 单调读一致性（Monotonic read consistency）"></a>3.3.4. 单调读一致性（Monotonic read consistency）</h4><p>单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p><h4 id="3-3-5-单调写一致性（Monotonic-write-consistency）"><a href="#3-3-5-单调写一致性（Monotonic-write-consistency）" class="headerlink" title="3.3.5. 单调写一致性（Monotonic write consistency）"></a>3.3.5. 单调写一致性（Monotonic write consistency）</h4><p>单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p><blockquote><p>在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。</p></blockquote><p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p><hr><p>欢迎扫码关注公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，才用适当的方式来使系统打到最终一致性。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="BASE" scheme="https://ostenant.coding.me/tags/BASE/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(一) - CAP定理</title>
    <link href="https://ostenant.coding.me/2018/04/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%B8%80)%20-%20CAP%E5%AE%9A%E7%90%86/"/>
    <id>https://ostenant.coding.me/2018/04/23/分布式理论(一) - CAP定理/</id>
    <published>2018-04-23T12:33:00.000Z</published>
    <updated>2018-05-08T02:49:46.094Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这三个基本需求，最多只能同时满足其中的2个。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/CAP.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-CAP原则简介"><a href="#1-CAP原则简介" class="headerlink" title="1. CAP原则简介"></a>1. CAP原则简介</h2><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Consistency（一致性）</td><td style="text-align:left">指数据在多个副本之间能够保持一致的特性（严格的一致性）</td></tr><tr><td style="text-align:left">Availability（可用性）</td><td style="text-align:left">指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）</td></tr><tr><td style="text-align:left">Partition tolerance（分区容错性）</td><td style="text-align:left">分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障</td></tr></tbody></table><p><strong>什么是分区？</strong></p><blockquote><p>在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域，这就是分区。</p></blockquote><h2 id="2-CAP原则论证"><a href="#2-CAP原则论证" class="headerlink" title="2. CAP原则论证"></a>2. CAP原则论证</h2><p>如图所示，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/CAP_prove.png" alt=""></p><ul><li>在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。</li><li>在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。</li><li>在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</li></ul><p>如图所示，这是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库V0为V1。分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/CAP_prove2.png" alt=""></p><p>根据CAP原则定义，系统的一致性、可用性和分区容错性细分如下：</p><ul><li>一致性：N1和N2的数据库V之间的数据是否完全一样。</li><li>可用性：N1和N2的对外部的请求能否做出正常的响应。</li><li>分区容错性：N1和N2之间的网络是否互通。</li></ul><p>这是正常运作的场景，也是理想的场景。作为一个分布式系统，它和单机系统的最大区别，就在于网络。现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常。相当于要满足分区容错性，能不能同时满足一致性和可用性呢？还是说要对他们进行取舍？</p><p><img src="http://ols3fdyll.bkt.clouddn.com/CAP_prove3.png" alt=""></p><p>假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1。由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0。这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？</p><p>这里有两种选择：</p><ul><li>第一：牺牲数据一致性，保证可用性。响应旧的数据V0给用户。</li><li>第二：牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。</li></ul><p>这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p><h2 id="3-CAP原则权衡"><a href="#3-CAP原则权衡" class="headerlink" title="3. CAP原则权衡"></a>3. CAP原则权衡</h2><p>通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p><h3 id="3-1-CA-without-P"><a href="#3-1-CA-without-P" class="headerlink" title="3.1. CA without P"></a>3.1. CA without P</h3><p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。</p><h3 id="3-2-CP-without-A"><a href="#3-2-CP-without-A" class="headerlink" title="3.2. CP without A"></a>3.2. CP without A</h3><p>如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p><h3 id="3-3-AP-wihtout-C"><a href="#3-3-AP-wihtout-C" class="headerlink" title="3.3. AP wihtout C"></a>3.3. AP wihtout C</h3><p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>对于多数大型互联网应用的场景，主机众多、部署分散。而且现在的集群规模越来越大，所以节点故障、网络故障是常态。这种应用一般要保证服务可用性达到N个9，即保证P和A，只有舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p><p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证CP，舍弃A，例如网络故障时只读不写。</p><p>孰优孰劣，没有定论，只能根据场景定夺，适合的才是最好的。</p><hr><p>欢迎扫码关注公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这三个基本需求，最多只能同时满足其中的2个。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="CAP" scheme="https://ostenant.coding.me/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker + Consul + Nginx + Consul-template的服务负载均衡实现</title>
    <link href="https://ostenant.coding.me/2018/02/08/%E5%9F%BA%E4%BA%8EDocker%20+%20Consul%20+%20Nginx%20+%20Consul-template%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ostenant.coding.me/2018/02/08/基于Docker + Consul + Nginx + Consul-template的服务负载均衡实现/</id>
    <published>2018-02-08T03:03:00.000Z</published>
    <updated>2018-05-08T02:49:46.095Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章使用 <code>Consul</code> 和 <code>Registrator</code> 在 <code>docker</code> 的容器环境中搭建了<strong>服务注册和发现</strong>集群。在服务发现和注册的基础上，本文将引入 <code>Nginx</code>反向代理服务器和 <code>Consul-template</code> 组件，实现动态的<strong>服务负载均衡</strong>。</p><a id="more"></a><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-工具介绍"><a href="#1-工具介绍" class="headerlink" title="1. 工具介绍"></a>1. 工具介绍</h2><h2 id="1-1-Nginx"><a href="#1-1-Nginx" class="headerlink" title="1.1. Nginx"></a>1.1. Nginx</h2><p>一个高性能的 <code>HTTP</code> 和<strong>反向代理服务器</strong>，用于前端访问流量到后台应用服务器<strong>负载均衡</strong>和<strong>请求转发</strong>。</p><h2 id="1-2-Consul-template"><a href="#1-2-Consul-template" class="headerlink" title="1.2. Consul-template"></a>1.2. Consul-template</h2><p><code>Consul-template</code> 是 <code>HashiCorp</code> 基于 <code>Consul</code> 所提供的可扩展的工具，通过监听 <code>Consul</code> 中的<strong>数据变化</strong>，动态地修改一些<strong>配置文件</strong>中地<strong>模板</strong>。常用于在 <code>Nginx</code>、<code>HAProxy</code> 上动态配置健康状态下的客户端反向代理信息。</p><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h2><ul><li>通过 <code>Nginx</code> 自身实现<strong>负载均衡</strong>和<strong>请求转发</strong>；</li><li>通过 <code>Consul-template</code> 的 <code>config</code> 功能实时监控 <code>Consul</code> 集群节点的<strong>服务</strong>和<strong>数据</strong>的变化；</li><li>实时的用 <code>Consul</code> 节点的信息<strong>替换</strong> <code>Nginx</code> 配置文件的<strong>模板</strong>，并<strong>重新加载</strong>配置文件；</li></ul><blockquote><p><code>Consul-template</code> 和 <code>nginx</code> 必须安装在同一台机器上，因为 <code>Consul-template</code> 需要动态修改 <code>nginx</code> 的配置文件 <code>nginx.conf</code>，然后执行 <code>nginx -s reload</code> 命令进行路由更新，达到<strong>动态负载均衡</strong>的目的。</p></blockquote><h3 id="2-1-传统负载均衡"><a href="#2-1-传统负载均衡" class="headerlink" title="2.1. 传统负载均衡"></a>2.1. 传统负载均衡</h3><p>传统的负载均衡，就是 <code>Client</code> 支姐访问 <code>Nginx</code>，然后被转发到后端某一台 <code>Web Server</code>。如果后端有<strong>添加</strong>/<strong>删除</strong> <code>Web Server</code>，运维需要手动改下 <code>nginx.conf</code> ，然后<strong>重新载入配置</strong>，就可以动态的调整负载均衡。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/tranditional_nginx3.png" alt=""></p><h3 id="2-2-自动负载均衡"><a href="#2-2-自动负载均衡" class="headerlink" title="2.2. 自动负载均衡"></a>2.2. 自动负载均衡</h3><p>再看看基于服务自动发现和注册的负载均衡，负载均衡的方式没有变，只是多了一些<strong>外围组件</strong>，当然这些组件对 <code>Client</code> 是不可见的，<code>client</code> 依然只能看到 <code>Nginx</code> 入口，访问方式也没变化。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/service_registry_nginx.png" alt=""></p><p><code>Nginx</code> 的动态负载均衡实现流程如下：</p><ol><li>以相同的 <code>Consul</code> <strong>标签</strong>对 <code>Web Server</code> 进行<strong>服务标记</strong>和<strong>分类</strong>，<strong>新增</strong>或者<strong>删除</strong> <code>Web Server</code> 服务器节点；</li><li><code>Registrator</code> <strong>监控</strong>到 <code>Web Server</code> 的状态更新，自动在 <code>Consul</code>服务注册中心将它<strong>注册</strong>或者<strong>注销</strong>；</li><li><code>Consul-template</code> 订阅了 <code>Consul</code> 服务注册中心的<strong>服务消息</strong>，接收到 <code>Consul</code> 的消息推送，即 <code>Web Server</code> 服务节点<strong>状态</strong>发生改变。</li><li><code>Consul-template</code> 自动去修改和<strong>替换</strong> <code>Nginx</code> 服务器下的 <code>nginx</code>配置文件中的<strong>模板</strong>，并<strong>重新加载</strong>服务达到自动负载均衡的目的。</li></ol><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3. 环境准备"></a>3. 环境准备</h2><h3 id="3-1-系统环境"><a href="#3-1-系统环境" class="headerlink" title="3.1. 系统环境"></a>3.1. 系统环境</h3><table><thead><tr><th style="text-align:left">软件</th><th style="text-align:left">版本</th></tr></thead><tbody><tr><td style="text-align:left">操作系统</td><td style="text-align:left">Ubuntu：16.04 x86_64，内核：4.8.0-58-generic</td></tr><tr><td style="text-align:left">docker</td><td style="text-align:left">Docker version 1.12.6, build 78d1802</td></tr><tr><td style="text-align:left">docker-compose</td><td style="text-align:left">docker-compose version 1.8.0</td></tr></tbody></table><h3 id="3-2-节点规划"><a href="#3-2-节点规划" class="headerlink" title="3.2. 节点规划"></a>3.2. 节点规划</h3><table><thead><tr><th style="text-align:left">主机IP</th><th style="text-align:left">组件</th></tr></thead><tbody><tr><td style="text-align:left">192.168.1.181</td><td style="text-align:left">Consul Server, Registrator, Nginx, Consul-template</td></tr><tr><td style="text-align:left">192.168.1.186</td><td style="text-align:left">Consul Server, Registrator, Nginx, Consul-template</td></tr><tr><td style="text-align:left">192.168.1.182</td><td style="text-align:left">Consul Client, Registrator, Client WebApp1, Server WebApp1, Server WebApp2</td></tr><tr><td style="text-align:left">192.168.1.183</td><td style="text-align:left">Consul Client, Registrator, Client WebApp2, Server WebApp3, Server WebApp4</td></tr><tr><td style="text-align:left">192.168.1.185</td><td style="text-align:left">Consul Client, Registrator, Client WebApp3, Server WebApp5, Server WebApp6</td></tr></tbody></table><ul><li><strong>Client WebApp</strong>：提供基于<code>Thrift</code>的<code>RPC</code>客户端和基于<code>Http</code>协议的<code>RESTful</code>客户端，用于访问 <code>Server</code> 程序。</li><li><strong>Server WebApp</strong>：提供基于<code>Thrift</code>的<code>RPC</code>服务端和基于<code>Http</code>协议的<code>RESTful</code>服务端，供 <code>Client</code> 程序调用。</li></ul><p>这里的3台主机 - <code>192.168.1.182</code>、<code>192.168.1.183</code> 和 <code>192.168.1.185</code>，每台主机部署两个 <code>Client WebApp</code> 容器和一个 <code>Client Server</code> 容器，用于模拟<strong>服务层</strong>的负载均衡。</p><h3 id="3-3-镜像构建"><a href="#3-3-镜像构建" class="headerlink" title="3.3. 镜像构建"></a>3.3. 镜像构建</h3><ul><li><strong>Consul</strong>：consul:latest</li><li><strong>Registrator</strong>：gliderlabs/registrator:latest</li><li><strong>Nginx</strong>和<strong>Consul-template</strong>：liberalman/nginx-consul-template:latest</li><li><strong>Client WebApp</strong>：test-client:latest</li><li><strong>Server WebApp</strong>：test-server:latest</li></ul><p>这里先说说 <code>test-client</code> 和 <code>test-server</code> 的镜像构建：</p><ol><li>克隆项目到本地项目环境： <a href="https://github.com/ostenant/spring-cloud-starter-thrift" target="_blank" rel="noopener">https://github.com/ostenant/spring-cloud-starter-thrift</a></li><li>切换到子模块 <code>spring-cloud-starter-thrift-examples</code> 下的 <code>test</code> 目录，执行命令 <code>mvn clean package</code> 进行程序打包。</li><li>分别将 <code>test-client</code> 和 <code>test-server</code> 项目<strong>根目录</strong>下的 <code>Dockerfile</code> 文件和<code>target</code>目录下的 <code>target/*.jar</code>程序拷贝到 <code>192.168.1.182</code> 、<code>192.168.1.183</code> 和 <code>192.168.1.185</code> 目录下。</li><li>进入<strong>客户端</strong> <code>Dockerfile</code> 所在目录，对<strong>客户端</strong>程序 <code>test-client</code> 进行镜像构建，命令如下：<code>docker build . -t test-client:latest</code></li><li>进入<strong>服务端</strong> <code>Dockerfile</code> 所在目录，对<strong>服务端</strong>程序 <code>test-server</code> 进行镜像构建，命令如下：<code>docker build . -t test-server:latest</code></li></ol><p>构建完成后查看本地镜像库：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Test_Client_Test_Server_docker_images.png" alt=""></p><h3 id="3-4-部署模型"><a href="#3-4-部署模型" class="headerlink" title="3.4. 部署模型"></a>3.4. 部署模型</h3><p>五台主机，其中 <code>192.168.1.181</code> 和 <code>192.168.1.186</code> 两台主机的主要作用如下：</p><ol><li>作为<strong>负载均衡转发器</strong> (这里只是演示，可以通过 <code>KeepAlived</code> 实现 <code>Nginx</code> 的<code>HA</code>)，将前端访问流量经过<strong>负载算法</strong>一次转发到后台 <code>Client WebApp</code> 。</li><li>以 <code>Server</code>模式启动 <code>Consul</code>节点，其中一台作为整个<strong>服务发现与注册集群</strong>的 <code>leader</code>， 用于<strong>同步</strong>和<strong>持久化</strong>其余三台 <code>Client</code> 模式的 <code>Consul</code> 节点的<strong>数据</strong>和<strong>状态信息</strong>。</li></ol><p>其余三台主机 - <code>192.168.1.182</code>、<code>192.168.1.183</code> 和 <code>192.168.1.185</code>，充当的角色如下：</p><ol><li>每台分别以 <code>Client</code> 模式部署 <code>Consul</code> 节点，用于<strong>注册</strong>和<strong>发现</strong>本机 <code>docker</code> 容器暴露的服务，同时和 <code>Consul Server</code> 的  <code>leader</code> 节点进行<strong>服务状态同步</strong>。</li><li>分别启动一个 <code>Client WebApp</code> 容器实例和两个 <code>Server WebApp</code> 容器实例，将 <code>Client WebApp</code> 的请求根据<strong>服务层</strong>的负载算法<strong>二次转发</strong>到 <code>Server WebApp</code> 中的任意一台上完成具体的业务处理。</li></ol><p><img src="http://ols3fdyll.bkt.clouddn.com/deploy_integration_1.png" alt=""></p><p>这里有两次服务转发操作：</p><ul><li><strong>接入层的转发：</strong>两台 <code>Nginx</code> 服务器将客户流量，经由<strong>一次转发</strong>至三个 <code>Client WebApp</code> 服务实例中任意一个做处理。</li><li><strong>服务层的转发：</strong>三个 <code>Client WebApp</code>服务实例其中之一，根据从<strong>服务注册中心</strong>拉取的健康的<strong>服务缓存列表</strong>，将请求<strong>二次转发</strong>至六个 <code>Server WebApp</code>服务实例其中之一做处理。</li></ul><h3 id="3-5-开始搭建"><a href="#3-5-开始搭建" class="headerlink" title="3.5. 开始搭建"></a>3.5. 开始搭建</h3><h3 id="3-5-1-Consul-Server主机"><a href="#3-5-1-Consul-Server主机" class="headerlink" title="3.5.1. Consul Server主机"></a>3.5.1. Consul Server主机</h3><p>(a). 分别编写 <code>docker-compose.yml</code>，注意 <code>Registrator</code> 需要配置各自的 <code>IP</code>地址。</p><ul><li><strong>主机：192.168.1.181</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  load_balancer:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">liberalman/nginx-consul-template:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">lb</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="attr">      - consul_server_master:</span><span class="string">consul</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  consul_server_master:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">consul_server_master</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-server</span> <span class="bullet">-bootstrap-expect</span> <span class="number">1</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="bullet">-node</span> <span class="string">consul_server_master</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">registrator</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="attr">      - consul_server_master:</span><span class="string">consul</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="attr">consul://192.168.1.181:8500</span></span><br></pre></td></tr></table></figure><ul><li><strong>主机：192.168.1.186</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  load_balancer:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">liberalman/nginx-consul-template:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">lb</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="attr">      - consul_server_slave:</span><span class="string">consul</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  consul_server_slave:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">consul_server_slave</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-server</span> <span class="bullet">-join=192.168.1.181</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.186</span> <span class="bullet">-node</span> <span class="string">consul_server_slave</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">registrator</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="attr">      - consul_server_slave:</span><span class="string">consul</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.186</span> <span class="attr">consul://192.168.1.186:8500</span></span><br></pre></td></tr></table></figure><p>(b). 在两台主机上分别通过 <code>docker-compose</code> 启动多容器应用，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>这是在主机 <code>192.168.1.181</code> 上运行启动命令时的输出，可以看到 <code>docker-compose</code> 启动时会先去检查<strong>目标镜像文件</strong>是否拉取到本地，然后依次<strong>创建</strong>并<strong>启动</strong> <code>docker-compose.yml</code> 文件配置的<strong>容器实例</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_compose_consul_server_1_console_output.png" alt=""></p><p>(c). 查看正常启动的容器进程，观察<code>Consul</code>、<code>Registrator</code> 和 <code>Nginx</code>/<code>Consul-template</code>的容器都正常启动。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_ps_consul_server_1.png" alt=""></p><p>(d). 利用 <code>docker-compose</code>，以相同的方式在主机 <code>192.168.1.186</code> 上启动所配置的容器服务实例，查看启动状态如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_ps_consul_server_2.png" alt=""></p><p>(e). 访问 <code>http://IP:8500</code> 查看 <code>Consul Server</code> 的<strong>节点信息</strong>和<strong>服务注册列表</strong>。</p><ul><li>节点信息：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_server_master_ui2.png" alt=""></p><ul><li>服务状态列表：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_server_master_ui.png" alt=""></p><p>两台 <code>Consul Server</code> 主机上的容器服务实例均正常启动！</p><h3 id="3-5-2-Consul-Client主机"><a href="#3-5-2-Consul-Client主机" class="headerlink" title="3.5.2. Consul Client主机"></a>3.5.2. Consul Client主机</h3><p>一般情况下，我们把 <code>Consul</code> 作为服务注册与发现中心，会使用它提供的<strong>服务定义</strong> (<code>Service Definition</code>) 和<strong>健康检查定义</strong> (<code>Health Check Definition</code>) 功能，相关配置说明参考如下：</p><h4 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h4><table><thead><tr><th style="text-align:left">环境变量Key</th><th style="text-align:left">环境变量Value</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SERVICE_ID</td><td style="text-align:left">web-001</td><td style="text-align:left">可以为GUID或者可读性更强变量，保证不重复</td></tr><tr><td style="text-align:left">SERVICE_NAME</td><td style="text-align:left">web</td><td style="text-align:left">如果ID没有设置，Consul会将name作为id，则有可能注册失败</td></tr><tr><td style="text-align:left">SERVICE_TAGS</td><td style="text-align:left">nodejs,web</td><td style="text-align:left">服务的标签，用逗号分隔，开发者可以根据标签来查询一些信息</td></tr><tr><td style="text-align:left">SERVICE_IP</td><td style="text-align:left">内网IP</td><td style="text-align:left">要使用Consul，可访问的IP</td></tr><tr><td style="text-align:left">SERVICE_PORT</td><td style="text-align:left">50001</td><td style="text-align:left">应用的IP, 如果应用监听了多个端口，理应被视为多个应用</td></tr><tr><td style="text-align:left">SERVICE_IGNORE</td><td style="text-align:left">Boolean</td><td style="text-align:left">是否忽略本Container，可以为一些不需要注册的Container添加此属性</td></tr></tbody></table><h4 id="服健康检查定义"><a href="#服健康检查定义" class="headerlink" title="服健康检查定义"></a>服健康检查定义</h4><p>配置原则为: <code>SERVICE_XXX_*</code>。如果你的应用监听的是 <code>5000</code> 端口，则改为 <code>SERVICE_5000_CHECK_HTTP</code>，其它环境变量配置同理。</p><table><thead><tr><th style="text-align:left">环境变量Key</th><th style="text-align:left">环境变量Value</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">— 以下为HTTP模式</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_80_CHECK_HTTP</td><td style="text-align:left">/path_to_health_check</td><td style="text-align:left">你的健康状态检查的路径如 /status</td></tr><tr><td style="text-align:left">SERVICE_80_CHECK_INTERVAL</td><td style="text-align:left">15s</td><td style="text-align:left">15秒检查一次</td></tr><tr><td style="text-align:left">SERVICE_80_CHECK_TIMEOUT</td><td style="text-align:left">2s</td><td style="text-align:left">状态检查超时时间</td></tr><tr><td style="text-align:left">— 以下为HTTPS模式</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_HTTPS</td><td style="text-align:left">/path_to_health_check</td><td style="text-align:left">你的健康状态检查的路径如 /status</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_INTERVAL</td><td style="text-align:left">15s</td><td style="text-align:left">15秒检查一次</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_TIMEOUT</td><td style="text-align:left">2s</td><td style="text-align:left">状态检查超时时间</td></tr><tr><td style="text-align:left">— 以下为TCP模式</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_TCP</td><td style="text-align:left">/path_to_health_check</td><td style="text-align:left">你的健康状态检查的路径如 /status</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_INTERVAL</td><td style="text-align:left">15s</td><td style="text-align:left">15秒检查一次</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_TIMEOUT</td><td style="text-align:left">2s</td><td style="text-align:left">状态检查超时时间</td></tr><tr><td style="text-align:left">— 使用脚本检查</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_CHECK_SCRIPT</td><td style="text-align:left">curl –silent –fail example.com</td><td style="text-align:left">如官方例子中的check_redis.py</td></tr><tr><td style="text-align:left">— 其他</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_CHECK_INITIAL_STATUS</td><td style="text-align:left">passing</td><td style="text-align:left">Consul默认注册后的服务为failed</td></tr></tbody></table><h4 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h4><p>(a). 分别编写 <code>docker-compose.yml</code>，同样注意 <code>Registrator</code> 需要配置各自的 <code>IP</code> 地址。<code>test-server</code> 和 <code>test-client</code> 的<strong>服务实例</strong>在配置时需要指定相关的<strong>环境变量</strong>。</p><ul><li><strong>主机：192.168.1.182</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  consul_client_01:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-retry-join</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.182</span> <span class="bullet">-node</span> <span class="string">consul_client_01</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.182</span> <span class="attr">consul://192.168.1.182:8500</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"16000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"30000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"18000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"32000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_client_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-client:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=my-web-server</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-client-http-service-01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/features</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:8080"</span></span><br></pre></td></tr></table></figure><ul><li><strong>主机：192.168.1.183</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  consul_client_02:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-retry-join</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.183</span> <span class="bullet">-node</span> <span class="string">consul_client_02</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.183</span> <span class="attr">consul://192.168.1.183:8500</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-03</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-03</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"16000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"30000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-04</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-04</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"18000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"32000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_client_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-client:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=my-web-server</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-client-http-service-02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/features</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:8080"</span></span><br></pre></td></tr></table></figure><ul><li><strong>主机：192.168.1.185</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  consul_client_03:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-retry-join</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.185</span> <span class="bullet">-node</span> <span class="string">consul_client_03</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.185</span> <span class="attr">consul://192.168.1.185:8500</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-05</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-05</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"16000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"30000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-06</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-06</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"18000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"32000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_client_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-client:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=my-web-server</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-client-http-service-03</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/features</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:8080"</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>我们使用的第三方镜像 <code>liberalman/nginx-consul-template</code>，<code>Nginx</code> 会把名称为 <code>my-web-server</code>的<strong>服务容器</strong>作为后台转发的<strong>目标服务器</strong>，因此，在 <code>test-client</code> 的配置项中，需要指定 <code>SERVICE_XXX_NAME</code> 为 <code>my-web-server</code>。当然你也可以自己<strong>制作镜像</strong>指定<strong>模板</strong>。</p></blockquote><p>(b). 在三台主机上使用 <code>docker-compose</code> 启动多容器应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>以主机 <code>192.168.1.182</code> 为例 (其余两台类似)，控制台日志显示，创建并启动 <code>docker-compose.yml</code> 文件配置的5个<strong>容器实例</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_compose_web_server_console_output.png" alt=""></p><p>(c). 查看正常启动的容器进程，观察到 <code>Consul</code>、一台<code>test-client</code> 和 两台<code>test-server</code>的容器都正常启动。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_ps_web_server_1.png" alt=""></p><p>(d). 在 <code>b</code> 操作中的控制台输出可以看到：<code>docker-compose</code> 并非按照 <code>docker-compose.yml</code> 文件中服务配置的<strong>先后顺序</strong>启动。 <code>registrator</code> 容器的启动依赖于 <code>consul</code> 容器，而此时 <code>consul</code> 还并未启动，就出现了 <code>registrator</code> 优先启动而<strong>异常退出</strong>的现象。解决方法是再运行一次 <code>docker-compose up -d</code> 命令。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_compose_web_server_console_output2.png" alt=""></p><p>(e). 再次查看容器进程，此时 <code>Registrator</code> 容器就已经正常启动了。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_ps_web_server_2.png" alt=""></p><p>(f). 以相同的方式在其余两台主机上<strong>重复</strong>以上操作，再次访问 <code>http://IP:8500</code> 查看 <code>Consul Server</code> 的<strong>节点信息</strong>和<strong>服务注册列表</strong>。</p><ul><li><code>Consul</code> 集群节点信息，包括两台 <code>Consul Server</code> 节点和一台 <code>Consul Client</code> 节点，节点右侧可以看到所有的<strong>服务注册列表</strong>和相关的<strong>健康检查结果</strong>：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_client_01%20.png" alt=""></p><ul><li><code>nginx</code> 服务状态列表，服务名称 <code>nginx-consul-template</code>，提供 <code>http</code> 服务，共有2个服务实例：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/nginx-consul-template.png" alt=""></p><ul><li><code>test-client</code> 服务状态列表，服务名称为 <code>my-web-server</code>，提供 <code>http</code> 服务，共有3个服务实例：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/my_web_app.png" alt=""></p><ul><li><code>test-server</code> 服务状态列表，服务名称为 <code>test-server-http-service</code> 和 <code>test-server-thrift-service</code>，分别对应6个 <code>http</code> 服务实例和 6个 <code>thrift</code> 服务实例：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/test-server-http-service.png" alt=""></p><p><img src="http://ols3fdyll.bkt.clouddn.com/test-server-thrift-service.png" alt=""></p><p>三台  <code>Consul Client</code> 主机上的容器服务实例均正常启动，服务注册和发现运行正常！</p><h2 id="4-结果验证"><a href="#4-结果验证" class="headerlink" title="4. 结果验证"></a>4. 结果验证</h2><h3 id="4-1-Nginx负载均衡"><a href="#4-1-Nginx负载均衡" class="headerlink" title="4.1. Nginx负载均衡"></a>4.1. Nginx负载均衡</h3><h4 id="4-1-1-访问Nginx"><a href="#4-1-1-访问Nginx" class="headerlink" title="4.1.1. 访问Nginx"></a>4.1.1. 访问Nginx</h4><p><code>Nginx</code> 默认访问端口号为<code>80</code>，任选一台 <code>Nginx</code> 访问，比如： <code>http://192.168.1.181/swagger-ui.html</code>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/test_client_swagger_ui.png" alt=""></p><p>请求转发至 <code>Test Client</code> 的 <code>Swagger</code>页面，表明 <code>nginx</code>配置文件 <code>nginx.conf</code> 被 <code>Consul-template</code> 成功修改。</p><h4 id="4-1-2-进入Nginx容器"><a href="#4-1-2-进入Nginx容器" class="headerlink" title="4.1.2. 进入Nginx容器"></a>4.1.2. 进入Nginx容器</h4><p>运行 <code>docker ps</code> 查看 <code>nginx-consul-template</code> 的容器 <code>ID</code>，比如这里是：<code>4f2731a7e0cb</code>。进入 <code>nginx-consul-template</code> 容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-enter 4f2731a7e0cb</span><br></pre></td></tr></table></figure><p>查看容器内部的进程列表：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/nginx_consul_template_ps_ef.png" alt=""></p><p>特别留意以下一行进程命令，这里完成了三步重要的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul-template -consul-addr=consul:8500 -template /etc/consul-templates/nginx.conf.ctmpl:/etc/nginx/conf.d/app.conf:nginx -s reload</span><br></pre></td></tr></table></figure><ol><li><code>Consul-template</code> 利用 <code>Consul</code> 上的<strong>服务信息</strong>对 <code>Nginx</code> 的<strong>配置文件模板</strong> <code>/etc/consul-templates/nginx.conf.ctmpl</code> 进行重新<strong>解析</strong>和<strong>渲染</strong>。</li><li><strong>渲染</strong>生成的 <code>nginx</code> 配置文件为 <code>/etc/nginx/conf.d/app.conf</code>。</li><li>进一步运行 <code>nginx -s reload</code> 重新加载 <code>app.conf</code>，更新<strong>路由转发列表</strong>。</li></ol><p>查看 <code>app.conf</code> 的配置项，发现三个 <code>test-client</code> 节点的 <code>IP:port</code> 都加入了<strong>路由转发列表</strong>中。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/nginx_consul_template_app_conf.png" alt=""></p><p>退出并关闭主机 <code>192.168.1.182</code> 上的 <code>test-client</code> 容器。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_stop_test-client.png" alt=""></p><p>再次查看 <code>app.conf</code>，可以发现<strong>路由节点</strong> <code>192.168.1.182:80</code> 已经从 <code>Nginx</code> 的<strong>路由转发列表</strong>上<strong>剔除</strong>掉了。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/nginx_consul_template_app_conf2.png" alt=""></p><p>同样的，重新启动 <code>test-client</code> 恢复容器，又可以发现 <code>Nginx</code> 的<strong>路由转发列表</strong> 再次自动将其添加!</p><h3 id="4-2-服务负载均衡"><a href="#4-2-服务负载均衡" class="headerlink" title="4.2. 服务负载均衡"></a>4.2. 服务负载均衡</h3><h4 id="4-2-1-接口测试"><a href="#4-2-1-接口测试" class="headerlink" title="4.2.1. 接口测试"></a>4.2.1. 接口测试</h4><p><code>test-client</code> 通过 <code>http</code> 通信方式请求任意一台 <code>test-server</code>，返回响应结果 (请求处理时间 <code>ms</code> )。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/test_clent_api_test2.png" alt=""></p><p><code>test-client</code> 通过 <code>thrift</code> 通信方式请求任意一台 <code>test-server</code>，返回响应结果 (请求处理时间 <code>ms</code> )。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/test_clent_api_test.png" alt=""></p><h4 id="4-2-3-日志分析"><a href="#4-2-3-日志分析" class="headerlink" title="4.2.3. 日志分析"></a>4.2.3. 日志分析</h4><p><strong>服务的负载均衡</strong>并不是很好观察，这里直接截取了一段 <code>test-client</code> 的<strong>服务缓存列表</strong>动态定时刷新时打印的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">2018-02-09 13:15:55.157  INFO 1 --- [erListUpdater-1] t.c.l.ThriftConsulServerListLoadBalancer : Refreshed thrift serverList: [</span><br><span class="line"><span class="built_in">test</span>-server-thrift-service: [</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-01], host=<span class="string">'192.168.1.182'</span>, port=30000, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-02], host=<span class="string">'192.168.1.182'</span>, port=32000, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-03], host=<span class="string">'192.168.1.183'</span>, port=30000, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-04], host=<span class="string">'192.168.1.183'</span>, port=32000, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-05], host=<span class="string">'192.168.1.185'</span>, port=30000, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-06], host=<span class="string">'192.168.1.185'</span>, port=32000, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;</span><br><span class="line">],</span><br><span class="line"><span class="built_in">test</span>-server-http-service: [</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-01], host=<span class="string">'192.168.1.182'</span>, port=16000, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-02], host=<span class="string">'192.168.1.182'</span>, port=18000, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-03], host=<span class="string">'192.168.1.183'</span>, port=16000, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-04], host=<span class="string">'192.168.1.183'</span>, port=18000, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-05], host=<span class="string">'192.168.1.185'</span>, port=16000, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-06], host=<span class="string">'192.168.1.185'</span>, port=18000, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;</span><br><span class="line">],</span><br><span class="line">my-web-server: [</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'my-web-server'</span>, tags=[<span class="built_in">test</span>-client-http-service-01], host=<span class="string">'192.168.1.182'</span>, port=80, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'my-web-server'</span>, tags=[<span class="built_in">test</span>-client-http-service-02], host=<span class="string">'192.168.1.183'</span>, port=80, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'my-web-server'</span>, tags=[<span class="built_in">test</span>-client-http-service-03], host=<span class="string">'192.168.1.185'</span>, port=80, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;</span><br><span class="line">]]</span><br></pre></td></tr></table></figure><h4 id="服务实例"><a href="#服务实例" class="headerlink" title="服务实例"></a>服务实例</h4><ul><li><code>test-server-http-service</code> 所有<strong>健康</strong>的服务实例：</li></ul><table><thead><tr><th>服务IP地址</th><th>服务端口</th><th>服务标签</th></tr></thead><tbody><tr><td>192.168.1.182</td><td>16000</td><td>test-server-http-service-01</td></tr><tr><td>192.168.1.182</td><td>18000</td><td>test-server-http-service-02</td></tr><tr><td>192.168.1.183</td><td>16000</td><td>test-server-http-service-03</td></tr><tr><td>192.168.1.183</td><td>18000</td><td>test-server-http-service-04</td></tr><tr><td>192.168.1.185</td><td>16000</td><td>test-server-http-service-05</td></tr><tr><td>192.168.1.185</td><td>18000</td><td>test-server-http-service-06</td></tr></tbody></table><ul><li><code>test-server-thrift-service</code> 所有<strong>健康</strong>的服务实例：</li></ul><table><thead><tr><th>服务IP地址</th><th>服务端口</th><th>服务标签</th></tr></thead><tbody><tr><td>192.168.1.182</td><td>30000</td><td>test-server-thrift-service-01</td></tr><tr><td>192.168.1.182</td><td>32000</td><td>test-server-thrift-service-02</td></tr><tr><td>192.168.1.183</td><td>30000</td><td>test-server-thrift-service-03</td></tr><tr><td>192.168.1.183</td><td>32000</td><td>test-server-thrift-service-04</td></tr><tr><td>192.168.1.185</td><td>30000</td><td>test-server-thrift-service-05</td></tr><tr><td>192.168.1.185</td><td>32000</td><td>test-server-thrift-service-06</td></tr></tbody></table><ul><li><code>my-web-server</code> 所有<strong>健康</strong>的服务实例：</li></ul><table><thead><tr><th>服务IP地址</th><th>服务端口</th><th>服务标签</th></tr></thead><tbody><tr><td>192.168.1.182</td><td>80</td><td>test-client-http-service-01</td></tr><tr><td>192.168.1.183</td><td>80</td><td>test-client-http-service-02</td></tr><tr><td>192.168.1.185</td><td>80</td><td>test-client-http-service-03</td></tr></tbody></table><p><code>spring-cloud-starter-thrift</code> 采用的<strong>轮询</strong>的转发策略，也就是说 <code>my-web-server</code> 会按<strong>次序循环往来</strong>地将 <code>http</code> 或者 <code>rpc</code> 请求分发到各自的 <code>6</code> 个<strong>服务实例</strong>完成处理。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文提供了一套基于<strong>微服务服务注册与发现体系</strong>和<strong>容器</strong>的<strong>高可用</strong> (<code>HA</code>) 解决方案，引入了<strong>接入层</strong>和<strong>服务层</strong>的<strong>自动负载均衡</strong>的实现，详细给出了<strong>实践方案</strong>和<strong>技术手段</strong>！</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章使用 &lt;code&gt;Consul&lt;/code&gt; 和 &lt;code&gt;Registrator&lt;/code&gt; 在 &lt;code&gt;docker&lt;/code&gt; 的容器环境中搭建了&lt;strong&gt;服务注册和发现&lt;/strong&gt;集群。在服务发现和注册的基础上，本文将引入 &lt;code&gt;Nginx&lt;/code&gt;反向代理服务器和 &lt;code&gt;Consul-template&lt;/code&gt; 组件，实现动态的&lt;strong&gt;服务负载均衡&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Consul" scheme="https://ostenant.coding.me/tags/Consul/"/>
    
      <category term="Nginx" scheme="https://ostenant.coding.me/tags/Nginx/"/>
    
      <category term="Consul-template" scheme="https://ostenant.coding.me/tags/Consul-template/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker + Consul + Registrator的服务注册与发现集群搭建</title>
    <link href="https://ostenant.coding.me/2018/02/05/%E5%9F%BA%E4%BA%8EDocker%20+%20Consul%20+%20Registrator%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://ostenant.coding.me/2018/02/05/基于Docker + Consul + Registrator的服务注册与发现集群搭建/</id>
    <published>2018-02-05T03:22:00.000Z</published>
    <updated>2018-05-08T02:49:46.096Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近年微服务架构在互联网应用领域中愈来愈火，引入微服务主要解决了单体应用<strong>多个模块的紧耦合</strong>、<strong>无法扩展</strong>和<strong>运维困难</strong>等问题。微服务架构就是按照<strong>功能粒度</strong>将业务模块进行<strong>垂直拆分</strong>，对单体应用本身进行<strong>服务化</strong>和<strong>组件化</strong>，每个组件单独部署为<strong>小应用</strong>（从<code>DB</code>到<code>UI</code>）。微服务与微服务之间通过<code>Service API</code>进行交互，同时为了支持<strong>水平扩展</strong>、<strong>性能提升</strong>和<strong>服务可用性</strong>，单个服务允许同时部署一个或者多个<strong>服务实例</strong>。在运行时，每个实例通常是一个<strong>云虚拟机</strong>或者<code>Docker</code><strong>容器</strong>。</p><a id="more"></a><p>微服务系统内部多个服务的实例之间如何通信？如何感知到彼此的存在和销毁？生产者服务如何知道消费者服务的地址？如何实现服务与注册中心的解耦？这就需要一个第三方的服务注册中心，提供对生产者服务节点的注册管理和消费者服务节点的发现管理。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-服务发现与注册"><a href="#1-服务发现与注册" class="headerlink" title="1. 服务发现与注册"></a>1. 服务发现与注册</h2><h3 id="1-1-具体流程"><a href="#1-1-具体流程" class="headerlink" title="1.1. 具体流程"></a>1.1. 具体流程</h3><ul><li><strong>服务注册中心：</strong>作为整个架构中的核心，要支持<strong>分布式</strong>、<strong>持久化存储</strong>，<strong>注册信息变动</strong>实时通知消费者。</li><li><strong>服务提供者：</strong>服务以 <code>docker</code> <strong>容器化</strong>方式部署(实现<strong>服务端口</strong>的<strong>动态生成</strong>)，可以通过 <code>docker-compose</code> 的方式来管理。通过 <code>Registrator</code> 检测到 <code>docker</code> 进程信息以完成服务的<strong>自动注册</strong>。</li><li><strong>服务消费者：</strong>要使用<strong>服务提供者</strong>提供的服务，和服务提供者往往是动态相互转位置的。</li></ul><p>一个较为完整的服务注册与发现流程如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Service_registry_component.png" alt=""></p><ol><li><strong>注册服务：</strong>服务提供者到注册中心<strong>注册</strong>；</li><li><strong>订阅服务：</strong>服务消费者到注册中心<strong>订阅</strong>服务信息，对其进行<strong>监听</strong>；</li><li><strong>缓存服务列表：</strong>本地<strong>缓存</strong>服务列表，减少与注册中心的网络通信；</li><li><strong>调用服务：</strong>先<strong>查找</strong>本地缓存，找不到再去注册中心<strong>拉取</strong>服务地址，然后发送服务请求；</li><li><strong>变更通知：</strong>服务节点<strong>变动</strong>时 (<strong>新增</strong>、<strong>删除</strong>等)，注册中心将通知监听节点，<strong>更新</strong>服务信息。</li></ol><h3 id="1-2-相关组件"><a href="#1-2-相关组件" class="headerlink" title="1.2. 相关组件"></a>1.2. 相关组件</h3><p>一个服务发现系统主要由三部分组成：</p><ol><li><strong>注册器(registrator)：</strong>根据服务运行状态，注册/注销服务。主要要解决的问题是，何时发起注册/注销动作。</li><li><strong>注册表(registry)：</strong>存储服务信息。常见的解决方案有zookeeper、etcd、cousul等。</li><li><strong>发现机制(discovery)：</strong>从注册表读取服务信息，给用户封装访问接口。</li></ol><h3 id="1-3-第三方实现"><a href="#1-3-第三方实现" class="headerlink" title="1.3. 第三方实现"></a>1.3. 第三方实现</h3><p>对于第三方的服务注册与发现的实现，现有的工具主要有以下三种：</p><ol><li><strong>zookeeper：</strong>一个高性能、分布式应用程序协调服务，用于名称服务、分布式锁定、共享资源同步和分布式配置管理。</li><li><strong>Etcd：</strong>一个采用HTTP协议的健/值对存储系统，主要用于共享配置和服务发现，提供的功能相对Zookeeper和Consul相对简单。</li><li><strong>Consul：</strong>一个分布式高可用的服务发现和配置共享的软件，支持服务发现与注册、多数据中心、健康检查和分布式键/值存储。</li></ol><p>简单对比：</p><blockquote><p>与Zookeeper和etcd不一样，Consul内嵌实现了服务发现系统，不需要构建自己的系统或使用第三方系统，客户只需要注册服务，并通过DNS或HTTP接口执行服务发现。</p></blockquote><h2 id="2-Consul和Registrator"><a href="#2-Consul和Registrator" class="headerlink" title="2. Consul和Registrator"></a>2. Consul和Registrator</h2><h3 id="2-1-Consul简介"><a href="#2-1-Consul简介" class="headerlink" title="2.1. Consul简介"></a>2.1. Consul简介</h3><p><strong>Consul是什么</strong></p><p><code>Consul</code> 是一种<strong>分布式</strong>的、<strong>高可用</strong>、<strong>支持水平扩展</strong>的的服务注册与发现工具。它大致包括以下特性：</p><ul><li><strong>服务发现：</strong> <code>Consul</code> 通过 <code>DNS</code> 或者 <code>HTTP</code> 接口使<strong>服务注册和服务发现</strong>变的很容易。一些外部服务，例如 <code>saas</code> 提供的也可以一样注册；</li><li><strong>健康检查：</strong>健康检测使 <code>consul</code> 可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面；</li><li><strong>键/值存储：</strong>一个用来<strong>存储动态配置</strong>的系统。提供简单的 <code>HTTP</code> 接口，可以在任何地方操作；</li><li><strong>多数据中心：</strong>支持<strong>多数据中心</strong>以避免<strong>单点故障</strong>，内外网的服务采用不同的端口进行监听。而其部署则需要考虑网络延迟, 分片等情况等。<code>zookeeper</code>和<code>etcd</code>均不提供多数据中心功能的支持；</li><li><strong>一致性算法：</strong>采用 <code>Raft</code> 一致性协议算法，比<code>Paxos</code>算法好用。 使用 <code>GOSSIP</code> 协议管理成员和广播消息, 并且支持 <code>ACL</code> 访问控制；</li><li><strong>服务管理Dashboard：</strong>提供一个 <code>Web UI</code> 的服务注册于<strong>健康状态监控</strong>的管理页面。</li></ul><p><strong>Consul的几个概念</strong></p><p>下图是<code>Consul</code>官方文档提供的架构设计图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul-architecture.png" alt=""></p><p>图中包含两个<code>Consul</code>数据中心，每个数据中心都是一个<code>consul</code>的集群。在数据中心1中，可以看出<code>consul</code>的集群是由<code>N</code>个<code>SERVER</code>，加上<code>M</code>个<code>CLIENT</code>组成的。而不管是<code>SERVER</code>还是<code>CLIENT</code>，都是<code>consul</code>集群的一个节点。所有的服务都可以注册到这些节点上，正是通过这些节点实现服务注册信息的共享。除了这两个，还有一些小细节 一一 简单介绍。</p><ul><li><strong>CLIENT</strong></li></ul><p><code>CLIENT</code>表示<code>consul</code>的<code>client</code>模式，就是<strong>客户端模式</strong>。是<code>consul</code>节点的一种模式，这种模式下，所有注册到当前节点的服务会被<strong>转发</strong>到<code>SERVER</code>节点，本身是<strong>不持久化</strong>这些信息。</p><ul><li><strong>SERVER</strong></li></ul><p><code>SERVER</code>表示<code>consul</code>的<code>server</code>模式，表明这个<code>consul</code>是个<code>server</code>节点。这种模式下，功能和<code>CLIENT</code>都一样，唯一不同的是，它会把所有的信息<strong>持久化</strong>的本地。这样遇到故障，信息是可以被保留的。</p><ul><li><strong>SERVER-LEADER</strong></li></ul><p>中间那个<code>SERVER</code>下面有<code>LEADER</code>的描述，表明这个<code>SERVER</code>节点是它们的老大。和其它<code>SERVER</code>不一样的一点是，它需要负责<strong>同步注册信息</strong>给其它的<code>SERVER</code>，同时也要负责<strong>各个节点</strong>的<strong>健康监测</strong>。</p><ul><li><strong>其它信息</strong></li></ul><p>其它信息包括各个节点之间的<strong>通信方式</strong>，还有<strong>一些协议信息</strong>、<strong>算法</strong>。它们是用于保证节点之间的<strong>数据同步</strong>、<strong>实时性要求</strong>等等一系列集群问题的解决。这些有兴趣的自己看看官方文档。</p><h3 id="2-2-Registrator简介"><a href="#2-2-Registrator简介" class="headerlink" title="2.2. Registrator简介"></a>2.2. Registrator简介</h3><p><strong>什么是Registrator</strong><br><code>Registrator</code>是一个独立于服务注册表的<strong>自动服务注册/注销组件</strong>，一般以<code>Docker container</code>的方式进行部署。<code>Registrator</code>会自动侦测它所在的<strong>宿主机</strong>上的所有<code>Docker</code>容器状态（启用/销毁），并根据容器状态到对应的<strong>服务注册列表</strong>注册/注销服务。</p><p>事实上，<code>Registrator</code>通过读取同一台宿主机的其他容器<code>Container</code>的<strong>环境变量</strong>进行<strong>服务注册</strong>、<strong>健康检查定义</strong>等操作。</p><p><code>Registrator</code>支持<strong>可插拔式</strong>的<strong>服务注册表</strong>配置，目前支持包括<code>Consul</code>, <code>etcd</code>和<code>SkyDNS 2</code>三种注册工具。</p><h2 id="2-3-Docker安装Consul集群"><a href="#2-3-Docker安装Consul集群" class="headerlink" title="2.3. Docker安装Consul集群"></a>2.3. Docker安装Consul集群</h2><h3 id="2-3-1-集群节点规划"><a href="#2-3-1-集群节点规划" class="headerlink" title="2.3.1.  集群节点规划"></a>2.3.1.  集群节点规划</h3><p>我本地的使用的是<code>Ubuntu16.04</code>的虚拟机：</p><table><thead><tr><th>容器名称</th><th>容器IP地址</th><th>映射端口号</th><th>宿主机IP地址</th><th>服务运行模式</th></tr></thead><tbody><tr><td>node1</td><td>172.17.0.2</td><td>8500 -&gt; 8500</td><td>192.168.127.128</td><td>Server Master</td></tr><tr><td>node2</td><td>172.17.0.3</td><td>9500 -&gt; 8500</td><td>192.168.127.128</td><td>Server</td></tr><tr><td>node3</td><td>172.17.0.4</td><td>10500 -&gt; 8500</td><td>192.168.127.128</td><td>Server</td></tr><tr><td>node4</td><td>172.17.0.5</td><td>11500 -&gt; 8500</td><td>192.168.127.128</td><td>Client</td></tr></tbody></table><h3 id="2-3-2-Consul集群安装"><a href="#2-3-2-Consul集群安装" class="headerlink" title="2.3.2. Consul集群安装"></a>2.3.2. Consul集群安装</h3><p><code>Consul</code>的配置参数信息说明：</p><table><thead><tr><th>参数列表</th><th>参数的含义和使用场景说明</th></tr></thead><tbody><tr><td>advertise</td><td>通知展现地址用来改变我们给集群中的其他节点展现的地址，一般情况下-bind地址就是展现地址</td></tr><tr><td>bootstrap</td><td>用来控制一个server是否在bootstrap模式，在一个datacenter中只能有一个server处于bootstrap模式，当一个server处于bootstrap模式时，可以自己选举为raft leader</td></tr><tr><td>bootstrap-expect</td><td>在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用</td></tr><tr><td>bind</td><td>该地址用来在集群内部的通讯IP地址，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0</td></tr><tr><td>client</td><td>consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1</td></tr><tr><td>config-file</td><td>明确的指定要加载哪个配置文件</td></tr><tr><td>config-dir</td><td>配置文件目录，里面所有以.json结尾的文件都会被加载</td></tr><tr><td>data-dir</td><td>提供一个目录用来存放agent的状态，所有的agent允许都需要该目录，该目录必须是稳定的，系统重启后都继续存在</td></tr><tr><td>dc</td><td>该标记控制agent允许的datacenter的名称，默认是dc1</td></tr><tr><td>encrypt</td><td>指定secret key，使consul在通讯时进行加密，key可以通过consul keygen生成，同一个集群中的节点必须使用相同的key</td></tr><tr><td>join</td><td>加入一个已经启动的agent的ip地址，可以多次指定多个agent的地址。如果consul不能加入任何指定的地址中，则agent会启动失败，默认agent启动时不会加入任何节点</td></tr><tr><td>retry-interval</td><td>两次join之间的时间间隔，默认是30s</td></tr><tr><td>retry-max</td><td>尝试重复join的次数，默认是0，也就是无限次尝试</td></tr><tr><td>log-level</td><td>consul agent启动后显示的日志信息级别。默认是info，可选：trace、debug、info、warn、err</td></tr><tr><td>node</td><td>节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名</td></tr><tr><td>protocol</td><td>consul使用的协议版本</td></tr><tr><td>rejoin</td><td>使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中</td></tr><tr><td>server</td><td>定义agent运行在server模式，每个集群至少有一个server，建议每个集群的server不要超过5个</td></tr><tr><td>syslog</td><td>开启系统日志功能，只在linux/osx上生效</td></tr><tr><td>pid-file</td><td>提供一个路径来存放pid文件，可以使用该文件进行SIGINT/SIGHUP(关闭/更新)agent</td></tr></tbody></table><h2 id="2-4-Docker安装Consul集群"><a href="#2-4-Docker安装Consul集群" class="headerlink" title="2.4. Docker安装Consul集群"></a>2.4. Docker安装Consul集群</h2><h3 id="2-4-1-拉取consul官方镜像"><a href="#2-4-1-拉取consul官方镜像" class="headerlink" title="2.4.1. 拉取consul官方镜像"></a>2.4.1. 拉取consul官方镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker pull consul:latest</span><br></pre></td></tr></table></figure><h3 id="2-4-2-启动Server节点"><a href="#2-4-2-启动Server节点" class="headerlink" title="2.4.2. 启动Server节点"></a>2.4.2. 启动Server节点</h3><p>运行<code>consul</code>镜像，启动<code>Server Master</code>节点<code>node1</code>：</p><p><strong>node1</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=node1 --restart=always \</span><br><span class="line">             -e <span class="string">'CONSUL_LOCAL_CONFIG=&#123;"skip_leave_on_interrupt": true&#125;'</span> \</span><br><span class="line">             -p 8300:8300 \</span><br><span class="line">             -p 8301:8301 \</span><br><span class="line">             -p 8301:8301/udp \</span><br><span class="line">             -p 8302:8302/udp \</span><br><span class="line">             -p 8302:8302 \</span><br><span class="line">             -p 8400:8400 \</span><br><span class="line">             -p 8500:8500 \</span><br><span class="line">             -p 8600:8600 \</span><br><span class="line">             -h node1 \</span><br><span class="line">             consul agent -server -<span class="built_in">bind</span>=172.17.0.2 -bootstrap-expect=3 -node=node1 \</span><br><span class="line">             -data-dir=/tmp/data-dir -client 0.0.0.0 -ui</span><br></pre></td></tr></table></figure></p><p>查看<code>node1</code>的日志，追踪运行情况：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node1_logs_1.png" alt=""></p><p>现在集群中还没有选举<code>leader</code>节点，继续启动其余两台<code>Server</code>节点<code>node2</code>和<code>node3</code>：</p><p><strong>node2</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=node2 --restart=always \</span><br><span class="line">             -e <span class="string">'CONSUL_LOCAL_CONFIG=&#123;"skip_leave_on_interrupt": true&#125;'</span> \</span><br><span class="line">             -p 9300:8300  \</span><br><span class="line">             -p 9301:8301 \</span><br><span class="line">             -p 9301:8301/udp \</span><br><span class="line">             -p 9302:8302/udp \</span><br><span class="line">             -p 9302:8302 \</span><br><span class="line">             -p 9400:8400 \</span><br><span class="line">             -p 9500:8500 \</span><br><span class="line">             -p 9600:8600 \</span><br><span class="line">             -h node2 \</span><br><span class="line">             consul agent -server -<span class="built_in">bind</span>=172.17.0.3 \</span><br><span class="line">             -join=192.168.127.128 -node-id=$(uuidgen | awk <span class="string">'&#123;print tolower($0)&#125;'</span>) \</span><br><span class="line">             -node=node2 \</span><br><span class="line">             -data-dir=/tmp/data-dir -client 0.0.0.0 -ui</span><br></pre></td></tr></table></figure></p><p>查看<code>node2</code>节点的进程启动日志：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node2_logs_1.png" alt=""></p><p><strong>node3</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=node3 --restart=always \</span><br><span class="line">             -e <span class="string">'CONSUL_LOCAL_CONFIG=&#123;"skip_leave_on_interrupt": true&#125;'</span> \</span><br><span class="line">             -p 10300:8300  \</span><br><span class="line">             -p 10301:8301 \</span><br><span class="line">             -p 10301:8301/udp \</span><br><span class="line">             -p 10302:8302/udp \</span><br><span class="line">             -p 10302:8302 \</span><br><span class="line">             -p 10400:8400 \</span><br><span class="line">             -p 10500:8500 \</span><br><span class="line">             -p 10600:8600 \</span><br><span class="line">             -h node2 \</span><br><span class="line">             consul agent -server -<span class="built_in">bind</span>=172.17.0.4 \</span><br><span class="line">             -join=192.168.127.128 -node-id=$(uuidgen | awk <span class="string">'&#123;print tolower($0)&#125;'</span>) \</span><br><span class="line">             -node=node3 \</span><br><span class="line">             -data-dir=/tmp/data-dir -client 0.0.0.0 -ui</span><br></pre></td></tr></table></figure></p><p>查看<code>node3</code>节点的进程启动日志：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node3_logs_1.png" alt=""></p><p>当3个<code>Server</code>节点都启动并正常运行时，观察<code>node2</code>和<code>node3</code>的进程日志，可以发现<code>node1</code>被选举为<code>leader</code>节点，也就是这个<strong>数据中心</strong>的<code>Server Master</code>。</p><p>再次查看<code>node1</code>节点的进程启动日志：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node1_logs_2.png" alt=""></p><p>观察日志发现，<code>node2</code>和<code>node3</code>都成功join到了<code>node1</code>所在的数据中心<code>dc1</code>。当集群中有3台<code>Consul Server</code>启动时，<code>node1</code>被选举为<code>dc1</code>中的主节点。然后，<code>node1</code>会通过心跳检查的方式，不断地对<code>node2</code>和<code>node3</code>进行健康检查。</p><h3 id="2-4-4-启动Client节点"><a href="#2-4-4-启动Client节点" class="headerlink" title="2.4.4. 启动Client节点"></a>2.4.4. 启动Client节点</h3><p><strong>node4</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=node4  --restart=always \</span><br><span class="line">            -e <span class="string">'CONSUL_LOCAL_CONFIG=&#123;"leave_on_terminate": true&#125;'</span> \</span><br><span class="line">            -p 11300:8300 \</span><br><span class="line">            -p 11301:8301 \</span><br><span class="line">            -p 11301:8301/udp \</span><br><span class="line">            -p 11302:8302/udp \</span><br><span class="line">            -p 11302:8302 \</span><br><span class="line">            -p 11400:8400 \</span><br><span class="line">            -p 11500:8500 \</span><br><span class="line">            -p 11600:8600 \</span><br><span class="line">            -h node4 \</span><br><span class="line">            consul agent -<span class="built_in">bind</span>=172.17.0.5 -retry-join=192.168.127.128  \</span><br><span class="line">            -node-id=$(uuidgen | awk <span class="string">'&#123;print tolower($0)&#125;'</span>) \</span><br><span class="line">            -node=node4 -client 0.0.0.0 -ui</span><br></pre></td></tr></table></figure><p>查看<code>node4</code>节点的进程启动日志:</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node4_logs_2.png" alt=""></p><p>可以发现：<code>node4</code>是以<code>Client</code>模式启动运行的。启动后完成后，把<code>dc1</code>数据中心中的以<code>Server</code>模式启动的节点<code>node1</code>、<code>node2</code>和<code>node3</code>都添加到<strong>本地缓存列表</strong>中。当客户端向<code>node4</code>发起服务发现的请求后，<code>node4</code>会通过<code>RPC</code>将请求转发给<code>Server</code>节点中的其中一台做处理。</p><h3 id="2-4-5-查看集群状态"><a href="#2-4-5-查看集群状态" class="headerlink" title="2.4.5. 查看集群状态"></a>2.4.5. 查看集群状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker <span class="built_in">exec</span> -t node1 consul members</span><br></pre></td></tr></table></figure><p><code>dc1</code>数据中心中的4个节点<code>node1</code>, <code>node2</code>, <code>node3</code>和<code>node4</code>分别成功启动，<code>Status</code>表示他们的状态，都为<code>alive</code>。<code>node1</code>, <code>node2</code>, <code>node3</code>以<code>Server</code>模式启动，而<code>node4</code>以<code>Client</code>模式启动。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_members.png" alt=""></p><h2 id="2-5-Docker安装Registrator"><a href="#2-5-Docker安装Registrator" class="headerlink" title="2.5. Docker安装Registrator"></a>2.5. Docker安装Registrator</h2><h3 id="2-5-1-拉取Registrator的镜像"><a href="#2-5-1-拉取Registrator的镜像" class="headerlink" title="2.5.1. 拉取Registrator的镜像"></a>2.5.1. 拉取Registrator的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker pull gliderlabs/registrator:latest</span><br></pre></td></tr></table></figure><h3 id="2-5-2-启动Registrator节点"><a href="#2-5-2-启动Registrator节点" class="headerlink" title="2.5.2. 启动Registrator节点"></a>2.5.2. 启动Registrator节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=registrator \</span><br><span class="line">             -v /var/run/docker.sock:/tmp/docker.sock \</span><br><span class="line">             --net=host \</span><br><span class="line">             gliderlabs/registrator -ip=<span class="string">"192.168.127.128"</span> consul://192.168.127.128:8500</span><br></pre></td></tr></table></figure><blockquote><p> –net指定为host表明使用主机模式。<br> -ip用于指定宿主机的IP地址，用于健康检查的通信地址。<br> consul://192.168.127.128:8500: 使用Consul作为服务注册表，指定具体的Consul通信地址进行服务注册和注销（注意：8500是Consul对外暴露的HTTP通信端口）。</p></blockquote><p>查看<code>Registrator</code>的容器进程启动日志：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/registrator_logs_1.png" alt=""></p><p><code>Registrator</code>在启动过程完成了以下几步操作：</p><ol><li>查看Consul数据中心的leader节点，作为服务注册表；</li><li>同步当前宿主机的启用容器，以及所有的服务端口；</li><li>分别将各个容器发布的服务地址/端口注册到Consul的服务注册列表。</li></ol><h3 id="2-5-3-查看Consul的注册状态"><a href="#2-5-3-查看Consul的注册状态" class="headerlink" title="2.5.3. 查看Consul的注册状态"></a>2.5.3. 查看Consul的注册状态</h3><p><code>Consul</code>提供了一个<code>Web UI</code>来可视化<strong>服务注册列表</strong>、<strong>通信节点</strong>、<strong>数据中心</strong>和<strong>键/值存储</strong>等，直接访问宿主机的<code>8500</code>端口。</p><p><strong>服务注册列表</strong>：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_ui_1.png" alt=""></p><p><code>NODES</code>节点下挂载着<code>dc1</code>数据中心中的所有的<code>Consul</code>节点，包括<code>Consul Server</code>和<code>Client</code>。</p><p><strong>通信节点列表</strong>：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_ui_2.png" alt=""></p><p>启动<code>Registrator</code>以后，宿主机中的所有容器把服务都注册到<code>Consul</code>的<code>SERVICES</code>上，测试完成！</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>单数据中心</strong>的<code>Consul</code>集群的搭建就完成了！！！后续章节我会介绍如何使用<code>Registrator</code>进行服务注册的<strong>标签化</strong>。然后通过<code>docker</code>部署<strong>多实例</strong>的<code>Web</code>容器来实现基于<code>HTTP</code>的<code>RESTful Service</code>和基于<code>TCP</code>的<code>RPC Service</code>的<strong>服务注册</strong>和<strong>健康检查定义</strong>，并演示如何以<strong>标签</strong>标识一个服务的多个实例。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;近年微服务架构在互联网应用领域中愈来愈火，引入微服务主要解决了单体应用&lt;strong&gt;多个模块的紧耦合&lt;/strong&gt;、&lt;strong&gt;无法扩展&lt;/strong&gt;和&lt;strong&gt;运维困难&lt;/strong&gt;等问题。微服务架构就是按照&lt;strong&gt;功能粒度&lt;/strong&gt;将业务模块进行&lt;strong&gt;垂直拆分&lt;/strong&gt;，对单体应用本身进行&lt;strong&gt;服务化&lt;/strong&gt;和&lt;strong&gt;组件化&lt;/strong&gt;，每个组件单独部署为&lt;strong&gt;小应用&lt;/strong&gt;（从&lt;code&gt;DB&lt;/code&gt;到&lt;code&gt;UI&lt;/code&gt;）。微服务与微服务之间通过&lt;code&gt;Service API&lt;/code&gt;进行交互，同时为了支持&lt;strong&gt;水平扩展&lt;/strong&gt;、&lt;strong&gt;性能提升&lt;/strong&gt;和&lt;strong&gt;服务可用性&lt;/strong&gt;，单个服务允许同时部署一个或者多个&lt;strong&gt;服务实例&lt;/strong&gt;。在运行时，每个实例通常是一个&lt;strong&gt;云虚拟机&lt;/strong&gt;或者&lt;code&gt;Docker&lt;/code&gt;&lt;strong&gt;容器&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Consul" scheme="https://ostenant.coding.me/tags/Consul/"/>
    
      <category term="Registrator" scheme="https://ostenant.coding.me/tags/Registrator/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud整合Thrift RPC(二) - 应用案例</title>
    <link href="https://ostenant.coding.me/2018/01/24/Spring%20Cloud%E6%95%B4%E5%90%88Thrift%20RPC(%E4%BA%8C)%20-%20%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>https://ostenant.coding.me/2018/01/24/Spring Cloud整合Thrift RPC(二) - 应用案例/</id>
    <published>2018-01-24T02:21:00.000Z</published>
    <updated>2018-05-08T02:49:46.092Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇简单的阐述了 <code>spring-cloud-thrift-starter</code> 这个插件的配置和使用，并引入了一个<code>calculator</code>的项目。本文将基于一个银行存款、取款的业务场景，给出一套<code>thrift</code>在生产环境的应用案例。</p><a id="more"></a><p>首先设计如下几张简单的数据库表：银行(<code>bank</code>)、分支(<code>branch</code>)、银行卡(<code>deposit_card</code>)、客户(<code>customer</code>)、存款历史纪录(<code>deposit_history</code>)、取款历史纪录(<code>withdraw_history</code>)。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring_cloud_thrift_deposit_table_design.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>项目结构如下，依然是由三个模块组成：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring-cloud-starter-thrift-deposit-project-structure.png" alt=""></p><ul><li>deposit<ul><li>deposit-client</li><li>deposit-iface</li><li>deposit-server</li></ul></li></ul><h3 id="Thrift-IDL编写"><a href="#Thrift-IDL编写" class="headerlink" title="Thrift IDL编写"></a>Thrift IDL编写</h3><p>关于 <code>thrift</code>更复杂的用法可以参考<code>Apache Thrift</code>基础学习系列，根据<strong>数据库表</strong>的设计编写 <code>deposit.thrift</code>。</p><p><code>deposit.thrift</code>定义了以下四个部分：<strong>命名空间</strong> (<code>namespace</code>)、<strong>枚举类型</strong> (<code>enum</code>)、<strong>结构类型</strong> (<code>struct</code>)和<strong>服务类型</strong> (<code>service</code>)。</p><p>(a). <strong>命名空间</strong> (<code>namespace</code>)</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定编译生成的源代码的包路径名称</span></span><br><span class="line"><span class="keyword">namespace</span> java com.icekredit.rpc.thrift.examples.thrift</span><br></pre></td></tr></table></figure><p>(b). <strong>枚举类型</strong> (<code>enum</code>)</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过枚举定义银行分支所属区域</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ThriftRegion</span> </span>&#123;</span><br><span class="line">   NORTH = <span class="number">1</span>,</span><br><span class="line">   CENTRAL = <span class="number">2</span>,</span><br><span class="line">   SOUTH = <span class="number">3</span>,</span><br><span class="line">   EAST = <span class="number">4</span>,</span><br><span class="line">   SOUTHWEST = <span class="number">5</span>,</span><br><span class="line">   NORTHWEST = <span class="number">6</span>,</span><br><span class="line">   NORTHEAST = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存款完成状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ThriftDepositStatus</span> </span>&#123;</span><br><span class="line">   FINISHED = <span class="number">1</span>,</span><br><span class="line">   PROCCEDING = <span class="number">2</span>,</span><br><span class="line">   FAILED = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取款完成状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ThriftWithdrawStatus</span> </span>&#123;</span><br><span class="line">   FINISHED = <span class="number">1</span>,</span><br><span class="line">   PROCCEDING = <span class="number">2</span>,</span><br><span class="line">   FAILED = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(c). <strong>结构类型</strong> (<code>struct</code>)</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 银行</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftBank</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">i64</span> id,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> code,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> name,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">optional</span> <span class="built_in">string</span> description,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> map&lt;ThriftRegion, list&lt;ThriftBranch&gt;&gt; branches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行分支</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftBranch</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">i64</span> id,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> code,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> name,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">required</span> <span class="built_in">string</span> address,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> <span class="built_in">i32</span> staffs,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> ThriftBank bank,</span><br><span class="line">   <span class="number">7</span>: <span class="keyword">optional</span> ThriftRegion region</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftCustomer</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> IDNumber,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> name,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> birthday,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">required</span> <span class="built_in">i32</span> sex = <span class="number">0</span>,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">required</span> <span class="built_in">i32</span> age,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> list&lt;<span class="keyword">string</span>&gt; address,</span><br><span class="line">   <span class="number">7</span>: <span class="keyword">optional</span> set&lt;ThriftDepositCard&gt; depositCards</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行卡</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftDepositCard</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> id,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">bool</span> isVip,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> openingTime,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">required</span> <span class="built_in">double</span> accountBalance,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> <span class="built_in">double</span> accountFlow,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> ThriftBranch branch,</span><br><span class="line">   <span class="number">7</span>: <span class="keyword">optional</span> ThriftCustomer customer,</span><br><span class="line">   <span class="number">8</span>: <span class="keyword">optional</span> list&lt;ThriftDeposit&gt; depositHistory,</span><br><span class="line">   <span class="number">9</span>: <span class="keyword">optional</span> list&lt;ThriftWithdraw&gt; WithdrawHistory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存款历史纪录</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftDeposit</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> serialNumber,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">double</span> transactionAmount,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> submittedTime,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">optional</span> <span class="built_in">string</span> finishedTime,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> ThriftDepositStatus status,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> ThriftDepositCard depositCard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取款历史纪录</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftWithdraw</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> serialNumber,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">double</span> transactionAmount,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> submittedTime,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">optional</span> <span class="built_in">string</span> finishedTime,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> ThriftWithdrawStatus status,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> ThriftDepositCard depositCard</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(d). <strong>服务类型</strong> (<code>service</code>)</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 银行 - 业务服务定义</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ThriftBankService</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span> registerNewBank(ThriftBank bank);</span><br><span class="line">   list&lt;ThriftBank&gt; queryAllBanks();</span><br><span class="line">   ThriftBank getBankById(<span class="built_in">i64</span> bankId);</span><br><span class="line">   map&lt;ThriftRegion, list&lt;ThriftBranch&gt;&gt; queryAllBranchesByRegion(<span class="built_in">i64</span> bankId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行分支 - 业务服务定义</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ThriftBranchService</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span> addNewBranch(<span class="built_in">i64</span> bankId, ThriftBranch branch);</span><br><span class="line">   list&lt;ThriftBranch&gt; queryAllBranches(<span class="built_in">i64</span> bankId);</span><br><span class="line">   ThriftBranch getBranchById(<span class="built_in">i64</span> branchId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户 - 业务服务定义</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ThriftCustomerService</span> </span>&#123;</span><br><span class="line">   ThriftCustomer getCustomerById(<span class="built_in">string</span> customerId);</span><br><span class="line">   list&lt;ThriftCustomer&gt; queryAllCustomers();</span><br><span class="line">   <span class="keyword">void</span> addNewUser(ThriftCustomer customer);</span><br><span class="line">   <span class="keyword">void</span> modifyUserById(<span class="built_in">string</span> customerId, ThriftCustomer customer);</span><br><span class="line">   <span class="built_in">i32</span> getTotalDepositCard(<span class="built_in">string</span> customerId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行卡 - 业务服务定义</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ThriftDepositCardService</span> </span>&#123;</span><br><span class="line">   set&lt;ThriftDepositCard&gt; queryAllDepositCards(<span class="built_in">string</span> customerId);</span><br><span class="line">   <span class="keyword">void</span> addNewDepositCard(<span class="built_in">string</span> customerId, ThriftDepositCard depositCard);</span><br><span class="line">   ThriftDepositStatus depositMoney(<span class="built_in">string</span> depositCardId, <span class="built_in">double</span> money);</span><br><span class="line">   ThriftWithdrawStatus withdrawMoney(<span class="built_in">string</span> depositCardId, <span class="built_in">double</span> money);</span><br><span class="line">   list&lt;ThriftDeposit&gt; queryDepositHistorys(<span class="built_in">string</span> depositCardId);</span><br><span class="line">   list&lt;ThriftWithdraw&gt; queryWithdrawHistorys(<span class="built_in">string</span> depositCardId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>src/main/thrift</code>目录，编译生成所需的<strong>枚举类</strong>、<strong>结构类</strong>和<strong>业务服务类</strong>的源文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -gen java ./deposit.thrift</span><br></pre></td></tr></table></figure><p>所有生成的源文件都位于同一个<strong>命名空间(包)</strong>下面：<code>com.icekredit.rpc.thrift.examples.thrift</code></p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring-cloud-starter-thrift-deposit-generate-code.png" alt=""></p><h2 id="中间契约-deposit-iface"><a href="#中间契约-deposit-iface" class="headerlink" title="中间契约(deposit-iface)"></a>中间契约(deposit-iface)</h2><p>将<strong>上述源文件</strong>拷贝到 <code>deposit-iface</code> 模块中。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring-cloud-starter-thrift-deposit-thrift-iface.png" alt=""></p><p>通过<code>Mybatis</code>逆向工程插件生成<code>SQLMapper</code>的<code>XML</code>和<strong>接口</strong>文件以及<strong>实体类</strong>。</p><blockquote><p><strong>友情提示</strong>：<code>Mybatis</code>逆向工程生成的<strong>实体类</strong> (<code>entity</code>)，需要和<code>Thrift</code>编译生成器生成的<strong>结构类</strong> (<code>struct</code>) 区分开来。而<code>Thrift</code>生成器生成的所有源文件，都一定程度封装了底层的<strong>通信方式</strong>和<strong>相关协议</strong>，开发人员是不应该动手脚的。</p></blockquote><p>为了在<code>Thrift</code>中通过<code>Mybatis</code>完成<strong>数据持久化</strong>，必须在<strong>实体类</strong> (<code>entity</code>)包装一层与<strong>结构类</strong> (<code>struct</code>)相互转换的方法。<br>在每个实体类中，根据业务添加以下两个方法，以<code>DepositCard</code>为例：</p><ul><li><strong>toThrift()</strong>：将<strong>实体类对象</strong>转换为<strong>结构类对象</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ThriftDepositCard <span class="title">toThrift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThriftDepositCard thriftDepositCard = <span class="keyword">new</span> ThriftDepositCard();</span><br><span class="line">    thriftDepositCard.setId(<span class="keyword">this</span>.getId());</span><br><span class="line">    thriftDepositCard.setAccountBalance(<span class="keyword">this</span>.getAccountBalance());</span><br><span class="line">    thriftDepositCard.setAccountFlow(<span class="keyword">this</span>.getAccountFlow());</span><br><span class="line">    thriftDepositCard.setIsVip(<span class="keyword">this</span>.getIsVip());</span><br><span class="line">    thriftDepositCard.setOpeningTime(<span class="keyword">this</span>.getOpeningTime());</span><br><span class="line"></span><br><span class="line">    ThriftBranch thriftBranch = <span class="keyword">new</span> ThriftBranch();</span><br><span class="line">    thriftBranch.setId(<span class="keyword">this</span>.getBranchId());</span><br><span class="line">    thriftDepositCard.setBranch(thriftBranch);</span><br><span class="line"></span><br><span class="line">    ThriftCustomer thriftCustomer = <span class="keyword">new</span> ThriftCustomer();</span><br><span class="line">    thriftCustomer.setIDNumber(<span class="keyword">this</span>.getCustomerId());</span><br><span class="line">    thriftDepositCard.setCustomer(thriftCustomer);</span><br><span class="line">    <span class="keyword">return</span> thriftDepositCard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>fromThrift()</strong>：<strong>静态</strong>方法，将<strong>结构类对象</strong>转换为<strong>实体类对象</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DepositCard <span class="title">fromThrift</span><span class="params">(ThriftDepositCard thriftDepositCard)</span> </span>&#123;</span><br><span class="line">    DepositCard depositCard = <span class="keyword">new</span> DepositCard();</span><br><span class="line">    depositCard.setId(thriftDepositCard.getId());</span><br><span class="line">    depositCard.setAccountBalance(thriftDepositCard.getAccountBalance());</span><br><span class="line">    depositCard.setAccountFlow(thriftDepositCard.getAccountFlow());</span><br><span class="line">    depositCard.setIsVip(thriftDepositCard.isIsVip());</span><br><span class="line"></span><br><span class="line">    ThriftCustomer thriftCustomer = thriftDepositCard.getCustomer();</span><br><span class="line">    <span class="keyword">if</span> (thriftCustomer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String customerIDNumber = thriftCustomer.getIDNumber();</span><br><span class="line">        depositCard.setCustomerId(customerIDNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThriftBranch thriftBranch = thriftDepositCard.getBranch();</span><br><span class="line">    <span class="keyword">if</span> (thriftBranch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Long branchId = thriftBranch.getId();</span><br><span class="line">        depositCard.setBranchId(branchId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depositCard.setOpeningTime(thriftDepositCard.getOpeningTime());</span><br><span class="line">    <span class="keyword">return</span> depositCard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端-deposit-server"><a href="#服务端-deposit-server" class="headerlink" title="服务端(deposit-server)"></a>服务端(deposit-server)</h2><p>在服务端模块引入：</p><ul><li><strong>spring-cloud-starter-thrift-server</strong>：<code>thrift</code>服务端的 <code>starter</code>程序。</li><li><strong>calculator-iface</strong>：中间契约模块，这里作为服务端骨架(<code>Skeleton</code>)程序。</li></ul><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Thrift相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-thrift-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringBoot依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Swagger依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中配置<code>thrift</code>服务端的<strong>运行参数</strong>、<strong>数据源连接池参数</strong>和<code>Mybatis</code>相关属性：</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">  actuator:</span></span><br><span class="line"><span class="attr">    sensitive:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    druid:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://localhost:3306/deposit?useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">      driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  thrift:</span></span><br><span class="line"><span class="attr">    server:</span></span><br><span class="line"><span class="attr">      service-id:</span> <span class="string">deposit-server-rpc</span></span><br><span class="line"><span class="attr">      service-model:</span> <span class="string">hsHa</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">25000</span></span><br><span class="line"><span class="attr">      worker-queue-capacity:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">      hs-ha:</span></span><br><span class="line"><span class="attr">        min-worker-threads:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        max-worker-threads:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">        keep-alived-time:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  mapper-locations:</span> <span class="attr">classpath:mapper/*.xml</span></span><br><span class="line"><span class="attr">  type-aliases-package:</span> <span class="string">com.icekredit.rpc.thrift.examples.http.entities</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    root:</span> <span class="string">INFO</span></span><br><span class="line"><span class="attr">    com:</span></span><br><span class="line"><span class="attr">      icekredit:</span></span><br><span class="line"><span class="attr">        rpc:</span></span><br><span class="line"><span class="attr">          thrift:</span></span><br><span class="line"><span class="attr">            examples:</span></span><br><span class="line"><span class="attr">              mapper:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><p>服务端程序启动入口类，设置 <code>Swagger API</code>所在的包路径名称。</p><p>Application.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestfulApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.icekredit.rpc.thrift.examples.service.http.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"Deposit Server"</span>)</span><br><span class="line">                .description(<span class="string">"Deposit Server"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写服务端的<code>Thrift</code>的实现，以<code>ThriftDepositCardService</code>为例，由实现类<code>ThriftDepositCardServiceImpl</code>实现<code>ThriftDepositCardService.Iface</code>接口的方法：</p><p>ThriftDepositCardServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftService</span>(name = <span class="string">"thriftDepositCardService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThriftDepositCardServiceImpl</span> <span class="keyword">implements</span> <span class="title">ThriftDepositCardService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BranchMapper branchMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DepositCardMapper depositCardMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerMapper customerMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DepositHistoryMapper depositHistoryMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WithdrawHistoryMapper withdrawHistoryMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThriftDepositCardServiceImpl</span><span class="params">(BranchMapper branchMapper, DepositCardMapper depositCardMapper, CustomerMapper customerMapper, DepositHistoryMapper depositHistoryMapper, WithdrawHistoryMapper withdrawHistoryMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.branchMapper = branchMapper;</span><br><span class="line">        <span class="keyword">this</span>.depositCardMapper = depositCardMapper;</span><br><span class="line">        <span class="keyword">this</span>.customerMapper = customerMapper;</span><br><span class="line">        <span class="keyword">this</span>.depositHistoryMapper = depositHistoryMapper;</span><br><span class="line">        <span class="keyword">this</span>.withdrawHistoryMapper = withdrawHistoryMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ThriftDepositCard&gt; <span class="title">queryAllDepositCards</span><span class="params">(String customerId)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        List&lt;DepositCard&gt; depositCardList = depositCardMapper.queryAllDepositCards(customerId);</span><br><span class="line">        <span class="comment">// 查询客户持有的银行卡</span></span><br><span class="line">        <span class="keyword">return</span> depositCardList.stream().map(depositCard -&gt; &#123;</span><br><span class="line">            ThriftDepositCard thriftDepositCard = depositCard.toThrift();</span><br><span class="line">            Long branchId = depositCard.getBranchId();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(branchId) &amp;&amp; branchId &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                Branch branch = branchMapper.findById(branchId);</span><br><span class="line">                ThriftBranch thriftBranch = branch.toThrift();</span><br><span class="line">                ThriftBank thriftBank = <span class="keyword">new</span> ThriftBank();</span><br><span class="line">                thriftBank.setId(branch.getBankId());</span><br><span class="line">                thriftBranch.setBank(thriftBank);</span><br><span class="line">                thriftDepositCard.setBranch(thriftBranch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Customer customer = customerMapper.findById(customerId);</span><br><span class="line">            ThriftCustomer thriftCustomer = customer.toThrift();</span><br><span class="line">            thriftDepositCard.setCustomer(thriftCustomer);</span><br><span class="line">            <span class="keyword">return</span> thriftDepositCard;</span><br><span class="line">        &#125;).collect(Collectors.toSet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewDepositCard</span><span class="params">(String customerId, ThriftDepositCard depositCard)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        DepositCard newDepositCard = DepositCard.fromThrift(depositCard);</span><br><span class="line">        <span class="comment">// 新增银行卡信息</span></span><br><span class="line">        depositCardMapper.save(newDepositCard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThriftDepositStatus <span class="title">depositMoney</span><span class="params">(String depositCardId, <span class="keyword">double</span> money)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DepositHistory depositHistory = <span class="keyword">new</span> DepositHistory();</span><br><span class="line">            depositHistory.setSubmittedTime(sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            depositCardMapper.incrementMoney(depositCardId, money);</span><br><span class="line">            depositHistory.setFinishedTime(sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            depositHistory.setSerialNumber(UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">            depositHistory.setTransactionAmount(money);</span><br><span class="line">            depositHistory.setDepositCardId(depositCardId);</span><br><span class="line">            depositHistory.setStatus(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 新增存款历史记录</span></span><br><span class="line">            depositHistoryMapper.save(depositHistory);</span><br><span class="line">            <span class="keyword">return</span> ThriftDepositStatus.FINISHED;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> ThriftDepositStatus.FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThriftWithdrawStatus <span class="title">withdrawMoney</span><span class="params">(String depositCardId, <span class="keyword">double</span> money)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WithdrawHistory withdrawHistory = <span class="keyword">new</span> WithdrawHistory();</span><br><span class="line">            withdrawHistory.setSubmittedTime(sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            depositCardMapper.decrementMoney(depositCardId, money);</span><br><span class="line">            withdrawHistory.setFinishedTime(sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            withdrawHistory.setSerialNumber(UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">            withdrawHistory.setTransactionAmount(money);</span><br><span class="line">            withdrawHistory.setDepositCardId(depositCardId);</span><br><span class="line">            withdrawHistory.setStatus(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 新增取款历史记录</span></span><br><span class="line">            withdrawHistoryMapper.save(withdrawHistory);</span><br><span class="line">            <span class="keyword">return</span> ThriftWithdrawStatus.FINISHED;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> ThriftWithdrawStatus.FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ThriftDeposit&gt; <span class="title">queryDepositHistorys</span><span class="params">(String depositCardId)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        List&lt;DepositHistory&gt; depositHistory = depositHistoryMapper.queryDepositHistoryList(depositCardId);</span><br><span class="line">        <span class="comment">// 查询存款历史纪录</span></span><br><span class="line">        <span class="keyword">return</span> depositHistory.stream().map(DepositHistory::toThrift).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ThriftWithdraw&gt; <span class="title">queryWithdrawHistorys</span><span class="params">(String depositCardId)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        List&lt;WithdrawHistory&gt; withdrawHistory = withdrawHistoryMapper.queryWithdrawHistoryList(depositCardId);</span><br><span class="line">        <span class="comment">// 查询取款历史纪录</span></span><br><span class="line">        <span class="keyword">return</span> withdrawHistory.stream().map(WithdrawHistory::toThrift).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Mybatis</code>持久层，还是以<code>DepositCardMapper</code>为例：</p><p>DepositCardMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepositCardMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">(DepositCard record)</span></span>;</span><br><span class="line">    <span class="function">List&lt;DepositCard&gt; <span class="title">queryAllDepositCards</span><span class="params">(@Param(<span class="string">"customerId"</span>)</span> String customerId)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decrementMoney</span><span class="params">(@Param(<span class="string">"depositCardId"</span>)</span> String depositCardId, @<span class="title">Param</span><span class="params">(<span class="string">"money"</span>)</span> Double money)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incrementMoney</span><span class="params">(@Param(<span class="string">"depositCardId"</span>)</span> String depositCardId, @<span class="title">Param</span><span class="params">(<span class="string">"money"</span>)</span> Double money)</span>;</span><br><span class="line">    <span class="function">Long <span class="title">countRowsByCustomerId</span><span class="params">(@Param(<span class="string">"customerId"</span>)</span> String customerId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DepositCardMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"com.icekredit.rpc.thrift.examples.http.entities.DepositCard"</span>&gt;</span></span><br><span class="line">    INSERT INTO deposit_card (id, is_vip, opening_time,</span><br><span class="line">                              account_balance, account_flow, branch_id,</span><br><span class="line">                              customer_id)</span><br><span class="line">    VALUES (#&#123;id,jdbcType=VARCHAR&#125;, #&#123;isVip,jdbcType=BIT&#125;, #&#123;openingTime,jdbcType=VARCHAR&#125;,</span><br><span class="line">            #&#123;accountBalance,jdbcType=DOUBLE&#125;, #&#123;accountFlow,jdbcType=DOUBLE&#125;, #&#123;branchId,jdbcType=BIGINT&#125;,</span><br><span class="line">            #&#123;customerId,jdbcType=VARCHAR&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryAllDepositCards"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span>/&gt;</span></span><br><span class="line">    FROM deposit_card</span><br><span class="line">    WHERE customer_id = #&#123;customerId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"countRowsByCustomerId"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Long"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">    SELECT COUNT(id)</span><br><span class="line">    FROM deposit_card</span><br><span class="line">    WHERE customer_id = #&#123;customerId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"decrementMoney"</span>&gt;</span></span><br><span class="line">    UPDATE deposit_card</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"money != null"</span>&gt;</span></span><br><span class="line">            account_balance = account_balance - #&#123;money&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE id = #&#123;depositCardId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"incrementMoney"</span>&gt;</span></span><br><span class="line">    UPDATE deposit_card</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"money != null"</span>&gt;</span></span><br><span class="line">            account_balance = account_balance + #&#123;money&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE id = #&#123;depositCardId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="客户端-deposit-client"><a href="#客户端-deposit-client" class="headerlink" title="客户端(deposit-client)"></a>客户端(deposit-client)</h2><p>同样，在客户端模块引入：</p><ul><li><strong>spring-cloud-starter-thrift-client</strong>：<code>thrift</code>客户端的 <code>starter</code>程序。</li><li><strong>deposit-iface</strong>：中间契约模块，这里作为客户端桩(<code>Stub</code>)程序。</li></ul><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Thrift相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-thrift-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringBoot依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Cloud Consul服务注册与发现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Cloud声明式Restful客户端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Swagger依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中配置<code>thrift</code><strong>的客户端</strong>的的运行参数和 <code>Consul</code> <strong>的服务注册与发现</strong>的参数：</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">  actuator:</span></span><br><span class="line"><span class="attr">    sensitive:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        register:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">        register-health-check:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        health-check-interval:</span> <span class="number">30</span><span class="string">s</span></span><br><span class="line"><span class="attr">      retry:</span></span><br><span class="line"><span class="attr">        max-attempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">        max-interval:</span> <span class="number">2000</span></span><br><span class="line"><span class="attr">  thrift:</span></span><br><span class="line"><span class="attr">    client:</span></span><br><span class="line"><span class="attr">      package-to-scan:</span> <span class="string">com.icekredit.rpc.thrift.examples.thrift.client</span></span><br><span class="line"><span class="attr">      service-model:</span> <span class="string">hsHa</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        retry-times:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">        pool-max-total-per-key:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">        pool-min-idle-per-key:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">        pool-max-idle-per-key:</span> <span class="number">40</span></span><br><span class="line"><span class="attr">        pool-max-wait:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">        connect-timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p><strong>客户端程序</strong>启动入口类，设置 <code>Swagger API</code>所在的<strong>包路径名称</strong>，同时允许自身作为<strong>注册程序</strong>注册到<strong>注册中心</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestfulApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.icekredit.rpc.thrift.examples"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"Deposit Client"</span>)</span><br><span class="line">                .description(<span class="string">"Deposit Client"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>客户端</strong>使用<code>@ThriftClient</code>注解标识<strong>服务端</strong>的<code>thrift</code><strong>服务代理接口</strong>，<strong>代理服务</strong><code>ID</code>为<code>deposit-server-rpc</code>，<strong>代理的目标类</strong>是<code>ThriftDepositCardService</code>。</p><p>DepositCardThriftClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftClient</span>(serviceId = <span class="string">"deposit-server-rpc"</span>, refer = ThriftDepositCardService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepositCardThriftClient</span> <span class="keyword">extends</span> <span class="title">ThriftClientAware</span>&lt;<span class="title">ThriftDepositCardService</span>.<span class="title">Client</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BankThriftClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftClient</span>(serviceId = <span class="string">"deposit-server-rpc"</span>, refer = ThriftBankService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BankThriftClient</span> <span class="keyword">extends</span> <span class="title">ThriftClientAware</span>&lt;<span class="title">ThriftBankService</span>.<span class="title">Client</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端控制器中通过<code>ThriftReferer</code>注入需要使用的<strong>服务代理接口</strong>，通过 <code>thriftClient.client()</code>即可获取<code>Thrift</code><strong>客户端</strong>桩对象，然后实现远程服务的调用。</p><p>DepositCardRpcController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rpc/deposit"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepositCardRpcController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ThriftReferer</span></span><br><span class="line">    <span class="keyword">private</span> DepositCardThriftClient thriftClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/queryAllDepositCards"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DepositCard&gt; <span class="title">queryAllDepositCards</span><span class="params">(@RequestParam(<span class="string">"customerId"</span>)</span> String customerId)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().queryAllDepositCards(customerId)</span><br><span class="line">                .stream().map(DepositCard::fromThrift)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/addNewDepositCard"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewDepositCard</span><span class="params">(DepositCard depositCard)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        thriftClient.client().addNewDepositCard(depositCard.getCustomerId(), depositCard.toThrift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/depositMoney"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThriftDepositStatus <span class="title">depositMoney</span><span class="params">(@RequestParam(<span class="string">"depositCardId"</span>)</span> String depositCardId,</span></span><br><span class="line"><span class="function">                                            @<span class="title">RequestParam</span><span class="params">(<span class="string">"money"</span>)</span> <span class="keyword">double</span> money) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().depositMoney(depositCardId, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/withdrawMoney"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThriftWithdrawStatus <span class="title">withdrawMoney</span><span class="params">(@RequestParam(<span class="string">"depositCardId"</span>)</span> String depositCardId,</span></span><br><span class="line"><span class="function">                                              @<span class="title">RequestParam</span><span class="params">(<span class="string">"money"</span>)</span> <span class="keyword">double</span> money) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().withdrawMoney(depositCardId, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/queryDepositHistory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DepositHistory&gt; <span class="title">queryDepositHistory</span><span class="params">(@RequestParam(<span class="string">"depositCardId"</span>)</span> String depositCardId)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().queryDepositHistorys(depositCardId)</span><br><span class="line">                .stream().map(DepositHistory::fromThrift)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/queryWithdrawHistory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;WithdrawHistory&gt; <span class="title">queryWithdrawHistory</span><span class="params">(@RequestParam(<span class="string">"depositCardId"</span>)</span> String depositCardId)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().queryWithdrawHistorys(depositCardId)</span><br><span class="line">                .stream().map(WithdrawHistory::fromThrift)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BankRpcController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rpc/bank"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankRpcController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ThriftReferer</span></span><br><span class="line">    <span class="keyword">private</span> BankThriftClient thriftClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/addNewBank"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewBank</span><span class="params">(Bank bank)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        thriftClient.client().registerNewBank(bank.toThrift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getBankById"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bank <span class="title">getBankById</span><span class="params">(@RequestParam(<span class="string">"bankId"</span>)</span> Long bankId) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bank.fromThrift(thriftClient.client().getBankById(bankId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/queryAllBranchesByRegion"</span>)</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Region, List&lt;Branch&gt;&gt; queryAllBranchesByRegion(<span class="meta">@RequestParam</span>(<span class="string">"bankId"</span>) Long bankId) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;ThriftRegion, List&lt;ThriftBranch&gt;&gt; thriftRegionListMap = thriftClient.client()</span><br><span class="line">                .queryAllBranchesByRegion(bankId);</span><br><span class="line">        Map&lt;Region, List&lt;Branch&gt;&gt; regionListMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ThriftRegion, List&lt;ThriftBranch&gt;&gt; entry : thriftRegionListMap.entrySet()) &#123;</span><br><span class="line">            ThriftRegion thriftRegion = entry.getKey();</span><br><span class="line">            Region region = Region.findByValue(thriftRegion.getValue());</span><br><span class="line"></span><br><span class="line">            List&lt;ThriftBranch&gt; thriftBranches = entry.getValue();</span><br><span class="line">            List&lt;Branch&gt; branchList = thriftBranches.stream().map(Branch::fromThrift).collect(Collectors.toList());</span><br><span class="line">            regionListMap.put(region, branchList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> regionListMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<strong>服务代理客户端接口</strong>使用<code>@ThriftClient</code>标识，通过(服务ID + 客户端桩 + 版本号)唯一标识, 即使同时注入多个<strong>服务代理客户端接口</strong>，<code>@ThriftReferer</code>也可忽略<strong>注解属性</strong>的配置。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有一点是肯定的，那就是在已有技术框架(比如说：<code>Spring</code> + <code>Mybatis/JPA</code>)内，为了提高服务的<strong>性能</strong>和<strong>吞吐量</strong>，而引入诸如<code>Thrift</code>的<code>RPC</code>框架，<strong>编程难度</strong>和<strong>复杂度</strong>是会大大提高的。好比一把双刃剑，技术选型时还需要多方面权衡利弊。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇简单的阐述了 &lt;code&gt;spring-cloud-thrift-starter&lt;/code&gt; 这个插件的配置和使用，并引入了一个&lt;code&gt;calculator&lt;/code&gt;的项目。本文将基于一个银行存款、取款的业务场景，给出一套&lt;code&gt;thrift&lt;/code&gt;在生产环境的应用案例。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Thrift" scheme="https://ostenant.coding.me/tags/Thrift/"/>
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
      <category term="Spring Cloud" scheme="https://ostenant.coding.me/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud整合Thrift RPC(一) - 使用指南</title>
    <link href="https://ostenant.coding.me/2018/01/18/Spring%20Cloud%E6%95%B4%E5%90%88Thrift%20RPC(%E4%B8%80)%20-%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://ostenant.coding.me/2018/01/18/Spring Cloud整合Thrift RPC(一) - 使用指南/</id>
    <published>2018-01-18T07:07:00.000Z</published>
    <updated>2018-05-08T02:49:46.092Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面几篇博客，着重对<code>Apache Thrift</code>的使用和原理做了介绍。在微服架构流行的今天，自然而然就会想到<code>Spring Boot</code>和<code>Spring Cloud</code>作为<strong>微服务</strong>的基础框架。然而，<code>Spring Cloud</code>从诞生以来，就基于<code>HTTP</code>协议的<strong>轻量级</strong><code>Restful API</code>作为服务之间的通信方式。</p><a id="more"></a><p>在微服务架构设计中，可以分为<strong>外部服务</strong>和<strong>内部服务</strong>。两者主要区别是：</p><ul><li><strong>外部服务</strong>：基于<code>Restful</code>风格的<code>HTTP</code>协议，通过<strong>外网</strong>向外部提供服务，相对来说<strong>简单并且通用</strong>。</li><li><strong>内部服务</strong>：基于<code>RPC</code>消息通信的<code>TCP/IP</code>协议，提供<strong>内网</strong>服务与服务之间的调用，以达到<strong>减少带宽</strong>、<strong>降低延迟率</strong>、<strong>提高性能</strong>。</li></ul><p>一些应用场景，尤其是<strong>内部服务</strong>需要高频地调用，就需要考虑是否需要改造为<code>RPC</code>实现，来<strong>提高吞吐量</strong>和<strong>系统性能</strong>，比如说<strong>鉴权服务</strong>一类。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>下载 <code>spring-cloud-starter-thrift</code>并导入<code>IDEA</code>开发环境，项目地址：<a href="https://github.com/ostenant/spring-cloud-starter-thrift" target="_blank" rel="noopener">https://github.com/ostenant/spring-cloud-starter-thrift</a></p><p><img src="http://ols3fdyll.bkt.clouddn.com/Spring-cloud-starter-thrift2.png" alt=""><br><code>spring-cloud-starter-thrift</code> 提供 <code>Spring Cloud</code> 对<strong>可伸缩</strong>的<strong>跨语言</strong>服务调用框架<code>Apache Thrift</code>的封装和集成。</p><p><code>spring-cloud-starter-thrift</code>包括<strong>客户端</strong><code>spring-cloud-starter-thrift-client</code>和<strong>服务端</strong><code>spring-cloud-starter-thrift-server</code>两个模块。而<code>spring-cloud-starter-thrift-examples</code> 子模块提供了<code>3</code>个示例项目：<code>calculator</code>、<code>deposit</code>和<code>test</code>。</p><ul><li><strong>calculator</strong>：简单上手项目示例。</li><li><strong>deposit</strong>：复杂业务场景项目示例。</li><li><strong>test</strong>：性能测试项目示例。</li></ul><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li>支持 <code>Apache Thrift</code>的各种原生<strong>线程服务模型</strong>，包括<strong>单线程阻塞模型</strong>(<code>simple</code>)、<strong>单线程非阻塞模型</strong>(<code>nonBlocking</code>)、<strong>线程池阻塞模型</strong>(<code>threadPool</code>)、<strong>半同步半异步模型</strong>(<code>hsHa</code>)和<strong>线程选择器模型</strong>(<code>threadedSelector</code>)。</li><li>支持 <code>Apache Thrift 0.10.0</code>版本后提供的<strong>多路复用处理器</strong>，提供服务的统一注册管理功能。</li><li>支持由<strong>服务签名</strong> (服务<code>ID</code> + 客户端<code>Stub</code>接口名称 + 服务版本号) 唯一标识服务<code>Stub</code>的<strong>具体实现类</strong>，支持服务版本的<strong>平滑升级</strong>。</li><li>支持<code>Server Group</code>形式的启动方式，每个<strong>服务实例</strong>可以开启多台<code>Thrift Server</code>，通过不同的<strong>端口号</strong>暴露给客户端。</li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>支持由<strong>服务签名</strong> (服务<code>ID</code> + 客户端<code>Stub</code>接口名称 + 服务版本号) 唯一标识和调用服务端的<code>Stub</code><strong>具体实现类</strong>。</li><li>支持<code>Apache Thrift</code>的<code>Transport</code>层的<strong>连接池管理</strong>，<strong>减少</strong>了客户端与服务端之间<strong>连接</strong>的频繁<strong>创建</strong>和<strong>销毁</strong>。</li><li>支持与<code>Spring Cloud Consul</code>的<strong>无缝集成</strong>，客户端通过<strong>心跳检测</strong>与<strong>服务注册中心</strong><code>Consul</code>保持连接，动态定时的<strong>刷新服务列表</strong>、<strong>监测</strong>服务的<strong>启用</strong>、<strong>关闭</strong>和<strong>健康状态</strong>。</li><li>支持<strong>客户端负载均衡</strong>，包括<strong>随机</strong>、<strong>轮询</strong>的负载均衡策略，客户端的<code>Thrift</code>程序通过本地的<strong>服务缓存列表</strong>实现调用的动态转发。</li></ol><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>项目结构：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring-cloud-thrift-starter-example-calculator.png" alt=""></p><ul><li>calculator<ul><li>calculator-client</li><li>calculator-iface</li><li>calculator-server</li></ul></li></ul><p><code>spring-cloud-starter-thrift</code> 使用的是 <code>0.10.0</code>版本的 <code>thrift</code>。以<code>calculator</code>项目入手，首先，通过 <code>Thrift IDL</code> (接口描述语言) 编写<strong>客户端桩</strong><code>Stub</code>和<strong>服务端骨架</strong><code>Skeleton</code>，通过<code>.thrift</code>文件定义接口规范。</p><p>首先进入 <code>spring-cloud-starter-thrift</code> 根目录，<code>pom.xml</code> 定义如下：</p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>calculator-client<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>calculator-server<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>calculator-iface<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Dalston.SR4<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将项目打包并<strong>安装</strong>到本地<code>Maven</code>仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><h3 id="Thrift-IDL编写"><a href="#Thrift-IDL编写" class="headerlink" title="Thrift IDL编写"></a>Thrift IDL编写</h3><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java com.icekredit.rpc.thrift.example</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">CalculatorService</span> </span>&#123;</span><br><span class="line">    <span class="built_in">i32</span> add(<span class="number">1</span>: <span class="built_in">i32</span> arg1, <span class="number">2</span>: <span class="built_in">i32</span> arg2)</span><br><span class="line">    <span class="built_in">i32</span> subtract(<span class="number">1</span>: <span class="built_in">i32</span> arg1, <span class="number">2</span>: <span class="built_in">i32</span> arg2)</span><br><span class="line">    <span class="built_in">i32</span> multiply(<span class="number">1</span>: <span class="built_in">i32</span> arg1, <span class="number">2</span>: <span class="built_in">i32</span> arg2)</span><br><span class="line">    <span class="built_in">i32</span> division(<span class="number">1</span>: <span class="built_in">i32</span> arg1, <span class="number">2</span>: <span class="built_in">i32</span> arg2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载并安装<code>0.10.0</code>的 <code>Thrift IDL</code><strong>编译生成器</strong>，下载地址：<a href="http://thrift.apache.org/docs/install" target="_blank" rel="noopener">http://thrift.apache.org/docs/install</a>。通过<strong>编译器</strong>生成<code>.java</code>的<code>Stub</code>类文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -gen java ./CalculatorService.thrift</span><br></pre></td></tr></table></figure><p>编译器生成的<code>CalculatorService.java</code>文件。<code>CalculatorService.java</code>有成千上万行代码。对于开发人员而言，只需要关注以下<strong>四个核心接口/类</strong>：<code>Iface</code>、<code>AsyncIface</code>、<code>Client</code>和<code>AsyncClient</code>。</p><ul><li><strong>Iface</strong>：<strong>服务端</strong>通过实现 <code>HelloWorldService.Iface</code> 接口，向<strong>客户端</strong>的提供具体的<strong>同步</strong>业务逻辑。</li><li><strong>AsyncIface</strong>：<strong>服务端</strong>通过实现 <code>HelloWorldService.Iface</code> 接口，向<strong>客户端</strong>的提供具体的<strong>异步</strong>业务逻辑。</li><li><strong>Client</strong>：<strong>客户端</strong>通过 <code>HelloWorldService.Client</code> 的实例对象，以<strong>同步</strong>的方式<strong>访问服务端</strong>提供的服务方法。</li><li><strong>AsyncClient</strong>：<strong>客户端</strong>通过 <code>HelloWorldService.AsyncClient</code> 的实例对象，以<strong>异步</strong>的方式<strong>访问服务端</strong>提供的服务方法。</li></ul><h3 id="中间契约-calculator-iface"><a href="#中间契约-calculator-iface" class="headerlink" title="中间契约(calculator-iface)"></a>中间契约(calculator-iface)</h3><p>在<strong>中间契约模块</strong>引入<code>thrift</code>的<code>maven</code>依赖，拷贝上一步<code>thrift</code>编译生成器生成的 <code>CalculatorService</code>源文件到此模块。</p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务端-calculator-server"><a href="#服务端-calculator-server" class="headerlink" title="服务端(calculator-server)"></a>服务端(calculator-server)</h3><p>在<strong>服务端模块</strong>引入：</p><ul><li><strong>spring-cloud-starter-thrift-server</strong>：<code>thrift</code>服务端的 <code>starter</code>程序。</li><li><strong>calculator-iface</strong>：中间契约模块，这里作为服务端骨架(<code>Skeleton</code>)程序。</li></ul><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-thrift-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中配置<code>thrift</code>服务端的运行参数：</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 服务端Restful服务所在的HTTP端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 用于Consul健康检查</span></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">  actuator:</span></span><br><span class="line"><span class="attr">    sensitive:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Spring Thrift服务端配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  thrift:</span></span><br><span class="line"><span class="attr">    server:</span></span><br><span class="line"><span class="attr">      service-id:</span> <span class="string">thrift-rpc-calculator</span> <span class="comment">##</span></span><br><span class="line"><span class="attr">      service-model:</span> <span class="string">hsHa</span>  <span class="comment">## 半同步/半异步服务模型</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">25000</span>  <span class="comment">## 服务端RPC服务所在的TCP端口号</span></span><br><span class="line"><span class="attr">      worker-queue-capacity:</span> <span class="number">1000</span></span><br><span class="line">      <span class="comment">## 半同步/半异步服务模型参数配置</span></span><br><span class="line"><span class="attr">      hs-ha:</span></span><br><span class="line"><span class="attr">        min-worker-threads:</span> <span class="number">5</span>  <span class="comment">## 最少工作线程数</span></span><br><span class="line"><span class="attr">        max-worker-threads:</span> <span class="number">20</span>  <span class="comment">## 最大工作线程数</span></span><br><span class="line"><span class="attr">        keep-alived-time:</span> <span class="number">3</span>  <span class="comment">## 空闲线程存活时间</span></span><br></pre></td></tr></table></figure><p>实现<code>Thrift IDL</code>生成的骨架(<code>Skeleton</code>)类<code>CalculatorService</code>的内部接口<code>Iface</code>，编写具体的业务逻辑：</p><p>这里需要注意几点：</p><ul><li>实现 <code>CalculatorService.Iface</code>接口。</li><li>实现类标记 <code>@ThriftService</code>注解，包含以下属性：<ul><li><strong>name</strong>：通过<code>name</code>标识<strong>服务名称</strong>，缺省时默认为<strong>类名称首字母小写</strong>。</li><li><strong>version</strong>：通过<code>version</code>标识<strong>服务版本</strong>，缺省值为<code>1.0</code>，也就是说同一个<strong>服务名称</strong>可以拥有<strong>多个版本实现</strong>。</li></ul></li></ul><p>RpcCalculatorService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftService</span>(name = <span class="string">"rpcCalculatorService"</span>, version = <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcCalculatorService</span> <span class="keyword">implements</span> <span class="title">CalculatorService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        BigDecimal arg1Decimal = <span class="keyword">new</span> BigDecimal(arg1);</span><br><span class="line">        BigDecimal arg2Decimal = <span class="keyword">new</span> BigDecimal(arg2);</span><br><span class="line">        <span class="keyword">return</span> arg1Decimal.add(arg2Decimal).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        BigDecimal arg1Decimal = <span class="keyword">new</span> BigDecimal(arg1);</span><br><span class="line">        BigDecimal arg2Decimal = <span class="keyword">new</span> BigDecimal(arg2);</span><br><span class="line">        <span class="keyword">return</span> arg1Decimal.subtract(arg2Decimal).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        BigDecimal arg1Decimal = <span class="keyword">new</span> BigDecimal(arg1);</span><br><span class="line">        BigDecimal arg2Decimal = <span class="keyword">new</span> BigDecimal(arg2);</span><br><span class="line">        <span class="keyword">return</span> arg1Decimal.multiply(arg2Decimal).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        BigDecimal arg1Decimal = <span class="keyword">new</span> BigDecimal(arg1);</span><br><span class="line">        BigDecimal arg2Decimal = <span class="keyword">new</span> BigDecimal(arg2);</span><br><span class="line">        <span class="keyword">return</span> arg1Decimal.divide(arg2Decimal).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对服务端程序进行打包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>编写 <code>Dockerfile</code> 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/spring-boot-thrift-server-0.0.1-SNAPSHOT.jar calculator-server.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"calculator-server.jar"</span>]</span></span><br></pre></td></tr></table></figure><p>将<code>Dockerfile</code> 和 <code>target/spring-boot-thrift-server-0.0.1-SNAPSHOT.jar</code>拷贝到服务器上，构建 <code>Thrift Server</code> 的服务镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t icekredit/calculator-server</span><br></pre></td></tr></table></figure><h3 id="客户端-calculator-client"><a href="#客户端-calculator-client" class="headerlink" title="客户端(calculator-client)"></a>客户端(calculator-client)</h3><p>在<strong>客户端模块</strong>引入：</p><ul><li><strong>spring-cloud-starter-thrift-client</strong>：<code>thrift</code>客户端的 <code>starter</code>程序。</li><li><strong>calculator-iface</strong>：中间契约模块，这里作为客户端桩(<code>Stub</code>)程序。</li></ul><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-thrift-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>application.yml</code>中配置 <code>thrift</code><strong>客户端</strong>的运行参数，需要与<strong>服务端</strong>配置保持一致：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 客户端Restful服务所在的HTTP端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 用于Consul健康检查</span></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">  actuator:</span></span><br><span class="line"><span class="attr">    sensitive:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Spring Thrift客户端配置(Thrift Client的自动配置取决于Spring Cloud Consul的正确配置)</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">thrift-calculator-client</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>  <span class="comment">## Consul的IP地址</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span>  <span class="comment">## Consul的HTTP端口号</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        register:</span> <span class="literal">false</span>  <span class="comment">## 不使用SpringCloud提供的基于服务的程序注册方式</span></span><br><span class="line"><span class="attr">        register-health-check:</span> <span class="literal">false</span>  <span class="comment">## 不使用Spring Cloud进行健康检查</span></span><br><span class="line"><span class="attr">      retry:</span></span><br><span class="line"><span class="attr">        max-attempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">        max-interval:</span> <span class="number">2000</span></span><br><span class="line">  <span class="comment">## Thrift Client配置</span></span><br><span class="line"><span class="attr">  thrift:</span></span><br><span class="line"><span class="attr">    client:</span></span><br><span class="line"><span class="attr">      package-to-scan:</span> <span class="string">com.icekredit.rpc.thrift.example.rpc</span>  <span class="comment">## 标记由有注解@ThriftClient接口的包路径</span></span><br><span class="line"><span class="attr">      service-model:</span> <span class="string">hsHa</span>  <span class="comment">##服务线程模型（这里必须与服务端保持一致, 默认都是hsHa）</span></span><br><span class="line">      <span class="comment">## 客户端连接池配置</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        retry-times:</span> <span class="number">3</span>  <span class="comment">## 异常失败，连接超时后的重试次数</span></span><br><span class="line">        <span class="comment">## key由IP + Port组成，唯一标识一个服务实例</span></span><br><span class="line"><span class="attr">        pool-max-total-per-key:</span> <span class="number">200</span> <span class="comment">## 客户端保持的最大连接数，包含不同的服务和服务实例</span></span><br><span class="line"><span class="attr">        pool-min-idle-per-key:</span> <span class="number">10</span>  <span class="comment">## 每个服务实例最小的空闲连接数</span></span><br><span class="line"><span class="attr">        pool-max-idle-per-key:</span> <span class="number">40</span>  <span class="comment">## 每个服务实例最大的空闲连接数</span></span><br><span class="line"><span class="attr">        pool-max-wait:</span> <span class="number">30000</span>  <span class="comment">## 空闲连接最大存活时间</span></span><br><span class="line"><span class="attr">        connect-timeout:</span> <span class="number">2000</span>  <span class="comment">## 连接超时时间</span></span><br></pre></td></tr></table></figure><p>编写 <code>Thrift Client</code>的<strong>客户端代理接口</strong>，这里有两点注意事项：</p><ul><li>接口需要继承于<strong>父接口</strong> <code>ThriftClientAware</code>，且 <code>ThriftClientAware</code> 里的<strong>泛型参数</strong>填写为 <code>Thrift IDL</code> 生成的 <code>Stub</code> 类 <code>CalculatorService</code> 中的 <code>Client</code> 内部类。</li><li>接口需要标识 <code>@ThriftClient</code> 注解， <code>@ThriftClient</code> 包含如下属性：<ul><li><strong>serviceId</strong>：此客户端代理接口绑定的 <code>Thrift</code> <strong>服务端</strong>的<strong>服务注册ID</strong> (与服务端<strong>保持一致</strong>)。</li><li><strong>refer</strong>：客户端桩 <code>Stub</code>的类型，例如这里是<code>CalculatorService.class</code>。</li><li><strong>version</strong>：具体业务实现类的<strong>版本号</strong>(不填写默认为<code>1.0</code>)，需要与服务端<strong>保持一致</strong>。</li></ul></li></ul><p>CalculatorThriftClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftClient</span>(serviceId = <span class="string">"thrift-rpc-calculator"</span>, refer = CalculatorService.class, version = <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculatorThriftClient</span> <span class="keyword">extends</span> <span class="title">ThriftClientAware</span>&lt;<span class="title">CalculatorService</span>.<span class="title">Client</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解 <code>@ThriftReferer</code>，在客户端的 <code>Controller</code> 中注入 <code>CalculatorThriftClient</code>。 使用时，通过 <code>CalculatorThriftClient.thriftClient()</code> 方法，即可调用<code>Thrift Server</code>的服务方法。</p><p>RpcCalculatorController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rpc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcCalculatorController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ThriftReferer</span></span><br><span class="line">    <span class="keyword">private</span> CalculatorThriftClient calculators;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(@RequestParam(<span class="string">"arg1"</span>)</span> <span class="keyword">int</span> arg1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"arg2"</span>)</span> <span class="keyword">int</span> arg2) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculators.client().add(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/subtract"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtract</span><span class="params">(@RequestParam(<span class="string">"arg1"</span>)</span> <span class="keyword">int</span> arg1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"arg2"</span>)</span> <span class="keyword">int</span> arg2) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculators.client().subtract(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/multiply"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(@RequestParam(<span class="string">"arg1"</span>)</span> <span class="keyword">int</span> arg1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"arg2"</span>)</span> <span class="keyword">int</span> arg2) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculators.client().multiply(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/division"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">division</span><span class="params">(@RequestParam(<span class="string">"arg1"</span>)</span> <span class="keyword">int</span> arg1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"arg2"</span>)</span> <span class="keyword">int</span> arg2) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculators.client().division(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方便，在<strong>本地开发环境</strong>配置<code>Consul</code>的地址，运行<strong>客户端程序</strong>即可。对于<strong>容器环境</strong>测试，配置对客户端程序进行打包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>编写 <code>Dockerfile</code> 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/spring-boot-thrift-client-0.0.1-SNAPSHOT.jar calculator-client.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"calculator-client.jar"</span>]</span></span><br></pre></td></tr></table></figure><p>将<code>Dockerfile</code> 和 <code>target/spring-boot-thrift-client-0.0.1-SNAPSHOT.jar</code>拷贝到服务器上，构建 <code>Thrift Client</code> 的服务镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t icekredit/calculator-client</span><br></pre></td></tr></table></figure><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><h3 id="发布服务端程序"><a href="#发布服务端程序" class="headerlink" title="发布服务端程序"></a>发布服务端程序</h3><p>为了方便测试，在一台主机上启动三个 <code>Thrift Server</code> 的 <code>docker</code> 容器，以不同的<strong>端口</strong>区分，分别指定对应的<strong>端口号</strong>和 <code>Consul</code> 注册信息：</p><p><code>Thrift Server</code>实例1(<code>25001</code>端口)：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 8081:8080 -p 25001:25000 --name calculator-server-01 \</span></span><br><span class="line"><span class="bash">    -e <span class="string">"SERVICE_25000_NAME=thrift-rpc-calculator"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TCP=/"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_INTERVAL=30s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TIMEOUT=3s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_TAGS=thrift-rpc-calculator-25001"</span> \</span></span><br><span class="line"><span class="bash">  icekredit/calculator-server</span></span><br></pre></td></tr></table></figure><p><code>Thrift Server</code>实例2(<code>25002</code>端口)：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 8081:8080 -p 25002:25000 --name calculator-server-01 \</span></span><br><span class="line"><span class="bash">    -e <span class="string">"SERVICE_25000_NAME=thrift-rpc-calculator"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TCP=/"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_INTERVAL=30s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TIMEOUT=3s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_TAGS=thrift-rpc-calculator-25002"</span> \</span></span><br><span class="line"><span class="bash">  icekredit/calculator-server</span></span><br></pre></td></tr></table></figure><p><code>Thrift Server</code>实例3(<code>25003</code>端口)：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 8081:8080 -p 25003:25000 --name calculator-server-01 \</span></span><br><span class="line"><span class="bash">    -e <span class="string">"SERVICE_25000_NAME=thrift-rpc-calculator"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TCP=/"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_INTERVAL=30s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TIMEOUT=3s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_TAGS=thrift-rpc-calculator-25003"</span> \</span></span><br><span class="line"><span class="bash">    icekredit/calculator-server</span></span><br></pre></td></tr></table></figure><p>观察各个容器的启动日志，如果包含以下<strong>几行输出信息</strong>，则表明 <code>Thrift Server</code> 成功启动并正常提供 <code>RPC</code> 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-11-19 22:28:47.779  INFO 12960 --- [           main] c.i.r.t.s.context.ThriftServerContext    : Build thrift server from HsHaServerContext</span><br><span class="line">2017-11-19 22:28:47.820  INFO 12960 --- [           main] c.i.r.t.s.p.TRegisterProcessorFactory    : Processor bean org.ostenant.springboot.learning.examples.CalculatorService<span class="variable">$Processor</span>@445bce9a with signature [thrift-rpc-calculator<span class="variable">$org</span>.ostenant.springboot.learning.examples.CalculatorService<span class="variable">$2</span>.0] is instantiated</span><br><span class="line">2017-11-19 22:28:47.822  INFO 12960 --- [           main] c.i.r.t.s.p.TRegisterProcessorFactory    : Single processor org.ostenant.springboot.learning.examples.CalculatorService<span class="variable">$Processor</span>@445bce9a register onto multiplexed processor with signature [thrift-rpc-calculator<span class="variable">$org</span>.ostenant.springboot.learning.examples.CalculatorService<span class="variable">$2</span>.0]</span><br><span class="line">2017-11-19 22:28:47.822  INFO 12960 --- [           main] c.i.r.t.s.p.TRegisterProcessorFactory    : Multiplexed processor totally owns 1 service processors</span><br></pre></td></tr></table></figure><p>启动 <code>Consul</code> 和<code>Registrator</code> 容器，<code>Thrift Server</code> 的三个服务实例成功注册到<code>Consul</code>服务列表：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_server_calculator.png" alt=""></p><p>有关 <code>Consul</code>和 <code>Registrator</code>的安装配置以及使用，请参考：<strong>Docker+Consul+Registrator(一) 搭建服务发现与注册集群</strong>！</p><p>服务端程序成功运行，<code>Thrift RPC</code>服务正常发布！</p><h3 id="启动客户端程序"><a href="#启动客户端程序" class="headerlink" title="启动客户端程序"></a>启动客户端程序</h3><p>在本地 <code>8080</code> 端口号启动 <code>Thrift</code> 客户端，正常启动后观察启动日志如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2017-11-20 11:00:20.025  INFO 4052 --- [           main] .r.t.c.ThriftClientBeanScannerConfigurer : Base package org.ostenant.springboot.learning.examples.rpc is to be scanned with com.icekredit.rpc.thrift.client.scanner.ThriftClientBeanScanner@37496720</span><br><span class="line">2017-11-20 11:00:20.029  INFO 4052 --- [           main] c.i.r.t.c.s.ThriftClientBeanScanner      : Packages scanned by thriftClientBeanDefinitionScanner is [org.ostenant.springboot.learning.examples.rpc]</span><br><span class="line">2017-11-20 11:00:20.029  INFO 4052 --- [           main] c.i.r.t.c.s.ThriftClientBeanScanner      : Scanned and found thrift client, bean calculatorThriftClient assigned from org.ostenant.springboot.learning.examples.rpc.CalculatorThriftClient</span><br><span class="line">2017-11-20 11:00:20.050  INFO 4052 --- [           main] f.a.AutowiredAnnotationBeanPostProcessor : JSR-330 <span class="string">'javax.inject.Inject'</span> annotation found and supported <span class="keyword">for</span> autowiring</span><br><span class="line">2017-11-20 11:00:20.134  INFO 4052 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">'org.ostenant.springboot.learning.examples.rest.CalculatorFeignClient'</span> of <span class="built_in">type</span> [org.springframework.cloud.netflix.feign.FeignClientFactoryBean] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2017-11-20 11:00:20.136  WARN 4052 --- [           main] c.i.r.t.c.s.ThriftClientFactoryBean      : Bean class is not found</span><br><span class="line">2017-11-20 11:00:20.142  INFO 4052 --- [           main] c.i.r.t.c.s.ThriftClientFactoryBean      : Succeed to instantiate an instance of ThriftClientFactoryBean: com.icekredit.rpc.thrift.client.scanner.ThriftClientFactoryBean@7bac686b</span><br><span class="line">2017-11-20 11:00:20.142  INFO 4052 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">'calculatorThriftClient'</span> of <span class="built_in">type</span> [com.icekredit.rpc.thrift.client.scanner.ThriftClientFactoryBean] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2017-11-20 11:00:20.411  INFO 4052 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">'org.springframework.cloud.netflix.metrics.MetricsInterceptorConfiguration$MetricsRestTemplateConfiguration'</span> of <span class="built_in">type</span> [org.springframework.cloud.netflix.metrics.MetricsInterceptorConfiguration<span class="variable">$MetricsRestTemplateConfiguration</span>$<span class="variable">$EnhancerBySpringCGLIB</span>$<span class="variable">$a9ef18dc</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2017-11-20 11:00:20.423  INFO 4052 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">'org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration'</span> of <span class="built_in">type</span> [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$<span class="variable">$EnhancerBySpringCGLIB</span>$<span class="variable">$93dc7598</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2017-11-20 11:00:21.592  INFO 4052 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)</span><br></pre></td></tr></table></figure><p>启动过程中，所有的标记有注解 <code>@ThriftClient</code>的接口都生成了<strong>代理对象</strong>，并通过注解 <code>@ThriftReferer</code>注入到 <code>Controller</code>中。</p><p>同时，<strong>客户端</strong>启动时开启了一个<code>ServerUpdater</code>，<strong>定时动态</strong>的去<code>Consul</code>服务注册列表抓取<strong>健康的服务节点信息</strong>，缓存到<strong>本地服务列表</strong>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-11-20 11:02:26.726  INFO 4052 --- [erListUpdater-0] t.c.l.ThriftConsulServerListLoadBalancer : Refreshed thrift serverList: [thrift-rpc-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25001], host=<span class="string">'192.168.91.128'</span>, port=25001, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25002], host=<span class="string">'192.168.91.128'</span>, port=25002, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25003], host=<span class="string">'192.168.91.128'</span>, port=25003, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8301: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8302: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], thrift-rest-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8081], host=<span class="string">'192.168.91.128'</span>, port=8081, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8082], host=<span class="string">'192.168.91.128'</span>, port=8082, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8083], host=<span class="string">'192.168.91.128'</span>, port=8083, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;]]</span><br><span class="line">2017-11-20 11:02:56.752  INFO 4052 --- [erListUpdater-0] t.c.l.ThriftConsulServerListLoadBalancer : Refreshed thrift serverList: [thrift-rpc-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25001], host=<span class="string">'192.168.91.128'</span>, port=25001, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25002], host=<span class="string">'192.168.91.128'</span>, port=25002, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25003], host=<span class="string">'192.168.91.128'</span>, port=25003, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8301: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8302: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], thrift-rest-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8081], host=<span class="string">'192.168.91.128'</span>, port=8081, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8082], host=<span class="string">'192.168.91.128'</span>, port=8082, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8083], host=<span class="string">'192.168.91.128'</span>, port=8083, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;]]</span><br><span class="line">2017-11-20 11:03:26.764  INFO 4052 --- [erListUpdater-0] t.c.l.ThriftConsulServerListLoadBalancer : Refreshed thrift serverList: [thrift-rpc-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25001], host=<span class="string">'192.168.91.128'</span>, port=25001, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25002], host=<span class="string">'192.168.91.128'</span>, port=25002, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25003], host=<span class="string">'192.168.91.128'</span>, port=25003, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8301: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8302: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], thrift-rest-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8081], host=<span class="string">'192.168.91.128'</span>, port=8081, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8082], host=<span class="string">'192.168.91.128'</span>, port=8082, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8083], host=<span class="string">'192.168.91.128'</span>, port=8083, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;]]</span><br></pre></td></tr></table></figure><p>访问本地<code>Thrift</code>客户端：</p><table><thead><tr><th style="text-align:left">访问地址</th><th style="text-align:center">参数arg1</th><th style="text-align:center">参数arg2</th><th style="text-align:center">页面输出结果</th></tr></thead><tbody><tr><td style="text-align:left">/rpc/add</td><td style="text-align:center">200</td><td style="text-align:center">100</td><td style="text-align:center">300</td></tr><tr><td style="text-align:left">/rpc/subtract</td><td style="text-align:center">200</td><td style="text-align:center">100</td><td style="text-align:center">100</td></tr><tr><td style="text-align:left">/rpc/multiply</td><td style="text-align:center">200</td><td style="text-align:center">100</td><td style="text-align:center">20000</td></tr><tr><td style="text-align:left">/rpc/division</td><td style="text-align:center">200</td><td style="text-align:center">100</td><td style="text-align:center">2</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单地介绍了如何利用 <code>starter</code> 将 <code>Apache Thrift</code> 整合进入 <code>Spring Cloud</code> 中，关于更复杂的应用场景和<code>starter</code>内部的设计、实现原理，后续会一步步的给出具体的介绍！</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面几篇博客，着重对&lt;code&gt;Apache Thrift&lt;/code&gt;的使用和原理做了介绍。在微服架构流行的今天，自然而然就会想到&lt;code&gt;Spring Boot&lt;/code&gt;和&lt;code&gt;Spring Cloud&lt;/code&gt;作为&lt;strong&gt;微服务&lt;/strong&gt;的基础框架。然而，&lt;code&gt;Spring Cloud&lt;/code&gt;从诞生以来，就基于&lt;code&gt;HTTP&lt;/code&gt;协议的&lt;strong&gt;轻量级&lt;/strong&gt;&lt;code&gt;Restful API&lt;/code&gt;作为服务之间的通信方式。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Thrift" scheme="https://ostenant.coding.me/tags/Thrift/"/>
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
      <category term="Spring Cloud" scheme="https://ostenant.coding.me/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>阿里云CentOS 7上安装配置Docker</title>
    <link href="https://ostenant.coding.me/2018/01/18/%E9%98%BF%E9%87%8C%E4%BA%91CentOS%207%E4%B8%8A%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEDocker/"/>
    <id>https://ostenant.coding.me/2018/01/18/阿里云CentOS 7上安装配置Docker/</id>
    <published>2018-01-18T01:44:00.000Z</published>
    <updated>2018-05-08T02:49:46.097Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Docker</code>是一个开源工具，它可以让创建和管理<code>Linux</code>容器变得简单。<strong>容器</strong>就像是<strong>轻量级</strong>的<strong>虚拟机</strong>，并且可以以<strong>毫秒级</strong>的速度来启动或停止。<code>Docker</code>帮助系统管理员和程序员<strong>在容器中开发应用程序</strong>，并且可以扩展到成千上万的节点。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_logo.png" alt=""></p><p>这是一只鲸鱼，它托着许多集装箱。我们可以把<strong>宿主机</strong>可当做这只<strong>鲸鱼</strong>，把<strong>相互隔离</strong>的<strong>容器</strong>可看成<strong>集装箱</strong>，每个集装箱中都包含自己的<strong>应用程序</strong>。</p><hr><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><h2 id="Docker与传统虚拟区别"><a href="#Docker与传统虚拟区别" class="headerlink" title="Docker与传统虚拟区别"></a>Docker与传统虚拟区别</h2><ul><li>传统虚拟化技术的体系架构：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/virtualization_host_architecture.png" alt=""></p><ul><li><code>Docker</code>技术的体系架构：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_architecture.png" alt=""></p><p><strong>容器</strong>和<strong>虚拟机</strong>(<code>VM</code>)的主要区别是：</p><ul><li>容器提供了基于<strong>进程</strong>的隔离，而虚拟机提供了<strong>资源</strong>(<code>CPU</code>、内存和硬盘)的<strong>完全隔离</strong>。</li><li>虚拟机可能需要<strong>一分钟</strong>来启动，而容器只需要<strong>一秒钟</strong>或更短。</li><li>虚拟机占用的<strong>内存空间</strong>可达到<strong>几个</strong><code>G</code>，而容器可能只需要<strong>几百兆</strong>。</li><li>容器使用<strong>宿主操作系统</strong>的内核，而虚拟机使用<strong>独立</strong>的内核。</li></ul><h2 id="Docker平台的基本构成"><a href="#Docker平台的基本构成" class="headerlink" title="Docker平台的基本构成"></a>Docker平台的基本构成</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_component.jpg" alt=""></p><p><code>Docker</code>平台基本上由三部分组成：</p><ul><li><strong>客户端</strong>：用户使用<code>Docker</code>提供的工具(<code>CLI</code>以及<code>API</code>等)来构建，<strong>上传镜像</strong>并发布命令来<strong>创建</strong>和<strong>启动容器</strong>。</li><li><strong>Docker主机</strong>：从<code>Docker registry</code>上下载<strong>镜像</strong>并<strong>启动</strong>和<strong>托管</strong>容器。</li><li><strong>Docker registry</strong>：<code>Docker</code>镜像仓库，用于<strong>保存镜像</strong>，并提供镜像上传和下载。</li></ul><h2 id="Docker容器的状态机"><a href="#Docker容器的状态机" class="headerlink" title="Docker容器的状态机"></a>Docker容器的状态机</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_lifecycle.jpg" alt=""></p><p>一个容器在某个时刻可能处于以下几种状态之一：</p><p><strong>created</strong>：已经被创建 (使用<code>docker ps -a</code>命令可以列出) 但是还没有被启动，使用<code>docker ps</code>命令还无法列出。<br><strong>running</strong>：容器在这正常运行中。<br><strong>paused</strong>：容器的进程被暂停了。<br><strong>restarting</strong>：容器的进程正在重启过程中。<br><strong>exited</strong>：上图中的<code>stopped</code>状态，表示容器之前运行过但是现在处于停止状态 (要区别于<code>created</code>状态，它是指一个<strong>新创建</strong>的<strong>尚未运行过</strong>的容器)。可以通过<code>start</code>命令使其重新进入<code>running</code>状态。<br><strong>destroyed</strong>：容器从宿主机删除了，再也不存在了。</p><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><p><code>RedHat/CentOS</code>必须要<code>6.6</code>版本以上，或者<code>7.x</code>才能安装<code>docker</code>，建议在<code>RedHat/CentOS 7</code>上使用<code>docker</code>，因为<code>RedHat/CentOS 7</code>的<strong>内核</strong>升级到了<code>kernel 3.10</code>，对<code>lxc</code>容器支持更好。</p><p>查看<code>Linux</code><strong>内核版本</strong>(内核版本必须是<code>3.10</code>或者以上)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line"></span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line">lsb_release -a</span><br><span class="line"></span><br><span class="line"><span class="comment">##无法执行命令安装</span></span><br><span class="line">yum install -y redhat-lsb</span><br></pre></td></tr></table></figure><p>更新<code>yum</code>安装源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker -y</span><br></pre></td></tr></table></figure><p>检查<code>docker</code>版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>安装完成后，使用下面的命令来启动<code>docker</code>服务，并将其设置为<strong>开机启动</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">chkconfig docker on</span><br></pre></td></tr></table></figure><p>下载官方的<code>CentOS</code>的<code>docker</code>镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p>检查<code>CentOS</code>镜像是否被成功拉取到本地宿主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地镜像列表</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi &lt;image id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像(针对多个相同image id的镜像)</span></span><br><span class="line">docker rmi repository:tag</span><br></pre></td></tr></table></figure><p>镜像下载完成后，你应该会看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze74fkxrls31tr2ia2fZ ~]<span class="comment"># docker images centos</span></span><br><span class="line">REPOSITORY       TAG        IMAGE ID     CREATED         SIZE</span><br><span class="line">docker.io/centos latest    3fa822599e10    3weeks ago   203.5 MB</span><br></pre></td></tr></table></figure><p>如果看到以上输出，说明你可以使用<code>docker.io/centos</code>这个镜像了，或将其称为<strong>仓库</strong>(<code>Repository</code>)，该镜像有一个名为<code>latest</code>的<strong>标签</strong>(<code>Tag</code>)，此外还有一个名为<code>3fa822599e10</code>的镜像<code>ID</code> (可能您所看到的镜像 ID 与此处的不一致，那是正常现象，因为这个数字是随机生成的)。<br>此外，我们可以看到该镜像只有<code>203.5MB</code>，非常小巧，而不像虚拟机的镜像文件那样庞大。</p><p>重命名<code>TAG</code>为<code>centos</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker tag IMAGE_ID(镜像id) REPOSITORY:TAG(仓库：标签)</span></span><br><span class="line">docker tag 3fa822599e10  docker.io/centos:centos</span><br></pre></td></tr></table></figure><p>启动<code>CentOS</code>的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t -v /root/software/:/mnt/software/ 3fa822599e10 /bin/bash</span><br></pre></td></tr></table></figure><p>命令参数说明：<br>docker run &lt;相关参数&gt; &lt;镜像ID&gt; &lt;初始命令&gt;</p><ul><li><code>-i</code>：表示以<strong>交互模式</strong>运行容器</li><li><code>-t</code>：表示容器启动后会进入其命令行</li><li><code>-v</code>：表示需要将本地哪个目录<strong>挂载</strong>到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;</li></ul><p>更多参数详解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">  -d, --detach=<span class="literal">false</span>         指定容器运行于前台还是后台，默认为<span class="literal">false</span></span><br><span class="line">  -i, --interactive=<span class="literal">false</span>   打开STDIN，用于控制台交互</span><br><span class="line">  -t, --tty=<span class="literal">false</span>            分配tty设备，该可以支持终端登录，默认为<span class="literal">false</span></span><br><span class="line">  -u, --user=<span class="string">""</span>              指定容器的用户</span><br><span class="line">  -a, --attach=[]            登录容器（必须是以docker run -d启动的容器）</span><br><span class="line">  -w, --workdir=<span class="string">""</span>           指定容器的工作目录</span><br><span class="line">  -c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用</span><br><span class="line">  -e, --env=[]               指定环境变量，容器中可以使用该环境变量</span><br><span class="line">  -m, --memory=<span class="string">""</span>            指定容器的内存上限</span><br><span class="line">  -P, --publish-all=<span class="literal">false</span>    指定容器暴露的端口</span><br><span class="line">  -p, --publish=[]           指定容器暴露的端口</span><br><span class="line">  -h, --hostname=<span class="string">""</span>          指定容器的主机名</span><br><span class="line">  -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录</span><br><span class="line">  --volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录</span><br><span class="line">  --<span class="built_in">cap</span>-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">  --<span class="built_in">cap</span>-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">  --cidfile=<span class="string">""</span>               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</span><br><span class="line">  --cpuset=<span class="string">""</span>                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</span><br><span class="line">  --device=[]                添加主机设备给容器，相当于设备直通</span><br><span class="line">  --dns=[]                   指定容器的dns服务器</span><br><span class="line">  --dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</span><br><span class="line">  --entrypoint=<span class="string">""</span>            覆盖image的入口点</span><br><span class="line">  --env-file=[]              指定环境变量文件，文件格式为每行一个环境变量</span><br><span class="line">  --expose=[]                指定容器暴露的端口，即修改镜像的暴露端口</span><br><span class="line">  --link=[]                  指定容器间的关联，使用其他容器的IP、env等信息</span><br><span class="line">  --lxc-conf=[]              指定容器的配置文件，只有在指定--<span class="built_in">exec</span>-driver=lxc时使用</span><br><span class="line">  --name=<span class="string">""</span>                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</span><br><span class="line">  --net=<span class="string">"bridge"</span>             容器网络设置:</span><br><span class="line">                                bridge 使用docker daemon指定的网桥</span><br><span class="line">                                host     //容器使用主机的网络</span><br><span class="line">                                container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源</span><br><span class="line">                                none 容器使用自己的网络（类似--net=bridge），但是不进行配置</span><br><span class="line">  --privileged=<span class="literal">false</span>         指定容器是否为特权容器，特权容器拥有所有的capabilities</span><br><span class="line">  --restart=<span class="string">"no"</span>             指定容器停止后的重启策略:</span><br><span class="line">                                no：容器退出时不重启</span><br><span class="line">                                on-failure：容器故障退出（返回值非零）时重启</span><br><span class="line">                                always：容器退出时总是重启</span><br><span class="line">  --rm=<span class="literal">false</span>                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</span><br><span class="line">  --sig-proxy=<span class="literal">true</span>           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</span><br></pre></td></tr></table></figure><h2 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h2><p>我们可以把<code>Docker</code>的命令大概地分类如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 镜像操作：</span></span><br><span class="line">    build     Build an image from a Dockerfile</span><br><span class="line">    commit    Create a new image from a container<span class="string">'s changes</span></span><br><span class="line"><span class="string">    images    List images</span></span><br><span class="line"><span class="string">    load      Load an image from a tar archive or STDIN</span></span><br><span class="line"><span class="string">    pull      Pull an image or a repository from a registry</span></span><br><span class="line"><span class="string">    push      Push an image or a repository to a registry</span></span><br><span class="line"><span class="string">    rmi       Remove one or more images</span></span><br><span class="line"><span class="string">    search    Search the Docker Hub for images</span></span><br><span class="line"><span class="string">    tag       Tag an image into a repository</span></span><br><span class="line"><span class="string">    save      Save one or more images to a tar archive</span></span><br><span class="line"><span class="string">    history   显示某镜像的历史</span></span><br><span class="line"><span class="string">    inspect   获取镜像的详细信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 容器及其中应用的生命周期操作：</span></span><br><span class="line"><span class="string">    create    创建一个容器</span></span><br><span class="line"><span class="string">    kill      Kill one or more running containers</span></span><br><span class="line"><span class="string">    inspect   Return low-level information on a container, image or task</span></span><br><span class="line"><span class="string">    pause     Pause all processes within one or more containers</span></span><br><span class="line"><span class="string">    ps        List containers</span></span><br><span class="line"><span class="string">    rm        删除一个或者多个容器</span></span><br><span class="line"><span class="string">    rename    Rename a container</span></span><br><span class="line"><span class="string">    restart   Restart a container</span></span><br><span class="line"><span class="string">    run       创建并启动一个容器</span></span><br><span class="line"><span class="string">    start     启动一个处于停止状态的容器</span></span><br><span class="line"><span class="string">    stats     显示容器实时的资源消耗信息</span></span><br><span class="line"><span class="string">    stop      停止一个处于运行状态的容器</span></span><br><span class="line"><span class="string">    top       Display the running processes of a container</span></span><br><span class="line"><span class="string">    unpause   Unpause all processes within one or more containers</span></span><br><span class="line"><span class="string">    update    Update configuration of one or more containers</span></span><br><span class="line"><span class="string">    wait      Block until a container stops, then print its exit code</span></span><br><span class="line"><span class="string">    attach    Attach to a running container</span></span><br><span class="line"><span class="string">    exec      Run a command in a running container</span></span><br><span class="line"><span class="string">    port      List port mappings or a specific mapping for the container</span></span><br><span class="line"><span class="string">    logs      获取容器的日志</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 容器文件系统操作：</span></span><br><span class="line"><span class="string">    cp        Copy files/folders between a container and the local filesystem</span></span><br><span class="line"><span class="string">    diff      Inspect changes on a container'</span>s filesystem</span><br><span class="line">    <span class="built_in">export</span>    Export a container<span class="string">'s filesystem as a tar archive</span></span><br><span class="line"><span class="string">    import    Import the contents from a tarball to create a filesystem image</span></span><br><span class="line"><span class="string">    Docker registry 操作：</span></span><br><span class="line"><span class="string">    login     Log in to a Docker registry.</span></span><br><span class="line"><span class="string">    logout    Log out from a Docker registry.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Volume操作：</span></span><br><span class="line"><span class="string">    volume    Manage Docker volumes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 网络操作：</span></span><br><span class="line"><span class="string">    network   Manage Docker networks</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Swarm 相关操作：</span></span><br><span class="line"><span class="string">    swarm     Manage Docker Swarm</span></span><br><span class="line"><span class="string">    service   Manage Docker services</span></span><br><span class="line"><span class="string">    node      Manage Docker Swarm nodes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 系统操作：</span></span><br><span class="line"><span class="string">    version   Show the Docker version information</span></span><br><span class="line"><span class="string">    events    持续返回docker 事件</span></span><br><span class="line"><span class="string">    info      显示Docker 主机系统范围内的信息</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line">按Ctrl+D 即可退出当前容器【但退出后会停止容器】</span><br><span class="line"><span class="comment"># 退出不停止容器：</span></span><br><span class="line">组合键：Ctrl+P+Q</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start 容器名或ID</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker attach 容器名或ID</span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop 容器名或ID</span><br><span class="line"><span class="comment"># 暂停容器</span></span><br><span class="line">docker pause 容器名或ID</span><br><span class="line"><span class="comment">#继续容器</span></span><br><span class="line">docker unpause 容器名或ID</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm 容器名或ID</span><br><span class="line"><span class="comment"># 删除全部容器--慎用</span></span><br><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br><span class="line"><span class="comment">#保存容器，生成镜像</span></span><br><span class="line">docker commit 容器ID 镜像名称</span><br><span class="line"><span class="comment">#从 host 拷贝文件到 container 里面</span></span><br><span class="line">docker cp /home/soft centos:/webapp</span><br></pre></td></tr></table></figure><h2 id="docker-run与start的区别"><a href="#docker-run与start的区别" class="headerlink" title="docker run与start的区别"></a>docker run与start的区别</h2><p><code>docker run</code>只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令<code>docker start</code> 即可。</p><p><code>docker run</code>相当于执行了两步操作：将镜像放入容器中(<code>docker create</code>)，然后将容器启动，使之变成运行时容器(<code>docker start</code>)。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_run_docker_start.png" alt=""></p><p>而<code>docker start</code>的作用是，重新启动已存在的镜像。也就是说，如果使用这个命令，我们必须事先知道这个<strong>容器</strong>的<code>ID</code>，或者这个容器的<strong>名字</strong>，我们可以使用<code>docker ps</code>找到这个容器的信息。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_rename_ps.png" alt=""></p><p>因为容器的<code>ID</code>是<strong>随机码</strong>，而容器的名字又是看似无意义的命名，我们可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename jovial_cori  centos</span><br></pre></td></tr></table></figure><p>给这个容器命名。这样以后，我们再次启动或停止容器时，就可以直接使用这个名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [stop] [start]  new_name</span><br></pre></td></tr></table></figure><p>而要显示出所有容器，包括没有启动的，可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h2 id="Docker的配置"><a href="#Docker的配置" class="headerlink" title="Docker的配置"></a>Docker的配置</h2><p>更改存储目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制docker存储目录</span></span><br><span class="line">rsync -aXS /var/lib/docker/. /home/docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#更改 docker 存储文件目录</span></span><br><span class="line">ln -s  /home/docker  /var/lib/docker</span><br></pre></td></tr></table></figure><p>查看启动容器的具体信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;container_id&gt;</span><br></pre></td></tr></table></figure><p>要获取所有容器名称及其<code>IP</code>地址只需一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">'&#123;&#123;.Name&#125;&#125; - &#123;&#123;.NetworkSettings.IPAddress &#125;&#125;'</span> $(docker ps -aq)</span><br><span class="line"></span><br><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;'</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure><h2 id="Docker镜像加速器"><a href="#Docker镜像加速器" class="headerlink" title="Docker镜像加速器"></a>Docker镜像加速器</h2><p>注册一个阿里云帐号：</p><p><a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></p><p>阿里云会自动为用户分配一个镜像加速器的地址，登录后进入”管理中心” —&gt; ”加速器”，里面有分配给你的镜像加速器的地址以及各个环境的使用说明。</p><p>镜像加速器地址示例：<a href="https://xxxxx.mirror.aliyuncs.com" target="_blank" rel="noopener">https://xxxxx.mirror.aliyuncs.com</a></p><h3 id="如何配置镜像加速器"><a href="#如何配置镜像加速器" class="headerlink" title="如何配置镜像加速器"></a>如何配置镜像加速器</h3><p>针对<code>Docker</code>客户端版本大于<code>1.10.0</code>的用户，可以通过修改<code>daemon</code>配置文件<code>/etc/docker/daemon.json</code><strong>来使用</strong>加速器**：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [<span class="string">"&lt;your accelerate address&gt;"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启<code>Docker Daemon</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;是一个开源工具，它可以让创建和管理&lt;code&gt;Linux&lt;/code&gt;容器变得简单。&lt;strong&gt;容器&lt;/strong&gt;就像是&lt;strong&gt;轻量级&lt;/strong&gt;的&lt;strong&gt;虚拟机&lt;/strong&gt;，并且可以以&lt;strong&gt;毫秒级&lt;/strong&gt;的速度来启动或停止。&lt;code&gt;Docker&lt;/code&gt;帮助系统管理员和程序员&lt;strong&gt;在容器中开发应用程序&lt;/strong&gt;，并且可以扩展到成千上万的节点。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker学习系列" scheme="https://ostenant.coding.me/categories/Docker%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="CentOS" scheme="https://ostenant.coding.me/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Apache Thrift系列详解(三) - 序列化机制</title>
    <link href="https://ostenant.coding.me/2018/01/16/Apache%20Thrift%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3(%E4%B8%89)%20-%20%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>https://ostenant.coding.me/2018/01/16/Apache Thrift系列详解(三) - 序列化机制/</id>
    <published>2018-01-16T07:37:00.000Z</published>
    <updated>2018-05-08T02:49:46.087Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Thrift</code>支持<strong>二进制</strong>，<strong>压缩格式</strong>，以及<code>json</code>格式数据的<strong>序列化</strong>和<strong>反序列化</strong>。开发人员可以更加灵活的选择协议的具体形式。协议是可<strong>自由扩展</strong>的，新版本的协议，完全<strong>兼容</strong>老的版本！</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="数据交换格式简介"><a href="#数据交换格式简介" class="headerlink" title="数据交换格式简介"></a>数据交换格式简介</h2><p>当前流行的<strong>数据交换格式</strong>可以分为如下几类：</p><h3 id="一-自解析型"><a href="#一-自解析型" class="headerlink" title="(一) 自解析型"></a>(一) 自解析型</h3><p>序列化的数据包含<strong>完整</strong>的结构， 包含了<code>field</code><strong>名称</strong>和<code>value</code><strong>值</strong>。比如<code>xml/json/java serizable</code>，大百度的<code>mcpack/compack</code>，都属于此类。即调整不同属性的<strong>顺序</strong>对<strong>序列化/反序列化</strong>不造成影响。</p><h3 id="二-半解析型"><a href="#二-半解析型" class="headerlink" title="(二) 半解析型"></a>(二) 半解析型</h3><p>序列化的数据，丢弃了部分信息， 比如<code>field</code>名称， 但引入了<code>index</code>(常常是<code>id</code>+<code>type</code>的方式)来对应具体<strong>属性</strong>和<strong>值</strong>。这方面的代表有<code>google protobuf/thrift</code>也属于此类。</p><h3 id="三-无解析型"><a href="#三-无解析型" class="headerlink" title="(三) 无解析型"></a>(三) 无解析型</h3><p>传说中大百度的<code>infpack</code>实现，就是借助该种方式来实现，丢弃了很多<strong>有效信息</strong>，<strong>性能/压缩</strong>比最好，不过向后兼容需要开发做一定的工作， 详情不知。</p><table><thead><tr><th>交换格式</th><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Xml</td><td>文本</td><td>易读</td><td>臃肿，不支持二进制数据类型</td></tr><tr><td>JSON</td><td>文本</td><td>易读</td><td>丢弃了类型信息，比如”score”:100，对score类型是int/double解析有二义性， 不支持二进制数据类型</td></tr><tr><td>Java serizable</td><td>二进制</td><td>使用简单</td><td>臃肿，只限制在JAVA领域</td></tr><tr><td>Thrift</td><td>二进制</td><td>高效</td><td>不易读，向后兼容有一定的约定限制</td></tr><tr><td>Google Protobuf</td><td>二进制</td><td>高效</td><td>不易读，向后兼容有一定的约定限制</td></tr></tbody></table><h2 id="Thrift的数据类型"><a href="#Thrift的数据类型" class="headerlink" title="Thrift的数据类型"></a>Thrift的数据类型</h2><ol><li><strong>基本类型：</strong><br>　　<strong>bool</strong>: 布尔值<br>　　<strong>byte</strong>: 8位有符号整数<br>　　<strong>i16</strong>: 16位有符号整数<br>　　<strong>i32</strong>: 32位有符号整数<br>　　<strong>i64</strong>: 64位有符号整数<br>　　<strong>double</strong>: 64位浮点数<br>　　<strong>string</strong>: UTF-8编码的字符串<br>　　<strong>binary</strong>: 二进制串</li><li><strong>结构体类型：</strong><br>　　<strong>struct</strong>: 定义的结构体对象</li><li><strong>容器类型：</strong><br>　　<strong>list</strong>: 有序元素列表<br>　　<strong>set</strong>: 无序无重复元素集合<br>　　<strong>map</strong>: 有序的key/value集合</li><li><strong>异常类型：</strong><br>　　<strong>exception</strong>: 异常类型</li><li><strong>服务类型：</strong><br>　　<strong>service</strong>: 具体对应服务的类</li></ol><h2 id="Thrift的序列化协议"><a href="#Thrift的序列化协议" class="headerlink" title="Thrift的序列化协议"></a>Thrift的序列化协议</h2><p><code>Thrift</code>可以让用户选择<strong>客户端</strong>与<strong>服务端</strong>之间<strong>传输通信协议</strong>的类别，在<strong>传输协议</strong>上总体划分为<strong>文本</strong>(<code>text</code>)和<strong>二进制</strong>(<code>binary</code>)传输协议。为<strong>节约带宽</strong>，<strong>提高传输效率</strong>，一般情况下使用<strong>二进制</strong>类型的传输协议为多数，有时还会使用基于<strong>文本类型</strong>的协议，这需要根据项目/产品中的实际需求。常用协议有以下几种：</p><ul><li>TBinaryProtocol：<strong>二进制</strong>编码格式进行数据传输</li><li>TCompactProtocol：<strong>高效率</strong>的、<strong>密集</strong>的<strong>二进制</strong>编码格式进行数据传输</li><li>TJSONProtocol： 使用<code>JSON</code><strong>文本</strong>的数据编码协议进行数据传输</li><li>TSimpleJSONProtocol：只提供<code>JSON</code><strong>只写</strong>的协议，适用于通过<strong>脚本语言解析</strong></li></ul><h2 id="Thrift的序列化测试"><a href="#Thrift的序列化测试" class="headerlink" title="Thrift的序列化测试"></a>Thrift的序列化测试</h2><p>(a). 首先编写一个简单的<code>thrift</code>文件<code>pair.thrift</code>：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> key</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里标识了<code>required</code>的字段，要求在使用时必须正确赋值，否则运行时会抛出<code>TProtocolException</code>异常。缺省和指定为<code>optional</code>时，则运行时不做字段非空校验。</p></blockquote><p>(b). 编译并生成<code>java</code>源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -gen java pair.thrift</span><br></pre></td></tr></table></figure><p>(c). 编写序列化和反序列化的测试代码：</p><ul><li>序列化测试，将<code>Pair</code>对象写入文件中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> <span class="keyword">throws</span> IOException， TException </span>&#123;</span><br><span class="line">    Pair pair = <span class="keyword">new</span> Pair();</span><br><span class="line">    pair.setKey(<span class="string">"key1"</span>).setValue(<span class="string">"value1"</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"pair.txt"</span>));</span><br><span class="line">    pair.write(<span class="keyword">new</span> TBinaryProtocol(<span class="keyword">new</span> TIOStreamTransport(fos)));</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反序列化测试，从文件中解析生成<code>Pair</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> <span class="keyword">throws</span> TException， IOException </span>&#123;</span><br><span class="line">    Pair pair = <span class="keyword">new</span> Pair();</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"pair.txt"</span>));</span><br><span class="line">    pair.read(<span class="keyword">new</span> TBinaryProtocol(<span class="keyword">new</span> TIOStreamTransport(fis)));</span><br><span class="line">    System.out.println(<span class="string">"key =&gt; "</span> + pair.getKey());</span><br><span class="line">    System.out.println(<span class="string">"value =&gt; "</span> + pair.getValue());</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(d) 观察运行结果，正常输出表明<strong>序列化</strong>和<strong>反序列化</strong>过程正常完成。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Serialization_Pair.png" alt=""></p><h2 id="Thrift协议源码"><a href="#Thrift协议源码" class="headerlink" title="Thrift协议源码"></a>Thrift协议源码</h2><h3 id="一-writeData-分析"><a href="#一-writeData-分析" class="headerlink" title="(一) writeData()分析"></a>(一) writeData()分析</h3><p>首先查看<code>thrift</code>的<strong>序列化机制</strong>，即数据写入实现，这里采用<strong>二进制协议</strong><code>TBinaryProtocol</code>，切入点为<code>pair.write(TProtocol)</code>：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_write.png" alt=""></p><p>查看<code>scheme()</code>方法，决定采用<strong>元组计划</strong>(<code>TupleScheme</code>)还是<strong>标准计划</strong>(<code>StandardScheme</code>)来实现序列化，默认采用的是<strong>标准计划</strong><code>StandardScheme</code>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_Scheme.png" alt=""></p><p><strong>标准计划</strong>(<code>StandardScheme</code>)下的<code>write()</code>方法：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_Standard_Scheme_Write.png" alt=""></p><p>这里完成了几步操作：</p><p>(a). 根据<code>Thrift IDL</code>文件中定义了<code>required</code>的字段验证字段是否正确赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">  <span class="comment">// check for required fields</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'key' was not present! Struct: "</span> + toString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'value' was not present! Struct: "</span> + toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(b). 通过<code>writeStructBegin()</code>记录<strong>写入结构</strong>的<strong>开始标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructBegin</span><span class="params">(TStruct struct)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>(c). 逐一写入<code>Pair</code>对象的各个字段，包括字段<strong>字段开始标记</strong>、<strong>字段的值</strong>和<strong>字段结束标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (struct.key != <span class="keyword">null</span>) &#123;</span><br><span class="line">  oprot.writeFieldBegin(KEY_FIELD_DESC);</span><br><span class="line">  oprot.writeString(struct.key);</span><br><span class="line">  oprot.writeFieldEnd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略...</span></span><br></pre></td></tr></table></figure><p>(1). 首先是<strong>字段开始标记</strong>，包括<code>type</code>和<code>field-id</code>。<code>type</code>是字段的<strong>数据类型的标识号</strong>，<code>field-id</code>是<code>Thrift IDL</code>定义的<strong>字段次序</strong>，比如说<code>key</code>为1，<code>value</code>为2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  writeByte(field.type);</span><br><span class="line">  writeI16(field.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thrift</code>提供了<code>TType</code>，对不同的<strong>数据类型</strong>(<code>type</code>)提供了唯一标识的<code>typeID</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STOP   = <span class="number">0</span>;   <span class="comment">// 数据读写完成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> VOID   = <span class="number">1</span>;   <span class="comment">// 空值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BOOL   = <span class="number">2</span>;   <span class="comment">// 布尔值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BYTE   = <span class="number">3</span>;   <span class="comment">// 字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DOUBLE = <span class="number">4</span>;   <span class="comment">// 双精度浮点型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I16    = <span class="number">6</span>;   <span class="comment">// 短整型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I32    = <span class="number">8</span>;   <span class="comment">// 整型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I64    = <span class="number">10</span>;  <span class="comment">// 长整型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRING = <span class="number">11</span>;  <span class="comment">// 字符串类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRUCT = <span class="number">12</span>;  <span class="comment">// 引用类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAP    = <span class="number">13</span>;  <span class="comment">// Map</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SET    = <span class="number">14</span>;  <span class="comment">// 集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LIST   = <span class="number">15</span>;  <span class="comment">// 列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ENUM   = <span class="number">16</span>;  <span class="comment">// 枚举</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2). 然后是写入<strong>字段的值</strong>，根据字段的数据类型又归纳为以下实现：<code>writeByte()</code>、<code>writeBool()</code>、<code>writeI32()</code>、<code>writeI64()</code>、<code>writeDouble()</code>、<code>writeString()</code>和<code>writeBinary()</code>方法。</p><p><code>TBinaryProtocol</code>通过一个长度为<code>8</code>的<code>byte</code>字节数组缓存<strong>写入</strong>或<strong>读取</strong>的临时字节数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] inoutTemp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong>常识1：</strong>16进制的介绍。以0x开始的数据表示16进制，0xff换成十进制为255。在16进制中，A、B、C、D、E、F这五个字母来分别表示10、11、12、13、14、15。</p></blockquote><p><code>16</code><strong>进制</strong>变<strong>十进制</strong>：f表示15。第n位的权值为16的n次方，由右到左从0位起：0xff = 15<em>16^1 + 15</em>16^0 = 255<br><code>16</code><strong>进制</strong>变<strong>二进制</strong>再变<strong>十进制</strong>：0xff = 1111 1111 = 2^8 - 1 = 255</p><blockquote><p><strong>常识2：</strong>位运算符的使用。&gt;&gt;表示代表右移符号，如：int i=15; i&gt;&gt;2的结果是3，移出的部分将被抛弃。而&lt;&lt;表示左移符号，与&gt;&gt;刚好相反。</p></blockquote><p>转为<strong>二进制</strong>的形式可能更好理解，0000 1111(15)右移2位的结果是0000 0011(3)，0001 1010(18)右移3位的结果是0000 0011(3)。</p><ul><li><strong>writeByte()</strong>：写入<strong>单个字节</strong>数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  inoutTemp[<span class="number">0</span>] = b;</span><br><span class="line">  trans_.write(inoutTemp， <span class="number">0</span>， <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeBool()</strong>：写入<strong>布尔值</strong>数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  writeByte(b ? (<span class="keyword">byte</span>)<span class="number">1</span> : (<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeI16()</strong>：写入<strong>短整型</strong><code>short</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI16</span><span class="params">(<span class="keyword">short</span> i16)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  inoutTemp[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i16 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">  inoutTemp[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i16));</span><br><span class="line">  trans_.write(inoutTemp， <span class="number">0</span>， <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeI32()</strong>：写入<strong>整型</strong><code>int</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI32</span><span class="params">(<span class="keyword">int</span> i32)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  inoutTemp[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">  inoutTemp[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">  inoutTemp[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">  inoutTemp[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32));</span><br><span class="line">  trans_.write(inoutTemp， <span class="number">0</span>， <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeI64()</strong>：写入<strong>长整型</strong><code>long</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  inoutTemp[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">56</span>));</span><br><span class="line">  inoutTemp[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">48</span>));</span><br><span class="line">  inoutTemp[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">40</span>));</span><br><span class="line">  inoutTemp[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">32</span>));</span><br><span class="line">  inoutTemp[<span class="number">4</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">  inoutTemp[<span class="number">5</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">  inoutTemp[<span class="number">6</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">  inoutTemp[<span class="number">7</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64));</span><br><span class="line">  trans_.write(inoutTemp， <span class="number">0</span>， <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeDouble()</strong>：写入<strong>双浮点型</strong><code>double</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> dub)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  writeI64(Double.doubleToLongBits(dub));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeString()</strong>：写入<strong>字符串类型</strong>，这里先写入<strong>字符串长度</strong>，再写入<strong>字符串内容</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] dat = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">    writeI32(dat.length);</span><br><span class="line">    trans_.write(dat， <span class="number">0</span>， dat.length);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeBinary</strong>：写入<strong>二进制数组</strong>类型数据，这里数据输入是<code>NIO</code>中的<code>ByteBuffer</code>类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(ByteBuffer bin)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> length = bin.limit() - bin.position();</span><br><span class="line">  writeI32(length);</span><br><span class="line">  trans_.write(bin.array()， bin.position() + bin.arrayOffset()， length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3). 每个字段写入完成后，都需要记录<strong>字段结束标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>(d). 当所有的字段都写入以后，需要记录<strong>字段停止标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldStop</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  writeByte(TType.STOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(e). 当所有数据写入完成后，通过<code>writeStructEnd()</code>记录<strong>写入结构</strong>的<strong>完成标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="二-readData-分析"><a href="#二-readData-分析" class="headerlink" title="(二) readData()分析"></a>(二) readData()分析</h3><p>查看<code>thrift</code>的<strong>反序列化机制</strong>，即<strong>数据读取</strong>实现，同样采用<strong>二进制协议</strong><code>TBinaryProtocol</code>，切入点为<code>pair.read(TProtocol)</code>：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_scheme2.png" alt=""></p><p><strong>数据读取</strong>和<strong>数据写入</strong>一样，也是采用的<strong>标准计划</strong><code>StandardScheme</code>。<strong>标准计划</strong>(<code>StandardScheme</code>)下的<code>read()</code>方法：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_read.png" alt=""></p><p>这里完成的几步操作：</p><p>(a). 通过<code>readStructBegin</code>读取<strong>结构</strong>的<strong>开始标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iprot.readStructBegin();</span><br></pre></td></tr></table></figure><p>(b). 循环读取<strong>结构</strong>中的<strong>所有字段数据</strong>到<code>Pair</code>对象中，直到读取到<code>org.apache.thrift.protocol.TType.STOP</code>为止。<code>iprot.readFieldBegin()</code>指明开始读取<strong>下一个字段</strong>的前需要读取<strong>字段开始标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  schemeField = iprot.readFieldBegin();</span><br><span class="line">  <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STOP) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 字段的读取，省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(c). 根据<code>Thrift IDL</code>定义的<code>field-id</code>读取对应的字段，并赋值到<code>Pair</code>对象中，并设置<code>Pair</code>对象相应的字段为<strong>已读状态</strong>(前提：字段在<code>IDL</code>中被定义为<code>required</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (schemeField.id) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// KEY</span></span><br><span class="line">    <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STRING) &#123;</span><br><span class="line">      struct.key = iprot.readString();</span><br><span class="line">      struct.setKeyIsSet(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      org.apache.thrift.protocol.TProtocolUtil.skip(iprot， schemeField.type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STRING) &#123;</span><br><span class="line">      struct.value = iprot.readString();</span><br><span class="line">      struct.setValueIsSet(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      org.apache.thrift.protocol.TProtocolUtil.skip(iprot， schemeField.type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    org.apache.thrift.protocol.TProtocolUtil.skip(iprot， schemeField.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<strong>读取字段</strong>的值，根据字段的<strong>数据类型</strong>也分为以下实现：<code>readByte()</code>、<code>readBool()</code>、<code>readI32()</code>、<code>readI64()</code>、<code>readDouble()</code>、<code>readString()</code>和<code>readBinary()</code>方法。</p><ul><li><strong>readByte()</strong>：读取<strong>单个字节</strong>数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">byte</span> b = trans_.getBuffer()[trans_.getBufferPosition()];</span><br><span class="line">    trans_.consumeBuffer(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">  readAll(inoutTemp， <span class="number">0</span>， <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> inoutTemp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readBool()</strong>：读取<strong>布尔值</strong>数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (readByte() == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readI16()</strong>：读取<strong>短整型</strong><code>short</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] buf = inoutTemp;</span><br><span class="line">  <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    buf = trans_.getBuffer();</span><br><span class="line">    off = trans_.getBufferPosition();</span><br><span class="line">    trans_.consumeBuffer(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readAll(inoutTemp， <span class="number">0</span>， <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">short</span>) (((buf[off] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">                 ((buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readI32()</strong>：读取<strong>整型</strong><code>int</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readI32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] buf = inoutTemp;</span><br><span class="line">  <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">    buf = trans_.getBuffer();</span><br><span class="line">    off = trans_.getBufferPosition();</span><br><span class="line">    trans_.consumeBuffer(<span class="number">4</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readAll(inoutTemp， <span class="number">0</span>， <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((buf[off] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">         ((buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         ((buf[off+<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">         ((buf[off+<span class="number">3</span>] &amp; <span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readI64()</strong>：读取<strong>长整型</strong><code>long</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readI64</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] buf = inoutTemp;</span><br><span class="line">  <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">    buf = trans_.getBuffer();</span><br><span class="line">    off = trans_.getBufferPosition();</span><br><span class="line">    trans_.consumeBuffer(<span class="number">8</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readAll(inoutTemp， <span class="number">0</span>， <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">long</span>)(buf[off]   &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">56</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">4</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">5</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">6</span>] &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">7</span>] &amp; <span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readDouble()</strong>：读取<strong>双精度浮点</strong><code>double</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Double.longBitsToDouble(readI64());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readString()</strong>：读取<strong>字符串类型</strong>的数据，首先读取并校验<code>4</code>字节的<strong>字符串长度</strong>，然后检查<code>NIO</code><strong>缓冲区</strong>中是否有对应长度的字节<strong>未消费</strong>。如果有，直接从<strong>缓冲区</strong>中读取；否则，从<strong>传输通道</strong>中读取数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = readI32();</span><br><span class="line">  checkStringReadLength(size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String s = <span class="keyword">new</span> String(trans_.getBuffer()， trans_.getBufferPosition()， size， <span class="string">"UTF-8"</span>);</span><br><span class="line">      trans_.consumeBuffer(size);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> readStringBody(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是从<strong>传输通道</strong>中读取数据，查看<code>readStringBody()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readStringBody</span><span class="params">(<span class="keyword">int</span> size)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    trans_.readAll(buf， <span class="number">0</span>， size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf， <span class="string">"UTF-8"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readBinary()</strong>：读取<strong>二进制数组</strong>类型数据，和<strong>字符串读取</strong>类似，返回一个<code>ByteBuffer</code>字节缓存对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">readBinary</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = readI32();</span><br><span class="line">  checkStringReadLength(size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.wrap(trans_.getBuffer()， trans_.getBufferPosition()， size);</span><br><span class="line">    trans_.consumeBuffer(size);</span><br><span class="line">    <span class="keyword">return</span> bb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">  trans_.readAll(buf， <span class="number">0</span>， size);</span><br><span class="line">  <span class="keyword">return</span> ByteBuffer.wrap(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(d). 每个字段数据读取完成后，都需要再读取一个<strong>字段结束标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>(e). 当所有字段读取完成后，需要通过<code>readStructEnd()</code>再读入一个<strong>结构完成标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStructEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>(f). 读取结束后，同样需要校验在<code>Thrift IDL</code>中定义为<code>required</code>的字段是否为空，是否合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">  <span class="comment">// check for required fields</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'key' was not present! Struct: "</span> + toString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'value' was not present! Struct: "</span> + toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实到这里，对于<code>Thrift</code>的<strong>序列化机制</strong>和<strong>反序列化机制</strong>的<strong>具体实现</strong>和<strong>高效性</strong>，相信各位已经有了比较深入的认识！</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Thrift&lt;/code&gt;支持&lt;strong&gt;二进制&lt;/strong&gt;，&lt;strong&gt;压缩格式&lt;/strong&gt;，以及&lt;code&gt;json&lt;/code&gt;格式数据的&lt;strong&gt;序列化&lt;/strong&gt;和&lt;strong&gt;反序列化&lt;/strong&gt;。开发人员可以更加灵活的选择协议的具体形式。协议是可&lt;strong&gt;自由扩展&lt;/strong&gt;的，新版本的协议，完全&lt;strong&gt;兼容&lt;/strong&gt;老的版本！&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Thrift" scheme="https://ostenant.coding.me/tags/Thrift/"/>
    
      <category term="Apache" scheme="https://ostenant.coding.me/tags/Apache/"/>
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Apache Thrift系列详解(二) - 网络服务模型</title>
    <link href="https://ostenant.coding.me/2018/01/11/Apache%20Thrift%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3(%E4%BA%8C)%20-%20%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ostenant.coding.me/2018/01/11/Apache Thrift系列详解(二) - 网络服务模型/</id>
    <published>2018-01-11T09:36:00.000Z</published>
    <updated>2018-05-08T02:49:46.088Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Thrift</code>提供的<strong>网络服务模型</strong>：<strong>单线程</strong>、<strong>多线程</strong>、<strong>事件驱动</strong>，从另一个角度划分为：<strong>阻塞服务模型</strong>、<strong>非阻塞服务模型</strong>。</p><a id="more"></a><ul><li><p>阻塞服务模型：<code>TSimpleServer</code>、<code>TThreadPoolServer</code>。</p></li><li><p>非阻塞服务模型：<code>TNonblockingServer</code>、<code>THsHaServer</code>和<code>TThreadedSelectorServer</code>。</p></li></ul><p><code>TServer</code>类的层次关系：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/TServer_Model2.png" alt=""></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="TServer"><a href="#TServer" class="headerlink" title="TServer"></a>TServer</h2><p><code>TServer</code>定义了静态内部类<code>Args</code>，<code>Args</code>继承自抽象类<code>AbstractServerArgs</code>。<code>AbstractServerArgs</code>采用了建造者模式，向<code>TServer</code>提供各种工厂：</p><table><thead><tr><th>工厂属性</th><th>工厂类型</th><th>作用</th></tr></thead><tbody><tr><td>ProcessorFactory</td><td>TProcessorFactory</td><td>处理层工厂类，用于具体的TProcessor对象的创建</td></tr><tr><td>InputTransportFactory</td><td>TTransportFactory</td><td>传输层输入工厂类，用于具体的TTransport对象的创建</td></tr><tr><td>OutputTransportFactory</td><td>TTransportFactory</td><td>传输层输出工厂类，用于具体的TTransport对象的创建</td></tr><tr><td>InputProtocolFactory</td><td>TProtocolFactory</td><td>协议层输入工厂类，用于具体的TProtocol对象的创建</td></tr><tr><td>OutputProtocolFactory</td><td>TProtocolFactory</td><td>协议层输出工厂类，用于具体的TProtocol对象的创建</td></tr></tbody></table><p>下面是<code>TServer</code>的部分核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Args</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">server</span>.<span class="title">TServer</span>.<span class="title">AbstractServerArgs</span>&lt;<span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">server</span>.<span class="title">TServer</span>.<span class="title">Args</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Args</span><span class="params">(TServerTransport transport)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(transport);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerArgs</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">server</span>.<span class="title">TServer</span>.<span class="title">AbstractServerArgs</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TServerTransport serverTransport;</span><br><span class="line">        TProcessorFactory processorFactory;</span><br><span class="line">        TTransportFactory inputTransportFactory = <span class="keyword">new</span> TTransportFactory();</span><br><span class="line">        TTransportFactory outputTransportFactory = <span class="keyword">new</span> TTransportFactory();</span><br><span class="line">        TProtocolFactory inputProtocolFactory = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line">        TProtocolFactory outputProtocolFactory = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbstractServerArgs</span><span class="params">(TServerTransport transport)</span> </span>&#123;</span><br><span class="line">            serverTransport = transport;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> TProcessorFactory processorFactory_;</span><br><span class="line">    <span class="keyword">protected</span> TServerTransport serverTransport_;</span><br><span class="line">    <span class="keyword">protected</span> TTransportFactory inputTransportFactory_;</span><br><span class="line">    <span class="keyword">protected</span> TTransportFactory outputTransportFactory_;</span><br><span class="line">    <span class="keyword">protected</span> TProtocolFactory inputProtocolFactory_;</span><br><span class="line">    <span class="keyword">protected</span> TProtocolFactory outputProtocolFactory_;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isServing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TServer</span><span class="params">(org.apache.thrift.server.TServer.AbstractServerArgs args)</span> </span>&#123;</span><br><span class="line">        processorFactory_ = args.processorFactory;</span><br><span class="line">        serverTransport_ = args.serverTransport;</span><br><span class="line">        inputTransportFactory_ = args.inputTransportFactory;</span><br><span class="line">        outputTransportFactory_ = args.outputTransportFactory;</span><br><span class="line">        inputProtocolFactory_ = args.inputProtocolFactory;</span><br><span class="line">        outputProtocolFactory_ = args.outputProtocolFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isServing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isServing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setServing</span><span class="params">(<span class="keyword">boolean</span> serving)</span> </span>&#123;</span><br><span class="line">        isServing = serving;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TServer</code>的三个方法：<code>serve()</code>、<code>stop()</code>和<code>isServing()</code>。<code>serve()</code>用于启动服务，<code>stop()</code>用于关闭服务，<code>isServing()</code>用于检测服务的起停状态。</p><p><code>TServer</code>的<strong>不同实现类</strong>的启动方式不一样，因此<code>serve()</code>定义为抽象方法。不是所有的服务都需要优雅的退出, 因此<code>stop()</code>方法没有被定义为抽象。</p><hr><h2 id="TSimpleServer"><a href="#TSimpleServer" class="headerlink" title="TSimpleServer"></a>TSimpleServer</h2><p><code>TSimpleServer</code>的<strong>工作模式</strong>采用最简单的<strong>阻塞</strong>IO，实现方法简洁明了，便于理解，但是一次只能接收和处理一个<code>socket</code>连接，效率比较低。它主要用于演示<code>Thrift</code>的工作过程，在实际开发过程中很少用到它。</p><h3 id="一-工作流程"><a href="#一-工作流程" class="headerlink" title="(一) 工作流程"></a>(一) 工作流程</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/Simple_Server_Processor.png" alt=""></p><h3 id="二-使用入门"><a href="#二-使用入门" class="headerlink" title="(二) 使用入门"></a>(二) 使用入门</h3><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(ServerConfig.SERVER_PORT);</span><br><span class="line">TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(serverSocket);</span><br><span class="line">HelloWorldService.Processor processor =</span><br><span class="line">        <span class="keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="keyword">new</span> HelloWorldServiceImpl());</span><br><span class="line">TBinaryProtocol.Factory protocolFactory = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line"></span><br><span class="line">TSimpleServer.Args tArgs = <span class="keyword">new</span> TSimpleServer.Args(serverTransport);</span><br><span class="line">tArgs.processor(processor);</span><br><span class="line">tArgs.protocolFactory(protocolFactory);</span><br><span class="line"><span class="comment">// 简单的单线程服务模型 一般用于测试</span></span><br><span class="line">TServer tServer = <span class="keyword">new</span> TSimpleServer(tArgs);</span><br><span class="line">System.out.println(<span class="string">"Running Simple Server"</span>);</span><br><span class="line">tServer.serve();</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TTransport transport = <span class="keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT);</span><br><span class="line">TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">HelloWorldService.Client client = <span class="keyword">new</span> HelloWorldService.Client(protocol);</span><br><span class="line">transport.open();</span><br><span class="line"></span><br><span class="line">String result = client.say(<span class="string">"Leo"</span>);</span><br><span class="line">System.out.println(<span class="string">"Result =: "</span> + result);</span><br><span class="line">transport.close();</span><br></pre></td></tr></table></figure><h3 id="三-源码分析"><a href="#三-源码分析" class="headerlink" title="(三) 源码分析"></a>(三) 源码分析</h3><p>查看上述流程的源代码，即<code>TSimpleServer.java</code>中的<code>serve()</code>方法如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Simple_Server_Source_Code_Snapshot.png" alt=""></p><p><code>serve()</code>方法的操作：</p><ol><li>设置<code>TServerSocket</code>的<code>listen()</code>方法启动连接<strong>监听</strong>。</li><li>以<strong>阻塞</strong>的方式接受客户端地连接请求，每进入一个<strong>连接</strong>即为其创建一个通道<code>TTransport</code>对象。</li><li>为客户端创建<strong>处理器对象</strong>、<strong>输入传输通道对象</strong>、<strong>输出传输通道对象</strong>、<strong>输入协议对象</strong>和<strong>输出协议对象</strong>。</li><li>通过<code>TServerEventHandler</code>对象处理具体的业务请求。</li></ol><hr><h2 id="ThreadPoolServer"><a href="#ThreadPoolServer" class="headerlink" title="ThreadPoolServer"></a>ThreadPoolServer</h2><p><code>TThreadPoolServer</code>模式采用<strong>阻塞</strong><code>socket</code>方式工作，主线程负责<strong>阻塞式</strong>监听是否有新<code>socket</code>到来，具体的业务处理交由一个<strong>线程池</strong>来处理。</p><h3 id="一-工作流程-1"><a href="#一-工作流程-1" class="headerlink" title="(一) 工作流程"></a>(一) 工作流程</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/Thread_Pool_Server.png" alt=""></p><h3 id="二-使用入门-1"><a href="#二-使用入门-1" class="headerlink" title="(二) 使用入门"></a>(二) 使用入门</h3><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(ServerConfig.SERVER_PORT);</span><br><span class="line">TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(serverSocket);</span><br><span class="line">HelloWorldService.Processor&lt;HelloWorldService.Iface&gt; processor =</span><br><span class="line">        <span class="keyword">new</span> HelloWorldService.Processor&lt;&gt;(<span class="keyword">new</span> HelloWorldServiceImpl());</span><br><span class="line"></span><br><span class="line">TBinaryProtocol.Factory protocolFactory = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line">TThreadPoolServer.Args ttpsArgs = <span class="keyword">new</span> TThreadPoolServer.Args(serverTransport);</span><br><span class="line">ttpsArgs.processor(processor);</span><br><span class="line">ttpsArgs.protocolFactory(protocolFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池服务模型 使用标准的阻塞式IO 预先创建一组线程处理请求</span></span><br><span class="line">TServer ttpsServer = <span class="keyword">new</span> TThreadPoolServer(ttpsArgs);</span><br><span class="line">System.out.println(<span class="string">"Running ThreadPool Server"</span>);</span><br><span class="line">ttpsServer.serve();</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TTransport transport = <span class="keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT);</span><br><span class="line">TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">HelloWorldService.Client client = <span class="keyword">new</span> HelloWorldService.Client(protocol);</span><br><span class="line"></span><br><span class="line">transport.open();</span><br><span class="line">String result = client.say(<span class="string">"ThreadPoolClient"</span>);</span><br><span class="line">System.out.println(<span class="string">"Result =: "</span> + result);</span><br><span class="line">transport.close();</span><br></pre></td></tr></table></figure><h3 id="三-源码分析-1"><a href="#三-源码分析-1" class="headerlink" title="(三) 源码分析"></a>(三) 源码分析</h3><p><code>ThreadPoolServer</code>解决了<code>TSimpleServer</code>不支持<strong>并发</strong>和<strong>多连接</strong>的问题，引入了<strong>线程池</strong>。实现的模型是<code>One Thread Per Connection</code>。查看上述流程的源代码，先查看<strong>线程池</strong>的代码片段：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thread_Pool_Execute_Service.png" alt=""></p><p><code>TThreadPoolServer.java</code>中的<code>serve()</code>方法如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thread_Pool_Serve_Code_Snapshot.png" alt=""></p><p><code>serve()</code>方法的操作：</p><ol><li>设置<code>TServerSocket</code>的<code>listen()</code>方法启动连接<strong>监听</strong>。</li><li>以<strong>阻塞</strong>的方式接受<strong>客户端</strong>的<strong>连接请求</strong>，每进入一个<strong>连接</strong>，将<strong>通道对象</strong>封装成一个<code>WorkerProcess</code>对象(<code>WorkerProcess</code>实现了<code>Runnabel</code>接口)，并提交到<strong>线程池</strong>。</li><li><code>WorkerProcess</code>的<code>run()</code>方法负责<strong>业务处理</strong>，为客户端创建了<strong>处理器对象</strong>、<strong>输入传输通道对象</strong>、<strong>输出传输通道对象</strong>、<strong>输入协议对象</strong>和<strong>输出协议对象</strong>。</li><li>通过<code>TServerEventHandler</code>对象处理具体的业务请求。</li></ol><p><code>WorkerProcess</code>的<code>run()</code>方法：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thread_Pool_WorkProcessor_Snapshot.png" alt=""></p><h3 id="四-优缺点"><a href="#四-优缺点" class="headerlink" title="(四) 优缺点"></a>(四) 优缺点</h3><h4 id="TThreadPoolServer模式的优点"><a href="#TThreadPoolServer模式的优点" class="headerlink" title="TThreadPoolServer模式的优点"></a>TThreadPoolServer模式的优点</h4><p>拆分了<strong>监听线程</strong>(<code>Accept Thread</code>)和处理<strong>客户端连接</strong>的<strong>工作线程</strong>(<code>Worker Thread</code>)，<strong>数据读取</strong>和<strong>业务处理</strong>都交给<strong>线程池</strong>处理。因此在<strong>并发量较大</strong>时新连接也能够被及时接受。</p><p><strong>线程池模式</strong>比较适合<strong>服务器端</strong>能预知最多有多少个<strong>客户端并发</strong>的情况，这时每个请求都能被业务线程池及时处理，性能也非常高。</p><h4 id="TThreadPoolServer模式的缺点"><a href="#TThreadPoolServer模式的缺点" class="headerlink" title="TThreadPoolServer模式的缺点"></a>TThreadPoolServer模式的缺点</h4><p>线程池模式的处理能力受限于<strong>线程池</strong>的工作能力，当<strong>并发请求数</strong>大于线程池中的<strong>线程数</strong>时，新请求也只能<strong>排队等待</strong>。</p><hr><h2 id="TNonblockingServer"><a href="#TNonblockingServer" class="headerlink" title="TNonblockingServer"></a>TNonblockingServer</h2><p><code>TNonblockingServer</code>模式也是<strong>单线程工作</strong>，但是采用<code>NIO</code>的模式，借助<code>Channel/Selector</code>机制, 采用<code>IO</code><strong>事件模型</strong>来处理。</p><p>所有的<code>socket</code>都被注册到<code>selector</code>中，在一个<strong>线程</strong>中通过<code>seletor</code><strong>循环监控</strong>所有的<code>socket</code>。</p><p>每次<code>selector</code>循环结束时，处理所有的处于<strong>就绪状态</strong>的<code>socket</code>，对于有数据到来的<code>socket</code>进行<strong>数据读取</strong>操作，对于有数据发送的socket则进行<strong>数据发送</strong>操作，对于监听<code>socket</code>则产生一个新业务<code>socket</code>并将其<strong>注册</strong>到<code>selector</code>上。</p><blockquote><p>注意：TNonblockingServer要求底层的传输通道必须使用TFramedTransport。</p></blockquote><h3 id="一-工作流程-2"><a href="#一-工作流程-2" class="headerlink" title="(一) 工作流程"></a>(一) 工作流程</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/Nonblocking_Server.png" alt=""></p><h3 id="二-使用入门-2"><a href="#二-使用入门-2" class="headerlink" title="(二) 使用入门"></a>(二) 使用入门</h3><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TProcessor tprocessor = <span class="keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="keyword">new</span> HelloWorldServiceImpl());</span><br><span class="line">TNonblockingServerSocket tnbSocketTransport = <span class="keyword">new</span> TNonblockingServerSocket(ServerConfig.SERVER_PORT);</span><br><span class="line"></span><br><span class="line">TNonblockingServer.Args tnbArgs = <span class="keyword">new</span> TNonblockingServer.Args(tnbSocketTransport);</span><br><span class="line">tnbArgs.processor(tprocessor);</span><br><span class="line">tnbArgs.transportFactory(<span class="keyword">new</span> TFramedTransport.Factory());</span><br><span class="line">tnbArgs.protocolFactory(<span class="keyword">new</span> TCompactProtocol.Factory());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用非阻塞式IO服务端和客户端需要指定TFramedTransport数据传输的方式</span></span><br><span class="line">TServer server = <span class="keyword">new</span> TNonblockingServer(tnbArgs);</span><br><span class="line">System.out.println(<span class="string">"Running Non-blocking Server"</span>);</span><br><span class="line">server.serve();</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TTransport transport = <span class="keyword">new</span> TFramedTransport(<span class="keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT));</span><br><span class="line"><span class="comment">// 协议要和服务端一致</span></span><br><span class="line">TProtocol protocol = <span class="keyword">new</span> TCompactProtocol(transport);</span><br><span class="line">HelloWorldService.Client client = <span class="keyword">new</span> HelloWorldService.Client(protocol);</span><br><span class="line">transport.open();</span><br><span class="line"></span><br><span class="line">String result = client.say(<span class="string">"NonBlockingClient"</span>);</span><br><span class="line">System.out.println(<span class="string">"Result =: "</span> + result);</span><br><span class="line">transport.close();</span><br></pre></td></tr></table></figure><h3 id="三-源码分析-2"><a href="#三-源码分析-2" class="headerlink" title="(三) 源码分析"></a>(三) 源码分析</h3><p><code>TNonblockingServer</code>继承于<code>AbstractNonblockingServer</code>，这里我们更关心基于<code>NIO</code>的<code>selector</code>部分的关键代码。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Nonblocking_Server_Selector.png" alt=""></p><h3 id="四-优缺点-1"><a href="#四-优缺点-1" class="headerlink" title="(四) 优缺点"></a>(四) 优缺点</h3><h4 id="TNonblockingServer模式优点"><a href="#TNonblockingServer模式优点" class="headerlink" title="TNonblockingServer模式优点"></a>TNonblockingServer模式优点</h4><p>相比于<code>TSimpleServer</code>效率提升主要体现在<code>IO</code><strong>多路复用上</strong>，<code>TNonblockingServer</code>采用<strong>非阻塞</strong><code>IO</code>，对<code>accept/read/write</code>等<code>IO</code>事件进行<strong>监控</strong>和<strong>处理</strong>，同时监控多个<code>socket</code>的状态变化。</p><h4 id="TNonblockingServer模式缺点"><a href="#TNonblockingServer模式缺点" class="headerlink" title="TNonblockingServer模式缺点"></a>TNonblockingServer模式缺点</h4><p><code>TNonblockingServer</code>模式在<strong>业务处理</strong>上还是采用<strong>单线程顺序</strong>来完成。在业务处理比较<strong>复杂</strong>、<strong>耗时</strong>的时候，例如某些接口函数需要读取数据库执行时间较长，会导致<strong>整个服务</strong>被<strong>阻塞</strong>住，此时该模式<strong>效率也不高</strong>，因为<strong>多个调用请求任务</strong>依然是<strong>顺序</strong>一个接一个执行。</p><h2 id="THsHaServer"><a href="#THsHaServer" class="headerlink" title="THsHaServer"></a>THsHaServer</h2><p>鉴于<code>TNonblockingServer</code>的缺点，<code>THsHaServer</code>继承于<code>TNonblockingServer</code>，引入了<strong>线程池</strong>提高了任务处理的<strong>并发能力</strong>。<code>THsHaServer</code>是<strong>半同步半异步</strong>(<code>Half-Sync/Half-Async</code>)的处理模式，<code>Half-Aysnc</code>用于<code>IO</code><strong>事件处理</strong>(<code>Accept/Read/Write</code>)，<code>Half-Sync</code>用于业务<code>handler</code>对<code>rpc</code>的<strong>同步处理</strong>上。</p><blockquote><p>注意：THsHaServer和TNonblockingServer一样，要求底层的传输通道必须使用TFramedTransport。</p></blockquote><h3 id="一-工作流程-3"><a href="#一-工作流程-3" class="headerlink" title="(一) 工作流程"></a>(一) 工作流程</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/HsHaServer.png" alt=""></p><h3 id="二-使用入门-3"><a href="#二-使用入门-3" class="headerlink" title="(二) 使用入门"></a>(二) 使用入门</h3><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TNonblockingServerSocket tnbSocketTransport = <span class="keyword">new</span> TNonblockingServerSocket(ServerConfig.SERVER_PORT);</span><br><span class="line">TProcessor tprocessor = <span class="keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="keyword">new</span> HelloWorldServiceImpl());</span><br><span class="line"><span class="comment">// 半同步半异步</span></span><br><span class="line">THsHaServer.Args thhsArgs = <span class="keyword">new</span> THsHaServer.Args(tnbSocketTransport);</span><br><span class="line">thhsArgs.processor(tprocessor);</span><br><span class="line">thhsArgs.transportFactory(<span class="keyword">new</span> TFramedTransport.Factory());</span><br><span class="line">thhsArgs.protocolFactory(<span class="keyword">new</span> TBinaryProtocol.Factory());</span><br><span class="line"></span><br><span class="line">TServer server = <span class="keyword">new</span> THsHaServer(thhsArgs);</span><br><span class="line">System.out.println(<span class="string">"Running HsHa Server"</span>);</span><br><span class="line">server.serve();</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TTransport transport = <span class="keyword">new</span> TFramedTransport(<span class="keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT));</span><br><span class="line"><span class="comment">// 协议要和服务端一致</span></span><br><span class="line">TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">HelloWorldService.Client client = <span class="keyword">new</span> HelloWorldService.Client(protocol);</span><br><span class="line">transport.open();</span><br><span class="line"></span><br><span class="line">String result = client.say(<span class="string">"HsHaClient"</span>);</span><br><span class="line">System.out.println(<span class="string">"Result =: "</span> + result);</span><br><span class="line">transport.close();</span><br></pre></td></tr></table></figure><h3 id="三-源码分析-3"><a href="#三-源码分析-3" class="headerlink" title="(三) 源码分析"></a>(三) 源码分析</h3><p><code>THsHaServer</code>继承于<code>TNonblockingServer</code>，新增了<strong>线程池</strong>并发处理工作任务的功能，查看线程池的相关代码：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/HsHaServer_Args.png" alt=""></p><p><strong>任务线程池</strong>的创建过程：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/HsHaServer_Args_createInvokerPool.png" alt=""></p><blockquote><p>下文的TThreadedSelectorServer囊括了THsHaServer的大部分特性，源码分析可参考TThreadedSelectorServer。</p></blockquote><h3 id="四-优缺点-2"><a href="#四-优缺点-2" class="headerlink" title="(四) 优缺点"></a>(四) 优缺点</h3><h4 id="THsHaServer的优点"><a href="#THsHaServer的优点" class="headerlink" title="THsHaServer的优点"></a>THsHaServer的优点</h4><p><code>THsHaServer</code>与<code>TNonblockingServer</code>模式相比，<code>THsHaServer</code>在完成<strong>数据读取</strong>之后，将<strong>业务处理</strong>过程交由一个<strong>线程池</strong>来完成，<strong>主线程</strong>直接返回进行<strong>下一次循环</strong>操作，效率大大提升。</p><h4 id="THsHaServer的缺点"><a href="#THsHaServer的缺点" class="headerlink" title="THsHaServer的缺点"></a>THsHaServer的缺点</h4><p><strong>主线程</strong>仍然需要完成所有<code>socket</code>的<strong>监听接收</strong>、<strong>数据读取</strong>和<strong>数据写入</strong>操作。当<strong>并发请求数</strong>较大时，且发送<strong>数据量</strong>较多时，监听<code>socket</code>上<strong>新连接请求</strong>不能被及时接受。</p><hr><h2 id="TThreadedSelectorServer"><a href="#TThreadedSelectorServer" class="headerlink" title="TThreadedSelectorServer"></a>TThreadedSelectorServer</h2><p><code>TThreadedSelectorServer</code>是对<code>THsHaServer</code>的一种扩充，它将<code>selector</code>中的<strong>读写</strong><code>IO</code><strong>事件</strong>(<code>read/write</code>)从<strong>主线程</strong>中分离出来。同时引入<code>worker</code><strong>工作线程池</strong>，它也是种<code>Half-Sync/Half-Async</code>的服务模型。</p><p><code>TThreadedSelectorServer</code>模式是目前<code>Thrift</code>提供的最高级的<strong>线程服务模型</strong>，它内部有如果几个部分构成：</p><ol><li><strong>一个</strong><code>AcceptThread</code>线程对象，专门用于处理监听<code>socket</code>上的新连接。</li><li><strong>若干个</strong><code>SelectorThread</code>对象专门用于处理业务<code>socket</code>的<strong>网络</strong><code>I/O</code><strong>读写</strong>操作，所有网络数据的<strong>读写</strong>均是有这些线程来完成。</li><li>一个<strong>负载均衡器</strong><code>SelectorThreadLoadBalancer</code>对象，主要用于<code>AcceptThread</code><strong>线程</strong>接收到一个新<code>socket</code>连接请求时，决定将这个<strong>新连接</strong>请求分配给哪个<code>SelectorThread</code><strong>线程</strong>。</li><li>一个<code>ExecutorService</code>类型的<strong>工作线程池</strong>，在<code>SelectorThread</code>线程中，监听到有业务<code>socket</code>中有调用请求过来，则将<strong>请求数据读取</strong>之后，交给<code>ExecutorService</code><strong>线程池</strong>中的线程完成此次调用的具体执行。主要用于处理每个<code>rpc</code>请求的<code>handler</code><strong>回调处理</strong>(这部分是<strong>同步的</strong>)。</li></ol><h3 id="一-工作流程-4"><a href="#一-工作流程-4" class="headerlink" title="(一) 工作流程"></a>(一) 工作流程</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadedSelectorServer.png" alt=""></p><h3 id="二-使用入门-4"><a href="#二-使用入门-4" class="headerlink" title="(二) 使用入门"></a>(二) 使用入门</h3><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TNonblockingServerSocket serverSocket = <span class="keyword">new</span> TNonblockingServerSocket(ServerConfig.SERVER_PORT);</span><br><span class="line">TProcessor processor = <span class="keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="keyword">new</span> HelloWorldServiceImpl());</span><br><span class="line"><span class="comment">// 多线程半同步半异步</span></span><br><span class="line">TThreadedSelectorServer.Args ttssArgs = <span class="keyword">new</span> TThreadedSelectorServer.Args(serverSocket);</span><br><span class="line">ttssArgs.processor(processor);</span><br><span class="line">ttssArgs.protocolFactory(<span class="keyword">new</span> TBinaryProtocol.Factory());</span><br><span class="line"><span class="comment">// 使用非阻塞式IO时 服务端和客户端都需要指定数据传输方式为TFramedTransport</span></span><br><span class="line">ttssArgs.transportFactory(<span class="keyword">new</span> TFramedTransport.Factory());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程半同步半异步的服务模型</span></span><br><span class="line">TThreadedSelectorServer server = <span class="keyword">new</span> TThreadedSelectorServer(ttssArgs);</span><br><span class="line">System.out.println(<span class="string">"Running ThreadedSelector Server"</span>);</span><br><span class="line">server.serve();</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread "</span> + i) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 设置传输通道 对于非阻塞服务 需要使用TFramedTransport(用于将数据分块发送)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                TTransport transport = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    transport = <span class="keyword">new</span> TFramedTransport(<span class="keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT));</span><br><span class="line">                    TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">                    HelloWorldService.Client client = <span class="keyword">new</span> HelloWorldService.Client(protocol);</span><br><span class="line">                    transport.open();</span><br><span class="line">                    String result = client.say(<span class="string">"ThreadedSelector Client"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Result =: "</span> + result);</span><br><span class="line">                    transport.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 关闭传输通道</span></span><br><span class="line">                    transport.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-核心代码"><a href="#三-核心代码" class="headerlink" title="(三) 核心代码"></a>(三) 核心代码</h3><p>以上工作流程的三个组件<code>AcceptThread</code>、<code>SelectorThread</code>和<code>ExecutorService</code>在源码中的定义如下：</p><p><code>TThreadedSelectorServer</code>模式中有一个专门的线程<code>AcceptThread</code>用于处理<strong>新连接请求</strong>，因此能够及时响应<strong>大量并发连接请求</strong>；另外它将<strong>网络I/O操作</strong>分散到多个<code>SelectorThread</code><strong>线程</strong>中来完成，因此能够快速对<strong>网络</strong><code>I/O</code>进行<strong>读写操作</strong>，能够很好地应对<strong>网络</strong><code>I/O</code>较多的情况。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadedSelector_ThreadList.png" alt=""></p><p><code>TThreadedSelectorServer</code>默认参数定义如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thread_Selector_Args_Default.png" alt=""></p><ul><li>负责网络IO读写的selector默认线程数(selectorThreads)：2</li><li>负责业务处理的默认工作线程数(workerThreads)：5</li><li>工作线程池单个线程的任务队列大小(acceptQueueSizePerThread)：4</li></ul><p>创建、初始化并启动<code>AcceptThread</code>和<code>SelectorThreads</code>，同时启动<code>selector</code>线程的<strong>负载均衡器</strong>(<code>selectorThreads</code>)。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thread_Selector_SelectorThreads.png" alt=""></p><h4 id="AcceptThread源码"><a href="#AcceptThread源码" class="headerlink" title="AcceptThread源码"></a>AcceptThread源码</h4><p><code>AcceptThread</code>继承于<code>Thread</code>，可以看出包含三个重要的属性：<strong>非阻塞式传输通道</strong>(<code>TNonblockingServerTransport</code>)、<code>NIO</code><strong>选择器</strong>(<code>acceptSelector</code>)和<strong>选择器线程负载均衡器</strong>(<code>threadChooser</code>)。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelectorServer_AcceptThread_1.png" alt=""></p><p>查看<code>AcceptThread</code>的<code>run()</code>方法，可以看出<code>accept</code>线程一旦启动，就会不停地调用<code>select()</code>方法：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelectorServer_AcceptThread_run_2.png" alt=""></p><p>查看<code>select()</code>方法，<code>acceptSelector</code><strong>选择器</strong>等待<code>IO</code>事件的到来，拿到<code>SelectionKey</code>即检查是不是<code>accept</code>事件。如果是，通过<code>handleAccept()</code>方法接收一个<strong>新来的连接</strong>；否则，如果是<code>IO</code><strong>读写事件</strong>，<code>AcceptThread</code>不作任何处理，交由<code>SelectorThread</code>完成。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelectorServer_AcceptThread_select_3.png" alt=""></p><p>在<code>handleAccept()</code>方法中，先通过<code>doAccept()</code>去拿<strong>连接通道</strong>，然后<code>Selector</code><strong>线程负载均衡器</strong>选择一个<code>Selector</code>线程，完成接下来的<code>IO</code><strong>读写事件</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelectorServer_AcceptThread_handle_Accept.png" alt=""></p><p>接下来继续查看<code>doAddAccept()</code>方法的实现，毫无悬念，它进一步调用了<code>SelectorThread</code>的<code>addAcceptedConnection()</code>方法，把<strong>非阻塞传输通道对象</strong>传递给<strong>选择器线程</strong>做进一步的<code>IO</code><strong>读写操作</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelectorServer_AcceptorThread_doAddAccept.png" alt=""></p><h4 id="SelectorThreadLoadBalancer源码"><a href="#SelectorThreadLoadBalancer源码" class="headerlink" title="SelectorThreadLoadBalancer源码"></a>SelectorThreadLoadBalancer源码</h4><p><code>SelectorThreadLoadBalancer</code>如何创建？</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelectorServer_SelectThread_create.png" alt=""></p><p><code>SelectorThreadLoadBalancer</code>是一个基于<strong>轮询算法</strong>的<code>Selector</code><strong>线程选择器</strong>，通过<strong>线程迭代器</strong>为新进来的<strong>连接</strong>顺序分配<code>SelectorThread</code>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelectorServer_SelectorThreadLoadBalancer.png" alt=""></p><h4 id="SelectorThread源码"><a href="#SelectorThread源码" class="headerlink" title="SelectorThread源码"></a>SelectorThread源码</h4><p><code>SelectorThread</code>和<code>AcceptThread</code>一样，是<code>TThreadedSelectorServer</code>的一个<strong>成员内部类</strong>，每个<code>SelectorThread</code><strong>线程对象</strong>内部都有一个<strong>阻塞式的队列</strong>，用于存放该线程<strong>被接收</strong>的<strong>连接通道</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelector_SelectorThread_Overview.png" alt=""></p><p><strong>阻塞队列</strong>的大小可由构造函数指定：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelector_SelectorThread_Constructor.png" alt=""></p><p>上面看到，在<code>AcceptThread</code>的<code>doAddAccept()</code>方法中调用了<code>SelectorThread</code>的<code>addAcceptedConnection()</code>方法。</p><p>这个方法做了两件事：</p><ol><li>将被此<code>SelectorThread</code>线程接收的<strong>连接通道</strong>放入<strong>阻塞队列</strong>中。</li><li>通过<code>wakeup()</code>方法唤醒<code>SelectorThread</code>中的<code>NIO</code><strong>选择器</strong><code>selector</code>。</li></ol><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelector_SelectorThread_addAcceptedConnection.png" alt=""></p><p>既然<code>SelectorThread</code>也是继承于<code>Thread</code>，查看其<code>run()</code>方法的实现：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelector_SelectorThread_run.png" alt=""></p><p><code>SelectorThread</code>方法的<code>select()</code>监听<code>IO</code>事件，仅仅用于处理<strong>数据读取</strong>和<strong>数据写入</strong>。如果连接有<strong>数据可读</strong>，读取并以<code>frame</code>的方式缓存；如果需要向连接中<strong>写入数据</strong>，缓存并发送客户端的数据。且在<strong>数据读写</strong>处理完成后，需要向<code>NIO</code>的<code>selector</code><strong>清空</strong>和<strong>注销</strong>自身的<code>SelectionKey</code>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelector_SelectorThread_select.png" alt=""></p><ul><li><strong>数据写操作</strong>完成以后，整个<code>rpc</code>调用过程也就结束了，<code>handleWrite()</code>方法如下：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelector_SelectorThread_handleWrite.png" alt=""></p><ul><li><strong>数据读操作</strong>完成以后，<code>Thrift</code>会利用<strong>已读数据</strong>执行<strong>目标方法</strong>，<code>handleRead()</code>方法如下：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelector_SelectorThread_handleRead.png" alt=""></p><p><code>handleRead</code>方法在执行<code>read()</code>方法，将<strong>数据读取</strong>完成后，会调用<code>requestInvoke()</code>方法调用<strong>目标方法</strong>完成具体业务处理。<code>requestInvoke()</code>方法将<strong>请求数据</strong>封装为一个<code>Runnable</code>对象，提交到<strong>工作任务线程池</strong>(<code>ExecutorService</code>)进行处理。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelector_requestInvoke.png" alt=""></p><p><code>select()</code>方法完成后，线程继续运行<code>processAcceptedConnections()</code>方法处理<strong>下一个连接</strong>的<code>IO</code>事件。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/ThreadSelector_SelectThread_processAccepted_Connections.png" alt=""></p><p>这里比较核心的几个操作：</p><ol><li>尝试从<code>SelectorThread</code>的<strong>阻塞队列</strong><code>acceptedQueue</code>中获取一个<strong>连接的传输通道</strong>。如果获取成功，调用<code>registerAccepted()</code>方法；否则，进入下一次循环。</li><li><code>registerAccepted()</code>方法将<strong>传输通道</strong>底层的<strong>连接</strong>注册到<code>NIO</code>的<strong>选择器</strong><code>selector</code>上面，获取到一个<code>SelectionKey</code>。</li><li>创建一个<code>FrameBuffer</code>对象，并绑定到获取的<code>SelectionKey</code>上面，用于数据传输时的中间<strong>读写缓存</strong>。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对<code>Thrift</code>的各种<strong>线程服务模型</strong>进行了介绍，包括2种<strong>阻塞式服务模型</strong>：<code>TSimpleServer</code>、<code>TThreadPoolServer</code>，3种<strong>非阻塞式服务模型</strong>：<code>TNonblockingServer</code>、<code>THsHaServer</code>和<code>TThreadedSelectorServer</code>。对各种服务模型的<strong>具体用法</strong>、<strong>工作流程</strong>、<strong>原理和源码实现</strong>进行了一定程度的分析。</p><p>鉴于篇幅较长，请各位看官请慢慢批阅！</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Thrift&lt;/code&gt;提供的&lt;strong&gt;网络服务模型&lt;/strong&gt;：&lt;strong&gt;单线程&lt;/strong&gt;、&lt;strong&gt;多线程&lt;/strong&gt;、&lt;strong&gt;事件驱动&lt;/strong&gt;，从另一个角度划分为：&lt;strong&gt;阻塞服务模型&lt;/strong&gt;、&lt;strong&gt;非阻塞服务模型&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Thrift" scheme="https://ostenant.coding.me/tags/Thrift/"/>
    
      <category term="Apache" scheme="https://ostenant.coding.me/tags/Apache/"/>
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Apache Thrift系列详解(一) - 概述与入门</title>
    <link href="https://ostenant.coding.me/2018/01/08/Apache%20Thrift%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3(%E4%B8%80)%20-%20%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%85%A5%E9%97%A8/"/>
    <id>https://ostenant.coding.me/2018/01/08/Apache Thrift系列详解(一) - 概述与入门/</id>
    <published>2018-01-08T02:14:00.000Z</published>
    <updated>2018-05-08T02:49:46.087Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Thrift</code>是一个<strong>轻量级</strong>、<strong>跨语言</strong>的<strong>远程服务调用</strong>框架，最初由<code>Facebook</code>开发，后面进入<code>Apache</code>开源项目。它通过自身的<code>IDL</code><strong>中间语言</strong>, 并借助<strong>代码生成引擎</strong>生成各种主流语言的<code>RPC</code><strong>服务端</strong>/<strong>客户端</strong>模板代码。</p><a id="more"></a><p><code>Thrift</code>支持多种不同的<strong>编程语言</strong>，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等，本系列主要讲述基于<code>Java</code>语言的<code>Thrift</code>的配置方式和具体使用。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Thrift的技术栈"><a href="#Thrift的技术栈" class="headerlink" title="Thrift的技术栈"></a>Thrift的技术栈</h2><p><code>Thrift</code>对<strong>软件栈</strong>的定义非常的清晰, 使得各个组件能够<strong>松散的耦合</strong>, 针对不同的应用场景, 选择不同是方式去搭建服务。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Apache_thrift_architecture.png" alt=""></p><p><code>Thrift</code><strong>软件栈</strong>分层<strong>从下向上</strong>分别为：<strong>传输层</strong>(<code>Transport Layer</code>)、<strong>协议层</strong>(<code>Protocol Layer</code>)、<strong>处理层</strong>(<code>Processor Layer</code>)和<strong>服务层</strong>(<code>Server Layer</code>)。</p><ul><li><p><strong>传输层</strong>(<code>Transport Layer</code>)：传输层负责直接从网络中<strong>读取</strong>和<strong>写入</strong>数据，它定义了具体的<strong>网络传输协议</strong>；比如说<code>TCP/IP</code>传输等。</p></li><li><p><strong>协议层</strong>(<code>Protocol Layer</code>)：协议层定义了<strong>数据传输格式</strong>，负责网络传输数据的<strong>序列化</strong>和<strong>反序列化</strong>；比如说<code>JSON</code>、<code>XML</code>、<strong>二进制数据</strong>等。</p></li><li><p><strong>处理层</strong>(<code>Processor Layer</code>)：处理层是由具体的<code>IDL</code>（<strong>接口描述语言</strong>）生成的，封装了具体的<strong>底层网络传输</strong>和<strong>序列化方式</strong>，并委托给用户实现的<code>Handler</code>进行处理。</p></li><li><p><strong>服务层</strong>(<code>Server Layer</code>)：整合上述组件，提供具体的<strong>网络线程/IO服务模型</strong>，形成最终的服务。</p></li></ul><h2 id="Thrift的特性"><a href="#Thrift的特性" class="headerlink" title="Thrift的特性"></a>Thrift的特性</h2><h3 id="一-开发速度快"><a href="#一-开发速度快" class="headerlink" title="(一) 开发速度快"></a>(一) 开发速度快</h3><p>通过编写<code>RPC</code>接口<code>Thrift IDL</code>文件，利用<strong>编译生成器</strong>自动生成<strong>服务端骨架</strong>(<code>Skeletons</code>)和<strong>客户端桩</strong>(<code>Stubs</code>)。从而省去开发者<strong>自定义</strong>和<strong>维护接口编解码</strong>、<strong>消息传输</strong>、<strong>服务器多线程模型</strong>等基础工作。</p><ul><li>服务端：只需要按照<strong>服务骨架</strong>即<strong>接口</strong>，编写好具体的<strong>业务处理程序</strong>(<code>Handler</code>)即<strong>实现类</strong>即可。</li><li>客户端：只需要拷贝<code>IDL</code>定义好的<strong>客户端桩</strong>和<strong>服务对象</strong>，然后就像调用本地对象的方法一样调用远端服务。</li></ul><h3 id="二-接口维护简单"><a href="#二-接口维护简单" class="headerlink" title="(二) 接口维护简单"></a>(二) 接口维护简单</h3><p>通过维护<code>Thrift</code>格式的IDL（<strong>接口描述语言</strong>）文件（注意写好注释），即可作为给<code>Client</code>使用的接口文档使用，也<strong>自动生成</strong>接口代码，始终保持代码和文档的一致性。且<code>Thrift</code>协议可灵活支持<strong>接口</strong>的<strong>可扩展性</strong>。</p><h3 id="三-学习成本低"><a href="#三-学习成本低" class="headerlink" title="(三) 学习成本低"></a>(三) 学习成本低</h3><p>因为其来自<code>Google Protobuf</code>开发团队，所以其<code>IDL</code>文件风格类似<code>Google Protobuf</code>，且更加<strong>易读易懂</strong>；特别是<code>RPC</code><strong>服务接口</strong>的风格就像写一个<strong>面向对象</strong>的<code>Class</code>一样简单。</p><p>初学者只需参照：<a href="http://thrift.apache.org/" target="_blank" rel="noopener">http://thrift.apache.org/</a>，一个多小时就可以理解<code>Thrift IDL</code>文件的语法使用。</p><h3 id="四-多语言-跨语言支持"><a href="#四-多语言-跨语言支持" class="headerlink" title="(四) 多语言/跨语言支持"></a>(四) 多语言/跨语言支持</h3><p><code>Thrift</code>支持<code>C++</code>、 <code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>、<code>Erlang</code>、<code>Perl</code>、<code>Haskell</code>、<code>C#</code>、<code>Cocoa</code>、<code>JavaScript</code>、<code>Node.js</code>、<code>Smalltalk</code>等多种语言，即可生成上述语言的<strong>服务器端</strong>和<strong>客户端程序</strong>。</p><p>对于我们经常使用的<code>Java</code>、<code>PHP</code>、<code>Python</code>、<code>C++</code>支持良好，虽然对<code>iOS</code>环境的<code>Objective-C</code>(<code>Cocoa</code>)支持稍逊，但也完全满足我们的使用要求。</p><h3 id="五-稳定-广泛使用"><a href="#五-稳定-广泛使用" class="headerlink" title="(五) 稳定/广泛使用"></a>(五) 稳定/广泛使用</h3><p><code>Thrift</code>在很多开源项目中已经被验证是<strong>稳定</strong>和<strong>高效</strong>的，例如<code>Cassandra</code>、<code>Hadoop</code>、<code>HBase</code>等；国外在<code>Facebook</code>中有广泛使用，国内包括百度、美团小米、和饿了么等公司。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Service_use_thrift.png" alt=""></p><h2 id="Thrift的数据类型"><a href="#Thrift的数据类型" class="headerlink" title="Thrift的数据类型"></a>Thrift的数据类型</h2><p>Thrift 脚本可定义的数据类型包括以下几种类型：</p><ol><li><strong>基本类型：</strong><br>　　<strong>bool</strong>: 布尔值<br>　　<strong>byte</strong>: 8位有符号整数<br>　　<strong>i16</strong>: 16位有符号整数<br>　　<strong>i32</strong>: 32位有符号整数<br>　　<strong>i64</strong>: 64位有符号整数<br>　　<strong>double</strong>: 64位浮点数<br>　　<strong>string</strong>: UTF-8编码的字符串<br>　　<strong>binary</strong>: 二进制串</li><li><strong>结构体类型：</strong><br>　　<strong>struct</strong>: 定义的结构体对象</li><li><strong>容器类型：</strong><br>　　<strong>list</strong>: 有序元素列表<br>　　<strong>set</strong>: 无序无重复元素集合<br>　　<strong>map</strong>: 有序的key/value集合</li><li><strong>异常类型：</strong><br>　　<strong>exception</strong>: 异常类型</li><li><strong>服务类型：</strong><br>　　<strong>service</strong>: 具体对应服务的类</li></ol><h2 id="Thrift的协议"><a href="#Thrift的协议" class="headerlink" title="Thrift的协议"></a>Thrift的协议</h2><p><code>Thrift</code>可以让用户选择<strong>客户端</strong>与<strong>服务端</strong>之间<strong>传输通信协议</strong>的类别，在<strong>传输协议</strong>上总体划分为<strong>文本</strong>(<code>text</code>)和<strong>二进制</strong>(<code>binary</code>)传输协议。为<strong>节约带宽</strong>，<strong>提高传输效率</strong>，一般情况下使用<strong>二进制</strong>类型的传输协议为多数，有时还会使用基于<strong>文本类型</strong>的协议，这需要根据项目/产品中的实际需求。常用协议有以下几种：</p><ul><li>TBinaryProtocol：<strong>二进制</strong>编码格式进行数据传输</li><li>TCompactProtocol：<strong>高效率</strong>的、<strong>密集</strong>的<strong>二进制</strong>编码格式进行数据传输</li><li>TJSONProtocol： 使用<code>JSON</code><strong>文本</strong>的数据编码协议进行数据传输</li><li>TSimpleJSONProtocol：只提供<code>JSON</code><strong>只写</strong>的协议，适用于通过<strong>脚本语言解析</strong></li></ul><h2 id="Thrift的传输层"><a href="#Thrift的传输层" class="headerlink" title="Thrift的传输层"></a>Thrift的传输层</h2><p>常用的传输层有以下几种：</p><ul><li>TSocket：使用<strong>阻塞式</strong><code>I/O</code>进行传输，是最常见的模式</li><li>TNonblockingTransport：使用<strong>非阻塞方式</strong>，用于构建<strong>异步客户端</strong></li><li>TFramedTransport：使用<strong>非阻塞方式</strong>，按<strong>块的大小</strong>进行传输，类似于<code>Java</code>中的<code>NIO</code></li></ul><h2 id="Thrift的服务端类型"><a href="#Thrift的服务端类型" class="headerlink" title="Thrift的服务端类型"></a>Thrift的服务端类型</h2><ul><li>TSimpleServer：<strong>单线程</strong>服务器端，使用标准的<strong>阻塞式</strong><code>I/O</code></li><li>TThreadPoolServer：<strong>多线程</strong>服务器端，使用标准的<strong>阻塞式</strong><code>I/O</code></li><li>TNonblockingServer：<strong>单线程</strong>服务器端，使用<strong>非阻塞式</strong><code>I/O</code></li><li>THsHaServer：<strong>半同步半异步</strong>服务器端，基于<strong>非阻塞式</strong><code>IO</code>读写和<strong>多线程</strong>工作任务处理</li><li>TThreadedSelectorServer：<strong>多线程选择器</strong>服务器端，对<code>THsHaServer</code>在<strong>异步</strong><code>IO</code>模型上进行增强</li></ul><h2 id="Thrift入门示例"><a href="#Thrift入门示例" class="headerlink" title="Thrift入门示例"></a>Thrift入门示例</h2><h3 id="一-编写Thrift-IDL文件"><a href="#一-编写Thrift-IDL文件" class="headerlink" title="(一) 编写Thrift IDL文件"></a>(一) 编写Thrift IDL文件</h3><p>a). 下载<code>0.10.0</code>的<code>Thrift IDL</code>编译器，下载地址：<a href="http://thrift.apache.org/docs/install。" target="_blank" rel="noopener">http://thrift.apache.org/docs/install。</a> 通过<strong>编译生成器</strong>生成<code>.java</code>接口的类文件。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_code_generator_compiler.png" alt=""></p><p>b). 下载<code>Windows</code>安装环境的<code>.exe</code>文件，将<code>thrift.exe</code>的路径加入环境变量中。在<code>Idea</code>上安装<code>Thrift</code>编辑插件。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_idea_plugin.png" alt=""></p><p>c). 编写<code>hello.thrift</code>的<code>IDL</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service HelloWorldService &#123;</span><br><span class="line">  <span class="function">string <span class="title">say</span><span class="params">(<span class="number">1</span>: string username)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>d). 使用代码生成工具生成代码，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -gen java hello.thrift</span><br></pre></td></tr></table></figure><p>e). 由于未指定代码生成的目标目录，生成的类文件默认存放在<code>gen-java</code>目录下。这里生成一个<code>HelloWorldService.java</code>类文件，文件大小超过数千行，下面截取一部分<strong>核心代码</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iface</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String username)</span> <span class="keyword">throws</span> org.apache.thrift.TException</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncIface</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String username, org.apache.thrift.async.AsyncMethodCallback&lt;String&gt; resultHandler)</span> <span class="keyword">throws</span> org.apache.thrift.TException</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TServiceClient</span> <span class="keyword">implements</span> <span class="title">Iface</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TServiceClientFactory</span>&lt;<span class="title">Client</span>&gt; </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Client <span class="title">getClient</span><span class="params">(org.apache.thrift.protocol.TProtocol prot)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Client(prot);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Client <span class="title">getClient</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Client(iprot, oprot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(org.apache.thrift.protocol.TProtocol prot)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(prot, prot);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(iprot, oprot);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String username)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">            send_say(username);</span><br><span class="line">            <span class="keyword">return</span> recv_say();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略.....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncClient</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">async</span>.<span class="title">TAsyncClient</span> <span class="keyword">implements</span> <span class="title">AsyncIface</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">async</span>.<span class="title">TAsyncClientFactory</span>&lt;<span class="title">AsyncClient</span>&gt; </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> org.apache.thrift.async.TAsyncClientManager clientManager;</span><br><span class="line">            <span class="keyword">private</span> org.apache.thrift.protocol.TProtocolFactory protocolFactory;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.protocol.TProtocolFactory protocolFactory)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.clientManager = clientManager;</span><br><span class="line">                <span class="keyword">this</span>.protocolFactory = protocolFactory;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> AsyncClient <span class="title">getAsyncClient</span><span class="params">(org.apache.thrift.transport.TNonblockingTransport transport)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AsyncClient(protocolFactory, clientManager, transport);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AsyncClient</span><span class="params">(org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.transport.TNonblockingTransport transport)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(protocolFactory, clientManager, transport);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String username, org.apache.thrift.async.AsyncMethodCallback&lt;String&gt; resultHandler)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">            checkReady();</span><br><span class="line">            say_call method_call = <span class="keyword">new</span> say_call(username, resultHandler, <span class="keyword">this</span>, ___protocolFactory, ___transport);</span><br><span class="line">            <span class="keyword">this</span>.___currentMethod = method_call;</span><br><span class="line">            ___manager.call(method_call);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于开发人员而言，使用原生的<code>Thrift</code>框架，仅需要关注以下四个核心<strong>内部接口/类</strong>：<code>Iface</code>, <code>AsyncIface</code>, <code>Client</code>和<code>AsyncClient</code>。</p><ul><li><strong>Iface</strong>：<strong>服务端</strong>通过实现<code>HelloWorldService.Iface</code>接口，向<strong>客户端</strong>的提供具体的<strong>同步</strong>业务逻辑。</li><li><strong>AsyncIface</strong>：<strong>服务端</strong>通过实现<code>HelloWorldService.Iface</code>接口，向<strong>客户端</strong>的提供具体的<strong>异步</strong>业务逻辑。</li><li><strong>Client</strong>：<strong>客户端</strong>通过<code>HelloWorldService.Client</code>的实例对象，以<strong>同步</strong>的方式<strong>访问服务端</strong>提供的服务方法。</li><li><strong>AsyncClient</strong>：<strong>客户端</strong>通过<code>HelloWorldService.AsyncClient</code>的实例对象，以<strong>异步</strong>的方式<strong>访问服务端</strong>提供的服务方法。</li></ul><h3 id="二-新建Maven工程"><a href="#二-新建Maven工程" class="headerlink" title="(二) 新建Maven工程"></a>(二) 新建Maven工程</h3><p>a). 新建<code>maven</code>工程，引入<code>thrift</code>的依赖，这里使用的是版本<code>0.10.0</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b). 将生成类的<code>HelloWorldService.java</code>源文件拷贝进项目源文件目录中，并实现<code>HelloWorldService.Iface</code>的定义的<code>say()</code>方法。</p><p>HelloWorldServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorldService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String username)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c). 服务器端程序编写：</p><p>SimpleServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(ServerConfig.SERVER_PORT);</span><br><span class="line">        TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(serverSocket);</span><br><span class="line">        HelloWorldService.Processor processor =</span><br><span class="line">                <span class="keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="keyword">new</span> HelloWorldServiceImpl());</span><br><span class="line"></span><br><span class="line">        TBinaryProtocol.Factory protocolFactory = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line">        TSimpleServer.Args tArgs = <span class="keyword">new</span> TSimpleServer.Args(serverTransport);</span><br><span class="line">        tArgs.processor(processor);</span><br><span class="line">        tArgs.protocolFactory(protocolFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单的单线程服务模型 一般用于测试</span></span><br><span class="line">        TServer tServer = <span class="keyword">new</span> TSimpleServer(tArgs);</span><br><span class="line">        System.out.println(<span class="string">"Running Simple Server"</span>);</span><br><span class="line">        tServer.serve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d). 客户端程序编写：</p><p>SimpleClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TTransport transport = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transport = <span class="keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT);</span><br><span class="line">            TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">            HelloWorldService.Client client = <span class="keyword">new</span> HelloWorldService.Client(protocol);</span><br><span class="line">            transport.open();</span><br><span class="line"></span><br><span class="line">            String result = client.say(<span class="string">"Leo"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Result =: "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != transport) &#123;</span><br><span class="line">                transport.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e). 运行服务端程序，<strong>服务端</strong>在<strong>指定端口</strong>监听<strong>客户端</strong>的<strong>连接请求</strong>，控制台输出启动日志：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Simple_Server_Running.png" alt=""></p><p>f). 运行客户端程序，<strong>客户端</strong>通过网络请求<code>HelloWorldService</code>的<code>say()</code>方法的<strong>具体实现</strong>，控制台输出返回结果：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Simple_Client_Running.png" alt=""></p><p>这里使用的一个基于<strong>单线程同步</strong>的<strong>简单服务模型</strong>，一般仅用于入门学习和测试！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对<code>Thrift</code>的概念做了相关介绍，体验了一番<code>thrift</code>程序如何编写！</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Thrift&lt;/code&gt;是一个&lt;strong&gt;轻量级&lt;/strong&gt;、&lt;strong&gt;跨语言&lt;/strong&gt;的&lt;strong&gt;远程服务调用&lt;/strong&gt;框架，最初由&lt;code&gt;Facebook&lt;/code&gt;开发，后面进入&lt;code&gt;Apache&lt;/code&gt;开源项目。它通过自身的&lt;code&gt;IDL&lt;/code&gt;&lt;strong&gt;中间语言&lt;/strong&gt;, 并借助&lt;strong&gt;代码生成引擎&lt;/strong&gt;生成各种主流语言的&lt;code&gt;RPC&lt;/code&gt;&lt;strong&gt;服务端&lt;/strong&gt;/&lt;strong&gt;客户端&lt;/strong&gt;模板代码。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Thrift" scheme="https://ostenant.coding.me/tags/Thrift/"/>
    
      <category term="Apache" scheme="https://ostenant.coding.me/tags/Apache/"/>
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出OAuth 2.0授权机制</title>
    <link href="https://ostenant.coding.me/2018/01/04/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAOAuth%202.0%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6/"/>
    <id>https://ostenant.coding.me/2018/01/04/深入浅出OAuth 2.0授权机制/</id>
    <published>2018-01-04T13:10:00.000Z</published>
    <updated>2018-05-08T02:49:46.097Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>举个简单的例子。新浪微博是你的家，有时候你会想让一些人(第三方应用)去你的家里帮你办点事情，或者取点东西。你可以直接复制一把钥匙(用户名和密码)给他们，但这里存在几个问题：</p><a id="more"></a><ol><li>别人拿了钥匙后可以去你家里的所有房间。</li><li>别人拿到你的钥匙后也许会不小心丢到，甚至故意送到它人手里。这样你都不知到谁有你家钥匙。</li><li>过一段时间你也许会想要回自己的钥匙，但别人不还怎么办？</li></ol><blockquote><p>总结起来就是两个问题：其一，拿到钥匙的人权限太大，可以进入任一房间；其二，拿到钥匙的人可能对钥匙进行复制和更改。</p></blockquote><p>OAuth是高级钥匙，可以理解为指纹识别，它主要解决了以上的缺陷：</p><ol><li>你可以配置不同权限的钥匙。有些只能进大厅(读取你的微博流)。有些钥匙可以进储藏柜(读取你的相片)。</li><li>钥匙上带着指纹验证程序(指纹 = appkey)，只有收到钥匙的人自己能使用钥匙。</li><li>钥匙有一定的时效性，同时你也可以远程废除钥匙。</li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><code>OAuth</code>是一个关于<strong>授权</strong>(<code>authorization</code>)的开放网络标准，在全世界得到广泛应用，目前的版本是<code>2.0</code>版。<br>本文对<code>OAuth 2.0</code>的设计思路和运行流程，做一个简明通俗的解释。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/oauth_log.png" alt=""></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>为了理解<code>OAuth</code>的适用场景，举一个通俗易懂的例子。<br>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/google_photogragh.png" alt=""></p><p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？<br>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><pre><code>1. &quot;云冲印&quot;为了后续的服务，会保存用户的密码，这样很不安全。2. Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。3. &quot;云冲印&quot;拥有了获取用户储存在Google所有资料的权利，用户没法限制&quot;云冲印&quot;获得授权的范围和有效期。4. 用户只有修改密码，才能收回赋予&quot;云冲印&quot;的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。5. 只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</code></pre><p>OAuth就是为了解决上面这些问题而诞生的。</p><h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><p>在详细讲解<code>OAuth 2.0</code>之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p><table><thead><tr><th>专业术语</th><th>中文含义</th><th>具体解释说明</th></tr></thead><tbody><tr><td>Third-party application</td><td>第三方应用程序</td><td>本文中又称”客户端”(client)，即上一节例子中的”云冲印”</td></tr><tr><td>Resource Owner</td><td>资源所有者</td><td>本文中又称”用户”(user)。</td></tr><tr><td>HTTP service</td><td>HTTP服务提供商</td><td>本文中简称”服务提供商”，即上一节例子中的Google。</td></tr><tr><td>User Agent</td><td>用户代理</td><td>本文中就是指浏览器。</td></tr><tr><td>Authorization server</td><td>认证服务器</td><td>即服务提供商专门用来处理认证的服务器。</td></tr><tr><td>Resource server</td><td>资源服务器</td><td>即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</td></tr></tbody></table><h2 id="OAuth的思路"><a href="#OAuth的思路" class="headerlink" title="OAuth的思路"></a>OAuth的思路</h2><p><code>OAuth</code>在”<strong>客户端</strong>“与”<strong>服务提供商</strong>“之间，设置了一个<strong>授权层</strong>(<code>authorization layer</code>)。”<strong>客户端</strong>“不能直接登录”<strong>服务提供商</strong>“，只能登录<strong>授权层</strong>，以此将用户与客户端区分开来。”<strong>客户端</strong>“登录<strong>授权层</strong>所用的<strong>令牌</strong>(<code>token</code>)，与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。<br>“客户端”登录授权层以后，”服务提供商”根据令牌的<strong>权限范围</strong>和<strong>有效期</strong>，向”<strong>客户端</strong>“开放用户储存的资料。</p><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/oauth_details_steps.png" alt=""></p><pre><code>(A). 用户打开客户端以后，客户端要求用户给予授权。(B). 用户同意给予客户端授权。(C). 客户端拿到上一步获取到的授权，向认证服务器申请令牌。(D). 认证服务器对客户端进行认证以后，确认无误，统一发放令牌。(E). 客户端使用令牌，向资源服务器申请获取用户的资源。(F). 资源服务器确认令牌无误，同意向客户端开放资源。</code></pre><p>不难看出来，上面<strong>六个步骤</strong>之中，步骤<code>(B)</code>是关键，即用户怎样才能给于客户端授权。有了这个<strong>授权</strong>以后，客户端就可以获取<strong>令牌</strong>，进而凭<strong>令牌</strong>获取<strong>资源</strong>。</p><h2 id="几种授权模式"><a href="#几种授权模式" class="headerlink" title="几种授权模式"></a>几种授权模式</h2><p>客户端必须得到了用户的<strong>授权</strong>。(<code>authorization grant</code>)，才能获取<strong>令牌</strong>(<code>access token</code>)。<code>OAuth 2.0</code>定义了四种授权方式。</p><ul><li><strong>授权码模式(authorization code)</strong></li><li><strong>简化模式(implicit)</strong></li><li><strong>密码模式(resource owner password credentials)</strong></li><li><strong>客户端模式(client credentials)</strong></li></ul><p>下面一一讲解客户端获取<strong>授权</strong>的<strong>四种模式</strong>。</p><h4 id="一-授权码模式"><a href="#一-授权码模式" class="headerlink" title="(一). 授权码模式"></a>(一). 授权码模式</h4><p><strong>授权码模式</strong>(<code>authorization code</code>)是<strong>功能最完整</strong>、<strong>流程最严密</strong>的<strong>授权模式</strong>。它的特点就是通过<strong>客户端</strong>的<strong>后台服务器</strong>，与”<strong>服务提供商</strong>“的<strong>认证服务器</strong>进行互动。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/authorization_code_mode.png" alt=""></p><p>它的步骤如下：</p><pre><code>(A). 用户访问客户端，后者将前者导向认证服务器。(B). 用户选择是否给予客户端授权。(C). 假设用户给予授权，认证服务器将用户导向客户端事先指定的&quot;重定向URI&quot;(redirection URI)，同时附上一个授权码。(D). 客户端收到授权码，附上早先的&quot;重定向URI&quot;，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。(E). 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌(access token)和更新令牌(refresh token)。</code></pre><p>对于每个步骤具体所需要参数如下：</p><p><strong>A步骤中，客户端申请认证的URI，包含以下参数：</strong></p><table><thead><tr><th>参数</th><th>具体含义</th><th>是否必填</th></tr></thead><tbody><tr><td>response_type</td><td>授权类型</td><td>必选项，此处的值固定为”code”</td></tr><tr><td>client_id</td><td>客户端的ID</td><td>必选项</td></tr><tr><td>redirect_uri</td><td>重定向URI</td><td>可选项</td></tr><tr><td>scope</td><td>申请的权限范围</td><td>可选项</td></tr><tr><td>state</td><td>客户端的当前状态，认证服务器会原封不动地返回这个值</td><td>可选项，可以指定任意值</td></tr></tbody></table><p>下面是一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Fclient%<span class="number">2</span>Eexample%<span class="number">2</span>Ecom%<span class="number">2</span>Fcb HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure></p><p><strong>C步骤中，服务器回应客户端的URI，包含以下参数：</strong></p><table><thead><tr><th>参数</th><th style="text-align:center">具体含义</th><th>是否必填</th></tr></thead><tbody><tr><td>code</td><td style="text-align:center">授权码。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系</td><td>必选项</td></tr><tr><td>state</td><td style="text-align:center">如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</td><td>可选项</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line">Location: https:<span class="comment">//client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz</span></span><br></pre></td></tr></table></figure><p><strong>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</strong></p><table><thead><tr><th>参数</th><th>具体含义</th><th>是否必填</th></tr></thead><tbody><tr><td>grant_type</td><td>授权模式</td><td>必选项，此处的值固定为”authorization_code”</td></tr><tr><td>code</td><td>上一步获得的授权码</td><td>必选项</td></tr><tr><td>redirect_uri</td><td>重定向URI</td><td>必选项，且必须与A步骤中的该参数值保持一致</td></tr><tr><td>client_id</td><td>客户端ID</td><td>必选项</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Fclient%<span class="number">2</span>Eexample%<span class="number">2</span>Ecom%<span class="number">2</span>Fcb</span><br></pre></td></tr></table></figure><p><strong>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</strong></p><table><thead><tr><th>参数</th><th>具体含义</th><th>是否必填</th></tr></thead><tbody><tr><td>access_token</td><td>访问令牌</td><td>必选项</td></tr><tr><td>token_type</td><td>牌类型，该值大小写不敏感</td><td>必选项，可以是bearer类型或mac类型</td></tr><tr><td>expires_in</td><td>过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间</td><td>可选项</td></tr><tr><td>refresh_token</td><td>更新令牌，用来获取下一次的访问令牌</td><td>可选项</td></tr><tr><td>scope</td><td>申请的权限范围</td><td>可选项</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: application/json;charset=UTF<span class="number">-8</span></span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">  <span class="string">"token_type"</span>:<span class="string">"bearer"</span>,</span><br><span class="line">  <span class="string">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">  <span class="string">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">  <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，相关参数使用<code>JSON</code>格式发送(<code>Content-Type: application/json</code>)。此外，<code>HTTP</code>头信息中明确指定<strong>不得缓存</strong>。</p><h4 id="二-简化模式"><a href="#二-简化模式" class="headerlink" title="(二). 简化模式"></a>(二). 简化模式</h4><p><strong>简化模式</strong>(<code>implicit grant type</code>)不通过<strong>第三方</strong>应用程序的服务器，直接在<strong>浏览器</strong>中向<strong>认证服务器</strong>申请<strong>令牌</strong>，跳过了”<strong>授权码</strong>“这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/implicit_mode.png" alt=""></p><p>它的步骤如下：</p><pre><code>(A). 客户端将用户导向认证服务器。(B). 用户决定是否给于客户端授权。(C). 假设用户给予授权，认证服务器将用户导向客户端指定的&quot;重定向URI&quot;，并在URI的Hash部分包含了访问令牌。(D). 浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。(E). 资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。(F). 浏览器执行上一步获得的脚本，提取出令牌。(G). 浏览器将令牌发给客户端。</code></pre><p>下面是上面这些步骤所需要的参数：</p><p><strong>A步骤中，客户端发出的HTTP请求，包含以下参数：</strong></p><table><thead><tr><th>参数</th><th>具体含义</th><th>是否必填</th></tr></thead><tbody><tr><td>response_type</td><td>授权类型</td><td>必选项，此处的值固定为”token”</td></tr><tr><td>client_id</td><td>客户端的ID</td><td>必选项</td></tr><tr><td>redirect_uri</td><td>重定向URI</td><td>可选项</td></tr><tr><td>scope</td><td>申请的权限范围</td><td>可选项</td></tr><tr><td>state</td><td>客户端的当前状态，认证服务器会原封不动地返回这个值</td><td>可选项，可以指定任意值</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">    &amp;redirect_uri=https%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Fclient%<span class="number">2</span>Eexample%<span class="number">2</span>Ecom%<span class="number">2</span>Fcb HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure><p><strong>C步骤中，认证服务器回应客户端的URI，包含以下参数：</strong></p><table><thead><tr><th>参数</th><th>具体含义</th><th>是否必填</th></tr></thead><tbody><tr><td>access_token</td><td>访问令牌</td><td>必选项</td></tr><tr><td>token_type</td><td>牌类型，该值大小写不敏感</td><td>必选项</td></tr><tr><td>expires_in</td><td>过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间</td><td>可选项</td></tr><tr><td>scope</td><td>权限范围</td><td>如果与客户端申请的范围一致，此项可省略</td></tr><tr><td>state</td><td>如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数</td><td>可选项</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line">Location: http:<span class="comment">//example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span></span><br><span class="line">          &amp;state=xyz&amp;token_type=example&amp;expires_in=<span class="number">3600</span></span><br></pre></td></tr></table></figure><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line">Location: http:<span class="comment">//example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span></span><br><span class="line">          &amp;state=xyz&amp;token_type=bearer&amp;expires_in=<span class="number">3600</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，认证服务器用<code>HTTP</code>头信息的<code>Location</code>栏，指定<strong>浏览器重定向</strong>的网址。注意，在这个网址的<code>Hash</code>部分包含了<strong>令牌</strong>。<br>根据上面的<code>D</code>步骤，下一步浏览器会访问<code>Location</code>指定的网址，但是<code>Hash</code>部分不会发送。<br>接下来的<code>E</code>步骤，服务提供商的<strong>资源服务器</strong>发送过来的<strong>脚本代码</strong>，会提取出<code>Hash</code>中的<strong>令牌</strong>。</p><h4 id="三-密码模式"><a href="#三-密码模式" class="headerlink" title="(三). 密码模式"></a>(三). 密码模式</h4><p><strong>密码模式</strong>(<code>Resource Owner Password Credentials Grant</code>)中，用户向客户端提供自己的<strong>用户名</strong>和<strong>密码</strong>。客户端使用这些信息，向”<strong>服务商提供商</strong>“索要<strong>授权</strong>。</p><p>在这种模式中，用户必须把自己的<strong>密码</strong>给客户端，但是<strong>客户端不得储存密码</strong>。这通常用在<strong>用户</strong>对<strong>客户端高度信任</strong>的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/crediential_grant_mode.png" alt=""></p><p>它的步骤如下：</p><pre><code>(A). 用户向客户端提供用户名和密码。(B). 客户端将用户名和密码发给认证服务器，向后者请求令牌。(C). 认证服务器确认无误后，向客户端提供访问令牌。</code></pre><p><strong>B步骤中，客户端发出的HTTP请求，包含以下参数：</strong></p><table><thead><tr><th>参数</th><th>具体含义</th><th>是否必填</th></tr></thead><tbody><tr><td>grant_type</td><td>授权类型</td><td>必选项，此处的值固定为”password”</td></tr><tr><td>username</td><td>用户名</td><td>必选项</td></tr><tr><td>password</td><td>用户的密码</td><td>必选项</td></tr><tr><td>scope</td><td>申请的权限范围</td><td>可选项</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure><p><strong>C步骤中，认证服务器向客户端发送访问令牌：</strong></p><table><thead><tr><th>参数</th><th>具体含义</th><th>是否必填</th></tr></thead><tbody><tr><td>access_token</td><td>访问令牌</td><td>必选项</td></tr><tr><td>token_type</td><td>牌类型，该值大小写不敏感</td><td>必选项</td></tr><tr><td>expires_in</td><td>过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间</td><td>可选项</td></tr><tr><td>scope</td><td>权限范围</td><td>如果与客户端申请的范围一致，此项可省略</td></tr><tr><td>example_parameter</td><td>如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数</td><td>可选项</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: application/json;charset=UTF<span class="number">-8</span></span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">  <span class="string">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">  <span class="string">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">  <span class="string">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">  <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-客户端模式"><a href="#四-客户端模式" class="headerlink" title="(四). 客户端模式"></a>(四). 客户端模式</h4><p><strong>客户端模式</strong>(<code>Client Credentials Grant</code>)指<strong>客户端</strong>以自己的名义，而不是以<strong>用户</strong>的名义，向”<strong>服务提供商</strong>“进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。</p><p>在这种模式中，<strong>用户</strong>直接向<strong>客户端注册</strong>，<strong>客户端</strong>以自己的名义要求”<strong>服务提供商</strong>“提供服务，其实不存在授权问题。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/client_mode.png" alt=""></p><p>它的步骤如下：</p><pre><code>(A). 客户端向认证服务器进行身份认证，并要求一个访问令牌。(B). 认证服务器确认无误后，向客户端提供访问令牌。</code></pre><p><strong>A步骤中，客户端发出的HTTP请求，包含以下参数：</strong></p><table><thead><tr><th>参数</th><th>具体含义</th><th>是否必填</th></tr></thead><tbody><tr><td>grant_type</td><td>授权类型</td><td>必选项，此处的值固定为”clientcredentials”</td></tr><tr><td>scope</td><td>权限范围</td><td>可选项。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure><p>认证服务器必须以某种方式，验证客户端身份。</p><p><strong>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: application/json;charset=UTF<span class="number">-8</span></span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">  <span class="string">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">  <span class="string">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">  <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了<code>OAuth 2.0</code>的一些基本概念，以及四种授权模式：授权码模式、简单模式、密码模式和客户端模式。o</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;举个简单的例子。新浪微博是你的家，有时候你会想让一些人(第三方应用)去你的家里帮你办点事情，或者取点东西。你可以直接复制一把钥匙(用户名和密码)给他们，但这里存在几个问题：&lt;/p&gt;
    
    </summary>
    
      <category term="认证与授权系列" scheme="https://ostenant.coding.me/categories/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="OAuth 2.0" scheme="https://ostenant.coding.me/tags/OAuth-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO系列(四) - Selector</title>
    <link href="https://ostenant.coding.me/2017/12/31/Java%20NIO%E7%B3%BB%E5%88%97(%E5%9B%9B)%20-%20Selector/"/>
    <id>https://ostenant.coding.me/2017/12/31/Java NIO系列(四) - Selector/</id>
    <published>2017-12-31T04:16:00.000Z</published>
    <updated>2018-05-08T02:49:46.092Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Selector</code> 是 <code>Java NIO</code> 中的一个组件，用于检查<strong>一个</strong>或<strong>多个</strong>通道 <code>Channel</code> 的状态是否处于<strong>可读</strong>、<strong>可写</strong>状态。如此可以实现<strong>单线程</strong>管理<strong>多个通道</strong>，也就是可以管理多个<strong>网络连接</strong>。</p><a id="more"></a><h2 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector?"></a>为什么使用Selector?</h2><p>用<strong>单线程</strong>处理多个 <code>Channel</code> 的好处是我需要更少的线程来处理 <code>Channel</code> 。实际上，你甚至可以用<strong>一个线程</strong>来处理所有的<code>Channel</code>。从操作系统的角度来看，<strong>切换线程的开销</strong>是比较昂贵的，并且<strong>每个线程</strong>都需要占用<strong>系统资源</strong>，因此暂用线程越少越好。</p><p>简而言之，通过 <code>Selector</code> 我们可以实现<strong>单线程</strong>操作多个 <code>Channel</code>。下面是<strong>单线程</strong>使用一个 <code>Selector</code> 处理 <code>3</code> 个 <code>Channel</code> 的示例图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Java_NIO_Selector_Channel.png" alt=""></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Selector的组件"><a href="#Selector的组件" class="headerlink" title="Selector的组件"></a>Selector的组件</h2><p><code>Java NIO Selector</code>中有三个重要的组成：<code>Selector</code>、<code>SelectableChannel</code> 和 <code>SelectionKey</code>。</p><h3 id="一-选择器-Selector"><a href="#一-选择器-Selector" class="headerlink" title="(一) 选择器(Selector)"></a>(一) 选择器(Selector)</h3><p><code>Selector</code><strong>选择器类</strong>管理着一个<strong>被注册</strong>的<strong>通道集合</strong>的信息和它们的<strong>就绪状态</strong>。<strong>选择器</strong>所在线程不停地更新通道的<strong>就绪状态</strong>，对通道注册的<strong>连接</strong>、<strong>数据读写事件</strong>等事件进行响应。</p><h3 id="二-可选择通道-SelectableChannel"><a href="#二-可选择通道-SelectableChannel" class="headerlink" title="(二) 可选择通道(SelectableChannel)"></a>(二) 可选择通道(SelectableChannel)</h3><p><code>SelectableChannel</code> 是一个<strong>抽象类</strong>，提供了<strong>通道</strong>的<strong>可选择性</strong>所需要的<strong>公共方法</strong>的实现，它是所有支持<strong>就绪检查</strong>的<strong>通道类</strong>的<strong>父类</strong>。</p><p>因为 <code>FileChannel</code> 类没有继承 <code>SelectableChannel</code>，因此不是<strong>可选通道</strong>。而所有 <code>Socket</code> <strong>通道</strong>都是可选择的，包括从<strong>管道</strong> (<code>Pipe</code>) 对象的中获得的通道。<br><code>SelectableChannel</code> 可以被注册到 <code>Selector</code> 对象上，并且注册时可以指定<strong>感兴趣</strong>的事件操作，比如：<strong>数据读取</strong>、<strong>数据写入</strong>操作。一个<strong>通道</strong>可以被注册到<strong>多个选择器</strong>上，但对<strong>每个</strong>选择器而言只能被注册<strong>一次</strong>。</p><h3 id="三-选择键-SelectionKey"><a href="#三-选择键-SelectionKey" class="headerlink" title="(三) 选择键(SelectionKey)"></a>(三) 选择键(SelectionKey)</h3><p><strong>选择键</strong>封装了<strong>特定的通道</strong>与<strong>特定的选择器</strong>的注册关系。<strong>选择键</strong>对象由被 <code>SelectableChannel.register()</code> 返回并提供一个表示这种<strong>注册关系</strong>的标记。选择键包含了<strong>两个比特集</strong>(以整数的形式进行编码)，指示了该注册关系所关心的<strong>通道操作</strong>，以及通道已经准备好的操作。</p><h2 id="Selector的使用"><a href="#Selector的使用" class="headerlink" title="Selector的使用"></a>Selector的使用</h2><h3 id="一-创建Selector对象"><a href="#一-创建Selector对象" class="headerlink" title="(一) 创建Selector对象"></a>(一) 创建Selector对象</h3><p><code>Selector</code> 对象是通过调用静态工厂方法 <code>open()</code> 来实例化的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector Selector = Selector.open();</span><br></pre></td></tr></table></figure><h3 id="二-将SelectableChannel注册到Selector"><a href="#二-将SelectableChannel注册到Selector" class="headerlink" title="(二) 将SelectableChannel注册到Selector"></a>(二) 将SelectableChannel注册到Selector</h3><p>为了将 <code>Channel</code> 和 <code>Selector</code> 配合使用，必须将 <code>Channel</code> 注册到 <code>Selector</code> 上。通过 <code>SelectableChannel.register()</code> 方法来实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 对读操作感兴趣，向Selector注册读事件</span></span><br><span class="line">SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>与 <code>Selector</code> 一起使用时，<code>Channel</code> 必须处于<strong>非阻塞模式</strong>下。这意味着不能将 <code>FileChannel</code> 与 <code>Selector</code> 一起使用，因为 <code>FileChannel</code> 不能切换到<strong>非阻塞模式</strong>，而<strong>套接字通道</strong>都可以。</p><p>注意 <code>register()</code> 方法的<strong>第二个参数</strong>。这是一个兴趣 (<code>interest</code>) 集合，意思是在通过 <code>Selector</code> 监听 <code>Channel</code> 时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li><strong>连接操作(Connect)</strong>：监听 <code>SocketChannel</code> 到来的连接事件。</li><li><strong>接受操作(Accept)</strong>：对应<strong>常量</strong> <code>SelectionKey.OP_ACCEPT</code>，专注于监听 <code>ServerSocketChannel</code> 接受 <code>SocketChannel</code> 的事件。</li><li><strong>读操作(Read)</strong>：对应<strong>常量</strong> <code>SelectionKey.OP_READ</code>，监听数据完全到达，<strong>通道可读</strong>的事件。</li><li><strong>写操作(Write)</strong>：对应<strong>常量</strong> <code>SelectionKey.OP_READ</code>，监听数据准备完成，<strong>通道可写</strong>的事件。</li></ul><blockquote><p><strong>注意</strong>：并非<strong>所有的操作</strong>在所有的<strong>可选择通道</strong>上都能被支持。比如 <code>ServerSocketChannel</code> 支持 <code>Accept</code>操作，而 <code>SocketChannel</code> 中不支持。我们可以通过通道上的 <code>validOps()</code> 方法来获取特定通道下所有支持的<strong>操作集合</strong>。</p></blockquote><p>以上<strong>四种事件</strong>用 <code>SelectionKey</code> 的四个常量来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;  <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>如果<strong>一个通道</strong>同时对<strong>多种操作</strong>感兴趣，可以用 “<strong>位或</strong>” 操作符将常量连接起来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="三-为SelectionKey绑定附加对象"><a href="#三-为SelectionKey绑定附加对象" class="headerlink" title="(三) 为SelectionKey绑定附加对象"></a>(三) 为SelectionKey绑定附加对象</h3><p>可以将<strong>一个对象</strong>或者<strong>更多信息</strong>附着到 <code>SelectionKey</code> 上，这样就能方便的识别<strong>某个给定的通道</strong>。例如，可以附加与<strong>通道</strong>一起使用的 <code>Buffer</code>，或是<strong>包含聚集数据</strong>的某个对象。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用 <code>register()</code> 方法向 <code>Selector</code> 注册 <code>Channel</code> 的时候附加对象，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><p>如果要取消该对象，则可以通过该种方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="四-通过Selector选择通道"><a href="#四-通过Selector选择通道" class="headerlink" title="(四) 通过Selector选择通道"></a>(四) 通过Selector选择通道</h3><p>一旦向 <code>Selector</code> 注册了一或多个通道，就可以调用几个<strong>重载</strong>的 <code>select()</code> 方法。这些方法返回你所感兴趣的事件 (如<strong>连接</strong>、<strong>接受</strong>、<strong>读</strong>或<strong>写</strong>) 已经准备就绪的那些通道。换句话说，如果你对“<strong>读就绪</strong>”的通道感兴趣，<code>select()</code> 方法会返回<strong>读事件已经就绪</strong>的那些通道的 <code>SelectionKey</code>。</p><p>下面是 <code>select()</code> 方法的几个重载：</p><ul><li><strong>int select()</strong>：<strong>阻塞</strong>到至少有一个<strong>通道</strong>在此<strong>选择器</strong>注册的事件上就绪了。</li><li><strong>int select(long timeout)</strong>：<code>select(long timeout)</code> 和 <code>select()</code> 一样，除了<strong>最长会阻塞</strong><code>timeout</code>毫秒(参数)。</li><li><strong>int selectNow()</strong>：<strong>不会阻塞</strong>，不管什么通道就绪都<strong>立刻返回</strong>。如果<strong>没有通道</strong>变成可选择的，则此方法直接返回 <code>0</code>。</li></ul><p>也可以通过<strong>遍历</strong> <code>SelectionKey</code> 上的<strong>已选择键集合</strong>来访问<strong>就绪</strong>的通道，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// 一个连接被ServerSocketChannel接受</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// 与远程服务器建立了连接</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// 一个channel做好了读准备</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// 一个channel做好了写准备</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：每次迭代完成时 <code>Selector</code> 自己不会将已经处理完成的 <code>SelectionKey</code>实例移除，在迭代的末尾需要调用 <code>keyIterator.remove()</code> 方法手动移除。</p></blockquote><p><code>SelectionKey.channel()</code> 方法返回的<strong>通道</strong>需要<strong>强转</strong>为你要处理的类型，如：<code>ServerSocketChannel</code> 或 <code>SocketChannel</code> 等。</p><h2 id="Selector完整实例"><a href="#Selector完整实例" class="headerlink" title="Selector完整实例"></a>Selector完整实例</h2><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> number = selector.select();</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey selectionKey = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 获取客户端通道</span></span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将客户端通道注册到选择器上</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">            handleRead(selectionKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">            handleWrite(selectionKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Isonnectable := true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端操作过程"><a href="#服务端操作过程" class="headerlink" title="服务端操作过程"></a>服务端操作过程</h3><ol><li>创建 <code>ServerSocketChannel</code> 实例，设置为<strong>非阻塞</strong>模式，并绑定指定的<strong>服务端口</strong>；</li><li>创建 <code>Selector</code> 实例；</li><li>将 <code>serverSocketChannel</code> 注册到 <code>selector</code> 上面，并指定事件 <code>OP_ACCEPT</code>，最底层的 <code>socket</code> 通过 <code>channel</code> 和 <code>selector</code> 建立关联；</li><li>如果没有准备好 (<code>Accept</code>) 的<code>socket</code>，<code>select</code>方法会被<strong>阻塞一段时间</strong>并返回 <code>0</code>；</li><li>如果底层有 <code>socket</code> 已经准备好，<code>selector</code> 的 <code>select()</code> 方法会返回 <code>socket</code> 的个数，而且 <code>selectedKeys</code> 方法会返回 <code>socket</code> 对应的<strong>事件</strong>(<code>connect</code>、<code>accept</code>、<code>read</code> 和 <code>write</code>)；</li><li>根据<strong>事件类型</strong>，进行不同的处理逻辑。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里简单的介绍了 <code>Java NIO</code> 中选择器的用法，有关 <code>Selector</code> 底层的实现原理需要进一步查看源码。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Selector&lt;/code&gt; 是 &lt;code&gt;Java NIO&lt;/code&gt; 中的一个组件，用于检查&lt;strong&gt;一个&lt;/strong&gt;或&lt;strong&gt;多个&lt;/strong&gt;通道 &lt;code&gt;Channel&lt;/code&gt; 的状态是否处于&lt;strong&gt;可读&lt;/strong&gt;、&lt;strong&gt;可写&lt;/strong&gt;状态。如此可以实现&lt;strong&gt;单线程&lt;/strong&gt;管理&lt;strong&gt;多个通道&lt;/strong&gt;，也就是可以管理多个&lt;strong&gt;网络连接&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java编程进阶系列" scheme="https://ostenant.coding.me/categories/Java%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="NIO" scheme="https://ostenant.coding.me/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO系列(三) - Channel</title>
    <link href="https://ostenant.coding.me/2017/12/27/Java%20NIO%E7%B3%BB%E5%88%97(%E4%B8%89)%20-%20Channel/"/>
    <id>https://ostenant.coding.me/2017/12/27/Java NIO系列(三) - Channel/</id>
    <published>2017-12-27T07:22:00.000Z</published>
    <updated>2018-05-08T02:49:46.091Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文讲到<code>Java NIO</code>一些基本概念。在标准的<code>IO</code>中，都是基于<strong>字节流/字符流</strong>进行数据操作的，而在<code>NIO</code>中则是是基于<code>Channel</code>和<code>Buffer</code>进行操作，其中的<code>Channel</code>的虽然模拟了<strong>流</strong>的概念，实则大不相同。</p><p>本文将详细阐述<code>NIO</code>中的<strong>通道</strong><code>Channel</code>的概念和具体的用法。</p><a id="more"></a><h2 id="Channel和Stream的区别"><a href="#Channel和Stream的区别" class="headerlink" title="Channel和Stream的区别"></a>Channel和Stream的区别</h2><table><thead><tr><th>区别</th><th>Stream</th><th>Channel</th></tr></thead><tbody><tr><td>是否支持异步</td><td>不支持</td><td>支持</td></tr><tr><td>是否支持双向数据传输</td><td>不支持，只能单向</td><td>支持，既可以从通道读取数据，也可以向通道写入数据</td></tr><tr><td>是否结合Buffer使用</td><td>不</td><td>必须结合Buffer使用</td></tr><tr><td>性能</td><td>较低</td><td>较高</td></tr></tbody></table><p><code>Channel</code>用于在<strong>字节缓冲区</strong>和位于通道另一侧的服务（通常是<strong>文件</strong>或者<strong>套接字</strong>）之间以便有效的进行<strong>数据传输</strong>。借助通道，可以用最小的总开销来访问操作系统本身的<code>I/O</code>服务。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Java_NIO_Channel_Buffer.png" alt=""></p><blockquote><p>需要注意的是Channel必须结合Buffer使用，应用程序不能直接向通道中读/写数据，也就是缓冲区充当着应用程序和通道数据流动的转换的角色。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Channel的源码"><a href="#Channel的源码" class="headerlink" title="Channel的源码"></a>Channel的源码</h2><p>查看<code>Channel</code>的源码。所有的接口都实现于<code>Channel</code>接口，从接口上来看，所有的通道都有这两种操作：检查通道的<strong>开启状态</strong>和<strong>关闭通道</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Channel的分类"><a href="#Channel的分类" class="headerlink" title="Channel的分类"></a>Channel的分类</h2><p>广义上来说通道可以被分为两类：文件<code>I/O</code>和网络<code>I/O</code>，也就是<strong>文件通道</strong>和<strong>套接字通道</strong>。如果分的更细致一点则是：</p><ul><li><strong>FileChannel</strong>：从文件读写数据；</li><li><strong>SocketChannel</strong>：通过<code>TCP</code>读写网络数据；</li><li><strong>ServerSocketChannel</strong>：可以监听新进来的<code>TCP</code>连接，并对每个链接创建对应的<code>SocketChannel</code>；</li><li><strong>DatagramChannel</strong>：通过<code>UDP</code>读写网络中的数据。</li></ul><h2 id="Channel的特性"><a href="#Channel的特性" class="headerlink" title="Channel的特性"></a>Channel的特性</h2><h3 id="单向or双向"><a href="#单向or双向" class="headerlink" title="单向or双向"></a>单向or双向</h3><p><strong>通道既可以是单向的也可以是双向的</strong>。只实现<code>ReadableByteChannel</code>接口中的<code>read()</code>方法或者只实现<code>WriteableByteChannel</code>接口中的<code>write()</code>方法的通道皆为<strong>单向通道</strong>，同时实现<code>ReadableByteChannel</code>和<code>WriteableByteChannel</code>为<strong>双向通道</strong>，比如<code>ByteChannel</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByteChannel</span> <span class="keyword">extends</span> <span class="title">ReadableByteChannel</span>, <span class="title">WritableByteChannel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Socket</code>通道来说，它们一直是<strong>双向的</strong>，而对于<code>FileChannel</code>来说，它同样实现了<code>ByteChannel</code>，但是通过<code>FileInputStream</code>的<code>getChannel()</code>获取的<code>FileChannel</code>只具有文件的<strong>只读权限</strong>。</p><blockquote><p>注意：调用FileChannel的write()方法会抛出了NonWriteChannelException异常。</p></blockquote><h3 id="阻塞or非阻塞"><a href="#阻塞or非阻塞" class="headerlink" title="阻塞or非阻塞"></a>阻塞or非阻塞</h3><p><strong>通道的工作模式有两种：阻塞或非阻塞</strong>。在<strong>非阻塞模式</strong>下，调用的线程不会休眠，请求的操作会立刻返回结果；在<strong>阻塞模式</strong>下，调用的线程会产生休眠。</p><p>除<code>FileChannel</code>不能运行在<strong>非阻塞模式</strong>下，其余的通道都可<strong>阻塞</strong>运行也可以以<strong>非阻塞</strong>的方式运行。</p><p>另外从<code>SelectableChannel</code>引申出的类可以和支持有条件选择的<code>Selector</code>结合使用，进而充分利用<strong>多路复用</strong>的<code>I/O</code>(<code>Multiplexed I/O</code>)来<strong>提高性能</strong>。</p><p><code>SelectableChannel</code>的源码中有以下几个抽象方法，可以看出支持配置两种工作模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectableChannel</span> <span class="keyword">extends</span> <span class="title">AbstractInterruptibleChannel</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置是否为Channel阻塞模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为Channel阻塞模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isBlocking</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取阻塞的锁对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">blockingLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>Socket</code><strong>通道</strong>类来说，通常与<code>Selector</code>共同使用以提高性能。需要注意的是通道<strong>不能被同时使用</strong>，一个<strong>打开的通道</strong>代表着与一个<strong>特定</strong><code>I/O</code>服务进行<strong>连接</strong>并封装了该<strong>连接的状态</strong>，通道一旦<strong>关闭</strong>，该连接便会<strong>断开</strong>。</p><p>通道的<code>close()</code>比较特殊，无论在通道时在<strong>阻塞模式</strong>下还是<strong>非阻塞模式</strong>下，由于<code>close()</code>方法的调用而导致<strong>底层</strong><code>I/O</code>的<strong>关闭</strong>都可能会造成线程的<strong>暂时阻塞</strong>。在一个<strong>已关闭</strong>的通道上调用<code>close()</code>并没有任何意义，只会立即返回。</p><h2 id="Channel的实战"><a href="#Channel的实战" class="headerlink" title="Channel的实战"></a>Channel的实战</h2><blockquote><p>对于Socket通道来说存在直接创建新Socket通道的方法，而对于文件通道来说，升级之后的FileInputStream、FileOutputStream和RandomAccessFile提供了getChannel()方法来获取通道。</p></blockquote><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p><code>Java NIO</code>中的<code>FileChannel</code>是一个连接到<strong>文件</strong>的通道，可以通过文件通道读写文件。文件通道总是<strong>阻塞式</strong>的，因此FileChannel无法设置为<strong>非阻塞模式</strong>。</p><h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><p><strong>(一). 文件写操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteOnFileChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile randomAccess = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://test.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fileChannel = randomAccess.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> String(<span class="string">"Java Non-blocking IO"</span>).getBytes();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓冲区中的字节写入文件通道中</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">// 强制将通道中未写入磁盘的数据立刻写入到磁盘</span></span><br><span class="line">        fileChannel.force(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 清空缓冲区，释放内存</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(二). 文件读操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReadOnFileChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D://test.txt"</span>));</span><br><span class="line">        FileChannel fileChannel = inputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 不断地写入缓冲区，写一次读一次</span></span><br><span class="line">        <span class="keyword">while</span> (fileChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓冲区从写模式切换为读模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="comment">// 开始读取</span></span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 一个字节一个字节地读取，并向后移动position地位置</span></span><br><span class="line">                System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缓冲区不会被自动覆盖，需要主动调用该方法(实际上还是覆盖)</span></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件读写测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Start to write"</span>);</span><br><span class="line">    <span class="comment">// 通过FileChannel写入数据</span></span><br><span class="line">    testWriteOnFileChannel();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Start to read"</span>);</span><br><span class="line">    <span class="comment">// 通过FileChannel读取数据</span></span><br><span class="line">    testReadOnFileChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果：<br><img src="http://ols3fdyll.bkt.clouddn.com/filechannel_test_result.png" alt=""></p><h4 id="transferFrom和transferTo"><a href="#transferFrom和transferTo" class="headerlink" title="transferFrom和transferTo"></a>transferFrom和transferTo</h4><p><strong>(一). transferFrom()的使用</strong></p><p><code>FileChannel</code>的<code>transferFrom()</code>方法可以将数据从<strong>源通道</strong>传输到<code>FileChannel</code>中。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTransferFrom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://file1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line">        RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://file2.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line">        toChannel.transferFrom(fromChannel, position, count);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(二). transferTo()的使用</strong></p><p><code>transferTo()</code>方法将数据从<code>FileChannel</code>传输到<strong>目标</strong><code>channel</code>中。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTransferTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://file1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line">        RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://file3.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line">        fromChannel.transferTo(position, count, toChannel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p><code>Java NIO</code>中的<code>ServerSocketChannel</code>是一个可以<strong>监听</strong>新进来的<strong>TCP连接</strong>的通道。它类似<code>ServerSocket</code>，要注意的是和<code>DatagramChannel</code>和<code>SocketChannel</code>不同，<code>ServerSocketChannel</code>本身<strong>不具备传输数据</strong>的能力，而只是负责<strong>监听</strong>传入的连接和<strong>创建</strong>新的<code>SocketChannel</code>。</p><h4 id="ServerSocketChannel的用法"><a href="#ServerSocketChannel的用法" class="headerlink" title="ServerSocketChannel的用法"></a>ServerSocketChannel的用法</h4><p><strong>(一). 创建ServerSocketChannel</strong></p><p>通过<code>ServerSocketChannel.open()</code>方法来创建一个新的<code>ServerSocketChannel</code>对象，该对象关联了一个<strong>未绑定</strong><code>ServerSocket</code>的<strong>通道</strong>。通过调用该对象上的<code>socket()</code>方法可以获取与之关联的<code>ServerSocket</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel socketChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure><p><strong>(二). 为ServerSocketChannel绑定监听端口号</strong></p><p>在<code>JDK 1.7</code>之前，<code>ServerSocketChannel</code>没有<code>bind()</code>方法，因此需要通过他关联的的<code>socket</code>对象的<code>socket()</code>来绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.7之前</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">25000</span>));</span><br></pre></td></tr></table></figure><p>从<code>JDK1.7</code>及以后，可以直接通过<code>ServerSocketChannel</code>的<code>bind()</code>方法来<strong>绑定端口号</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.7之后</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">25000</span>));</span><br></pre></td></tr></table></figure><p> <strong>(三). 设置<code>ServerSocketChannel</code>的工作模式</strong></p><p><code>ServerSocketChannel</code>底层默认采用<strong>阻塞</strong>的工作模式，它提供了一个<code>configureBlocking()</code>方法，允许配置<code>ServerSocketChannel</code>以<strong>非阻塞方式</strong>运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>进一步查看<code>configureBlocking</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        <span class="keyword">if</span> (blocking == block)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (block &amp;&amp; haveValidKeys())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">        implConfigureBlocking(block);</span><br><span class="line">        blocking = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Javadoc解释configureBlocking()方法用于调整底层通道的工作模式，即阻塞和非阻塞，默认是阻塞工作模式。</p></blockquote><p>如果block设置为true，直接返回当前的阻塞式的通道；如果block设置为false，configureBlocking()方法会调用implConfigureBlocking()方法。这里implConfigureBlocking()是由<code>ServerSocketChannelImpl</code>实现，最终调用了IOUtil中的native方法configureBlocking()。</p><p><strong>(四). 监听新进来的连接</strong></p><p>通过<code>ServerSocketChannel.accept()</code>方法监听新进来的连接，这里需要根据<code>configureBlocking()</code>的配置区分两种工作模式的使用：</p><ul><li>在<strong>阻塞模式</strong>下，当<code>accept()</code>方法返回的时候，它返回一个包含<strong>新连接</strong>的<code>SocketChannel</code>，否则<code>accept()</code>方法会一直<strong>阻塞到</strong>有新连接到达。</li><li>在<strong>非阻塞模式</strong>下，在没有新连接的情况下，<code>accept()</code>会立即返回<code>null</code>，该模式下通常<strong>不会仅仅</strong>监听一个连接，因此需在<code>while</code><strong>循环</strong>中调用<code>accept()</code>方法.</li></ul><p>阻塞模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">// 新连接没到达之前，后面的程序无法继续执行</span></span><br><span class="line">    InetSocketAddress remoteAddress = (InetSocketAddress) socketChannel.getRemoteAddress();</span><br><span class="line">    <span class="comment">// 其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非阻塞模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">// 新连接没到达之前，后面程序一直循环，直到检测到socketChannel不为null时进入真正的执行逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InetSocketAddress remoteAddress = (InetSocketAddress) socketChannel.getRemoteAddress();</span><br><span class="line">        <span class="comment">// 其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(五). 关闭ServerSocketChannel</strong></p><p>通过调用<code>ServerSocketChannel.close()</code>方法来关闭<code>ServerSocketChannel</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure><h4 id="ServerSocketChannel的完整示例"><a href="#ServerSocketChannel的完整示例" class="headerlink" title="ServerSocketChannel的完整示例"></a>ServerSocketChannel的完整示例</h4><p><strong>(一). 阻塞模式</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blockingTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">25000</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"ServerSocketChannel listening on 25000..."</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        InetSocketAddress remoteAddress = (InetSocketAddress) socketChannel.getRemoteAddress();</span><br><span class="line">        System.out.println(<span class="string">"Remote address: "</span> + remoteAddress.getHostString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/serversocket_channel_blocking_result.png" alt=""></p><p><strong>(二). 非阻塞模式</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonBlockingTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">25001</span>));</span><br><span class="line">    System.out.println(<span class="string">"ServerSocketChannel listening on 25001..."</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        System.out.println(<span class="string">"SocketChannel： "</span> + socketChannel);</span><br><span class="line">        <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            InetSocketAddress remoteAddress = (InetSocketAddress) socketChannel.getRemoteAddress();</span><br><span class="line">            System.out.println(<span class="string">"Remote address: "</span> + remoteAddress.getHostString());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/serversocket_channel_non_blocking_result.png" alt=""></p><hr><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p><code>Java NIO</code>中的<code>SocketChannel</code>是一个连接到<code>TCP</code><strong>网络套接字</strong>的<strong>通道</strong>，它是<code>Socket</code>类的对等类。</p><p>通常<code>SocketChannel</code>在<strong>客户端</strong>向<strong>服务器</strong>发起连接请求，每个<code>SocketChannel</code>对象创建时都关联一个对等的<code>Socket</code>对象。同样<code>SocketChannel</code>也可以运行在<strong>非阻塞模式</strong>下。</p><h4 id="SocketChannel的用法"><a href="#SocketChannel的用法" class="headerlink" title="SocketChannel的用法"></a>SocketChannel的用法</h4><p><code>SocketChannel</code>创建的方式有两种：</p><ul><li>客户端主动创建：客户端打开一个<code>SocketChannel</code>并连接到某台服务器上；</li><li>服务端被动创建：一个新连接到达<code>ServerSocketChannel</code>时，服务端会创建一个<code>SocketChannel</code>。</li></ul><p><strong>(一). 创建SocketChannel</strong></p><p>通过<code>SocketChannel</code>的静态方法<code>open()</code>创建<code>SocketChannel</code>对象。此时<strong>通道</strong>虽然打开，但并<strong>未建立连接</strong>。此时如果进行<code>I/O</code>操作会抛出<code>NotYetConnectedException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br></pre></td></tr></table></figure><p><strong>(二). 连接指定服务器</strong></p><p>通过<code>SocketChannel</code>对象的<code>connect()</code>连接指定地址。该通道一旦连接，将保持连接状态直到被关闭。可通过<code>isConnected()</code>来确定某个<code>SocketChannel</code>当前是否已连接。</p><ul><li><strong>阻塞模式</strong>：</li></ul><p>如果在<strong>客户端</strong>的<code>SocketChannel</code>阻塞模式下，即<strong>服务器端</strong>的<code>ServerSocketChannel</code>也为<strong>阻塞模式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">25000</span>));</span><br><span class="line"><span class="comment">// connect()方法调用以后，socketChannel底层的连接创建完成后，才会执行后面的打印语句</span></span><br><span class="line">System.out.println(<span class="string">"连接创建完成..."</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>非阻塞模式</strong>：</li></ul><blockquote><p>两点需要注意：其一，SocketChannel需要通过configureBlocking()设置为非阻塞模式；其二，非阻塞模式下，connect()方法调用后会异步返回，为了确定连接是否建立，需要调用finishConnect()的方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">25001</span>));</span><br><span class="line"><span class="comment">// connect()方法调用以后，异步返回，需要手动调用finishConnect确保连接创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!socketChannel.finishConnect())&#123;</span><br><span class="line">    <span class="comment">// 检测到还未创建成功则睡眠10ms</span></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"连接创建完成..."</span>);</span><br></pre></td></tr></table></figure><p><strong>(三). 从SocketChannel读数据</strong></p><p>利用<code>SocketChannel</code>对象的<code>read()</code>方法将数据从<code>SocketChannel</code><strong>读取</strong>到<code>Buffer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞模式下，read()方法在尚未读取到任何数据时可能就返回了，所以需要关注它的int返回值。</span></span><br><span class="line"><span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(四). 向SocketChannel写数据</strong></p><p>利用<code>SocketChannel</code>对象的<code>write()</code>将<code>Buffer</code>的数据<strong>写入</strong><code>SocketChannel</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">byteBuffer.put(<span class="string">"Client Blocking SocketChannel"</span>.getBytes());</span><br><span class="line"><span class="comment">// byteBuffer.put("Client Non-Blocking SocketChannel".getBytes());</span></span><br><span class="line">byteBuffer.flip();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()</span></span><br><span class="line"><span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">    socketChannel.write(byteBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保持睡眠，观察控制台输出</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">20000</span>);</span><br><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure><p><strong>(五). 关闭SocketChannel</strong></p><p>利用<code>SocketChannel</code>对象的<code>close()</code>方法关闭<code>SocketChannel</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure><h4 id="SocketChannel的完整示例"><a href="#SocketChannel的完整示例" class="headerlink" title="SocketChannel的完整示例"></a>SocketChannel的完整示例</h4><p><strong>(一). 阻塞模式</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blockingWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">    socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">25000</span>));</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"Client Blocking SocketChannel"</span>.getBytes());</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">20000</span>);</span><br><span class="line">    socketChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端打印结果：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/blocking_socketchannel_write_test.png" alt=""></p><p><strong>(一). 非阻塞模式</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonBlockingWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">25001</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!socketChannel.finishConnect())&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"Client Non-Blocking SocketChannel"</span>.getBytes());</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">20000</span>);</span><br><span class="line">    socketChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端打印结果：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/nonblocking_socketchannel_write_test.png" alt=""></p><hr><h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p><code>Java NIO</code>中的<code>DatagramChannel</code>是一个能收发<code>UDP</code><strong>包</strong>的通道，其底层实现为<code>DatagramSocket + Selector</code>。<code>DatagramChannel</code>可以调用<code>socket()</code>方法获取对等<code>DatagramSocket</code>对象。<br><code>DatagramChannel</code>对象既可以充当<strong>服务端（监听者）</strong>，也可以充当<strong>客户端（发送者）</strong>。如果需要新创建的通道负责监听，那么该通道必须绑定一个端口（或端口组）：</p><h4 id="DatagramChannel的完整示例"><a href="#DatagramChannel的完整示例" class="headerlink" title="DatagramChannel的完整示例"></a>DatagramChannel的完整示例</h4><p>数据报发送方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.wrap(<span class="string">"DatagramChannel Sender"</span>.getBytes());</span><br><span class="line">    <span class="keyword">int</span> byteSent = datagramChannel.send(byteBuffer, <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">50020</span>));</span><br><span class="line">    System.out.println(<span class="string">"Byte sent is: "</span> + byteSent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据报接收方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">    datagramChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">50020</span>));</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    datagramChannel.receive(byteBuffer);</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行<code>DatagramChannelReceiveTest</code>，再运行<code>DatagramChannelSendTest</code>，观察控制台输出：</p><p>数据报发送方：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/datagramchannel_sender.png" alt=""></p><p>数据报接收方：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/datagramchannel_recevirer.png" alt=""></p><hr><h2 id="工具类Channels"><a href="#工具类Channels" class="headerlink" title="工具类Channels"></a>工具类Channels</h2><p><code>NIO</code>通道提供了一个便捷的<strong>通道类</strong><code>Channels</code>，其中定义了几种<strong>静态的工厂方法</strong>以简化<strong>通道</strong>和<strong>流</strong>转换。其中常用的方法如下：</p><table><thead><tr><th>方法</th><th>返回</th><th>描述</th></tr></thead><tbody><tr><td>newChannel(InputStream in)</td><td>ReadableByteChannel</td><td>返回一个将从给定的输入流读取数据的通道。</td></tr><tr><td>newChannel(OutputStream out)</td><td>WritableByteChannel</td><td>返回一个将向给定的输出流写入数据的通道。</td></tr><tr><td>newInputStream(ReadableByteChannel ch)</td><td>InputStream</td><td>返回一个将从给定的通道读取字节的流。</td></tr><tr><td>newOutputStream(WritableByteChannel ch)</td><td>OutputStream</td><td>返回一个将向给定的通道写入字节的流。</td></tr><tr><td>newReader(ReadableByteChannel ch, CharsetDecoder dec, int minBufferCap)</td><td>Reader</td><td>返回一个reader，它将从给定的通道读取字节并依据提供的字符集名称对读取到的字节进行解码。</td></tr><tr><td>newReader(ReadableByteChannel ch, String csName)</td><td>Reader</td><td>返回一个reader，它将从给定的通道读取字节并依据提供的字符集名称将读取到的字节解码成字符。</td></tr><tr><td>newWriter(WritableByteChannel ch, CharsetEncoder dec, int minBufferCap)</td><td>Writer</td><td>返回一个writer，它将使用提供的字符集名称对字符编码并写到给定的通道中。</td></tr><tr><td>newWriter(WritableByteChannel ch, String csName)</td><td>Writer</td><td>返回一个writer，它将依据提供的字符集名称对字符编码并写到给定的通道中。</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文针对<code>NIO</code>中的通道的做了详细的介绍，对于<strong>文件通道</strong><code>FileChannel</code>，<strong>网络通道</strong><code>SocketChannel</code>、<code>ServerSocketChannel</code>和<code>DatagramChannel</code>进行了实战演示。</p><p>篇幅较长，可见<code>NIO</code>提供的原生的通道<code>API</code>在使用上并不是太容易。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上文讲到&lt;code&gt;Java NIO&lt;/code&gt;一些基本概念。在标准的&lt;code&gt;IO&lt;/code&gt;中，都是基于&lt;strong&gt;字节流/字符流&lt;/strong&gt;进行数据操作的，而在&lt;code&gt;NIO&lt;/code&gt;中则是是基于&lt;code&gt;Channel&lt;/code&gt;和&lt;code&gt;Buffer&lt;/code&gt;进行操作，其中的&lt;code&gt;Channel&lt;/code&gt;的虽然模拟了&lt;strong&gt;流&lt;/strong&gt;的概念，实则大不相同。&lt;/p&gt;
&lt;p&gt;本文将详细阐述&lt;code&gt;NIO&lt;/code&gt;中的&lt;strong&gt;通道&lt;/strong&gt;&lt;code&gt;Channel&lt;/code&gt;的概念和具体的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java编程进阶系列" scheme="https://ostenant.coding.me/categories/Java%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="NIO" scheme="https://ostenant.coding.me/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO系列(二) - Buffer</title>
    <link href="https://ostenant.coding.me/2017/12/26/Java%20NIO%E7%B3%BB%E5%88%97(%E4%BA%8C)%20-%20Buffer/"/>
    <id>https://ostenant.coding.me/2017/12/26/Java NIO系列(二) - Buffer/</id>
    <published>2017-12-26T13:41:00.000Z</published>
    <updated>2018-05-08T02:49:46.091Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<code>Java NIO</code>中，<strong>缓冲区</strong>用来<strong>临时</strong>存储数据，可以理解为是<code>I/O</code>操作中数据暂存的中转站。<strong>缓冲区</strong>直接为<strong>通道</strong>(<code>Channel</code>)服务，数据是从<strong>通道</strong>读入<strong>缓冲区</strong>，从<strong>缓冲区</strong>写入到<strong>通道</strong>中的。</p><p><strong>缓冲区</strong>本质上是一块可以<strong>写入数据</strong>，然后可以从中<strong>读取数据</strong>的内存。这块内存被包装成<code>NIO Buffer</code>对象，并提供了一组方法，用来方便的访问<strong>这块内存</strong>。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h2><p><code>Java NIO</code>提供以下几种<code>Buffer</code>类型：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Java_NIO_Buffer_Class_diagram.png" alt=""></p><ul><li><strong>ByteBuffer</strong></li><li><strong>MappedByteBuffer</strong></li><li><strong>ShortBuffer</strong></li><li><strong>LongBuffer</strong></li><li><strong>FloatBuffer</strong></li><li><strong>CharBuffer</strong></li><li><strong>IntBuffer</strong></li><li><strong>DoubleBuffer</strong></li></ul><p>这些<code>Buffer</code>类型代表了<code>Java</code>中7种基本数据类型。换句话说，就是可以通过<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>或<code>double</code>类型来操作<strong>缓冲区</strong>中的数据。</p><h2 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h2><p>使用<code>Buffer</code>读写数据一般遵循以下四个步骤：</p><ol><li>写入数据到<code>Buffer</code>中；</li><li>调用<code>Buffer</code>的<code>flip()</code>方法；</li><li>从<code>Buffer</code>中读取数据；</li><li>调用<code>clear()</code>方法或者<code>compact()</code>方法。</li></ol><p>当向<code>Buffer</code>写入数据时，<code>Buffer</code>会记录下写了多少数据。一旦要读取数据，需要通过<code>flip()</code>方法将<code>Buffer</code>从<strong>写模式</strong>切换到<strong>读模式</strong>。在<strong>读模式</strong>下，可以读取之前写入到<code>Buffer</code>的所有数据。</p><p>一旦读完了所有的数据，就需要<strong>清空缓冲区</strong>，让它可以再次被写入。两种方式能清空缓冲区：调用<code>clear()</code>或<code>compact()</code>方法。</p><ul><li><p><strong>clear()方法</strong>：清空<strong>整个</strong>缓冲区，包括<strong>已读</strong>和<strong>未读</strong>的数据。</p></li><li><p><strong>compact()方法</strong>：只会清空<strong>已读</strong>的数据，<strong>未读</strong>的数据都被移到<strong>缓冲区</strong>的<strong>起始处</strong>，新写入的数据将放到缓冲区<strong>未读数据</strong>的<strong>后面</strong>。</p></li></ul><p>下面给出一个<code>ByteBuffer</code>的简单使用示例，其他缓冲区<code>API</code>的使用类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReadFromBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://test.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fileChannel = file.getChannel();</span><br><span class="line">        <span class="comment">//创建容量为10byte的buffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 不断地写入缓冲区，写一次读一次</span></span><br><span class="line">        <span class="keyword">while</span> (fileChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置buffer切换模式为读模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 每次读取1byte，也就是一个字节</span></span><br><span class="line">                System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空整个缓存区，准备下次写入</span></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Buffer的重要属性"><a href="#Buffer的重要属性" class="headerlink" title="Buffer的重要属性"></a>Buffer的重要属性</h2><p>为了理解<code>Buffer</code>的工作原理，需要熟悉它的<code>4</code>个核心属性：</p><table><thead><tr><th>属性</th><th style="text-align:center">含义</th><th style="text-align:center">具体描述</th></tr></thead><tbody><tr><td>capacity</td><td style="text-align:center">容量</td><td style="text-align:center">缓冲区可以容纳的最大数据量，在缓冲区创建时被设定并且不能改变</td></tr><tr><td>limit</td><td style="text-align:center">上界</td><td style="text-align:center">缓冲区中当前已使用的数据量</td></tr><tr><td>position</td><td style="text-align:center">位置</td><td style="text-align:center">缓冲区下一个要被读或写的元素的索引</td></tr><tr><td>mark</td><td style="text-align:center">标记</td><td style="text-align:center">调用mark()来设置mark=position，再调用reset()可以让position恢复到标记的位置即position=mark</td></tr></tbody></table><p>其中，<code>position</code>和<code>limit</code>的含义取决于<code>Buffer</code>处在<strong>读模式</strong>还是<strong>写模式</strong>。不管<code>Buffer</code>处在什么模式，<code>capacity</code>的含义总是一样的。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Java_NIO_Buffer_capacity_limit_position.png" alt=""></p><h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><p>作为一个<strong>内存块</strong>，<code>Buffer</code>有一个固定的大小值，也叫<code>capacity</code>。你最多只能写入<code>capacity</code>个的<code>byte</code>、<code>char</code>、<code>int</code>、<code>long</code>等类型数据。一旦<code>Buffer</code>满了，需要将其<strong>清空</strong>（通过<strong>读数据</strong>或者<strong>清除数据</strong>）才能继续往里写数据。</p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul><li><strong>写入数据时</strong>：</li></ul><p>当你写数据到<code>Buffer</code>中时，<code>position</code>表示下一个<strong>可写入</strong>的数据的位置。<code>position</code>的<strong>初始位置</strong>为<code>0</code>，当一个<code>byte</code>、<code>char</code>、<code>int</code>、<code>long</code>等数据写到<code>Buffer</code>后，<code>position</code>会向前移动到<strong>下一个可插入</strong>数据的<code>Buffer</code>单元。<code>position</code>最大可为<code>capacity – 1</code>。</p><ul><li><strong>读取数据时</strong>：</li></ul><p>当从<code>Buffer</code>读取数据时，<code>position</code>表示下一个<strong>可读取</strong>的数据的位置。当将<code>Buffer</code>从<strong>写模式</strong>切换到<strong>读模式</strong>，<code>position</code>会被重置为<code>0</code>。当从<code>Buffer</code>的<code>position</code>处<strong>读取数据</strong>时，<code>position</code>向前移动到下一个<strong>可读</strong>的位置。</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><ul><li><strong>写入数据时</strong>：</li></ul><p>在<strong>写模式</strong>下，<code>Buffer</code>的<code>limit</code>表示你最多能往<code>Buffer</code>里写多少数据。写模式下，<code>limit</code>等于<code>Buffer</code>的<code>capacity</code>，也就是内存块的最大容量。</p><ul><li><strong>写入数据时</strong>：</li></ul><p>当切换<code>Buffer</code>到读模式时，<code>limit</code>会被设置成<strong>写模式</strong>下的<code>position</code>值，<code>limit</code>表示你最多能读到多少数据。<code>limit</code>被设置成<strong>已写</strong>数据的数量，这个值在<strong>写模式</strong>下就是<code>position</code>。</p><h2 id="Buffer的方法"><a href="#Buffer的方法" class="headerlink" title="Buffer的方法"></a>Buffer的方法</h2><h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><p>要想获得一个<code>Buffer</code>对象首先要进行分配，每一<code>个Buffer</code>类都有一个<code>allocate()</code>方法。下面是一个分配<code>10</code>字节<code>capacity</code>的<code>ByteBuffer</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>这是分配一个可存储<code>1024</code>个字符的<code>CharBuffer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h3 id="向Buffer中写入数据"><a href="#向Buffer中写入数据" class="headerlink" title="向Buffer中写入数据"></a>向Buffer中写入数据</h3><p>写数据到<code>Buffer</code>有两种方式：</p><ul><li>从<code>Channel</code>将数据写入<code>Buffer</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = channel.read(buffer);</span><br></pre></td></tr></table></figure><ul><li>通过<code>Buffer</code>的<code>put()</code>方法写到<code>Buffer</code>中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.put(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>put()</code>在<code>ByteBuffer</code>中为抽象方法，在<code>ByteBuffer</code>有很多的重载，由其子类<code>HeapByteBuffer</code>和<code>DirectByteBuffer</code>实现。</p><h3 id="写模式切换为读模式"><a href="#写模式切换为读模式" class="headerlink" title="写模式切换为读模式"></a>写模式切换为读模式</h3><p><code>flip()</code>方法将<code>Buffer</code>从<strong>写模式</strong>切换到<strong>读模式</strong>。调用<code>flip()</code>方法会将<code>position</code>设回<code>0</code>，并将<code>limit</code>设置成之前<code>position</code>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.flip();</span><br></pre></td></tr></table></figure><p>查看<code>flip()</code>方法的源码确认：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从Buffer从读取数据"><a href="#从Buffer从读取数据" class="headerlink" title="从Buffer从读取数据"></a>从Buffer从读取数据</h3><p>从<code>Buffer</code>中读取数据也有两种方式：</p><ul><li>从<code>Buffer</code>读取数据到<code>Channel</code>中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesWritten = channel.write(buf);</span><br></pre></td></tr></table></figure><ul><li>通过<code>Buffer</code>的<code>get()</code>方法从<code>Buffer</code>中读取数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = buffer.get();</span><br></pre></td></tr></table></figure><p><code>get()</code>方法和<code>put()</code>一样有很多的重载，允许以不同的方式从<code>Buffer</code>中读取数据。例如：从指定<code>position</code>读取，或者从<code>Buffer</code>中读取数据到字节数组。</p><h3 id="clear-和compact-方法"><a href="#clear-和compact-方法" class="headerlink" title="clear()和compact()方法"></a>clear()和compact()方法</h3><p>一旦读完<code>Buffer</code>中的数据，需要让<code>Buffer</code>准备好再次被写入。前面也说了，可以通过<code>clear()</code>或<code>compact()</code>方法来完成。</p><h4 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h4><p>如果调用的是<code>clear()</code>方法，<code>position</code>将被设回<code>0</code>，<code>limit</code>被设置成<code>capacity</code>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.clear();</span><br></pre></td></tr></table></figure><p>查看<code>clear()</code>方法的源码确认：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换句话说，<code>Buffer</code>被清空了。<code>Buffer</code>中的<strong>数据并未清除</strong>，只是这些标记告诉我们可以从哪里开始往<code>Buffer</code>里写数据。</p><h4 id="compact-方法"><a href="#compact-方法" class="headerlink" title="compact()方法"></a>compact()方法</h4><p>如果调用的是<code>compact()</code>方法，所有的<strong>未读数据</strong>都将被拷贝到<code>Buffer</code>的起始位置，<code>position</code>会设置为最后一个未读元素的后面。<code>limit()</code>方法和<code>clear()</code>方法一样，会被设置为<code>capacity</code>的大小。</p><p>查看<code>compact()</code>方法的实现，此方法在<code>ByteBuffer</code>中为抽象方法，查看其子类<code>HeapByteBuffer</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将未读的数据往前移动</span></span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    <span class="comment">// 设置postion为最后一个未读数据后面的位置</span></span><br><span class="line">    position(remaining());</span><br><span class="line">    <span class="comment">// 设置limit为最大的容量</span></span><br><span class="line">    limit(capacity());</span><br><span class="line">    <span class="comment">// 清除标记位</span></span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在<code>Buffer</code>准备好写数据了，但是<strong>不会覆盖未读</strong>的数据。</p><h3 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h3><p>通过调用<code>mark()</code>方法，可以标记<code>Buffer</code>中的一个特定<code>position</code>。之后可以通过调用<code>reset()</code>方法恢复到这个<code>position</code>。例如：</p><h4 id="mark-方法"><a href="#mark-方法" class="headerlink" title="mark()方法"></a>mark()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br></pre></td></tr></table></figure><p>查看<code>mark()</code>方法的源码，<code>mark</code>变量被设置为<code>position</code>的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reset-方法"><a href="#reset-方法" class="headerlink" title="reset()方法"></a>reset()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.reset();</span><br></pre></td></tr></table></figure><p>查看<code>mark()</code>方法的源码，<code>position</code>变量被设置为之前的<code>mark</code>的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h3><p>可以使用<code>equals()</code>和<code>compareTo()</code>方法比较两个<code>Buffer</code>。</p><h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h4><p>当同时满足下列条件时，表示两个<code>Buffer</code>相等：</p><ol><li>有相同的<strong>类型</strong>(<code>byte</code>、<code>char</code>、<code>int</code>和<code>long</code>类型等)。</li><li><code>Buffer</code>中剩余的<code>byte</code>、<code>char</code>等元素的<strong>个数</strong>相等。</li><li><code>Buffer</code>中所有剩余的<code>byte</code>、<code>char</code>等都相同。</li></ol><p><code>equals()</code>方法比较的实际是<code>Buffer</code>中的<strong>剩余元素</strong>是否相等。它只是比较<code>Buffer</code>的一部分，不是每一个在它里面的元素都比较。</p><h4 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h4><p><code>compareTo()</code>方法比较两个<code>Buffer</code>的剩余元素(<code>byte</code>、<code>char</code>等)。<br>当满足下列条件时，则认为一个<code>Buffer</code><strong>小于</strong>另一个<code>Buffer</code>。</p><ol><li>第一个<strong>不相等</strong>的元素<strong>小于</strong>另一个<code>Buffer</code>中对应的元素。</li><li>所有元素都相等，但第一个<code>Buffer</code>比另一个<strong>先耗尽</strong>(第一个<code>Buffer</code>的元素个数比另一个少)。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里只是对<code>Buffer</code>进行了入门的介绍，具体深入学习还需要查看各种<strong>缓冲区</strong>以及相关的具体实现。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在&lt;code&gt;Java NIO&lt;/code&gt;中，&lt;strong&gt;缓冲区&lt;/strong&gt;用来&lt;strong&gt;临时&lt;/strong&gt;存储数据，可以理解为是&lt;code&gt;I/O&lt;/code&gt;操作中数据暂存的中转站。&lt;strong&gt;缓冲区&lt;/strong&gt;直接为&lt;strong&gt;通道&lt;/strong&gt;(&lt;code&gt;Channel&lt;/code&gt;)服务，数据是从&lt;strong&gt;通道&lt;/strong&gt;读入&lt;strong&gt;缓冲区&lt;/strong&gt;，从&lt;strong&gt;缓冲区&lt;/strong&gt;写入到&lt;strong&gt;通道&lt;/strong&gt;中的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓冲区&lt;/strong&gt;本质上是一块可以&lt;strong&gt;写入数据&lt;/strong&gt;，然后可以从中&lt;strong&gt;读取数据&lt;/strong&gt;的内存。这块内存被包装成&lt;code&gt;NIO Buffer&lt;/code&gt;对象，并提供了一组方法，用来方便的访问&lt;strong&gt;这块内存&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java编程进阶系列" scheme="https://ostenant.coding.me/categories/Java%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="NIO" scheme="https://ostenant.coding.me/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>一天一个设计模式(五) - 适配器模式(Adapter)</title>
    <link href="https://ostenant.coding.me/2017/12/25/%E4%B8%80%E5%A4%A9%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%94)%20-%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F(Adapter)/"/>
    <id>https://ostenant.coding.me/2017/12/25/一天一个设计模式(五) - 适配器模式(Adapter)/</id>
    <published>2017-12-25T12:46:00.000Z</published>
    <updated>2018-05-08T02:49:46.094Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>适配器模式</strong>把一个<strong>类的接口</strong>变换成<strong>客户端</strong>所期待的<strong>另一种接口</strong>，从而使原本因<strong>接口不匹配</strong>而无法在一起工作的<strong>两个类</strong>能够在一起工作。</p><a id="more"></a><h2 id="适配器模式的用途"><a href="#适配器模式的用途" class="headerlink" title="适配器模式的用途"></a>适配器模式的用途</h2><p>最经典的就是电器的例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极之外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。</p><h2 id="适配器模式的形式"><a href="#适配器模式的形式" class="headerlink" title="适配器模式的形式"></a>适配器模式的形式</h2><p><strong>适配器模式</strong>有<strong>类的适配器模式</strong>和<strong>对象的适配器模式</strong>两种不同的形式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h2><p>类的适配器模式，简单来说，就是<strong>适配的类</strong>的<code>API</code>转换成为<strong>目标接口</strong>的<code>API</code>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Java_design_pattern_adapter_1.png" alt=""></p><p>从上图可以看出，<code>Adaptee</code>类并没有<code>sampleOperation2()</code>方法，而<strong>客户端</strong>则期待这个方法。</p><p>为了使<strong>客户端</strong>能够使用<code>Adaptee</code>类，提供一个<strong>中间环节</strong>，即类<code>Adapter</code>，把<code>Adaptee</code>类的<code>API</code>同<code>Target</code>接口的<code>API</code>衔接起来。<code>Adapter</code>与<code>Adaptee</code>是<strong>继承关系</strong>，这决定了这个适配器模式是<strong>类的适配器模式</strong>。</p><h3 id="相关角色"><a href="#相关角色" class="headerlink" title="相关角色"></a>相关角色</h3><ol><li><strong>目标(Target)角色</strong>：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</li><li><strong>源(Adaptee)角色</strong>：现在需要适配的到<strong>目标角色</strong>的类。</li><li><strong>适配器(Adapter)角色</strong>：适配器是<strong>目标角色</strong>和<strong>源角色</strong>之间的桥梁。适配器把<strong>源角色的类</strong>转换成<strong>目标接口</strong>的实现。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>Target.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是源类Adaptee中也有的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是源类Adaptee中没有的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面给出的是<strong>目标角色</strong>的接口代码，这个角色是以一个接口的形式实现的。可以看出，这个<strong>接口</strong>声明了两个方法：<code>sampleOperation1()</code>和<code>sampleOperation2()</code>，而<strong>源角色</strong><code>Adaptee</code>是一个<strong>具体类</strong>，它有一个<code>sampleOperation1()</code>方法，但是没有<code>sampleOperation2()</code>方法。</p><p>Adaptee.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Operation 1st"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器角色<code>Adapter</code>拓展了<code>Adaptee</code>，同时又实现了<strong>目标角色</strong><code>Target</code>接口。由于<code>Adaptee</code>没有提供<code>sampleOperation2()</code>方法，而<strong>目标接口</strong>有要求这个方法，因此<strong>适配器角色</strong><code>Adapter</code>实现了这个方法。</p><p>Adapter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Operation 2nd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h2><p>与<strong>类的适配器模式</strong>一样，<strong>对象的适配器模式</strong>把被<strong>适配类</strong>的<code>API</code>转换成为<strong>目标类</strong>的<code>API</code>。</p><p>与<strong>类的适配器模式</strong>不同的是，<strong>对象的适配器模式</strong>不是使用<strong>继承关系</strong>链接到<code>Adaptee</code>类，而是使用<strong>委派关系</strong>连接到<code>Adaptee</code>类。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Java_design_pattern_adapter_2.png" alt=""></p><p>从上图可以看出，<code>Adaptee</code>类并没有<code>sampleOperation2()</code>方法，而<strong>客户端</strong>则期待这个方法。</p><p>为使客户端能够使用<code>Adaptee</code>类，需要提供一个包装<code>Wrapper</code>类<code>Adapter</code>。这个包装类包括了一个<code>Adaptee</code>的实例，从而此<strong>包装类</strong>能够把<code>Adaptee</code>的<code>API</code>与<code>Target</code>类的<code>API</code>衔接起来。<code>Adapter</code>类与<code>Adaptee</code>类是<strong>委派关系</strong>，这决定了<strong>适配器模式</strong>是<strong>对象</strong>的。</p><h3 id="相关角色-1"><a href="#相关角色-1" class="headerlink" title="相关角色"></a>相关角色</h3><ol><li><strong>目标(Target)角色</strong>：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</li><li><strong>源(Adaptee)角色</strong>：现在需要适配的到<strong>目标角色</strong>的类。</li><li><strong>适配器(Adapter)角色</strong>：适配器是<strong>目标角色</strong>和<strong>源角色</strong>之间的桥梁。适配器把<strong>源角色的类</strong>包装到<strong>目标接口</strong>的实现中。</li></ol><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>Target.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是源类Adaptee中也有的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是源类Adaptee中没有的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面给出的是<strong>目标角色</strong>的接口代码，这个角色是以一个接口的形式实现的。可以看出，这个<strong>接口</strong>声明了两个方法：<code>sampleOperation1()</code>和<code>sampleOperation2()</code>，而<strong>源角色</strong><code>Adaptee</code>是一个<strong>具体类</strong>，它有一个<code>sampleOperation1()</code>方法，但是没有<code>sampleOperation2()</code>方法。</p><p>Adaptee.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Operation 1st"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>对象的适配器模式</strong>中，<strong>适配器角色</strong>中持有一个对<strong>源角色</strong>的引用，并在需要适配的方法中使用<strong>源角色</strong>的方法实现。</p><p>Adapter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span> <span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 源类Adaptee有方法sampleOperation1</span></span><br><span class="line"><span class="comment">     * 因此适配器可以直接进行委派</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee.sampleOperation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 源类Adaptee没有方法sampleOperation2</span></span><br><span class="line"><span class="comment">     * 因此适配器需要自己实现此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Operation 2nd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种适配器模式的对比"><a href="#两种适配器模式的对比" class="headerlink" title="两种适配器模式的对比"></a>两种适配器模式的对比</h2><h3 id="类的适配器模式-1"><a href="#类的适配器模式-1" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><ol><li>使用<strong>对象继承</strong>的方式，是<strong>静态</strong>的定义方式。</li><li>由于<strong>适配器</strong>直接继承了<code>Adaptee</code>，使得<strong>适配器</strong>不能和<code>Adaptee</code>的子类一起工作。因为继承是<strong>静态</strong>的关系，而<strong>适配器</strong>继承了<code>Adaptee</code>后，就不可能再去处理<code>Adaptee</code>的<strong>子类</strong>了。</li><li>适配器可以重定义<code>Adaptee</code>的部分行为，相当于子类<strong>覆盖</strong>父类的部分实现方法。</li><li>不需要额外的引用过来间接得到<code>Adaptee</code>。</li></ol><h3 id="对象的适配器模式-1"><a href="#对象的适配器模式-1" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h3><ol><li>使用<strong>对象组合</strong>的方式，是<strong>动态</strong>的组合方式。</li><li>一个适配器可以把<strong>多种</strong>不同的<strong>适配源</strong>适配到同<strong>一个目标类</strong>上。换言之，同一个适配器可以把<strong>源类</strong>和<strong>它的子类</strong>都适配到<strong>目标接口</strong>。因为对象适配器采用的是<strong>对象组合</strong>的关系，只要对象<strong>类型</strong>正确，是不是子类都无所谓。</li><li>要重定义<code>Adaptee</code>的行为比较困难，这种情况下，需要定义<code>Adaptee</code>的子类来实现重定义，然后让<strong>适配器</strong>组合子类。这样，虽然增加了一定的复杂性，也提供了一定的灵活性。</li><li>需要额外的引用来间接得到<code>Adaptee</code>。</li></ol><p>建议尽量使用<strong>对象适配器</strong>的实现方式，多用<strong>合成/聚合</strong>，少用<strong>继承</strong>。当然，具体问题还是需要具体分析，根据需要来选用实现方式，最适合的才是最好的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="适配器模式的优点"><a href="#适配器模式的优点" class="headerlink" title="适配器模式的优点"></a>适配器模式的优点</h2><ul><li><strong>更好的复用性</strong></li></ul><p>系统需要使用现有的类，因此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</p><ul><li><strong>更好的拓展性</strong></li></ul><p>在实现适配器功能的时候，可以调用自己开发的功能，从而自然的拓展系统的功能。</p><h2 id="适配器模式的缺点"><a href="#适配器模式的缺点" class="headerlink" title="适配器模式的缺点"></a>适配器模式的缺点</h2><p><strong>过多</strong>的使用适配器，会让系统非常<strong>零乱</strong>，不易整体进行把握。比如，明明看到调用的是<code>A</code>接口，其实内部都被适配成了<code>B</code>接口的实现。一个系统如果太多的出现这种情况，无异于异常灾难。</p><p>因此如果不是很有必要，可以不是用适配器，而是直接对系统进行重构。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;把一个&lt;strong&gt;类的接口&lt;/strong&gt;变换成&lt;strong&gt;客户端&lt;/strong&gt;所期待的&lt;strong&gt;另一种接口&lt;/strong&gt;，从而使原本因&lt;strong&gt;接口不匹配&lt;/strong&gt;而无法在一起工作的&lt;strong&gt;两个类&lt;/strong&gt;能够在一起工作。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA设计模式系列" scheme="https://ostenant.coding.me/categories/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Adapter" scheme="https://ostenant.coding.me/tags/Adapter/"/>
    
  </entry>
  
  <entry>
    <title>一天一个设计模式(四) - 原型模式(Prototype)</title>
    <link href="https://ostenant.coding.me/2017/12/21/%E4%B8%80%E5%A4%A9%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%9B%9B)%20-%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F(Prototype)/"/>
    <id>https://ostenant.coding.me/2017/12/21/一天一个设计模式(四) - 原型模式(Prototype)/</id>
    <published>2017-12-21T08:22:00.000Z</published>
    <updated>2018-05-08T02:49:46.094Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>原型模式</strong>属于对象的<strong>创建模式</strong>。通过给出一个<strong>原型对象</strong>来指明所有创建的对象的<strong>类型</strong>，然后用这个<strong>原型对象</strong>提供的<strong>复制办法</strong>创建出更多<strong>同类型</strong>的对象。</p><a id="more"></a><h2 id="原型模式的结构"><a href="#原型模式的结构" class="headerlink" title="原型模式的结构"></a>原型模式的结构</h2><p><strong>原型模式</strong>要求对象实现一个可以<strong>克隆自身</strong>的接口(类型)。这样一来，通过<strong>原型实例</strong>创建新的对象，就不需要关心这个<strong>实例本身</strong>的类型，只需要实现<strong>克隆自身</strong>的方法，也而无需再去通过<code>new</code>来创建。</p><h2 id="原型类型的表现形式"><a href="#原型类型的表现形式" class="headerlink" title="原型类型的表现形式"></a>原型类型的表现形式</h2><ol><li>简单形式</li><li>登记形式</li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简单形式"><a href="#简单形式" class="headerlink" title="简单形式"></a>简单形式</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/Java_Design_Pattern_Protype_Simple.png" alt=""></p><h3 id="相关角色"><a href="#相关角色" class="headerlink" title="相关角色"></a>相关角色</h3><ol><li><strong>客户(Client)角色</strong>：<strong>客户类</strong>提出创建对象的请求；</li><li><strong>抽象原型(Prototype)角色</strong>：这是一个抽象角色，通常由一个<code>Java</code><strong>接口</strong>或者<code>Java</code><strong>抽象类</strong>实现。此角色定义了的具体原型类所需的实现的方法。</li><li><strong>具体原型(Concrete Prototype)角色</strong>：此角色需要实现<strong>抽象原型角色</strong>要求的<strong>克隆相关</strong>的<strong>接口</strong>。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>Prototype.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象原型角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prototype</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 克隆自身的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个从自身克隆出来的对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcretePrototype1.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype1</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype1(<span class="keyword">this</span>.getId());</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcretePrototype2.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype2</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype2</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype2(<span class="keyword">this</span>.getId());</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/prototype_result_1.png" alt=""></p><h2 id="登记形式"><a href="#登记形式" class="headerlink" title="登记形式"></a>登记形式</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/Java_Design_Pattern_Protype_Register.png" alt=""></p><h3 id="相关角色-1"><a href="#相关角色-1" class="headerlink" title="相关角色"></a>相关角色</h3><ol><li><strong>客户(Client)角色</strong>：<strong>客户类</strong>提出创建对象的请求；</li><li><strong>抽象原型(Prototype)角色</strong>：这是一个抽象角色，通常由一个<code>Java</code><strong>接口</strong>或者<code>Java</code><strong>抽象类</strong>实现。此角色定义了的具体原型类所需的实现的方法。</li><li><strong>具体原型(Concrete Prototype)角色</strong>：此角色需要实现<strong>抽象原型角色</strong>要求的<strong>克隆相关</strong>的<strong>接口</strong>。</li><li><strong>原型管理器(Prototype Manager)角色</strong>：提供各种<strong>原型对象</strong>的<strong>创建</strong>和<strong>管理</strong>。</li></ol><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>除了<strong>原型管理器</strong><code>Prototype Manager</code>以外，<strong>登记模式</strong>和<strong>简单模式</strong>并无其他差异。</p><p>Prototype.java<br>W<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ConcretePrototype1.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype1();</span><br><span class="line">        prototype.setName(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ConcretePrototype1 [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ConcretePrototype2.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype2</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype2();</span><br><span class="line">        prototype.setName(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ConcretePrototype2 [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PrototypeManager.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来记录原型的编号同原型实例的对象关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Prototype&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法，避免从外部创建实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PrototypeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向原型管理器里面添加或者修改原型实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototypeId 原型编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototype   原型实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setProtoType</span><span class="params">(String prototypeId, Prototype prototype)</span> </span>&#123;</span><br><span class="line">        map.put(prototypeId, prototype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据原型编号从原型管理器里面移除原型实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototypeId 原型编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removePrototype</span><span class="params">(String prototypeId)</span> </span>&#123;</span><br><span class="line">        map.remove(prototypeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据原型编号获取原型实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototypeId 原型编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原型实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 如果根据原型编号无法获取对应实例，则提示异常“您希望获取的原型还没有注册或已被销毁”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Prototype <span class="title">getPrototype</span><span class="params">(String prototypeId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Prototype prototype = map.get(prototypeId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prototype == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"您希望获取的原型还没有注册或已被销毁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Client.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建第一个实例</span></span><br><span class="line">            Prototype p1 = <span class="keyword">new</span> ConcretePrototype1();</span><br><span class="line">            <span class="comment">// 注册第一个实例</span></span><br><span class="line">            PrototypeManager.setProtoType(<span class="string">"p1"</span>, p1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 克隆第一个实例的原型</span></span><br><span class="line">            Prototype p3 = PrototypeManager.getPrototype(<span class="string">"p1"</span>).clone();</span><br><span class="line">            p3.setName(<span class="string">"张三"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第一个实例的副本："</span> + p3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建第二个实例</span></span><br><span class="line">            Prototype p2 = <span class="keyword">new</span> ConcretePrototype2();</span><br><span class="line">            <span class="comment">// 注册第二个实例</span></span><br><span class="line">            PrototypeManager.setProtoType(<span class="string">"p2"</span>, p2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 克隆第二个实例的原型</span></span><br><span class="line">            Prototype p4 = PrototypeManager.getPrototype(<span class="string">"p2"</span>).clone();</span><br><span class="line">            p4.setName(<span class="string">"李四"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第二个实例的副本："</span> + p4);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注销第一个实例</span></span><br><span class="line">            PrototypeManager.removePrototype(<span class="string">"p1"</span>);</span><br><span class="line">            <span class="comment">// 再次克隆第一个实例的原型</span></span><br><span class="line">            Prototype p5 = PrototypeManager.getPrototype(<span class="string">"p1"</span>).clone();</span><br><span class="line">            p5.setName(<span class="string">"王五"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第一个实例的副本："</span> + p5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/prototype_result_12.png" alt=""></p><h2 id="两者之间的比较"><a href="#两者之间的比较" class="headerlink" title="两者之间的比较"></a>两者之间的比较</h2><p>简单形式和登记形式的原型模式各有其长处和短处。</p><ol><li>如果要创建的<strong>原型对象</strong>数据<strong>较少</strong>而且比较<strong>固定</strong>的话，可以采用<strong>第一种</strong>形式。在这种情况下，原型对象的引用可以由<strong>客户端</strong>自己保存。</li><li>如果要创建的<strong>原型对象</strong>数据<strong>不固定</strong>的话，可以采用<strong>第二种</strong>形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给<strong>原型管理器</strong>角色。在克隆一个对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以从<strong>原型管理器</strong>角色中取得这个对象引用；如果没有，客户端就需要<strong>自行复制</strong>此原型对象。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h2><p>原型模式允许在运行时<strong>动态</strong>改变具体的<strong>实现类型</strong>。原型模式可以在<strong>运行期间</strong>，有客户来注册符合原型接口的实现类型，也可以动态的改变具体的实现类型，看起来接口没有任何变化，但是其实运行的已经是另外一个类实体了。<strong>因为克隆一个原型对象就类似于实例化一个类</strong>。</p><h2 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h2><p>原型模式最主要的缺点是每一个类都必须要配备一个<strong>克隆方法</strong>。配备克隆方法需要对类的功能进行<strong>通盘考虑</strong>，这对于全新的类来说并不是很难，但是对于已有的类来说并不容易。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;原型模式&lt;/strong&gt;属于对象的&lt;strong&gt;创建模式&lt;/strong&gt;。通过给出一个&lt;strong&gt;原型对象&lt;/strong&gt;来指明所有创建的对象的&lt;strong&gt;类型&lt;/strong&gt;，然后用这个&lt;strong&gt;原型对象&lt;/strong&gt;提供的&lt;strong&gt;复制办法&lt;/strong&gt;创建出更多&lt;strong&gt;同类型&lt;/strong&gt;的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA设计模式系列" scheme="https://ostenant.coding.me/categories/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Prototype" scheme="https://ostenant.coding.me/tags/Prototype/"/>
    
  </entry>
  
  <entry>
    <title>一天一个设计模式(三) - 建造者模式(Builder)</title>
    <link href="https://ostenant.coding.me/2017/12/19/%E4%B8%80%E5%A4%A9%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%89)%20-%20Builder%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ostenant.coding.me/2017/12/19/一天一个设计模式(三) - Builder建造者模式/</id>
    <published>2017-12-19T09:20:00.000Z</published>
    <updated>2018-05-08T02:49:46.093Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>建造模式</strong>是对象的<strong>创建模式</strong>。<strong>建造模式</strong>可以将一个<strong>产品的内部表象</strong>(<code>internal representation</code>)与<strong>产品的生产过程</strong>分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。<br><a id="more"></a></p><h2 id="一-产品的内部表象"><a href="#一-产品的内部表象" class="headerlink" title="(一). 产品的内部表象"></a>(一). 产品的内部表象</h2><p>一个<strong>产品</strong>常有不同的<strong>组成成分</strong>作为产品的<strong>零件</strong>，这些零件有可能是对象，也有可能不是对象，他们通常又称为产品的内部表象(<code>internal representation</code>)。</p><h2 id="二-对象性质的建造"><a href="#二-对象性质的建造" class="headerlink" title="(二). 对象性质的建造"></a>(二). 对象性质的建造</h2><p>有些情况下，一个对象会有些重要的<strong>性质</strong>，在它们没有<strong>正确赋值</strong>之前，对象不能作为一个完整的产品使用。比如：一个电子邮件有发件人地址、收件人地址、主题、内容、附件等部分，而在最基本的发件人地址得到赋值之前，这个电子邮件是不可以发送的。</p><p>有些情况下，一个对象的有些<strong>性质</strong>必须按照<strong>某个顺序赋值</strong>才有意义。在某个性质没有赋值之前，另一个性质则无法赋值。</p><p>这些情况使得性质本身的建造设计到复杂的业务逻辑。设置后，此<strong>对象</strong>相当于一个<strong>有待建造的产品</strong>，而对象的这些<strong>性质</strong>相当于产品的<strong>零件</strong>，建造产品的过程是建造零件的过程。</p><p>由于建造零件的过程很复杂，因此，这些零件的建造过程往往被<strong>外部化</strong>到另一个成为<strong>建造者的对象</strong>中，<strong>建造者对象</strong>返还给客户端的是一个全部零件都<strong>建造完毕</strong>的产品对象。</p><blockquote><p>建造模式利用一个<strong>导演者对象</strong>和<strong>具体建造者对象</strong>一个个的建造出所有的零件，从而建造出完整的产品对象。建造者模式将<strong>产品的结构</strong>和<strong>产品的零件</strong>的建造过程对客户端<strong>隐藏</strong>起来，把对<strong>建造过程进行指挥的责任</strong>和<strong>具体建造者零件的责任</strong>分割开来，达到责任划分和封装的目的。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="建造模式的结构"><a href="#建造模式的结构" class="headerlink" title="建造模式的结构"></a>建造模式的结构</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/java_design_pattern_builder_structure.png" alt=""></p><p>在这个示意的系统里，最终产品<code>Product</code>只有两个零件，即<code>part1</code>和<code>part2</code>。相应的构造方法也有两个，即<code>buildPart1()</code>和<code>buildPart2()</code>。</p><p>同时可以看出本模式涉及到<strong>四个角色</strong>，它们分别为：</p><h3 id="抽象建造者-Builder-："><a href="#抽象建造者-Builder-：" class="headerlink" title="抽象建造者(Builder)："></a>抽象建造者(Builder)：</h3><p>给出一个<strong>抽象接口</strong>，以<strong>规范</strong>产品对象的各个组成成分的建造。模式中<strong>真正</strong>创建产品对象的是<strong>具体建造者</strong><code>ConcreteBuilder</code>角色。</p><p>具体建造者类必须<strong>实现</strong>这个接口要求的<strong>两种方法</strong>：</p><ol><li>一种是产品具体零件<strong>建造方法</strong>：<code>buildPart1()</code>和<code>buildPart2()</code>；</li><li>另一种是返回<strong>构造完成</strong>的产品的方法<code>retrieveResult()</code>。</li></ol><p>一般来说，产品所包含的<strong>零件数目</strong>与<strong>建造方法</strong>的数目相符。换言之，有多少零件需要建造，就会有多少相应的建造方法。</p><h3 id="具体建造者-ContreteBuilder-："><a href="#具体建造者-ContreteBuilder-：" class="headerlink" title="具体建造者(ContreteBuilder)："></a>具体建造者(ContreteBuilder)：</h3><p>担任这个角色的是抽象建造者在<strong>具体</strong>业务场景的下的<strong>建造实现</strong>。这个角色要完成的任务包括：</p><ol><li>实现<strong>抽象建造者</strong><code>Builder</code>所声明的接口，给出一步步完成创建产品实例的操作。</li><li>在建造过程完成后，提供产品的<strong>实例</strong>。</li></ol><h3 id="导演者-Director-："><a href="#导演者-Director-：" class="headerlink" title="导演者(Director)："></a>导演者(Director)：</h3><p>担任这个角色的类调用<strong>具体建造者角色</strong>以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。</p><h3 id="产品-Product-："><a href="#产品-Product-：" class="headerlink" title="产品(Product)："></a>产品(Product)：</h3><p>产品便是建造中的<strong>复杂对象</strong>，一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。</p><h3 id="建造模式的示例代码"><a href="#建造模式的示例代码" class="headerlink" title="建造模式的示例代码"></a>建造模式的示例代码</h3><p>Product.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品零件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String part1;</span><br><span class="line">    <span class="keyword">private</span> String part2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> part1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart1</span><span class="params">(String part1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.part1 = part1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> part2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart2</span><span class="params">(String part2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.part2 = part2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product [part1="</span> + part1 + <span class="string">", part2="</span> + part2 + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Builder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象建造者角色</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提供零件建造方法及返回结果方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Product <span class="title">retrieveResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体建造者角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建造零件1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPart1(<span class="string">"零件分类1，编号：10000"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建造零件2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPart2(<span class="string">"零件分类2，编号：20000"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回建造后成功的产品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">retrieveResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Director.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导演者角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建建造者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，给定建造者对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder 建造者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品构造方法，在该方法内，调用产品零件建造方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildPart1();</span><br><span class="line">        builder.buildPart2();</span><br><span class="line">        <span class="comment">// 返回builder建造完成的产品对象</span></span><br><span class="line">        <span class="keyword">return</span> builder.construct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建具体建造者对象</span></span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        <span class="comment">//创造导演者角色，给定建造者对象</span></span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        <span class="comment">//调用导演者角色，创建产品零件。并返回产品建造结果。</span></span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码完成的具体步骤：</p><ol><li>客户端创建具体建造者对象；</li><li>将具体建造者对象<strong>交给</strong>导演者；</li><li>导演者<strong>操作</strong>建造者对象建造产品零件；</li><li>当产品创建完成后，<strong>导演者</strong>将产品返回给客户端。</li></ol><h3 id="建造者模式构建复杂对象"><a href="#建造者模式构建复杂对象" class="headerlink" title="建造者模式构建复杂对象"></a>建造者模式构建复杂对象</h3><p>考虑这样一个实际业务应用，要创建一个<strong>保险合同</strong>的对象，里面很多<strong>属性的值</strong>都有<strong>约束</strong>，要求创建出来的对象是满足这些约束规则的。</p><p><strong>约束规则如下：</strong></p><blockquote><p>保险合同通常情况下可以和个人签订，也可以和某个公司签订个，但是一份保险合同不能同时和个人和公司签订。这个对象里有很多类似于这样的约束，采用建造者模式来构建复杂的对象，通常会对建造者模式进行一定的简化，因为目标明确，就是创建某个复杂对象，因此做适当的简化会使得程序更简介。</p></blockquote><p><strong>具体实现思路如下：</strong></p><ul><li>由于是用<code>Builder</code><strong>建造者模式</strong>来创建某个对象，因此就没有必要再定义一个<code>Builder</code><strong>接口</strong>，直接提供一个<strong>具体的建造类</strong>就可以了。</li><li>对于创建一个<strong>复杂的对象</strong>，可能会有很多种不同的<strong>选择和步骤</strong>，干脆去掉<strong>导演者</strong><code>Director</code>，把<strong>导演者</strong>的功能和<code>Client</code>客户端的功能合并起来，也就是说<code>Client</code><strong>客户端</strong>的功能就相当于<strong>导演者</strong>，它来<strong>指导建造者</strong>去构建需要的<strong>复杂对象</strong>。</li></ul><p>于是，<strong>建造者</strong>(<code>Builder</code>)可以抽象到<strong>目标产品</strong>(<code>Product</code>)的内部，这样最大的好处对外<strong>屏蔽</strong>掉具体的建造实现，是示例代码如下：</p><p>InstranceContract.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保险合同编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstranceContract</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保险合同编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String contractId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受保人名称，此处因为有限制条件：要么同个人签订，要么同公司签订</span></span><br><span class="line"><span class="comment">     * 也就是说，受保人名称属性同受保公司名称属性不能同时有值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受保公司名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> beginDate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束时间，需要大于开始时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> endDate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其他数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String otherData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InstranceContract</span><span class="params">(ConcreteBuilder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contractId = builder.contractId;</span><br><span class="line">        <span class="keyword">this</span>.personName = builder.personName;</span><br><span class="line">        <span class="keyword">this</span>.companyName = builder.companyName;</span><br><span class="line">        <span class="keyword">this</span>.beginDate = builder.beginDate;</span><br><span class="line">        <span class="keyword">this</span>.endDate = builder.endDate;</span><br><span class="line">        <span class="keyword">this</span>.otherData = builder.otherData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保险合同的一些操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前正在操作的保险合同编号为【"</span>+<span class="keyword">this</span>.contractId+<span class="string">"】"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"InstranceContract [contractId="</span> + contractId +</span><br><span class="line">              <span class="string">", personName="</span> + personName +</span><br><span class="line">              <span class="string">", companyName="</span>+ companyName +</span><br><span class="line">              <span class="string">", beginDate="</span> + beginDate +</span><br><span class="line">              <span class="string">", endDate="</span> + endDate +</span><br><span class="line">              <span class="string">", otherData="</span> + otherData +</span><br><span class="line">            <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String contractId;</span><br><span class="line">        <span class="keyword">private</span> String personName;</span><br><span class="line">        <span class="keyword">private</span> String companyName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> beginDate;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> endDate;</span><br><span class="line">        <span class="keyword">private</span> String otherData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> contractId 保险合同编号</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> beginDate 生效时间</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> endDate 失效时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConcreteBuilder</span><span class="params">(String contractId, <span class="keyword">long</span> beginDate, <span class="keyword">long</span> endDate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.contractId = contractId;</span><br><span class="line">            <span class="keyword">this</span>.beginDate = beginDate;</span><br><span class="line">            <span class="keyword">this</span>.endDate = endDate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConcreteBuilder <span class="title">setPersonName</span><span class="params">(String personName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.personName = personName;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConcreteBuilder <span class="title">setCompanyName</span><span class="params">(String companyName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.companyName = companyName;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConcreteBuilder <span class="title">setOtherData</span><span class="params">(String otherData)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.otherData = otherData;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> InstranceContract <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (contractId == <span class="keyword">null</span> || contractId.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"合同编号不能为空"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> signPerson = (personName != <span class="keyword">null</span> &amp;&amp; personName.trim().length() &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span> signCompany = (companyName != <span class="keyword">null</span> &amp;&amp; companyName.trim().length() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (signPerson &amp;&amp; signCompany) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同不能同时与个人和公司签订"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!signPerson &amp;&amp; !signCompany) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同不能没有签订对象"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (beginDate &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同必须有生效的日期"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endDate &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同必须有失效的日期"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endDate &lt;= beginDate) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同的失效日期必须要大于生效的日期"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InstranceContract(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong>(<code>Client</code>)、<strong>导演者</strong>(<code>Director</code>)合并到一个类上面，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InstranceContract.ConcreteBuilder builder =</span><br><span class="line">                <span class="keyword">new</span> InstranceContract.ConcreteBuilder(<span class="string">"8888"</span>, <span class="number">1233L</span>, <span class="number">2253L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 导演者进行组装</span></span><br><span class="line">        InstranceContract contract =</span><br><span class="line">                builder.setPersonName(<span class="string">"赵四"</span>).setOtherData(<span class="string">"测试数据"</span>).build();</span><br><span class="line"></span><br><span class="line">        contract.someOperation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>建造者模式</strong>主要适用于如下的业务场景：</p><ol><li>内部结构复杂：</li></ol><p>需要生成的产品对象有<strong>复杂的内部结构</strong>，每一个<strong>内部组件</strong>本身也可以是<strong>复杂对象</strong>，也可以仅仅是一个简单的组成部分。</p><ol start="2"><li>属性顺序和依赖：</li></ol><p>需要生成的产品对象的<strong>属性相互依赖</strong>。建造模式可以<strong>强</strong>制实行一种<strong>分步骤顺序进行</strong>的建造过程。因此，如果产品对象的一个属性必须在另外一个属性赋值之后才可以被赋值，那么，使用建造者模式是一个很好的设计思想。</p><ol start="3"><li>属性获取过程复杂：</li></ol><p>在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中<strong>不易得到</strong>。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;建造模式&lt;/strong&gt;是对象的&lt;strong&gt;创建模式&lt;/strong&gt;。&lt;strong&gt;建造模式&lt;/strong&gt;可以将一个&lt;strong&gt;产品的内部表象&lt;/strong&gt;(&lt;code&gt;internal representation&lt;/code&gt;)与&lt;strong&gt;产品的生产过程&lt;/strong&gt;分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA设计模式系列" scheme="https://ostenant.coding.me/categories/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Builder" scheme="https://ostenant.coding.me/tags/Builder/"/>
    
  </entry>
  
</feed>
