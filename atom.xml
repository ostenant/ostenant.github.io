<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Icarus&#39;s Blog</title>
  
  <subtitle>上善若水任方猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ostenant.coding.me/"/>
  <updated>2018-07-05T14:27:53.562Z</updated>
  <id>https://ostenant.coding.me/</id>
  
  <author>
    <name>Chen Icarus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈SAML, OAuth, OpenID和SSO, JWT和Session</title>
    <link href="https://ostenant.coding.me/2018/07/05/%E6%B5%85%E8%B0%88SAML,%20OAuth,%20OpenID%E5%92%8CSSO,%20JWT%E5%92%8CSession/"/>
    <id>https://ostenant.coding.me/2018/07/05/浅谈SAML, OAuth, OpenID和SSO, JWT和Session/</id>
    <published>2018-07-05T05:50:00.000Z</published>
    <updated>2018-07-05T14:27:53.562Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常为了弄清楚一个概念，我们需要掌握十个概念。在判断 <code>JWT(JsonWebToken)</code> 是否能代替 <code>session</code> 管理之前，我们要了解什么是 <code>token</code>，以及 <code>access token</code> 和 <code>refresh token</code> 的区别。</p><a id="more"></a><p>了解什么是 <code>OAuth</code>，什么是 <code>SSO</code>，<code>SSO</code> 下不同策略 <code>OAuth</code> 和 <code>SAML</code> 的不同，以及 <code>OAuth</code> 与 <code>OpenID</code> 的不同，更重要的是区分 <code>authorisation</code> 和 <code>authentication</code>。</p><p>最后我们引出 <code>JSON WEB TOKEN</code>，聊聊 <code>JWT</code> 在 <code>Session</code> 管理方面的优势和劣势，同时尝试解决这些劣势，看看成本和代价有多少。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/OAuth_logo.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文关于 <code>OAuth</code> <strong>授权</strong> 和 <code>API</code> 调用实例都来自 <code>Google API</code>。</p><h2 id="关于Token"><a href="#关于Token" class="headerlink" title="关于Token"></a>关于Token</h2><p><code>Token</code> 即使是在计算机领域中也有不同的定义，这里我们说的 <code>token</code>，是指 <strong>访问资源</strong> 的凭据。例如当你调用 <code>Google API</code> 时，需要带上有效 <code>token</code> 来表明你请求的 <strong>合法性</strong>。这个 <code>Token</code> 是 <code>Google</code> 给你的，这代表 <code>Google</code> 给你的 <strong>授权</strong> 使得你有能力访问 <code>API</code> 背后的 <strong>资源</strong>。</p><p>请求 <code>API</code> 时携带 <code>token</code> 的方式也有很多种，通过 <code>HTTP Header</code> 或者 <code>url</code> 参数或者 <code>google</code> 提供的类库都可以：</p><ul><li><strong>HTTP Header</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /drive/v2/files HTTP/1.1</span><br><span class="line"></span><br><span class="line">Authorization: Bearer &lt;token&gt;</span><br><span class="line">Host: www.googleapis.com/</span><br></pre></td></tr></table></figure><ul><li><strong>URL参数</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://www.googleapis.com/drive/v2/files?token=&lt;token&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>Python函数库</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> googleapiclient.discovery <span class="keyword">import</span> build</span><br><span class="line">drive = build(<span class="string">'drive'</span>, <span class="string">'v2'</span>, credentials=credentials)</span><br></pre></td></tr></table></figure><p>更具体的说，上面用于调用 <code>API</code> 的 <code>token</code>，我们称为细分为 <code>access token</code>。通常 <code>access token</code> 是有 <strong>有效期限</strong> 的，如果 <strong>过期</strong> 就需要 <strong>重新获取</strong>。那么如何重新获取？先看看第一次获取 <code>token</code> 的流程是怎样的:</p><ol><li><p>首先需要向 <code>Google API</code> 注册一个应用程序，注册完毕之后就会拿到 <strong>认证信息</strong>（<code>credentials</code>）包括 <code>ID</code> 和 <code>secret</code>。不是所有的程序类型都有 <code>secret</code>。</p></li><li><p>接下来就要向 <code>Google</code> 请求 <code>access token</code>。这里先忽略一些细节，例如请求参数（当然需要上面申请到的 <code>secret</code>）。重要的是，如果你想访问的是 <strong>用户资源</strong>，这里就会提醒用户进行 <strong>授权</strong>。</p></li><li><p>如果 <strong>用户授权</strong> 完毕。<code>Google</code> 就会返回 <code>access token</code>。又或者是返回 <strong>授权代码</strong>（<code>authorization code</code>），再通过代码取得 <code>access token</code>。</p></li></ol><p><code>token</code> 获取到之后，就能够带上 <code>token</code> 访问 <code>API</code> 了。</p><p>流程如下图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Token_flow.webp" alt=""></p><blockquote><p>注意：在第三步通过 <code>authorization code</code> 兑换 <code>access token</code> 的过程中，<code>Google</code> 并不会仅仅返回 <code>access token</code>，还会返回额外的信息，这其中和之后更新相关的就是 <code>refresh token</code>。</p></blockquote><p>一旦 <code>access token</code> 过期，你就可以通过 <code>refresh token</code> 再次请求 <code>access token</code>。</p><p>以上只是大致的流程，并且故意省略了一些额外的概念。比如更新 <code>access token</code> 当然也可以不需要 <code>refresh token</code>，这要根据你的 <strong>请求方式</strong> 和访问的 <strong>资源类型</strong> 而定。</p><p>这里又会引起另外的两个问题：</p><ol><li><p>如果 <code>refesh token</code> 也过期了怎么办？这时就需要用户 <strong>重新登陆授权</strong>。</p></li><li><p>为什么要区分 <code>refresh token</code> 和 <code>access token</code>？如果合并成一个 <code>token</code> 然后把 <strong>过期时间</strong> 调整的 <strong>更长</strong>，并且每次 <strong>失效</strong> 之后用户 <strong>重新登陆授权</strong> 就好了？这个问题会和后面谈的相关概念有关，后面会给予解释说明。</p></li></ol><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>从获取 <code>token</code> 到使用 <code>token</code> 访问接口。这其实是标准的 <code>OAuth2.0</code> 机制下访问 <code>API</code> 的流程。这里介绍一下 <code>OAuth</code> 里外相关的概念，更深入的理解 <code>token</code> 的作用。</p><h3 id="SSO-Single-sign-on"><a href="#SSO-Single-sign-on" class="headerlink" title="SSO (Single sign-on)"></a>SSO (Single sign-on)</h3><p>通常公司内部会有非常多的平台供大家使用，比如人力资源，代码管理，日志监控，预算申请等等。如果每一个平台都实现自己的用户体系的话无疑是巨大的浪费，所以公司内部会有一套 <strong>公用的用户体系</strong>，用户只要登陆之后，就能够 <strong>访问所有的系统</strong>。这就是 <strong>单点登录</strong>。</p><p><code>SSO</code> 是一类 <strong>解决方案</strong> 的统称，而在具体的实施方面，我们有两种策略可供选择：</p><ul><li><p><strong>SAML 2.0</strong></p></li><li><p><strong>OAuth 2.0</strong></p></li></ul><p>接下来我们区别这 <strong>两种授权方式</strong> 有什么不同。但是在描述 <strong>不同的策略</strong> 之前，我们先叙述几个 <strong>共有的特性</strong>，并且相当重要的概念。</p><h4 id="Authentication-VS-Authorisation"><a href="#Authentication-VS-Authorisation" class="headerlink" title="Authentication VS Authorisation"></a>Authentication VS Authorisation</h4><ul><li><p><strong>Authentication:</strong> 身份鉴别，以下简称 <strong>认证</strong>；</p></li><li><p><strong>Authorisation:</strong> 资源访问 <strong>授权</strong>。</p></li></ul><p><strong>认证</strong> 的作用在于 <strong>认可</strong> 你能够访问系统，用于 <strong>鉴别访问者</strong> 是否是 <strong>合法用户</strong>；而 <strong>授权</strong> 用于决定你有访问 <strong>哪些资源的权限</strong>。</p><p>大多数人不会区分这两者的区别，因为站在用户的立场上。而作为系统的设计者来说，这两者是有差别的，这是不同的两个工作职责。我们可以只需要 <strong>认证功能</strong>，而不需要 <strong>授权功能</strong>，甚至不需要自己实现 <strong>认证功能</strong>。而借助 <code>Google</code> 的认证系统，即用户可以用 <code>Google</code> 的账号进行登陆。</p><h4 id="Authorization-Server-Identity-Provider-IdP"><a href="#Authorization-Server-Identity-Provider-IdP" class="headerlink" title="Authorization Server/Identity Provider(IdP)"></a>Authorization Server/Identity Provider(IdP)</h4><p>把负责 <strong>认证的服务</strong> 称为 <code>AuthorizationServer</code> 或者 <code>IdentityProvider</code>，以下简称 <code>IDP</code>。</p><h4 id="Service-Provider-SP-Resource-Server"><a href="#Service-Provider-SP-Resource-Server" class="headerlink" title="Service Provider(SP)/Resource Server"></a>Service Provider(SP)/Resource Server</h4><p>把负责 <strong>提供资源</strong>（<code>API</code> 调用）的服务称为 <code>ResourceServer</code> 或者 <code>ServiceProvider</code>，以下简称 <code>SP</code>。</p><h3 id="SAML-2-0"><a href="#SAML-2-0" class="headerlink" title="SAML 2.0"></a>SAML 2.0</h3><p>下图是 <code>SAML2.0</code> 的流程图，看图说话：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/SAML_2" alt=""></p><ol><li><p>还 <strong>未登陆</strong> 的用户 <strong>打开浏览器</strong> 访问你的网站（<code>SP</code>），网站 <strong>提供服务</strong> 但是并 <strong>不负责用户认证</strong>。</p></li><li><p>于是 <code>SP</code> 向 <code>IDP</code> 发送了一个 <code>SAML</code> 认证请求，同时 <code>SP</code> 将 <strong>用户浏览器</strong> 重定向到 <code>IDP</code>。</p></li><li><p><code>IDP</code> 在验证完来自 <code>SP</code> 的 <strong>请求无误</strong> 之后，在浏览器中呈现 <strong>登陆表单</strong> 让用户填写 <strong>用户名</strong> 和 <strong>密码</strong> 进行登陆。</p></li><li><p>一旦用户登陆成功， <code>IDP</code> 会生成一个包含 <strong>用户信息</strong>（<strong>用户名</strong> 或者 <strong>密码</strong>）的 <code>SAML token</code>（<code>SAML token</code> 又称为 <code>SAML Assertion</code>，本质上是 <code>XML</code> 节点）。<code>IDP</code> 向 <code>SP</code> 返回 <code>token</code>，并且将 <strong>用户重定向</strong> 到 <code>SP</code> (<code>token</code> 的返回是在 <strong>重定向步骤</strong> 中实现的，下面会详细说明)。</p></li><li><p><code>SP</code> 对拿到的 <code>token</code> 进行验证，并从中解析出 <strong>用户信息</strong>，例如 <strong>用户是谁</strong> 以及 <strong>用户的权限</strong> 有哪些。此时就能够根据这些信息允许用户访问我们网站的内容。</p></li></ol><p>当用户在 <code>IDP</code> 登陆成功之后，<code>IDP</code> 需要将用户 <strong>再次重定向</strong> 到 <code>SP</code> 站点，这一步通常有两个办法：</p><ul><li><p><code>HTTP</code> 重定向：这并不推荐，因为 <strong>重定向</strong> 的 <code>URL</code> 长度 <strong>有限制</strong>，无法携带更长的信息，比如 <code>SAML Token</code>。</p></li><li><p><code>HTTP POST</code> 请求：这个是更常规的做法，当用户登陆完毕之后渲染出一个表单，用户点击后向 <code>SP</code> 提交 <code>POST</code> 请求。又或者可以使用 <code>JavaScript</code> 向 <code>SP</code> 发出一个 <code>POST</code> 请求。</p></li></ul><p>如果你的应用是基于 <code>Web</code>，那么以上的方案没有任何问题。但如果你开发的是一个 <code>iOS</code> 或者 <code>Android</code> 的手机应用，那么问题就来了：</p><ol><li><p>用户在 <code>iPhone</code> 上打开应用，此时用户需要通过 <code>IDP</code> 进行认证。</p></li><li><p>应用跳转至 <code>Safari</code> 浏览器，在登陆认证完毕之后，需要通过 <code>HTTP POST</code> 的形式将 <code>token</code> 返回至 <strong>手机应用</strong>。</p></li></ol><p>虽然 <code>POST</code> 的 <code>url</code> 可以 <strong>拉起应用</strong>，但是 <strong>手机应用</strong> 无法解析 <code>POST</code> 的内容，我们也就无法读取 <code>SAML Token</code>。</p><blockquote><p>当然还是有办法的，比如在 <code>IDP</code> <strong>授权阶段</strong> 不跳转至系统的 <code>Safari</code> 浏览器，在 <strong>内嵌</strong> 的 <code>Webview</code> 中解决，在想方设法从 <code>Webview</code> 中提取 <code>token</code>，或者利用 <strong>代理服务器</strong>。</p></blockquote><p>无论如何，<code>SAML 2.0</code> 并 <strong>不适用</strong> 于当下 <strong>跨平台</strong> 的场景，这也许与它产生的年代也有关系，它诞生于 <code>2005</code> 年，在那个时刻 <code>HTTP POST</code> 确实是最好的选择方案。</p><h3 id="OAuth-2-0-1"><a href="#OAuth-2-0-1" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>我们先简单了解 <code>SSO</code> 下的 <code>OAuth2.0</code> 的流程。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Oauth_process" alt=""></p><ol><li><p>用户通过 <strong>客户端</strong>（可以是 <strong>浏览器</strong> 也可以是 <strong>手机应用</strong>）想要访问 <code>SP</code> 上的资源，但是 <code>SP</code> 告诉用户需要进行 <strong>认证</strong>，将用户 <strong>重定向</strong> 至 <code>IDP</code>。</p></li><li><p><code>IDP</code> 向 <strong>用户</strong> 询问 <code>SP</code> 是否可以访问 <strong>用户信息</strong>。如果用户同意，<code>IDP</code> 向 <strong>客户端</strong> 返回 <code>authorization code</code>。</p></li><li><p>客户端拿到 <code>authorization code</code> 向 <code>IDP</code> 交换 <code>access token</code>，并拿着 <code>access token</code> 向 <code>SP</code> 请求资源。</p></li><li><p><code>SP</code> 接受到请求之后，拿着附带的 <code>token</code> 向 <code>IDP</code> 验证 <strong>用户的身份</strong>。确认身份无误后，<code>SP</code> 向 <strong>客户端</strong> 发放相关资源。</p></li></ol><p>那么 <code>OAuth</code> 是如何避免 <code>SAML</code> 流程下 <strong>无法解析</strong> <code>POST</code> 内容的信息的呢？</p><ul><li><p>一方面是用户从 <code>IDP</code> 返回 <strong>客户端</strong> 的方式，也是通过 <code>URL</code> 重定向，这里的 <code>URL</code> 允许 <strong>自定义</strong> <code>schema</code>，所以即使在 <strong>手机</strong> 上也能 <strong>拉起应用</strong>；</p></li><li><p>另一方面因为 <code>IDP</code> 向 <strong>客户端</strong> 传递的是 <code>authorization code</code>，而不是 <code>XML</code> 信息，所以 <code>code</code> 可以很轻易的附着在 <strong>重定向</strong> <code>URL</code> 上进行传递。</p></li></ul><p>但以上的 <code>SSO</code> 流程体现不出 <code>OAuth</code> 的本意。<code>OAuth</code> 的本意是 <strong>一个应用</strong> 允许 <strong>另一个应用</strong> 在 <strong>用户授权</strong> 的情况下 <strong>访问自己的数据</strong>。</p><p><code>OAuth</code> 的设计本意更倾向于 <strong>授权而非认证</strong>（当然授权用户信息就间接实现了认证），虽然 <code>Google</code> 的 <code>OAuth 2.0 API</code> 同时支持 <strong>授权</strong> 和 <strong>认证</strong>。所以你在使用 <code>Facebook</code> 或者 <code>Gmail</code> 账号登陆第三方站点时，会出现 <strong>授权对话框</strong>，告诉你 <strong>第三方站点</strong> 可以访问你的哪些信息，需要征得你的同意。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Google_gmail" alt=""></p><p>在上面 <code>SSO</code> 的 <code>OAuth</code> 流程中涉及三方角色: <code>SP</code>, <code>IDP</code> 以及 <code>Client</code>。但在实际工作中 <code>Client</code> 可以是不存在的，例如你编写了一个 <strong>后端程序</strong> 定时的通过 <code>Google API</code> 从 <code>Youtube</code> 拉取最新的节目数据，那么你的 <strong>后端程序</strong> 需要得到 <code>Youtube</code> 的 <code>OAuth</code> <strong>授权</strong> 即可。</p><h3 id="OAuth-VS-OpenId"><a href="#OAuth-VS-OpenId" class="headerlink" title="OAuth VS OpenId"></a>OAuth VS OpenId</h3><p>如果你有留心的话，你会在某些站点看到允许以 <code>OpenID</code> 的方式登陆，其实也就是以 <code>Facebook</code> 账号或者 <code>Google</code> 账号登陆站点：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/OpenID" alt=""></p><p><code>OpenID</code> 和 <code>OAuth</code> 很像。但本质上来说它们是截然不同的两个东西：</p><ul><li><p><strong>OpenID:</strong> 只用于 <strong>身份认证</strong>（<code>Authentication</code>），允许你以 <strong>同一个账户</strong> 在 <strong>多个网站登陆</strong>。它仅仅是为你的 <strong>合法身份</strong> 背书，当你以 <code>Facebook</code> 账号登陆某个站点之后，该站点 <strong>无权访问</strong> 你的在 <code>Facebook</code> 上的 <strong>数据</strong>。</p></li><li><p><strong>OAuth:</strong> 用于 <strong>授权</strong>（<code>Authorisation</code>），允许 <strong>被授权方</strong> 访问 <strong>授权方</strong> 的 <strong>用户数据</strong>。</p></li></ul><h4 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h4><p>现在可以回答上面的问题了，为什么我们需要 <code>refresh token</code>？</p><p>这样的处理是为了 <strong>职责的分离</strong>：</p><ul><li><p><strong>refresh token:</strong> 负责 <strong>身份认证</strong>；</p></li><li><p><strong>access token:</strong> 负责 <strong>请求资源</strong>。</p></li></ul><p>虽然 <code>refresh token</code> 和 <code>access token</code> 都由 <code>IDP</code> 发出，但是 <code>access token</code> 还要和 <code>SP</code> 进行 <strong>数据交换</strong>，如果 <strong>公用的话</strong> 这样就会有 <strong>身份泄露</strong> 的可能。并且 <code>IDP</code> 和 <code>SP</code> 可能是 <strong>完全不同</strong> 的 <strong>服务提供</strong> 的。而在上文，我们之所以没有这样的顾虑是因为 <code>IDP</code> 和 <code>SP</code> 都是 <code>Google</code>。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><h4 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h4><p>本质上来说 <code>JWT</code> 也是 <code>token</code>，正如我们在上文提到的，它是 <strong>访问资源</strong> 的 <strong>凭证</strong>。</p><p><code>Google</code> 的一些 <code>API</code> 诸如 <code>Prediction API</code> 或者 <code>Google Cloud Storage</code>，是不需要 <strong>访问</strong> 用户的 <strong>个人数据</strong> 的。因而不需要经过 <strong>用户的授权</strong> 这一步骤，应用程序可以直接访问。就像上面 <code>OAuth</code> 中没有 <code>Client</code> 没有参与的流程类似。这就要借助 <code>JWT</code> 完成访问了, 具体流程如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Auth_Resource" alt=""></p><ol><li><p>首先需要在 <code>Google API</code> 上创建一个服务账号（<code>service account</code>）。</p></li><li><p>获取 <strong>服务账号</strong> 的 <strong>认证信息</strong>（<code>credential</code>），包括 <strong>邮箱地址</strong>，<code>client ID</code>，以及一对 <strong>公钥/私钥</strong>。</p></li><li><p>使用 <code>Client ID</code> 和 <strong>私钥</strong> 创一个 <strong>签名</strong> 的 <code>JWT</code>，然后将这个 <code>JWT</code> 发送给 <code>Google</code> 交换 <code>access token</code>。</p></li><li><p><code>Google</code> 返回 <code>access token</code>。</p></li><li><p>程序通过 <code>access token</code> 访问 <code>API</code>。</p></li></ol><p>甚至你可以不需要向 <code>Google</code> 索要 <code>access token</code>，而是携带 <code>JWT</code> 作为 <code>HTTP header</code> 里的 <code>bearer token</code> 直接访问 <code>API</code> 也是可以的。这才是 <code>JWT</code> 的最大魅力。</p><h4 id="理性认识"><a href="#理性认识" class="headerlink" title="理性认识"></a>理性认识</h4><p><code>JWT</code> 顾名思义，它是 <code>JSON</code> 结构的 <code>token</code>，由三部分组成：</p><ul><li><p><strong>header</strong></p></li><li><p><strong>payload</strong></p></li><li><p><strong>signature</strong></p></li></ul><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p><code>header</code> 用于描述 <strong>元信息</strong>，例如产生 <code>signature</code> 的算法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">    <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>alg</code> 关键字就指定了使用哪一种 <strong>哈希算法</strong> 来创建 <code>signature</code>。</p><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p><code>payload</code> 用于携带你希望 <strong>向服务端传递</strong> 的信息。你既可以往里添加 <strong>官方字段</strong>，例如：<code>iss(Issuer)</code>, <code>sub(Subject)</code>, <code>exp(Expirationtime)</code>，也可以塞入 <strong>自定义的字段</strong>，比如 <code>userId</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p><code>signature</code> 译为 <strong>签名</strong>，创建签名要分以下几个步骤：</p><ol><li><p>从 <strong>接口服务端</strong> 拿到 <strong>密钥</strong>，假设为 <code>secret</code>。</p></li><li><p>对 <code>header</code> 进行 <code>base64</code> 编码，假设结果为 <code>headerStr</code>。</p></li><li><p>将 <code>payload</code> 进行 <code>base64</code> 编码，假设结果为 <code>payloadStr</code>。</p></li><li><p>将 <code>headerStr</code> 和 <code>payloadStr</code> 用 <code>.</code> <strong>字符</strong> 拼装起来成为字符 <code>data</code>。</p></li><li><p>以 <code>data</code> 和 <code>secret</code> 作为参数，使用 <strong>哈希算法</strong> 计算出 <strong>签名</strong>。</p></li></ol><p>如果上述描述还不直观，用 <strong>伪代码</strong> 表示就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Signature algorithm</span><br><span class="line">data = base64urlEncode( header ) + “.” + base64urlEncode( payload )</span><br><span class="line">signature = Hash( data, secret );</span><br></pre></td></tr></table></figure><p>假设我们的原始 <code>JSON</code> 结构是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Header</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">    <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Payload</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <strong>密钥</strong> 是字符串 <code>secret</code> 的话，那么最终 <code>JWT</code> 的结果就是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM</span><br></pre></td></tr></table></figure><blockquote><p>可以在 <code>jwt.io</code> 上 <strong>验证</strong> 这个结果。</p></blockquote><h3 id="JWT究竟带来了什么"><a href="#JWT究竟带来了什么" class="headerlink" title="JWT究竟带来了什么"></a>JWT究竟带来了什么</h3><h4 id="确保数据完整性"><a href="#确保数据完整性" class="headerlink" title="确保数据完整性"></a>确保数据完整性</h4><p><code>JWT</code> 的目的不是为了 <strong>隐藏</strong> 或者 <strong>保密数据</strong>，而是为了确保 <strong>数据</strong> 确实来自被 <strong>授权的人</strong> 创建的，以防止 <strong>中途篡改</strong>。</p><p>回想一下，当你拿到 <code>JWT</code> 时候，你完全可以在没有 <code>secret</code> 的情况下解码出 <code>header</code> 和 <code>payload</code>，因为 <code>header</code> 和 <code>payload</code> 只是经过了 <code>base64</code> 编码（<code>encode</code>）而已，编码的目的在于 <strong>利于数据结构的传输</strong>。</p><p>虽然创建 <code>signature</code> 的过程近似于 <strong>加密</strong> (<code>encrypt</code>)，但本质其实是一种 <strong>签名</strong> (<code>sign</code>) 的行为，用于保证 <strong>数据的完整性</strong>，实际上也并且并 <strong>没有加密任何数据</strong>。</p><h4 id="用于接口调用"><a href="#用于接口调用" class="headerlink" title="用于接口调用"></a>用于接口调用</h4><p>接下来在 <code>API</code> 调用中就可以附上 <code>JWT</code>（通常是在 <code>HTTP Header</code> 中）。又因为 <code>SP</code> 会与程序 <strong>共享</strong> 一个 <code>secret</code>，所以 <strong>程序</strong> 可以通过 <code>header</code> 提供的相同的 <code>hash</code> 算法来 <strong>验证签名</strong> 是否正确，从而判断应用是否有权力调用 <code>API</code>。</p><h3 id="有状态的对话Session"><a href="#有状态的对话Session" class="headerlink" title="有状态的对话Session"></a>有状态的对话Session</h3><p>因为 <code>HTTP</code> 是 <strong>无状态</strong> 的，所以 <strong>客户端</strong> 和 <strong>服务端</strong> 需要解决的问题是，如何让它们之间的对话变得有状态。例如只有是 <strong>登陆状态</strong> 的 <strong>用户</strong> 才有权限调用某些接口，那么在 <strong>用户登陆</strong> 之后，需要记住该用户是 <strong>已经登陆</strong> 的状态。常见的方法是使用 <code>session</code> 机制。</p><p>常见的 <code>session</code> 模型是这样工作的：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Session_Flow" alt=""></p><ol><li><p>用户在浏览器 <strong>登陆</strong> 之后，服务端为用户生成 <strong>唯一</strong> 的 <code>session id</code>，存储在 <strong>服务端</strong> 的 <strong>存储服务</strong>（例如 <code>MySQL</code>, <code>Redis</code>）中。</p></li><li><p>该 <code>session id</code> 也同时 <strong>返回给浏览器</strong>，以 <code>SESSION_ID</code> 为 <code>KEY</code> 存储在浏览器的 <code>cookie</code> 中。</p></li><li><p>如果用户再次访问该网站，<code>cookie</code> 里的 <code>SESSION_ID</code> 会随着 <strong>请求</strong> 一同发往 <strong>服务端</strong>。</p></li><li><p>服务端通过判断 <code>SESSION_ID</code> 是否已经在 <code>Redis</code> 中判断用户是否处于 <strong>登陆状态</strong>。</p></li></ol><p>相信你已经察觉了，理论上来说，<code>JWT</code> 机制可以取代 <code>session</code> 机制。用户不需要提前进行登陆，后端也不需要 <code>Redis</code> 记录用户的登陆信息。客户端的本地保存一份合法的 <code>JWT</code>，当用户需要调用接口时，附带上该合法的 <code>JWT</code>，每一次调用接口，后端都使用请求中附带的 <code>JWT</code> 做一次 <strong>合法性的验证</strong>。这样也间接达到了 <strong>认证用户</strong> 的目的。</p><p>然而 <code>JWT</code> 真的能取代 <code>session</code> 机制吗？这么做有哪些好处和坏处？这些问题将留在下一篇再讨论。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通常为了弄清楚一个概念，我们需要掌握十个概念。在判断 &lt;code&gt;JWT(JsonWebToken)&lt;/code&gt; 是否能代替 &lt;code&gt;session&lt;/code&gt; 管理之前，我们要了解什么是 &lt;code&gt;token&lt;/code&gt;，以及 &lt;code&gt;access token&lt;/code&gt; 和 &lt;code&gt;refresh token&lt;/code&gt; 的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="认证与授权系列" scheme="https://ostenant.coding.me/categories/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SAML" scheme="https://ostenant.coding.me/tags/SAML/"/>
    
      <category term="OAuth" scheme="https://ostenant.coding.me/tags/OAuth/"/>
    
      <category term="SSO" scheme="https://ostenant.coding.me/tags/SSO/"/>
    
      <category term="JWT" scheme="https://ostenant.coding.me/tags/JWT/"/>
    
      <category term="Session" scheme="https://ostenant.coding.me/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>浅谈分布式存储系统的数据分布算法</title>
    <link href="https://ostenant.coding.me/2018/07/01/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%08%E6%8D%AE%E5%88%86%E5%B8%83%E7%AE%97%E6%B3%95/"/>
    <id>https://ostenant.coding.me/2018/07/01/浅谈分布式存储系统的数据分布算法/</id>
    <published>2018-07-01T09:43:00.000Z</published>
    <updated>2018-07-01T13:01:25.154Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>分布式存储系统</strong> 面临着的首要问题，就是如何将 <strong>大量的数据</strong> 分布在 <strong>不同的存储节点</strong> 上。无论上层接口是 <code>KV</code> <strong>存储</strong>、<strong>对象存储</strong>、<strong>块存储</strong>、亦或是 <strong>列存储</strong>，在这个问题上大体是一致的。本文将介绍如何 <strong>分布式存储系统</strong> 中 <strong>做数据分布目标</strong> 及可选的 <strong>方案</strong>，并试着总结和权衡他们之间的关系及。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一-指标"><a href="#一-指标" class="headerlink" title="(一) 指标"></a>(一) 指标</h2><p>这里假设 <strong>目标数据</strong> 是以 <code>key</code> 标识的 <strong>数据块</strong> 或 <strong>对象</strong>。在一个包含 <strong>多个存储节点</strong> 的集群中，<strong>数据分布算法</strong> 需要为每一个给定的 <code>key</code> 指定 <strong>一个</strong> 或 <strong>多个</strong> 对应的 <strong>存储节点</strong> 负责，<strong>数据分布算法</strong> 有两个基本目标：</p><ul><li><p><strong>均匀性(Uniformity)</strong>：不同存储节点的 <strong>负载</strong> 应该 <strong>均衡</strong>；</p></li><li><p><strong>稳定性(Consistency)</strong>：每次一个 <code>key</code> 通过 <strong>数据分布算法</strong> 得到的 <strong>分布结果</strong> 应该保持 <strong>基本稳定</strong>，即使再有存储节点发生变化的情况下。</p></li></ul><p>可以看出，这两个目标在一定程度上是 <strong>相互矛盾</strong> 的。当有 <strong>存储节点增加或删除</strong> 时，为了保持稳定应该 <strong>尽量少</strong> 的进行 <strong>数据的移动</strong> 和 <strong>重新分配</strong>，而这样又势必会带来 <strong>负载不均衡</strong>。同样追求 <strong>极致均匀</strong> 也会导致较多的 <strong>数据迁移</strong>。</p><p>所以我们希望在这两个极端之间，找到一个点以获得合适的均匀性和稳定性。除了上述两个基本目标外，工程中还需要从以下几个方面考虑数据分布算法的优劣：</p><ol><li><p><strong>性能可扩展性</strong>：这个主要考虑的是算法相对于 <strong>存储节点规模</strong> 的 <strong>时间复杂度</strong>。为了整个系统的可扩展性，数据分布算法不应该在集群规模扩大后显著的增加运行时间。</p></li><li><p><strong>考虑节点异构</strong>：实际工程中，不同 <strong>存储节点</strong> 之间可能会有很大的 <strong>性能</strong> 或 <strong>容量差异</strong>，好的数据分布算法应该能很好的应对这种 <strong>异构</strong>，提供 <strong>加权的数据均匀</strong>。</p></li><li><p><strong>隔离故障域</strong>：为了 <strong>数据的高可用</strong>，数据分布算法应该为每个 <code>key</code> 找到 <strong>一组存储节点</strong>，这些节点可能提供的是 <strong>数据的镜像副本</strong>，也可能是类似 <strong>擦除码</strong> 的副本方式。数据分布算法应该尽量 <strong>隔离</strong> 这些副本的故障域，如 <strong>不同机房</strong>、<strong>不同机架</strong>、<strong>不同交换机</strong>、<strong>不同机器</strong>。</p></li></ol><h2 id="二-演进"><a href="#二-演进" class="headerlink" title="(二) 演进"></a>(二) 演进</h2><p>看完算法的评价指标后，接下来介绍一些可能的方案演进，并分析他们的优劣。这里假设 <code>key</code> 的值足够分散。</p><h3 id="1-Hash"><a href="#1-Hash" class="headerlink" title="1. Hash"></a>1. Hash</h3><p>一个简单直观的想法是直接用 <code>Hash</code> 来计算，简单的以 <code>Key</code> 做 <strong>哈希</strong> 后 <strong>对节点数取模</strong>。可以看出，在 <code>key</code> 足够分散的情况下，<strong>均匀性</strong> 可以获得，但一旦有 <strong>节点加入</strong> 或 <strong>退出</strong> 时，所有的原有节点都会受到影响。<strong>稳定性</strong> 无从谈起。</p><h3 id="2-一致性Hash"><a href="#2-一致性Hash" class="headerlink" title="2. 一致性Hash"></a>2. 一致性Hash</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b670a4be?w=576&amp;h=412&amp;f=png&amp;s=38351" alt=""></p><p>一致性 <code>Hash</code> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在收尾相接的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到先遇到的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。但这有带来 <strong>均匀性</strong> 的问题，即使可以将存储节点等距排列，也会在 <strong>存储节点个数</strong> 变化时带来 <strong>数据的不均匀</strong>。而这种可能 <strong>成倍数的不均匀</strong> 在实际工程中是不可接受的。</p><h3 id="3-带负载上限的一致性Hash"><a href="#3-带负载上限的一致性Hash" class="headerlink" title="3. 带负载上限的一致性Hash"></a>3. 带负载上限的一致性Hash</h3><p>一致性 <code>Hash</code> 有 <strong>节点变化时不均匀</strong>的问题。<code>Google</code> 在 <code>2017</code> 年提出了 Consistent Hashing with Bounded Loads 来控制这种 <strong>不均匀的程度</strong>。简单的说，该算法给 <code>Hash</code> 环上的每个节点一个 <strong>负载上限</strong> 为 <code>1 + e</code> 倍的 <strong>平均负载</strong>，这个 <code>e</code>可以自定义。当 <code>key</code> 在 <code>Hash</code> 环上 <strong>顺时针</strong> 找到合适的节点后，会判断这个节点的 <strong>负载</strong> 是否已经 <strong>到达上限</strong>，如果 <strong>已达上限</strong>，则需要继续找 <strong>之后的节点</strong> 进行分配。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b6ac1b85?w=431&amp;h=397&amp;f=png&amp;s=46890" alt=""></p><p>如上图所示，假设每个桶 <strong>当前上限</strong> 是 <code>2</code>，红色的小球按序号访问，当编号为 <code>6</code> 的红色小球到达时，发现顺时针首先遇到的 <code>B（3，4）</code>，<code>C（1，5）</code>都已经 <strong>达到上限</strong>，因此最终放置在桶 <code>A</code> 里。</p><p>这个算法最吸引人的地方在于 <strong>当有节点变化</strong> 时，需要迁移的数据量是 <code>1/e^2</code> 相关，而与 <strong>节点数</strong> 或 <strong>数据数量</strong> 均无关。</p><p>也就是说当 <strong>集群规模扩大</strong> 时，<strong>数据迁移量</strong> 并不会随着显著增加。另外，使用者可以通过调整 <code>e</code> 的值来控制 <strong>均匀性</strong> 和 <strong>稳定性</strong> 之间的权衡，就是一种 <strong>以时间换空间</strong> 的算法。总体来说，无论是 <strong>一致性</strong> <code>Hash</code> 还是 <strong>带负载限制</strong> 的 <strong>一致性</strong> <code>Hash</code>，都无法解决 <strong>节点异构</strong> 的问题。</p><h3 id="4-带虚拟节点的一致性Hash"><a href="#4-带虚拟节点的一致性Hash" class="headerlink" title="4. 带虚拟节点的一致性Hash"></a>4. 带虚拟节点的一致性Hash</h3><p>为了解决 <strong>负载不均匀</strong> 和 <strong>异构</strong> 的问题，可以在 <strong>一致性</strong> <code>Hash</code> 的基础上引入 <strong>虚拟节点</strong>。即 <code>hash</code> 环上的 <strong>每个节点</strong> 并不是 <strong>实际</strong> 的 <strong>存储节点</strong>，而是一个 <strong>虚拟节点</strong>。实际的 <strong>存储节点</strong> 根据其 <strong>不同的权重</strong>，对应 <strong>一个</strong> 或 <strong>多个虚拟节点</strong>，所有落到相应虚拟节点上的 <code>key</code> 都由该 <strong>存储节点负责</strong>。</p><p>如下图所示，存储节点 <code>A</code> 负责 <code>(1,3]</code>，<code>(4,8]</code>，<code>(10, 14]</code>，存储节点 <code>B</code> 负责 <code>(14,1]</code>，<code>(8,10]</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b6940588?w=700&amp;h=338&amp;f=png&amp;s=64488" alt=""></p><p>这个算法的问题在于，一个 <strong>实际存储节点</strong> 的 <strong>加入</strong> 或 <strong>退出</strong>，会影响 <strong>多个虚拟节点</strong>的重新分配，进而引起 <strong>很多节点</strong> 参与到 <strong>数据迁移</strong> 中来。</p><p>另外，实践中将一个 <strong>虚拟节点</strong> 重新分配给 <strong>新的实际节点</strong> 时，需要将这部分数据 <strong>遍历</strong> 出来 <strong>发送给新节点</strong>。我们需要一个更合适的 <strong>虚拟节点切分</strong> 和 <strong>分配方式</strong>，那就是 <strong>分片</strong>。</p><h3 id="5-分片"><a href="#5-分片" class="headerlink" title="5. 分片"></a>5. 分片</h3><p><strong>分片</strong> 将 <strong>哈希环</strong> 切割为 <strong>相同大小的分片</strong>，然后将这些 <strong>分片</strong> 交给 <strong>不同的节点</strong> 负责。</p><p>注意这里跟上面提到的 <strong>虚拟节点</strong> 有着很 <strong>本质的区别</strong>：<strong>分片的划分和分片的分配被解耦</strong>。</p><p>一个 <strong>节点退出</strong> 时，其所负责的 <strong>分片</strong> 并不需要 <strong>顺时针合并</strong> 给之后节点，而是可以更灵活的 <strong>将整个分片</strong> 作为一个 <strong>整体</strong> 交给 <strong>任意节点</strong>。在实践中，一个 <strong>分片</strong> 多作为 <strong>最小的数据迁移</strong> 和 <strong>备份单位</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b68eee2d?w=546&amp;h=462&amp;f=png&amp;s=34445" alt=""></p><p>而也正是由于上面提到的 <strong>解耦</strong>，相当于将原先的 <code>key</code> 到 <strong>节点</strong> 的 <strong>映射</strong> 拆成了两层。需要一个 <strong>新的机制</strong> 来进行 <strong>分片</strong> 到 <strong>存储节点</strong> 的 <strong>映射</strong>。由于 <strong>分片数</strong> 相对 <code>key</code> 空间已经很小并且 <strong>数量确定</strong>，可以更精确地初始设置，并引入 <strong>中心目录服务</strong> 来根据 <strong>节点存活</strong> 修改 <strong>分片的映射关系</strong>。同时将这个 <strong>映射信息</strong> 通知给所有的 <strong>存储节点</strong> 和 <strong>客户端</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b9a03c5b?w=700&amp;h=388&amp;f=png&amp;s=49049" alt=""></p><p>上图是 <strong>分布式KV存储</strong> <code>Zeppelin</code>中的 <strong>分片方式</strong>，<code>Key Space</code> 通过 <code>Hash</code> 到 <strong>分片</strong>，<strong>分片及其副本</strong> 又通过一层映射到 <strong>最终的存储节点</strong> <code>Node Server</code>。</p><h3 id="6-CRUSH算法"><a href="#6-CRUSH算法" class="headerlink" title="6. CRUSH算法"></a>6. CRUSH算法</h3><p><code>CRUSH</code> 算法本质上也是一种 <strong>基于分片</strong> 的数据分布方式，其试图在以下几个方面进行优化：</p><ul><li><p><strong>分片映射信息量</strong>：避免 <strong>中心目录服务</strong> 和 <strong>存储节点</strong> 及 <strong>客户端之间</strong> 交互大量的 <strong>分片映射信息</strong>，而改由 <strong>存储节点</strong> 或 <strong>客户端</strong> 自己根据 <strong>少量</strong> 且 <strong>稳定</strong> 的集群节点拓扑和确定的规则自己计算分片映射。</p></li><li><p><strong>完善的故障域划分</strong>：支持 <strong>层级</strong> 的 <strong>故障域控制</strong>，将 <strong>同一分片</strong> 的 <strong>不同副本</strong> 按照配置划分到 <strong>不同层级</strong> 的 <strong>故障域中</strong>。</p></li></ul><p><strong>客户端</strong> 或 <strong>存储节点</strong> 利用 <code>key</code>、<strong>存储节点</strong> 的 <strong>拓扑结构</strong> 和 <strong>分配算法</strong>，独立的进行 <strong>分片位置</strong> 的计算，得到一组负责对应 <strong>分片</strong> 及 <strong>副本</strong> 的 <strong>存储位置</strong>。</p><p>如图所示是 <strong>一次定位</strong> 的过程，最终选择了一个 <code>row</code> 下的 <code>cab21</code>，<code>cab23</code>，<code>cab24</code> 三个机柜下的三个存储节点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b6abde68?w=700&amp;h=254&amp;f=png&amp;s=72421" alt=""></p><p>当 <strong>节点变化</strong> 时，由于 <strong>节点拓扑</strong> 的变化，会影响 <strong>少量分片</strong> 数据进行迁移，如下图是加入 <strong>新节点</strong> 引起的 <strong>数据迁移</strong>。通过良好的 <strong>分配算法</strong>，可以得到很好的 <strong>负载均衡</strong> 和 <strong>稳定性</strong>，<code>CRUSH</code> 提供了 <code>Uniform</code>、<code>List</code>、<code>Tree</code>、<code>Straw</code> 四种分配算法。</p><h2 id="三-应用案例"><a href="#三-应用案例" class="headerlink" title="(三) 应用案例"></a>(三) 应用案例</h2><p>常见的 <strong>分布式存储系统</strong> 大多采用类似于 <strong>分片</strong> 的 <strong>数据分布和定位方式</strong>：</p><ol><li><p><strong>Cassandra/Dynamo</strong>：采用 <strong>分片</strong> 的方式并通过 <code>Gossip</code> 协议在对等节点间通信；</p></li><li><p><strong>Redis Cluster</strong>：将 <code>key Space</code> 划分为 <code>slots</code>，同样利用 <code>Gossip</code> 协议通信；</p></li><li><p><strong>Zeppelin</strong>：将数据分片为 <code>Partition</code>，通过 <code>Meta</code> 集群提供 <strong>中心目录服务</strong>；</p></li><li><p><strong>Bigtable</strong>：将数据切割为 <code>Tablet</code>，类似于可变的分片，<code>Tablet Server</code> 可以进行分片的切割，最终分片信息记录在 <code>Chubby</code> 中；</p></li><li><p><strong>Ceph</strong>：采用 <code>CRUSH</code> 方式，由 <strong>中心集群</strong> <code>Monitor</code> 提供并维护 <strong>集群拓扑</strong> 的变化。</p></li></ol><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5dcc40392?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分布式存储系统&lt;/strong&gt; 面临着的首要问题，就是如何将 &lt;strong&gt;大量的数据&lt;/strong&gt; 分布在 &lt;strong&gt;不同的存储节点&lt;/strong&gt; 上。无论上层接口是 &lt;code&gt;KV&lt;/code&gt; &lt;strong&gt;存储&lt;/strong&gt;、&lt;strong&gt;对象存储&lt;/strong&gt;、&lt;strong&gt;块存储&lt;/strong&gt;、亦或是 &lt;strong&gt;列存储&lt;/strong&gt;，在这个问题上大体是一致的。本文将介绍如何 &lt;strong&gt;分布式存储系统&lt;/strong&gt; 中 &lt;strong&gt;做数据分布目标&lt;/strong&gt; 及可选的 &lt;strong&gt;方案&lt;/strong&gt;，并试着总结和权衡他们之间的关系及。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式存储" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="一致性哈希" scheme="https://ostenant.coding.me/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
      <category term="分片" scheme="https://ostenant.coding.me/tags/%E5%88%86%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习Quartz任务调度框架</title>
    <link href="https://ostenant.coding.me/2018/06/27/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Quartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/"/>
    <id>https://ostenant.coding.me/2018/06/27/从零开始学习Quartz任务调度框架/</id>
    <published>2018-06-27T04:17:00.000Z</published>
    <updated>2018-06-29T04:50:45.047Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Quartz</code> 是个 <strong>任务调度工具</strong>，就是 <strong>定时</strong> 执行指定的任务。<code>Quartz</code> 提供了极为广泛的特性如 <strong>持久化任务</strong>，<strong>集群</strong> 和 <strong>分布式任务</strong> 等。<code>Quartz</code> 是用 <code>Java</code> 构建的，与 <code>Spring</code> 集成方便，<strong>伸缩性</strong>，<strong>负载均衡</strong>，<strong>高可用性</strong>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/Quartz_Logo_large.jpg" alt=""></p><p>本文只关注基于 <strong>数据库</strong> 的 <code>Quartz</code> 集群，基于 <code>Quartz 2.2.x</code> 来说明。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Quartz的核心组件"><a href="#Quartz的核心组件" class="headerlink" title="Quartz的核心组件"></a>Quartz的核心组件</h2><p><code>Quartz</code> 大致有三个核心的组件：</p><h3 id="1-调度器Scheduler"><a href="#1-调度器Scheduler" class="headerlink" title="1. 调度器Scheduler"></a>1. 调度器Scheduler</h3><p>一个 <strong>计划调度器容器</strong>，容器里面可以装载众多的 <code>JobDetail</code> 和 <code>Trigger</code>。当容器启动后，里面的每个 <code>JobDetail</code> 都会根据 <code>Trigger</code> 按部就班地 <strong>自动</strong> 去执行.</p><h3 id="2-任务Job"><a href="#2-任务Job" class="headerlink" title="2. 任务Job"></a>2. 任务Job</h3><p><code>Job</code> 表示要执行的 <strong>具体内容</strong>。<code>JobDetail</code> 表示具体的、可执行的调度程序，包含了这个任务的 <strong>调度方案</strong> 和 <strong>策略</strong>。</p><h3 id="3-触发器Trigger"><a href="#3-触发器Trigger" class="headerlink" title="3. 触发器Trigger"></a>3. 触发器Trigger</h3><p><strong>调度参数</strong> 的配置，配置任务执行触发的 <strong>时间间隔</strong>。</p><blockquote><p>几者的关系：<strong>调度器</strong> 就相当于一个 <strong>容器</strong>，装载着 <strong>任务</strong> 和 <strong>触发器</strong>。任务和触发器又是绑定在一起的，然而一个任务可以对应多个触发器，但一个触发器却只能对应一个任务。当 <code>JobDetail</code> 和 <code>Trigger</code> 在 <code>Scheduler</code> 容器上 <strong>注册</strong> 后，形成了装配好的 <strong>任务作业</strong>（<code>JobDetail</code> 和 <code>Trigger</code> 所组成的一对），伴随 <strong>容器启动</strong> 而调度执行。</p></blockquote><h2 id="Quartz的核心类"><a href="#Quartz的核心类" class="headerlink" title="Quartz的核心类"></a>Quartz的核心类</h2><h3 id="1-Scheduler"><a href="#1-Scheduler" class="headerlink" title="1. Scheduler"></a>1. Scheduler</h3><p><code>Quartz</code> 中 <strong>独立运行</strong> 的容器，<code>Trigger</code> 和 <code>JobDetail</code> 可以注册到 <code>Scheduler</code> 上。<code>Scheduler</code> 定义了多个 <strong>接口方法</strong>，允许外部通过 <strong>组及名称</strong> 访问和控制 <strong>容器</strong> 中 <code>Trigger</code> 和 <code>JobDetail</code>。</p><h3 id="2-Job"><a href="#2-Job" class="headerlink" title="2. Job"></a>2. Job</h3><p>任务接口，<strong>任务类</strong> 代表要调度执行的 <strong>业务逻辑实现</strong>，<strong>任务</strong> 必须实现该接口。</p><p>如果任务不允许 <strong>并发执行</strong>，则 <strong>任务类</strong> 必须添加注解 <code>@DisallowConcurrentExecution</code>。</p><p>该接口只定义了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException</span>;</span><br></pre></td></tr></table></figure><p>通过 <code>context</code> 可以访问配置给任务的 <strong>数据</strong> <code>context.getJobDetail().getJobDataMap()</code>，如果这个 <code>JobDataMap</code> 需要在修改后 <strong>持久化</strong> 到 <strong>数据库</strong> 里，则需要给 <strong>任务类</strong> 加上注解 <code>@PersistJobDataAfterExecution</code>。<code>Quartz</code> 在下次调度执行这个任务时，会把 <strong>持久化</strong> 的数据 <strong>反序列化</strong> 成 <code>JobDataMap</code> 供应用使用。</p><blockquote><p>不建议通过 <code>Quartz</code> 的这个机制 <strong>持久化</strong> 任何与 <strong>业务有关</strong> 的数据。因为 <strong>业务数据</strong> 应该由 <strong>应用</strong> 来存储，<code>Quartz</code> 只关注于调度执行。</p></blockquote><h3 id="3-JobDetail"><a href="#3-JobDetail" class="headerlink" title="3. JobDetail"></a>3. JobDetail</h3><p>任务在 <strong>内存</strong> 的标示。表示 <strong>任务详细信息</strong> 的接口，如 <code>Job</code> <strong>名字</strong>、<strong>描述信息</strong>、<strong>关联监听器</strong> 等信息。任务用调度器名称、任务名称和任务所归属的组名来作为 <strong>唯一标识</strong>。</p><h3 id="4-Trigger"><a href="#4-Trigger" class="headerlink" title="4. Trigger"></a>4. Trigger</h3><p><strong>触发器</strong>，用调度器名称、触发器名称和触发器所归属的组名来做 <strong>唯一标识</strong>。用于定义在什么情况、什么时间点执行任务。最常用的触发器类型就是基于 <code>cron</code> <strong>表达式</strong> 的触发器。</p><h3 id="5-JobStore"><a href="#5-JobStore" class="headerlink" title="5. JobStore"></a>5. JobStore</h3><p><strong>数据存储抽象</strong>，该接口定义了 <strong>任务</strong>、<strong>触发器</strong> 的 <strong>存储</strong>、<strong>检索</strong>、<strong>更新</strong> 的钩子函数，该接口还定义了任务执行完成后的 <strong>回调方法</strong>。</p><p><code>Quartz</code> 内建支持把 <strong>任务</strong>、<strong>触发器</strong> 等数据存储在 <code>JVM</code> <strong>内存</strong>、<strong>文件</strong>、<strong>数据库</strong> 中。通过这个接口，就隔离了 <strong>底层存储机制</strong> 的差异。可以在配置文件里通过 <code>org.quartz.JobStore.class</code> 属性来指定该接口的实现，比如基于 <code>Redis</code> 做 <strong>数据存储</strong> 的实现。</p><h4 id="5-1-RAMJobStore"><a href="#5-1-RAMJobStore" class="headerlink" title="5.1. RAMJobStore"></a>5.1. RAMJobStore</h4><ul><li><strong>优点</strong>：不依赖 <strong>外部数据库</strong>，配置容易，运行速度快。</li><li><strong>缺点</strong>：程序停止运行时，所有 <strong>调度信息</strong> 丢失。调度信息的 <strong>存储容量</strong> 也会被限制。</li></ul><h4 id="5-2-JDBCJobStore"><a href="#5-2-JDBCJobStore" class="headerlink" title="5.2. JDBCJobStore"></a>5.2. JDBCJobStore</h4><ul><li><strong>优点</strong>：支持 <strong>集群模式</strong>，所有的任务信息都会保存到 <strong>数据库</strong> 中。</li><li><strong>缺点</strong>：配置复杂。运行速度的快慢，取决于连接数据库的快慢。</li></ul><h3 id="6-JobFactory"><a href="#6-JobFactory" class="headerlink" title="6. JobFactory"></a>6. JobFactory</h3><p><strong>任务工厂</strong>，接口抽象了如何生成 <strong>任务实例</strong>，以便让应用来决定如何实例化任务类。</p><h3 id="7-JobStoreSupport"><a href="#7-JobStoreSupport" class="headerlink" title="7. JobStoreSupport"></a>7. JobStoreSupport</h3><p>提供了 <strong>基于数据库</strong> 的 <code>JobStore</code> 实现，通过 <code>MisfireHandler</code> 来检查错过发射的 <strong>触发器</strong>。如果是以 <strong>集群方式部署</strong>，还会通过内部类 <code>ClusterManager</code> 提供 <strong>集群健康检查</strong> 与 <strong>恢复</strong>。</p><h3 id="8-MisfireHandler"><a href="#8-MisfireHandler" class="headerlink" title="8. MisfireHandler"></a>8. MisfireHandler</h3><p><code>JobStoreSupport</code> 有个内部类 <code>MisfireHandler</code>，用于检查是否有 <strong>触发器</strong> 错过发射，它是用 <strong>单独的线程</strong> 执行。</p><p>但检测到有触发器 <strong>错过发射</strong> 时，该处理器只是 <strong>更新</strong> 触发器的状态为 <code>WAITING</code>，然后通知 <strong>监听器</strong>、通知 <strong>调度器</strong> 去处理。</p><h3 id="9-ClusterManager"><a href="#9-ClusterManager" class="headerlink" title="9. ClusterManager"></a>9. ClusterManager</h3><p>用于 <strong>管理集群</strong> 的 <strong>线程</strong>。<code>JobStoreSupport</code> 有个 <strong>内部类</strong> <code>ClusterManager</code> 用于进行 <strong>集群管理</strong>，它也是用 <strong>单独的线程</strong> 来执行，以防止 <strong>任务阻塞</strong>，其核心逻辑有：</p><ol><li>签入，向其他节点传达它所在的 <strong>调度器实例</strong> 还处于存活状态。</li><li>检查失败的节点，进行 <strong>恢复</strong>。<code>Quartz</code> 认为在一定时间后 <strong>没有签入</strong> 的节点是失败的，需要恢复。</li></ol><h3 id="10-Calendar"><a href="#10-Calendar" class="headerlink" title="10. Calendar"></a>10. Calendar</h3><p><code>org.quartz.Calendar</code> 和 <code>java.util.Calendar</code> 不同，它是一些 <strong>特定时间点</strong> 的 <strong>集合</strong>。一个 <code>Trigger</code> 可以和 <strong>多个</strong> <code>Calendar</code> 关联，以便 <strong>排除</strong> 或包含 <strong>某些时间点</strong>。</p><blockquote><p><code>Quartz</code> 在 <code>org.quartz.impl.calendar</code> 包下提供了若干个 <code>Calendar</code> 的 <strong>实现类</strong>，比如: <code>AnnualCalendar</code>、<code>MonthlyCalendar</code>、<code>WeeklyCalendar</code> 分别针对每年、每月和每周进行定义。</p></blockquote><h3 id="11-工作线程池"><a href="#11-工作线程池" class="headerlink" title="11. 工作线程池"></a>11. 工作线程池</h3><p><code>Quartz</code> 可以配置一个 <strong>线程池</strong> 来执行任务，线程池里的 <strong>线程用完</strong> 后，后续到期需要执行的任务就会 <strong>被阻塞</strong>。</p><h3 id="12-调度器线程"><a href="#12-调度器线程" class="headerlink" title="12. 调度器线程"></a>12. 调度器线程</h3><p>每个 <strong>调度器</strong> 都有自己的名称，对应一个 <code>org.quartz.core.QuartzSchedulerThread</code> <strong>调度器线程实例</strong>，调度逻辑就在这个线程类的 <code>run()</code> 方法里。</p><h2 id="Quartz的核心表"><a href="#Quartz的核心表" class="headerlink" title="Quartz的核心表"></a>Quartz的核心表</h2><h3 id="1-job-details"><a href="#1-job-details" class="headerlink" title="1. job_details"></a>1. job_details</h3><p>存储 <strong>任务</strong> 的信息，每一条记录表示一个任务。</p><h3 id="2-triggers"><a href="#2-triggers" class="headerlink" title="2. triggers"></a>2. triggers</h3><p>存储 <strong>触发器</strong> 的信息，<code>TRIGGER_STATE</code> 字段表示 <strong>触发器状态</strong>，用来控制这个 <strong>触发器</strong> 能不能被调度器 <strong>处理</strong>。</p><h3 id="3-fired-triggers"><a href="#3-fired-triggers" class="headerlink" title="3. fired_triggers"></a>3. fired_triggers</h3><p><strong>已发射触发器</strong> 的记录表，<code>STATE</code> 列用来表示任务的 <strong>执行状态</strong>。该表的作用是 <strong>跟踪任务</strong> 的 <strong>执行进度</strong>，用于 <strong>失败处理</strong>。</p><h3 id="4-locks"><a href="#4-locks" class="headerlink" title="4. locks"></a>4. locks</h3><p><code>locks</code> 表里的每条记录作为一个 <strong>悲观锁</strong>，要 <strong>加锁</strong> 时，用 <code>for update</code> 语句锁住对应的记录。</p><h3 id="5-scheduler-state"><a href="#5-scheduler-state" class="headerlink" title="5. scheduler_state"></a>5. scheduler_state</h3><p><strong>调度器状态表</strong>，集群的节点通过这个表来检查 <strong>其他节点</strong> 是否存活。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Quartz&lt;/code&gt; 是个 &lt;strong&gt;任务调度工具&lt;/strong&gt;，就是 &lt;strong&gt;定时&lt;/strong&gt; 执行指定的任务。&lt;code&gt;Quartz&lt;/code&gt; 提供了极为广泛的特性如 &lt;strong&gt;持久化任务&lt;/strong&gt;，&lt;strong&gt;集群&lt;/strong&gt; 和 &lt;strong&gt;分布式任务&lt;/strong&gt; 等。&lt;code&gt;Quartz&lt;/code&gt; 是用 &lt;code&gt;Java&lt;/code&gt; 构建的，与 &lt;code&gt;Spring&lt;/code&gt; 集成方便，&lt;strong&gt;伸缩性&lt;/strong&gt;，&lt;strong&gt;负载均衡&lt;/strong&gt;，&lt;strong&gt;高可用性&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="任务调度框架系列" scheme="https://ostenant.coding.me/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Quartz" scheme="https://ostenant.coding.me/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(六) - 单机定时任务的几种实现</title>
    <link href="https://ostenant.coding.me/2018/06/25/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E5%85%AD)%20-%20%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ostenant.coding.me/2018/06/25/实战Spring Boot 2.0系列(六) - 单机定时任务的几种实现/</id>
    <published>2018-06-25T10:20:00.000Z</published>
    <updated>2018-06-26T06:09:32.482Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>定时任务</strong> 一般会存在 <strong>中大型企业级</strong> 项目中，为了减少 <strong>服务器</strong>、<strong>数据库</strong> 的压力，往往会以 <strong>定时任务</strong> 的方式去完成某些业务逻辑。</p><a id="more"></a><p>常见的就是 <strong>金融服务系统</strong> 推送回调，一般支付系统订单在没有收到成功的回调返回内容时会 <strong>持续性的回调</strong>，这种回调一般都是 <strong>定时任务</strong> 来完成。</p><p>还有就是 <strong>报表的生成</strong>，我们一般会在客户 <strong>访问量小</strong> 时完成这个操作，也可以采用 <strong>定时任务</strong> 来完成。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413255f98b30e7?w=620&amp;h=595&amp;f=png&amp;s=81732" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="定时任务的几种方式"><a href="#定时任务的几种方式" class="headerlink" title="定时任务的几种方式"></a>定时任务的几种方式</h2><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>这是 <code>Java</code> 自带的 <code>java.util.Timer</code> 类，这个类允许调度一个名为 <code>java.util.TimerTask</code> 任务。使用这种方式可以让你的程序按照某一个 <strong>频度</strong> 执行，但不能在 <strong>指定时间</strong> 运行。现在一般用的较少。</p><h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h4><p><code>JDK</code> 自带的一个类，是基于 <strong>线程池</strong> 设计的定时任务类，每个 <strong>调度任务</strong> 都会分配到 <strong>线程池</strong> 中的一个 <strong>线程</strong> 去执行。也就是说，任务是 <strong>并发执行</strong>，互不影响的。</p><h4 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h4><p><code>Spring 3.0</code> 以后自带的 <code>Task</code>，支持 <strong>多线程</strong> 调度，可以将它看成一个 <strong>轻量级</strong> 的 <code>Quartz</code>，而且使用起来比 <code>Quartz</code> 简单许多，但是适用于 <strong>单节点</strong> 的 <strong>定时任务调度</strong>。</p><h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>这是一个 <strong>功能比较强大</strong> 的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来 <strong>稍显复杂</strong>。<code>Quartz</code> 功能强大，可以结合 <strong>数据库</strong> 做 <strong>持久化</strong>，进行 <strong>分布式</strong> 的 <strong>任务延时调度</strong>。</p><h2 id="Cron表达式简介"><a href="#Cron表达式简介" class="headerlink" title="Cron表达式简介"></a>Cron表达式简介</h2><p><code>Cron</code> 表达式是一个字符串，字符串以 <code>5</code> 或 <code>6</code> 个 <strong>空格</strong> 隔开，分为 <code>6</code> 或 <code>7</code> 个 <strong>域</strong>，每一个域代表一个含义，<code>Cron</code> 有如下两种语法格式：</p><blockquote><ol><li>Seconds Minutes Hours DayofMonth Month DayofWeek Year</li><li>Seconds Minutes Hours DayofMonth Month DayofWeek</li></ol></blockquote><p>每个域对应的含义、域值范围和特殊表示符，从左到右依次如下：</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">允许值</th><th style="text-align:left">允许的特殊字符</th></tr></thead><tbody><tr><td style="text-align:left">秒</td><td style="text-align:left">0-59</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">分</td><td style="text-align:left">0-59</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">小时</td><td style="text-align:left">0-23</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">日期</td><td style="text-align:left">1-31</td><td style="text-align:left">, - * / L W C</td></tr><tr><td style="text-align:left">月份</td><td style="text-align:left">1-12 或者 JAN-DEC</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">星期</td><td style="text-align:left">1-7 或者 SUN-SAT</td><td style="text-align:left">, - * / L C #</td></tr><tr><td style="text-align:left">年（可选）</td><td style="text-align:left">留空, 1970-2099</td><td style="text-align:left">, - * /</td></tr></tbody></table><p>如上面的表达式所示:</p><ul><li><p><strong>“”字符:</strong> 被用来指定所有的值。如：在分钟的字段域里表示”每分钟”。</p></li><li><p><strong>“-“字符:</strong> 被用来指定一个范围。如：”10-12” 在小时域意味着 “10点、11点、12点”。</p></li><li><p><strong>“,”字符:</strong> 被用来指定另外的值。如：”MON,WED,FRI” 在星期域里表示 “星期一、星期三、星期五”。</p></li><li><p><strong>“?”字符:</strong> 只在日期域和星期域中使用。它被用来指定”非明确的值”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。</p></li><li><p><strong>“L”字符:</strong> 指定在月或者星期中的某天（最后一天）。即 “Last” 的缩写。但是在星期和月中 “Ｌ” 表示不同的意思，如：在月子段中 “L” 指月份的最后一天 - 1月31日，2月28日。</p><ul><li>如果在星期字段中则简单的表示为 “7” 或者 “SAT” 字符。</li><li>如果在星期字段中在某个 value 值得后面，则表示 “某月的最后一个星期value”，如 “6L” 表示某月的最后一个星期五。</li></ul></li><li><p><strong>“W”字符:</strong> 只能用在月份字段中，该字段指定了离指定日期最近的那个星期日。</p></li><li><p><strong>“#”字符:</strong> 只能用在星期字段，该字段指定了第几个星期 value 在某月中</p></li></ul><p>每一个元素都可以显式地规定一个值（如 <code>6</code>），一个区间（如 <code>9-12</code>），一个列表（如 <code>9，11，13</code>）或一个通配符（如 <code>*</code>）。<strong>“月份中的日期”</strong> 和 <strong>“星期中的日期”</strong> 这两个元素是 <strong>互斥的</strong>，因此应该通过设置一个 <strong>问号</strong>（<code>?</code>）来表明你不想设置的那个字段。下表显示了一些 <code>cron</code> 表达式的 <strong>例子</strong> 和它们的意义：</p><table><thead><tr><th>表达式</th><th>意义</th></tr></thead><tbody><tr><td>“0 0 12 <em> </em> ?”</td><td>每天中午12点触发</td></tr><tr><td>“0 15 10 ? <em> </em>“</td><td>每天上午10:15触发</td></tr><tr><td>“0 15 10 <em> </em> ?”</td><td>每天上午10:15触发</td></tr><tr><td>“0 15 10 <em> </em> ? *”</td><td>每天上午10:15触发</td></tr><tr><td>“0 15 10 <em> </em> ? 2005”</td><td>2005年的每天上午10:15触发</td></tr><tr><td>“0 <em> 14 </em> * ?”</td><td>在每天下午2点到下午2:59期间的每1分钟触发</td></tr><tr><td>“0 0/5 14 <em> </em> ?”</td><td>在每天下午2点到下午2:55期间的每5分钟触发</td></tr><tr><td>“0 0/5 14,18 <em> </em> ?”</td><td>在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</td></tr><tr><td>“0 0-5 14 <em> </em> ?”</td><td>在每天下午2点到下午2:05期间的每1分钟触发</td></tr><tr><td>“0 10,44 14 ? 3 WED”</td><td>每年三月的星期三的下午2:10和2:44触发</td></tr><tr><td>“0 15 10 ? * MON-FRI”</td><td>周一至周五的上午10:15触发</td></tr><tr><td>“0 15 10 15 * ?”</td><td>每月15日上午10:15触发</td></tr><tr><td>“0 15 10 L * ?”</td><td>每月最后一日的上午10:15触发</td></tr><tr><td>“0 15 10 ? * 6L”</td><td>每月的最后一个星期五上午10:15触发</td></tr><tr><td>“0 15 10 ? * 6L 2002-2005”</td><td>2002年至2005年的每月的最后一个星期五上午10:15触发</td></tr><tr><td>“0 15 10 ? * 6#3”</td><td>每月的第三个星期五上午10:15触发</td></tr><tr><td>0 6 <em> </em> *</td><td>每天早上6点</td></tr><tr><td>0 /2 <em> </em></td><td>每两个小时</td></tr><tr><td>0 23-7/2，8 <em> </em> *</td><td>晚上11点到早上8点之间每两个小时，早上八点</td></tr><tr><td>0 11 4 * 1-3</td><td>每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点</td></tr><tr><td>0 4 1 1 *</td><td>1月1日早上4点</td></tr></tbody></table><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="配置gradle依赖"><a href="#配置gradle依赖" class="headerlink" title="配置gradle依赖"></a>配置gradle依赖</h3><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-scheduler-task-management</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter'</span>)</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Spring Boot</code> 入口类上配置 <code>@EnableScheduling</code> 注解开启 <code>Spring</code> 自带的定时处理功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置Timer任务"><a href="#配置Timer任务" class="headerlink" title="配置Timer任务"></a>配置Timer任务</h2><p>这个 <code>API</code> 目前在项目中很少用，直接给出示例代码。具体的介绍可以查看 <code>API</code>。<code>Timer</code> 的内部只有 <strong>一个线程</strong>，如果有 <strong>多个任务</strong> 的话就会 <strong>顺序执行</strong>，这样任务的 <strong>延迟时间</strong> 和 <strong>循环时间</strong> 就会出现问题。</p><p>TimerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TimerService.class);</span><br><span class="line">    <span class="keyword">private</span> AtomicLong counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">                LOGGER.info(<span class="string">"Schedule timerTask &#123;&#125; times"</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000L</span>, <span class="number">10</span> * <span class="number">1000L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个 <code>TimerTask</code>，在 <code>TimerTask</code> 中累加 <strong>执行次数</strong>，并通过 <code>slf4j</code> 进行打印 (自带执行时间)。然后通过 <code>Timer</code> 调度工具类调度 <code>TimerTask</code> 任务，设置 <strong>初始化延迟时间</strong> 为 <code>1s</code>，<strong>定时执行间隔</strong> 为 <code>10s</code>，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TimerService timerService = <span class="keyword">new</span> TimerService();</span><br><span class="line">    timerService.schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察测试结果，能够发现 <code>TimerTask</code> 配置的任务每隔 <code>10s</code> 被执行了一次，执行线程默认都是 <code>Timer-0</code> 这个线程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17:48:18.731 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 1 <span class="built_in">times</span></span><br><span class="line">17:48:28.730 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 2 <span class="built_in">times</span></span><br><span class="line">17:48:38.736 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 3 <span class="built_in">times</span></span><br><span class="line">17:48:48.738 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 4 <span class="built_in">times</span></span><br><span class="line">17:48:58.743 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 5 <span class="built_in">times</span></span><br></pre></td></tr></table></figure><h2 id="配置ScheduledExecutorService任务"><a href="#配置ScheduledExecutorService任务" class="headerlink" title="配置ScheduledExecutorService任务"></a>配置ScheduledExecutorService任务</h2><p><code>ScheduledExecutorService</code> 是 <strong>延时执行</strong> 的线程池，对于 <strong>多线程</strong> 环境下的 <strong>定时任务</strong>，推荐用 <code>ScheduledExecutorService</code> 代替 <code>Timer</code> 定时器。</p><p>创建一个线程数量为 <code>4</code> 的 <strong>任务线程池</strong>，同一时刻并向它提交 <code>4</code> 个定时任务，用于测试延时任务的 <strong>并发处理</strong>。执行 <code>ScheduledExecutorService</code> 的 <code>scheduleWithFixedDelay()</code> 方法，设置任务线程池的 <strong>初始任务延迟时间</strong> 为 <code>2</code> 秒，并在上一次 <strong>执行完毕时间点</strong> 之后 <code>10</code> 秒再执行下一次任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        scheduledExecutor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">            LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">        &#125;, <span class="number">2000L</span>, <span class="number">10</span> * <span class="number">1000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">"Start to schedule"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下，我们可以发现每隔 <code>20</code> 秒的时间间隔，就会有 <code>4</code> 个定时任务同时执行。因为在任务线程池初始化时，我们同时向线程池提交了 <code>4</code> 个任务，这 <strong>四个任务</strong> 会完全利用线程池中的 <code>4</code> 个线程进行任务执行。</p><p><code>20</code> 秒是怎么来的？首先每个任务的 <strong>时间间隔</strong> 设置为 <code>10</code> 秒。其次因为采用的是 <code>withFixedDelay</code> 策略，即当前任务执行的 <strong>结束时间</strong>，作为下次延时任务的 <strong>开始计时节点</strong>，并且每个任务在执行过程中睡眠了 <code>10</code> 秒的时间，累计起来就是 <code>20</code> 秒的时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">19:42:02.444 [main] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Start to schedule</span><br><span class="line">19:42:14.449 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 3 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:14.449 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 1 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:14.449 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 2 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:14.449 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 4 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 7 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 5 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 8 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 6 <span class="built_in">times</span> with fixed delay</span><br></pre></td></tr></table></figure><p>创建一个线程数量为 <code>4</code> 的 <strong>任务线程池</strong>，同一时刻并向它提交 <code>4</code> 个定时任务，用于测试延时任务的 <strong>并发处理</strong>。每个任务分别执行 <code>ScheduledExecutorService</code> 的 <code>scheduleAtFixedRate()</code> 方法，设置任务线程池的 <strong>初始任务延迟时间</strong> 为 <code>2</code> 秒，并在上一次 <strong>开始执行时间点</strong> 之后 <code>10</code> 秒再执行下一次任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        scheduledExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">            LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times at fixed rate"</span>, count);</span><br><span class="line">        &#125;, <span class="number">2000L</span>, <span class="number">10</span> * <span class="number">1000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">"Start to schedule"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下，我们可以发现每隔 <code>10</code> 秒的时间间隔，就会有 <code>4</code> 个定时任务同时执行，因为在任务线程池初始化时，我们同时向线程池提交了 <code>4</code> 个任务，这 <strong>四个任务</strong> 会完全利用线程池中的 <code>4</code> 个线程进行任务执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">19:31:46.837 [main] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Start to schedule</span><br><span class="line">19:31:48.840 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 1 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:48.840 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 3 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:48.840 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 2 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:48.840 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 4 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.839 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 6 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.840 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 8 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.839 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 7 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.839 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 5 <span class="built_in">times</span> at fixed rate</span><br></pre></td></tr></table></figure><h2 id="配置Spring-Task任务"><a href="#配置Spring-Task任务" class="headerlink" title="配置Spring Task任务"></a>配置Spring Task任务</h2><p><code>Spring</code> 提供了 <code>@Scheduled</code> 注解来实现 <strong>定时任务</strong>，<code>@Scheduled</code> 参数可以接受 <strong>两种</strong> 定时的设置，一种是我们常用的 <strong>格林时间表达式</strong> <code>cron = &quot;*/10 * * * * *&quot;</code>，另一种是 <code>fixedRate = 10 * 1000L</code>，两种都表示每隔 <code>10</code> 秒执行一次目标任务。</p><p>参数说明：</p><ul><li>@Scheduled(fixedRate = 10 * 1000L)：上一次 <strong>开始执行时间点</strong> 之后 <code>10</code> 秒再执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times at fixed rate"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Scheduled(fixedDelay = 10 * 1000L)：上一次 <strong>执行完毕时间点</strong> 之后 <code>10</code> 秒再执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Scheduled(initialDelay = 2000L, fixedRate = 10 * 1000L)：第一次延迟 <code>2</code> 秒后执行，之后按 <code>fixedRate</code> 的规则每 <code>10</code> 秒执行一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(initialDelay = <span class="number">2000L</span>, fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithinitialDelayAndFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Scheduled(cron = “0/10 <em> </em> <em> </em> *”)：根据 <code>cron</code> 表达式定义，每隔 <code>10</code> 秒执行一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/10 * * * * *"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithCronExpression</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with "</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><p>SpringTaskService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTaskService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SpringTaskService.class);</span><br><span class="line">    <span class="keyword">private</span> AtomicLong counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(initialDelay = <span class="number">2000L</span>, fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithinitialDelayAndFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times at fixed rate"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/10 * * * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithCronExpression</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with "</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看日志，任务每 <code>20</code> 秒的时间间隔执行一次。每次定时任务在上次 <strong>执行完毕时间点</strong> 之后 <code>10</code> 秒再执行，在任务中设置 <strong>睡眠时间</strong> 为 <code>10</code> 秒。这里只验证了 @Scheduled(initialDelay = 2000L, fixedDelay = 10 * 1000L)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-06-25 18:00:53.051  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 1 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:01:13.056  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 2 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:01:33.061  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 3 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:01:53.071  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 4 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:02:13.079  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 5 <span class="built_in">times</span> with fixed delay</span><br></pre></td></tr></table></figure><h3 id="配置任务线程池"><a href="#配置任务线程池" class="headerlink" title="配置任务线程池"></a>配置任务线程池</h3><p>上述配置都是基于 <strong>单线程</strong> 的任务调度，如何引入 <strong>多线程</strong> 提高 <strong>延时任务</strong> 的 <strong>并发处理</strong> 能力？</p><p><code>Spring Boot</code> 提供了一个 <code>SchedulingConfigurer</code> 配置接口。我们通过 <code>ScheduleConfig</code> 配置文件实现 <code>ScheduleConfiguration</code> 接口，并重写 <code>configureTasks()</code> 方法，向 <code>ScheduledTaskRegistrar</code> 注册一个 <code>ThreadPoolTaskScheduler</code> 任务线程对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleConfiguration</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ScheduleConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        taskRegistrar.setTaskScheduler(taskScheduler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">taskScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskScheduler taskScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">        taskScheduler.setPoolSize(<span class="number">4</span>);</span><br><span class="line">        taskScheduler.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(<span class="string">"schedule"</span>);</span><br><span class="line">        taskScheduler.setRemoveOnCancelPolicy(<span class="keyword">true</span>);</span><br><span class="line">        taskScheduler.setErrorHandler(t -&gt; LOGGER.error(<span class="string">"Error occurs"</span>, t));</span><br><span class="line">        <span class="keyword">return</span> taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 引用，上面 <code>SpringTaskService</code> 配置的 <code>4</code> 个定时任务会同时生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2018-06-20 20:37:50.746  INFO 8142 --- [      schedule1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 1 <span class="built_in">times</span> at fixed rate</span><br><span class="line">2018-06-20 20:38:00.001  INFO 8142 --- [      schedule3] i.o.s.sample.spring.SpringTaskService    : Schedule executor 2 <span class="built_in">times</span> with </span><br><span class="line">2018-06-20 20:38:00.751  INFO 8142 --- [      schedule1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 3 <span class="built_in">times</span> at fixed rate</span><br><span class="line">2018-06-20 20:38:02.748  INFO 8142 --- [      schedule2] i.o.s.sample.spring.SpringTaskService    : Schedule executor 4 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-20 20:38:10.005  INFO 8142 --- [      schedule4] i.o.s.sample.spring.SpringTaskService    : Schedule executor 5 <span class="built_in">times</span> with </span><br><span class="line">2018-06-20 20:38:10.747  INFO 8142 --- [      schedule3] i.o.s.sample.spring.SpringTaskService    : Schedule executor 6 <span class="built_in">times</span> at fixed rate</span><br><span class="line">2018-06-20 20:38:20.002  INFO 8142 --- [      schedule2] i.o.s.sample.spring.SpringTaskService    : Schedule executor 7 <span class="built_in">times</span> with </span><br><span class="line">2018-06-20 20:38:20.747  INFO 8142 --- [      schedule4] i.o.s.sample.spring.SpringTaskService    : Schedule executor 8 <span class="built_in">times</span> at fixed rate</span><br></pre></td></tr></table></figure><p>观察日志，<strong>线程名前缀</strong> 为 <code>schedule</code>，可以发现 <code>Spring Task</code> 将 <code>@Scheduled</code> 注解配置的 <code>4</code> 个任务，分发给我们配置的 <code>ThreadPoolTaskScheduler</code> 中的 <code>4</code> 个线程并发执行。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了基于单节点的定时任务调度及实现，包括 <code>JDK</code> 原生的 <code>Timer</code> 和 <code>ScheduledExecutorService</code>，以及 <code>Spring 3.0</code> 以后自带的基于注解的 <code>Spring Task</code> 任务调度方式。除此之外，重点阐述了基于 <strong>固定延时</strong>、<strong>固定频率</strong> 和 <code>cron</code> <strong>表达式</strong> 的不同之处，并对 <code>ScheduledExecutorService</code> 和 <code>Spring Scheduler</code> 的 <strong>线程池并发处理</strong> 进行了测试。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/1640df3c27eedf87?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定时任务&lt;/strong&gt; 一般会存在 &lt;strong&gt;中大型企业级&lt;/strong&gt; 项目中，为了减少 &lt;strong&gt;服务器&lt;/strong&gt;、&lt;strong&gt;数据库&lt;/strong&gt; 的压力，往往会以 &lt;strong&gt;定时任务&lt;/strong&gt; 的方式去完成某些业务逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Quartz" scheme="https://ostenant.coding.me/tags/Quartz/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
      <category term="定时任务" scheme="https://ostenant.coding.me/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="Spring Task" scheme="https://ostenant.coding.me/tags/Spring-Task/"/>
    
      <category term="Timer" scheme="https://ostenant.coding.me/tags/Timer/"/>
    
      <category term="ScheduledExecutorService" scheme="https://ostenant.coding.me/tags/ScheduledExecutorService/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(五) - Listener, Servlet和Filter, Controller和Interceptor</title>
    <link href="https://ostenant.coding.me/2018/06/20/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%BA%94)%20-%20Listener,%20Servlet%E5%92%8CFilter,%20Controller%E5%92%8CInterceptor/"/>
    <id>https://ostenant.coding.me/2018/06/20/实战Spring Boot 2.0系列(五) - Listener, Servlet和Filter, Controller和Interceptor/</id>
    <published>2018-06-20T11:20:00.000Z</published>
    <updated>2018-07-05T12:46:15.992Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用户认证授权、日志记录 <code>MDC</code>、编码解码、<code>UA</code> 检查、多端对应等都需要通过 <strong>拦截请求</strong> 来进行处理。这时就需要 <code>Servlet</code>、<code>Filter</code>、<code>Listener</code>、<code>Interceptor</code> 这几种组件。而把非 <code>Spring Boot</code> 项目转换成 <code>Spring Boot</code> 项目，需要沿用以前的这些代码，所以有必要了解这它们的 <strong>用法</strong> 和 <strong>生命周期</strong>。 </p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413255f98b30e7?w=620&amp;h=595&amp;f=png&amp;s=81732" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-几种组件介绍"><a href="#1-几种组件介绍" class="headerlink" title="1. 几种组件介绍"></a>1. 几种组件介绍</h2><h3 id="1-1-监听器Listener"><a href="#1-1-监听器Listener" class="headerlink" title="1.1. 监听器Listener"></a>1.1. 监听器Listener</h3><p><code>Listener</code> 可以监听 <code>web</code> 服务器中某一个 <strong>事件操作</strong>，并触发注册的 <strong>回调函数</strong>。通俗的语言就是在 <code>application</code>，<code>session</code>，<code>request</code> 三个对象 <strong>创建/消亡</strong> 或者 <strong>增删改</strong> 属性时，自动执行代码的功能组件。</p><h3 id="1-2-Servlet"><a href="#1-2-Servlet" class="headerlink" title="1.2. Servlet"></a>1.2. Servlet</h3><p><code>Servlet</code> 是一种运行 <strong>服务器端</strong> 的 <code>java</code> 应用程序，具有 <strong>独立于平台和协议</strong> 的特性，并且可以动态的生成 <code>web</code> 页面，它工作在 <strong>客户端请求</strong> 与 <strong>服务器响应</strong> 的中间层。</p><h3 id="1-3-过滤器Filter"><a href="#1-3-过滤器Filter" class="headerlink" title="1.3. 过滤器Filter"></a>1.3. 过滤器Filter</h3><p><code>Filter</code> 对 <strong>用户请求</strong> 进行 <strong>预处理</strong>，接着将请求交给 <code>Servlet</code> 进行 <strong>处理</strong> 并 <strong>生成响应</strong>，最后 <code>Filter</code> 再对 <strong>服务器响应</strong> 进行 <strong>后处理</strong>。<code>Filter</code> 是可以复用的代码片段，常用来转换 <code>HTTP</code> <strong>请求</strong>、<strong>响应</strong> 和 <strong>头信息</strong>。<code>Filter</code> 不像 <code>Servlet</code>，它不能产生 <strong>响应</strong>，而是只 <strong>修改</strong> 对某一资源的 <strong>请求</strong> 或者 <strong>响应</strong>。</p><h3 id="1-4-拦截器Interceptor"><a href="#1-4-拦截器Interceptor" class="headerlink" title="1.4. 拦截器Interceptor"></a>1.4. 拦截器Interceptor</h3><p>类似 <strong>面向切面编程</strong> 中的 <strong>切面</strong> 和 <strong>通知</strong>，我们通过 <strong>动态代理</strong> 对一个 <code>service()</code> 方法添加 <strong>通知</strong> 进行功能增强。比如说在方法执行前进行 <strong>初始化处理</strong>，在方法执行后进行 <strong>后置处理</strong>。<strong>拦截器</strong> 的思想和 <code>AOP</code> 类似，区别就是 <strong>拦截器</strong> 只能对 <code>Controller</code> 的 <code>HTTP</code> 请求进行拦截。</p><h2 id="2-过滤器-VS-拦截器"><a href="#2-过滤器-VS-拦截器" class="headerlink" title="2. 过滤器 VS 拦截器"></a>2. 过滤器 VS 拦截器</h2><h3 id="2-1-两者的区别"><a href="#2-1-两者的区别" class="headerlink" title="2.1. 两者的区别"></a>2.1. 两者的区别</h3><ol><li><p><code>Filter</code> 是基于 <strong>函数回调</strong>的，而 <code>Interceptor</code> 则是基于 <code>Java</code> <strong>反射</strong> 和 <strong>动态代理</strong>。</p></li><li><p><code>Filter</code> 依赖于 <code>Servlet</code> 容器，而 <code>Interceptor</code> 不依赖于 <code>Servlet</code> 容器。</p></li><li><p><code>Filter</code> 对几乎 <strong>所有的请求</strong> 起作用，而 <code>Interceptor</code> 只对 <code>Controller</code> 对请求起作用。</p></li></ol><h3 id="2-2-执行顺序"><a href="#2-2-执行顺序" class="headerlink" title="2.2. 执行顺序"></a>2.2. 执行顺序</h3><p>对于自定义 <code>Servlet</code> 对请求分发流程：</p><ol><li><code>Filter</code> 过滤请求处理；</li><li><code>Servlet</code> 处理请求；</li><li><code>Filter</code> 过滤响应处理。</li></ol><p>对于自定义 <code>Controller</code> 的请求分发流程：</p><ol><li><code>Filter</code> 过滤请求处理；</li><li><code>Interceptor</code> 拦截请求处理；</li><li>对应的 <code>HandlerAdapter</code> 处理请求；</li><li><code>Interceptor</code> 拦截响应处理；</li><li><code>Interceptor</code> 的最终处理；</li><li><code>Filter</code> 过滤响应处理。</li></ol><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3. 环境准备"></a>3. 环境准备</h2><h3 id="配置gradle依赖"><a href="#配置gradle依赖" class="headerlink" title="配置gradle依赖"></a>配置gradle依赖</h3><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-web-async-task</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置启动入口类"><a href="#配置启动入口类" class="headerlink" title="配置启动入口类"></a>配置启动入口类</h3><p>配置一个 <code>Spring Boot</code> 启动入口类，这里需要配置两个注解。</p><ul><li><p>@ServletComponentScan: 允许 <code>Spring Boot</code> 扫描和装载当前 <strong>包路径</strong> 和 <strong>子路径</strong> 下配置的 <code>Servlet</code>。</p></li><li><p>@EnableWvc: 允许 <code>Spring Boot</code> 配置 <code>Spring MVC</code> 相关自定义的属性，比如：拦截器、资源处理器、消息转换器等。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-配置监听器Listener"><a href="#4-配置监听器Listener" class="headerlink" title="4. 配置监听器Listener"></a>4. 配置监听器Listener</h2><p>配置一个 <code>ServletContext</code> 监听器，使用 <code>@WebListener</code> 标示即可。在 <code>Servlet</code> 容器 <strong>初始化</strong> 过程中，<code>contextInitialized()</code> 方法会被调用，在容器 <strong>销毁</strong> 时会调用 <code>contextDestroyed()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexServletContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(IndexServletContextListener.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INITIAL_CONTENT = <span class="string">"Content created in servlet Context"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Start to initialize servlet context"</span>);</span><br><span class="line">        ServletContext servletContext = sce.getServletContext();</span><br><span class="line">        servletContext.setAttribute(<span class="string">"content"</span>, INITIAL_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Destroy servlet context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在容器初始化时，往 <code>ServletContext</code> 上下文设置了参数名称为 <code>INITIAL_CONTENT</code>，可以全局直接访问。</p><h2 id="5-配置Servlet"><a href="#5-配置Servlet" class="headerlink" title="5. 配置Servlet"></a>5. 配置Servlet</h2><p>配置 <code>IndexHttpServlet</code>，重写 <code>HttpServlet</code> 的 <code>doGet()</code> 方法，直接输出 <code>IndexHttpServlet</code> 定义的 <strong>初始化参数</strong> 和在 <code>IndexServletContextListener</code> 设置的 <code>ServletContext</code> 上下文参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"IndexHttpServlet"</span>,</span><br><span class="line">        displayName = <span class="string">"indexHttpServlet"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"/index/IndexHttpServlet"</span>&#125;,</span><br><span class="line">        initParams = &#123;</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"createdBy"</span>, value = <span class="string">"Icarus"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"createdOn"</span>, value = <span class="string">"2018-06-20"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexHttpServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        resp.getWriter().println(format(<span class="string">"Created by %s"</span>, getInitParameter(<span class="string">"createdBy"</span>)));</span><br><span class="line">        resp.getWriter().println(format(<span class="string">"Created on %s"</span>, getInitParameter(<span class="string">"createdOn"</span>)));</span><br><span class="line">        resp.getWriter().println(format(<span class="string">"Servlet context param: %s"</span>,</span><br><span class="line">                req.getServletContext().getAttribute(<span class="string">"content"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 <code>@WebServlet</code> 注解用于注册这个 <code>Servlet</code>，<code>@WebServlet</code> 注解的 <strong>各个参数</strong> 分别对应 <code>web.xml</code> 中的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>IndexHttpServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index/IndexHttpServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>IndexHttpServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>io.ostenant.springboot.sample.servlet.IndexHttpServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>createdBy<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Icarus<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>createdOn<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2018-06-20<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-配置过滤器Filter"><a href="#6-配置过滤器Filter" class="headerlink" title="6. 配置过滤器Filter"></a>6. 配置过滤器Filter</h2><p>一个 <code>Servlet</code> 请求可以经由多个 <code>Filter</code> 进行过滤，最终由 <code>Servlet</code> 处理并响应客户端。这里配置两个过滤器示例：</p><p>FirstIndexFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"firstIndexFilter"</span>,</span><br><span class="line">        displayName = <span class="string">"firstIndexFilter"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"/index/*"</span>&#125;,</span><br><span class="line">        initParams = <span class="meta">@WebInitParam</span>(</span><br><span class="line">                name = <span class="string">"firstIndexFilterInitParam"</span>,</span><br><span class="line">                value = <span class="string">"io.ostenant.springboot.sample.filter.FirstIndexFilter"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstIndexFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FirstIndexFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Register a new filter &#123;&#125;"</span>, filterConfig.getFilterName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexFilter pre filter the request"</span>);</span><br><span class="line">        String filter = request.getParameter(<span class="string">"filter1"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(filter)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by firstIndexFilter, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"filter1\""</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexFilter post filter the response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Destroy filter &#123;&#125;"</span>, getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 <code>@WebFilter</code> 相关的配置属性，对应于 <code>web.xml</code> 的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>firstIndexFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>io.ostenant.springboot.sample.filter.FirstIndexFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>firstIndexFilterInitParam<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>io.ostenant.springboot.sample.filter.FirstIndexFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 <code>FirstIndexFilter</code>，使用 <code>@WebFilter</code> 注解进行标示。当 <code>FirstIndexFilter</code> 初始化时，会执行 <code>init()</code> 方法。每次请求路径匹配 <code>urlPatterns</code> 配置的路径时，就会进入 <code>doFilter()</code> 方法进行具体的 <strong>请求</strong> 和 <strong>响应过滤</strong>。</p><p>当 <code>HTTP</code> 请求携带 <code>filter1</code> 参数时，请求会被放行；否则，直接 <strong>过滤中断</strong>，结束请求处理。</p><p>SecondIndexFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"secondIndexFilter"</span>,</span><br><span class="line">        displayName = <span class="string">"secondIndexFilter"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"/index/*"</span>&#125;,</span><br><span class="line">        initParams = <span class="meta">@WebInitParam</span>(</span><br><span class="line">                name = <span class="string">"secondIndexFilterInitParam"</span>,</span><br><span class="line">                value = <span class="string">"io.ostenant.springboot.sample.filter.SecondIndexFilter"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondIndexFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SecondIndexFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Register a new filter &#123;&#125;"</span>, filterConfig.getFilterName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexFilter pre filter the request"</span>);</span><br><span class="line">        String filter = request.getParameter(<span class="string">"filter2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(filter)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by firstIndexFilter, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"filter2\""</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexFilter post filter the response"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Destroy filter &#123;&#125;"</span>, getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 <code>@WebFilter</code> 相关的配置属性，对应于 <code>web.xml</code> 的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>secondIndexFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>io.ostenant.springboot.sample.filter.SecondIndexFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>secondIndexFilterInitParam<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>io.ostenant.springboot.sample.filter.SecondIndexFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 <code>SecondIndexFilter</code>，使用 <code>@WebFilter</code> 注解进行标示。当 <code>SecondIndexFilter</code> 初始化时，会执行 <code>init()</code> 方法。每次请求路径匹配 <code>urlPatterns</code> 配置的路径时，就会进入 <code>doFilter()</code> 方法进行具体的 <strong>请求</strong> 和 <strong>响应过滤</strong>。</p><p>当 <code>HTTP</code> 请求携带 <code>filter2</code> 参数时，请求会被放行；否则，直接 <strong>过滤中断</strong>，结束请求处理。</p><p>来看看 <code>doFilter()</code> 最核心的三个参数：</p><ul><li>ServletRequest: 未到达 <code>Servlet</code> 的 <code>HTTP</code> 请求； </li><li>ServletResponse: 由 <code>Servlet</code> 处理并生成的 <code>HTTP</code> 响应；</li><li>FilterChain: <strong>过滤器链</strong> 对象，可以按顺序注册多个 <strong>过滤器</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterChain.doFilter(request, response);</span><br></pre></td></tr></table></figure><blockquote><p><strong>解释：</strong> 一个 <strong>过滤器链</strong> 对象可以按顺序注册多个 <strong>过滤器</strong>。符合当前过滤器过滤条件，即请求 <strong>过滤成功</strong> 直接放行，则交由下一个 <strong>过滤器</strong> 进行处理。所有请求过滤完成以后，由 <code>IndexHttpServlet</code> 处理并生成 <strong>响应</strong>，然后在 <strong>过滤器链</strong> 以相反的方向对 <strong>响应</strong> 进行后置过滤处理。</p></blockquote><h3 id="配置控制器Controller"><a href="#配置控制器Controller" class="headerlink" title="配置控制器Controller"></a>配置控制器Controller</h3><p>配置 <code>IndexController</code>，用于测试 <code>/index/IndexController</code> 路径是否会被 <code>Filter</code> 过滤和 <code>Interceptor</code> 拦截，并验证两者的先后顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"IndexController"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"IndexController"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-配置拦截器Interceptor"><a href="#7-配置拦截器Interceptor" class="headerlink" title="7. 配置拦截器Interceptor"></a>7. 配置拦截器Interceptor</h2><p>拦截器 <code>Interceptor</code> 只对 <code>Handler</code> 生效。<code>Spring MVC</code> 会为 <code>Controller</code> 中的每个 <strong>请求方法</strong> 实例化为一个 <code>Handler</code>对象，由 <code>HandlerMapping</code> 对象路由请求到具体的 <code>Handler</code>，然后由 <code>HandlerAdapter</code> 通过反射进行请求 <strong>处理</strong> 和 <strong>响应</strong>，这中间就穿插着 <strong>拦截处理</strong>。</p><h4 id="编写拦截器"><a href="#编写拦截器" class="headerlink" title="编写拦截器"></a>编写拦截器</h4><p>为了区分日志，下面同样对 <code>IndexController</code> 配置两个拦截器类：</p><p>FirstIndexInterceptor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstIndexInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FirstIndexInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexInterceptor pre intercepted the request"</span>);</span><br><span class="line">        String interceptor = request.getParameter(<span class="string">"interceptor1"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(interceptor)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by FirstIndexFilter, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"interceptor1\""</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexInterceptor post intercepted the response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexInterceptor do something after request completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecondIndexInterceptor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondIndexInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SecondIndexInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexInterceptor pre intercepted the request"</span>);</span><br><span class="line">        String interceptor = request.getParameter(<span class="string">"interceptor2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(interceptor)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by SecondIndexInterceptor, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"interceptor2\""</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexInterceptor post intercepted the response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexInterceptor do something after request completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h4><p>在 <code>Spring Boot</code> 中 <strong>配置拦截器</strong> 很简单，只需要实现 <code>WebMvcConfigurer</code> 接口，在 <code>addInterceptors()</code> 方法中通过 <code>InterceptorRegistry</code> 添加 <strong>拦截器</strong> 和 <strong>匹配路径</strong> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(WebConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> FirstIndexInterceptor()).addPathPatterns(<span class="string">"/index/**"</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> SecondIndexInterceptor()).addPathPatterns(<span class="string">"/index/**"</span>);</span><br><span class="line">        LOGGER.info(<span class="string">"Register FirstIndexInterceptor and SecondIndexInterceptor onto InterceptorRegistry"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>Spring XML</code> 配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"firstIndexInterceptor"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"io.ostenant.springboot.sample.interceptor.FirstIndexInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"secondIndexInterceptor"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"io.ostenant.springboot.sample.interceptor.SecondIndexInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/index/**"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"firstIndexInterceptor"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/index/**"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"secondIndexInterceptor"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h4><p>我们通过实现 <code>HandlerInterceptor</code> 接口来开发一个 <strong>拦截器</strong>，来看看 <code>HandlerInterceptor</code> 接口的三个重要的方法：</p><ul><li><p>preHandle(): 在 <code>controller</code> 接收请求、处理 <code>request</code> 之前执行，返回值为 <code>boolean</code>，返回值为 <code>true</code> 时接着执行 <code>postHandle()</code> 和 <code>afterCompletion()</code> 方法；如果返回 <code>false</code> 则 <strong>中断</strong> 执行。</p></li><li><p>postHandle(): 在 <code>controller</code> 处理请求之后， <code>ModelAndView</code> 处理前执行，可以对 <strong>响应结果</strong> 进行修改。</p></li><li><p>afterCompletion(): 在 <code>DispatchServlet</code> 对本次请求处理完成，即生成 <code>ModelAndView</code> 之后执行。</p></li></ul><p>下面简单的看一下 <code>Spring MVC</code> 中心调度器 <code>DispatcherServlet</code> 的 <code>doDispatch()</code> 方法的原理，重点关注 <strong>拦截器</strong> 的以上三个方法的执行顺序。</p><ul><li>doDispatch(): <code>DispatchServlet</code> 处理请求分发的核心方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 按从前往后的顺序调用各个拦截器preHandle()方法</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. HandlerAdapter开始真正的请求处理并生产响应视图对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 按照从后往前的顺序依次调用各个拦截器的postHandle()方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 4. 最终会调用拦截器的afterCompletion()方法</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        <span class="comment">// 4. 最终会调用拦截器的afterCompletion()方法</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面注释的几个 <code>HandlerExecutionChain</code> 的方法: <code>applyPreHandle()</code>、<code>applyPostHandle()</code> 和 <code>triggerAfterCompletion()</code>。 </p></blockquote><ul><li>applyPreHandle(): 按 <strong>从前往后</strong> 的顺序调用各个拦截器的 <code>preHandle()</code> 方法。任意一个 <code>HandlerInterceptor</code> 拦截返回 <code>false</code> ，则 <code>preHandle()</code> 返回 <code>false</code>，记录拦截器的位置 <code>interceptorIndex</code>，然后中断拦截处理，最终触发 <code>AfterCompletion()</code> 方法并返回 <code>false</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</span><br><span class="line">                triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.interceptorIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>applyPostHandle(): 按照 <strong>从后往前</strong> 的顺序依次调用各个拦截器的 <code>postHandle()</code> 方法。只有当所有 <code>HandlerInterceptor</code> 的 <code>preHandle()</code> 方法返回 <code>true</code> 时，才有机会执行到 <code>applyPostHandle()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>triggerAfterCompletion: <code>triggerAfterCompletion()</code> 只在 <code>preHandle()</code> 方法返回 <code>false</code> 和 <strong>程序抛出异常</strong> 时执行。在 <code>preHandle()</code> 方法中，通过 <code>interceptorIndex</code> 记录了返回 <code>false</code> 的 <strong>拦截器索引</strong>。一旦 <code>applyPreHandle()</code> 方法返回 <code>false</code>，则从当前返回 <code>false</code> 的拦截器 <strong>从后往前</strong> 的执行 <code>afterCompletion()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interceptor.afterCompletion(request, response, <span class="keyword">this</span>.handler, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">"HandlerInterceptor.afterCompletion threw exception"</span>, ex2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-开始测试"><a href="#8-开始测试" class="headerlink" title="8. 开始测试"></a>8. 开始测试</h2><h3 id="生命周期测试"><a href="#生命周期测试" class="headerlink" title="生命周期测试"></a>生命周期测试</h3><p>启动 <code>Spring Boot</code> 应用程序，观察启动时的程序日志，下面我按照 <strong>顺序</strong> 来分析启动过程中完成了哪些事情。</p><ul><li>注册 <code>Spring MVC</code> 的 <code>dispatcherServlet</code> 和自定义的 <code>IndexHttpServlet</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.400  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Servlet dispatcherServlet mapped to [/]</span><br><span class="line">2018-06-23 09:39:55.404  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Servlet IndexHttpServlet mapped to [/index/IndexHttpServlet]</span><br></pre></td></tr></table></figure><blockquote><p>注意: <code>dispatcherServlet</code> 的 <code>load-up-onstartup</code> 为 <code>1</code>，会优先于其他 <code>Servlet</code> 进行加载。</p></blockquote><ul><li>按照先后顺序，将所有的过滤器 <code>Filter</code> 对象与路径进行映射，其中 <code>characterEncodingFilter</code> 是 <code>Spring MVC</code> 自带的解决乱码的 <code>Filter</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.408  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: <span class="string">'characterEncodingFilter'</span> to: [/*]</span><br><span class="line">2018-06-23 09:39:55.409  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: <span class="string">'firstIndexFilter'</span> to urls: [/index/*]</span><br><span class="line">2018-06-23 09:39:55.409  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: <span class="string">'secondIndexFilter'</span> to urls: [/index/*]</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>IndexServletContextListener</code>，并执行 <code>contextInitialized()</code> 方法进行上下文初始化操作。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.429  INFO 12301 --- [ost-startStop-1] i.o.s.s.l.IndexServletContextListener    : Start to initialize servlet context</span><br></pre></td></tr></table></figure><ul><li>依次执行 <code>Filter</code> 的 <code>init()</code> 方法进行初始化处理。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.432  INFO 12301 --- [ost-startStop-1] i.o.s.sample.filter.SecondIndexFilter     : Register a new filter secondIndexFilter</span><br><span class="line">2018-06-23 09:39:55.434  INFO 12301 --- [ost-startStop-1] i.o.s.sample.filter.FirstIndexFilter      : Register a new filter firstIndexFilter</span><br></pre></td></tr></table></figure><ul><li>创建、初始化拦截器，并统一注册到 <code>InterceptorRegistry</code> 上。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.502  INFO 13150 --- [           main] i.o.s.s.interceptor.WebConfiguration     : Register FirstIndexInterceptor and SecondIndexInterceptor onto InterceptorRegistry</span><br></pre></td></tr></table></figure><ul><li>对 <code>IndexController</code> 进行处理，把 <strong>请求</strong> <code>URI</code> 和 <strong>处理方法</strong> 映射到 <code>HandlerMapping</code> 上并进行缓存。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.541  INFO 12301 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped <span class="string">"&#123;[/index/IndexController],methods=[GET]&#125;"</span> onto public java.lang.String io.ostenant.springboot.sample.controller.IndexController.index() throws java.lang.Exception</span><br></pre></td></tr></table></figure><p>关闭 <code>Spring Boot</code> 应用程序时，观察输出日志如下: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 10:07:03.294  INFO 12301 --- [ost-startStop-2] i.o.s.sample.filter.FirstIndexFilter     : Destroy filter io.ostenant.springboot.sample.filter.SecondIndexFilter</span><br><span class="line">2018-06-23 10:07:03.294  INFO 12301 --- [ost-startStop-2] i.o.s.sample.filter.FirstIndexFilter     : Destroy filter io.ostenant.springboot.sample.filter.FirstIndexFilter</span><br><span class="line">2018-06-23 10:07:03.294  INFO 12301 --- [ost-startStop-2] i.o.s.s.l.IndexServletContextListener    : Destroy servlet context</span><br></pre></td></tr></table></figure><p>可以看到上面配置的过滤器的 <code>destroy()</code> 方法和 <code>IndexServletContextListener</code> 的 <code>contextDestroyed()</code> 方法都被调用了。</p><h3 id="访问控制测试"><a href="#访问控制测试" class="headerlink" title="访问控制测试"></a>访问控制测试</h3><h4 id="Servlet测试"><a href="#Servlet测试" class="headerlink" title="Servlet测试"></a>Servlet测试</h4><p>访问 <a href="http://localhost:8080/index/IndexHttpServlet" target="_blank" rel="noopener">http://localhost:8080/index/IndexHttpServlet</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b22951f75288?w=2056&amp;h=132&amp;f=png&amp;s=36514" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexHttpServlet?filter1=filter1" target="_blank" rel="noopener">http://localhost:8080/index/IndexHttpServlet?filter1=filter1</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b2294f07adf2?w=2052&amp;h=130&amp;f=png&amp;s=38121" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexHttpServlet?filter1=filter1&amp;filter2=filter2" target="_blank" rel="noopener">http://localhost:8080/index/IndexHttpServlet?filter1=filter1&amp;filter2=filter2</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b22951104958?w=2048&amp;h=196&amp;f=png&amp;s=52106" alt=""></p><p>观察控制台输出日志，验证 <strong>过滤器</strong> 的过滤顺序正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter post filter the response</span><br><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter post filter the response</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong> 自定义的 <strong>过滤器</strong> 对 <code>IndexHttpServlet</code> 生效， 而 <strong>自定义</strong> 的拦截器生效。</p></blockquote><h4 id="controller测试"><a href="#controller测试" class="headerlink" title="controller测试"></a>controller测试</h4><p>访问 <a href="http://localhost:8080/index/IndexController" target="_blank" rel="noopener">http://localhost:8080/index/IndexController</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b2294fc8a36c?w=2052&amp;h=132&amp;f=png&amp;s=35303" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b2294fecf208?w=2042&amp;h=138&amp;f=png&amp;s=37551" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b229509d83f4?w=2052&amp;h=144&amp;f=png&amp;s=40857" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b229770dcdc4?w=2048&amp;h=142&amp;f=png&amp;s=45156" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1&amp;interceptor2=interceptor2" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1&amp;interceptor2=interceptor2</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b22976f450d8?w=2050&amp;h=144&amp;f=png&amp;s=36973" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 10:21:42.533  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:21:42.533  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:21:42.534  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.FirstIndexInterceptor          : FirstIndexInterceptor pre intercepted the request</span><br><span class="line">2018-06-23 10:21:42.534  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.SecondIndexInterceptor         : SecondIndexInterceptor pre intercepted the request</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.SecondIndexInterceptor         : SecondIndexInterceptor post intercepted the response</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.FirstIndexInterceptor          : FirstIndexInterceptor post intercepted the response</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.SecondIndexInterceptor         : SecondIndexInterceptor <span class="keyword">do</span> something after request completed</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.FirstIndexInterceptor          : FirstIndexInterceptor <span class="keyword">do</span> something after request completed</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter post filter the response</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter post filter the response</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong> 自定义的 <strong>过滤器</strong> 和 <strong>拦截器</strong> 对 <strong>控制器</strong> <code>Controller</code> 生效。而 <strong>过滤器</strong> 的优先级高于 <strong>拦截器</strong>。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文详细介绍了 <code>Listener</code>，<code>Servlet</code>，<code>Filter</code>，<code>Controller</code> 和 <code>Interceptor</code> 等 <code>Web</code> 多种组件的功能、方法、顺序、作用域和生命周期。给出了详细的示例代码，结合 <strong>源码</strong> 分析了流程，结合 <strong>测试</strong> 验证了结论。长篇大论，希望大家对 <code>Servlet</code> 组件和 <code>Spring MVC</code> 的框架组件有了更清晰的认识。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/1640df3c27eedf87?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;用户认证授权、日志记录 &lt;code&gt;MDC&lt;/code&gt;、编码解码、&lt;code&gt;UA&lt;/code&gt; 检查、多端对应等都需要通过 &lt;strong&gt;拦截请求&lt;/strong&gt; 来进行处理。这时就需要 &lt;code&gt;Servlet&lt;/code&gt;、&lt;code&gt;Filter&lt;/code&gt;、&lt;code&gt;Listener&lt;/code&gt;、&lt;code&gt;Interceptor&lt;/code&gt; 这几种组件。而把非 &lt;code&gt;Spring Boot&lt;/code&gt; 项目转换成 &lt;code&gt;Spring Boot&lt;/code&gt; 项目，需要沿用以前的这些代码，所以有必要了解这它们的 &lt;strong&gt;用法&lt;/strong&gt; 和 &lt;strong&gt;生命周期&lt;/strong&gt;。 &lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
      <category term="Listener" scheme="https://ostenant.coding.me/tags/Listener/"/>
    
      <category term="Servlet" scheme="https://ostenant.coding.me/tags/Servlet/"/>
    
      <category term="Filter" scheme="https://ostenant.coding.me/tags/Filter/"/>
    
      <category term="Interceptor" scheme="https://ostenant.coding.me/tags/Interceptor/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(四) - 使用WebAsyncTask处理异步任务</title>
    <link href="https://ostenant.coding.me/2018/06/18/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E5%9B%9B)%20-%20%E4%BD%BF%E7%94%A8WebAsyncTask%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>https://ostenant.coding.me/2018/06/18/实战Spring Boot 2.0系列(四) - 使用WebAsyncTask处理异步任务/</id>
    <published>2018-06-18T00:20:00.000Z</published>
    <updated>2018-06-18T14:08:49.695Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文介绍了基于 <code>@Async</code> 注解的 <strong>异步调用编程</strong>，本文将继续引入 <code>Spring Boot</code> 的 <code>WebAsyncTask</code> 进行更灵活异步任务处理，包括 <strong>异步回调</strong>，<strong>超时处理</strong> 和 <strong>异常处理</strong>。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413255f98b30e7?w=620&amp;h=595&amp;f=png&amp;s=81732" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-处理线程和异步线程"><a href="#1-处理线程和异步线程" class="headerlink" title="1. 处理线程和异步线程"></a>1. 处理线程和异步线程</h2><p>在开始下面的讲解之前，在这里先区别下两个概念：</p><ol><li><p>处理线程：<strong>处理线程</strong> 属于 <code>web</code> 服务器线程，负责 <strong>处理用户请求</strong>，采用 <strong>线程池</strong> 管理。</p></li><li><p>异步线程：<strong>异步线程</strong> 属于 <strong>用户自定义的线程</strong>，可采用 <strong>线程池管理</strong>。</p></li></ol><p><code>Spring</code> 提供了对 <strong>异步任务</strong> <code>API</code>，采用 <code>WebAsyncTask</code> 类即可实现 <strong>异步任务</strong>。对异步任务设置相应的 <strong>回调处理</strong>，如当 <strong>任务超时</strong>、<strong>异常抛出</strong> 等。异步任务通常非常实用，比如：当一笔订单支付完成之后，开启异步任务查询订单的支付结果。</p><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h2><h3 id="配置gradle依赖"><a href="#配置gradle依赖" class="headerlink" title="配置gradle依赖"></a>配置gradle依赖</h3><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-web-async-task</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置服务类"><a href="#配置服务类" class="headerlink" title="配置服务类"></a>配置服务类</h3><p>配置一个用于异步任务调度的 <code>Mock</code>   服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置异步处理控制器并注入以上服务 <code>Bean</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAsyncController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebAsyncService asyncService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ERROR_MESSAGE = <span class="string">"Task error"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TIME_MESSAGE = <span class="string">"Task timeout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebAsyncController</span><span class="params">(WebAsyncService asyncService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.asyncService = asyncService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-正常异步任务"><a href="#3-正常异步任务" class="headerlink" title="3. 正常异步任务"></a>3. 正常异步任务</h2><p>配置一个正常的 <code>WebAsyncTask</code> 任务对象，设置任务 <strong>超时时间</strong> 为 <code>10s</code>。异步任务执行采用 <code>Thread.sleep(long)</code> 模拟，这里设置 <strong>异步线程</strong> 睡眠时间为 <code>5s</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/completion"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印处理线程名</span></span><br><span class="line">    out.println(format(<span class="string">"请求处理线程：%s"</span>, currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟开启一个异步任务，超时时间为10s</span></span><br><span class="line">    WebAsyncTask&lt;String&gt; asyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, () -&gt; &#123;</span><br><span class="line">        out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">        <span class="comment">// 任务处理时间5s，不超时</span></span><br><span class="line">        sleep(<span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">return</span> asyncService.generateUUID();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行完成时调用该方法</span></span><br><span class="line">    asyncTask.onCompletion(() -&gt; out.println(<span class="string">"任务执行完成"</span>));</span><br><span class="line">    out.println(<span class="string">"继续处理其他事情"</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 项目，访问 <a href="http://localhost:8080/completion" target="_blank" rel="noopener">http://localhost:8080/completion</a> ，发起 <strong>正常</strong> 的异步任务请求。</p><p>观察控制台输出，可以验证 <code>WebAsyncTask</code> 的异步处理流程正常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求处理线程：http-nio-8080-exec-2</span><br><span class="line">继续处理其他事情</span><br><span class="line">异步工作线程：MvcAsync1</span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure><p><code>Web</code> 页面正常响应，页面响应消息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413283f62bb949?w=2052&amp;h=152&amp;f=png&amp;s=32271" alt=""></p><blockquote><p>注意：WebAsyncTask.onCompletion(Runnable) ：在当前任务执行结束以后，无论是执行成功还是异常中止，onCompletion的回调最终都会被调用。</p></blockquote><h2 id="4-抛出异常异步任务"><a href="#4-抛出异常异步任务" class="headerlink" title="4. 抛出异常异步任务"></a>4. 抛出异常异步任务</h2><p>配置一个 <strong>错误</strong> 的 <code>WebAsyncTask</code> 任务对象，设置任务 <strong>超时时间</strong> 为 <code>10s</code>。在异步任务执行方法中 <strong>抛出异常</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/exception"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印处理线程名</span></span><br><span class="line">    out.println(format(<span class="string">"请求处理线程：%s"</span>, currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟开启一个异步任务，超时时间为10s</span></span><br><span class="line">    WebAsyncTask&lt;String&gt; asyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, () -&gt; &#123;</span><br><span class="line">        out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">        <span class="comment">// 任务处理时间5s，不超时</span></span><br><span class="line">        sleep(<span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(ERROR_MESSAGE);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行完成时调用该方法</span></span><br><span class="line">    asyncTask.onCompletion(() -&gt; out.println(<span class="string">"任务执行完成"</span>));</span><br><span class="line">    asyncTask.onError(() -&gt; &#123;</span><br><span class="line">        out.println(<span class="string">"任务执行异常"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR_MESSAGE;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">"继续处理其他事情"</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 项目，访问 <a href="http://localhost:8080/exception" target="_blank" rel="noopener">http://localhost:8080/exception</a> ，发起 <strong>异常</strong> 的异步任务请求。</p><p><code>Web</code> 页面响应异常信息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413283fa3d4c0d?w=2050&amp;h=370&amp;f=png&amp;s=80643" alt=""></p><p>观察控制台输出，可以验证 <code>WebAsyncTask</code> 对于 <strong>异常请求</strong> 的异步处理过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">请求处理线程：http-nio-8080-exec-1</span><br><span class="line">继续处理其他事情</span><br><span class="line">异步工作线程：MvcAsync2</span><br><span class="line">2018-06-18 21:12:10.110 ERROR 89875 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] threw exception</span><br><span class="line"></span><br><span class="line">java.lang.Exception: Task error</span><br><span class="line">at io.ostenant.springboot.sample.controller.WebAsyncController.lambda<span class="variable">$asyncTaskException</span><span class="variable">$2</span>(WebAsyncController.java:55) ~[classes/:na]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.lambda<span class="variable">$startCallableProcessing</span><span class="variable">$4</span>(WebAsyncManager.java:317) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511) ~[na:1.8.0_172]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_172]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]</span><br><span class="line"></span><br><span class="line">2018-06-18 21:12:10.111 ERROR 89875 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] <span class="keyword">in</span> context with path [] threw exception [Request processing failed; nested exception is java.lang.Exception: Task error] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.Exception: Task error</span><br><span class="line">at io.ostenant.springboot.sample.controller.WebAsyncController.lambda<span class="variable">$asyncTaskException</span><span class="variable">$2</span>(WebAsyncController.java:55) ~[classes/:na]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.lambda<span class="variable">$startCallableProcessing</span><span class="variable">$4</span>(WebAsyncManager.java:317) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511) ~[na:1.8.0_172]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_172]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]</span><br><span class="line"></span><br><span class="line">任务执行异常</span><br><span class="line">2018-06-18 21:12:10.144  WARN 89875 --- [nio-8080-exec-2] o.apache.catalina.core.AsyncContextImpl  : onError() failed <span class="keyword">for</span> listener of <span class="built_in">type</span> [org.apache.catalina.core.AsyncListenerWrapper]</span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException: Cannot dispatch without an AsyncContext</span><br><span class="line">at org.springframework.util.Assert.notNull(Assert.java:193) ~[spring-core-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.dispatch(StandardServletAsyncWebRequest.java:131) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.setConcurrentResultAndDispatch(WebAsyncManager.java:353) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.lambda<span class="variable">$startCallableProcessing</span><span class="variable">$2</span>(WebAsyncManager.java:304) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.lambda<span class="variable">$onError</span><span class="variable">$0</span>(StandardServletAsyncWebRequest.java:146) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at java.util.ArrayList.forEach(ArrayList.java:1257) ~[na:1.8.0_172]</span><br><span class="line">at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.onError(StandardServletAsyncWebRequest.java:146) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.apache.catalina.core.AsyncListenerWrapper.fireOnError(AsyncListenerWrapper.java:49) ~[tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.catalina.core.AsyncContextImpl.setErrorState(AsyncContextImpl.java:397) ~[tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:239) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.coyote.AbstractProcessor.dispatch(AbstractProcessor.java:232) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:53) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.coyote.AbstractProtocol<span class="variable">$ConnectionHandler</span>.process(AbstractProtocol.java:790) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint<span class="variable">$SocketProcessor</span>.doRun(NioEndpoint.java:1468) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_172]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624) [na:1.8.0_172]</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread<span class="variable">$WrappingRunnable</span>.run(TaskThread.java:61) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]</span><br><span class="line"></span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure><blockquote><p>注意：WebAsyncTask.onError(Callable&lt;?&gt;) ：当异步任务抛出异常的时候，onError()方法即会被调用。</p></blockquote><h2 id="5-超时异步任务"><a href="#5-超时异步任务" class="headerlink" title="5. 超时异步任务"></a>5. 超时异步任务</h2><p>配置一个正常的 <code>WebAsyncTask</code> 任务对象，设置任务 <strong>超时时间</strong> 为 <code>10s</code>。异步任务执行采用 <code>Thread.sleep(long)</code> 模拟，这里设置 <strong>异步线程</strong> 睡眠时间为 <code>15s</code>，引发异步任务超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/timeout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印处理线程名</span></span><br><span class="line">    out.println(format(<span class="string">"请求处理线程：%s"</span>, currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟开启一个异步任务，超时时间为10s</span></span><br><span class="line">    WebAsyncTask&lt;String&gt; asyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, () -&gt; &#123;</span><br><span class="line">        out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">        <span class="comment">// 任务处理时间5s，不超时</span></span><br><span class="line">        sleep(<span class="number">15</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">return</span> TIME_MESSAGE;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行完成时调用该方法</span></span><br><span class="line">    asyncTask.onCompletion(() -&gt; out.println(<span class="string">"任务执行完成"</span>));</span><br><span class="line">    asyncTask.onTimeout(() -&gt; &#123;</span><br><span class="line">        out.println(<span class="string">"任务执行超时"</span>);</span><br><span class="line">        <span class="keyword">return</span> TIME_MESSAGE;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">"继续处理其他事情"</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 项目，访问 <a href="http://localhost:8080/timeout" target="_blank" rel="noopener">http://localhost:8080/timeout</a> ，发起 <strong>超时</strong> 的异步任务请求。</p><p>观察控制台输出，可以验证 <code>WebAsyncTask</code> 的异步超时处理的过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求处理线程：http-nio-8080-exec-1</span><br><span class="line">继续处理其他事情</span><br><span class="line">异步工作线程：MvcAsync3</span><br><span class="line">任务执行超时</span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure><p><code>Web</code> 页面常响应超时提示信息，页面响应消息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413283fdc0eed4?w=2052&amp;h=150&amp;f=png&amp;s=25521" alt=""></p><blockquote><p>注意：WebAsyncTask.onTimeout(Callable&lt;?&gt;) ：当异步任务发生超时的时候，onTimeout()方法即会被调用。</p></blockquote><h2 id="6-线程池异步任务"><a href="#6-线程池异步任务" class="headerlink" title="6. 线程池异步任务"></a>6. 线程池异步任务</h2><p>上面的三种情况中的 <strong>异步任务</strong> 默认不是采用 <strong>线程池机制</strong> 进行管理的。</p><p>也就是说，一个请求进来，虽然释放了处理线程，但是系统依旧会为每个请求创建一个 <strong>异步任务线程</strong>，也就是上面看到的 <code>MvcAsync</code> 开头的 <strong>异步任务线程</strong>。</p><p>后果就是开销严重，所以通常采用 <strong>线程池</strong> 进行统一的管理，直接在 <code>WebAsyncTask</code> 类构造器传入一个 <code>ThreadPoolTaskExecutor</code> 对象实例即可。</p><p>构造一个线程池 <code>Bean</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">"asyncTask"</span>);</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器中注入 <code>ThreadPoolTaskExecutor</code> 对象，重新配置基于 <strong>线程池</strong> 的 <strong>异步任务处理</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/threadPool"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, executor,</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">                <span class="keyword">return</span> asyncService.generateUUID();</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发地请求 <a href="http://localhost:8080/threadPool" target="_blank" rel="noopener">http://localhost:8080/threadPool</a> ，观察控制台输出的 <strong>异步线程</strong> 信息，可以发现 <strong>异步任务</strong> 直接从 <strong>线程池</strong> 中获取 <strong>异步线程</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">异步工作线程：asyncTask1</span><br><span class="line">异步工作线程：asyncTask2</span><br><span class="line">异步工作线程：asyncTask3</span><br><span class="line">异步工作线程：asyncTask4</span><br><span class="line">异步工作线程：asyncTask5</span><br><span class="line">异步工作线程：asyncTask1</span><br><span class="line">异步工作线程：asyncTask2</span><br><span class="line">异步工作线程：asyncTask3</span><br><span class="line">异步工作线程：asyncTask4</span><br><span class="line">异步工作线程：asyncTask5</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了 <code>Spring Boot</code> 提供的 <code>WebAsyncTask</code> 的异步编程 <code>API</code>。相比上问介绍的 <code>@Async</code> 注解，<code>WebAsyncTask</code> 提供更加健全的 <strong>超时处理</strong> 和 <strong>异常处理</strong> 支持。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/1640df3c27eedf87?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上文介绍了基于 &lt;code&gt;@Async&lt;/code&gt; 注解的 &lt;strong&gt;异步调用编程&lt;/strong&gt;，本文将继续引入 &lt;code&gt;Spring Boot&lt;/code&gt; 的 &lt;code&gt;WebAsyncTask&lt;/code&gt; 进行更灵活异步任务处理，包括 &lt;strong&gt;异步回调&lt;/strong&gt;，&lt;strong&gt;超时处理&lt;/strong&gt; 和 &lt;strong&gt;异常处理&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="异步" scheme="https://ostenant.coding.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(三) - 使用@Async进行异步调用详解</title>
    <link href="https://ostenant.coding.me/2018/06/17/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%B8%89)%20-%20%E4%BD%BF%E7%94%A8@Async%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ostenant.coding.me/2018/06/17/实战Spring Boot 2.0系列(三) - 使用@Async进行异步调用详解/</id>
    <published>2018-06-17T01:40:00.000Z</published>
    <updated>2018-06-18T01:57:16.309Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>异步调用</strong> 对应的是 <strong>同步调用</strong>，<strong>同步调用</strong> 指程序按照 <strong>定义顺序</strong> 依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行；<strong>异步调用</strong> 指程序在顺序执行时，<strong>不等待</strong> 异步调用的语句 <strong>返回结果</strong> 就执行后面的程序。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBootAll.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-async-task</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    compileOnly(<span class="string">'org.projectlombok:lombok'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Spring Boot</code> 入口类上配置 <code>@EnableAsync</code> 注解开启异步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建任务抽象类 <code>AbstractTask</code>，并分别配置三个任务方法 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.println(<span class="string">"开始做任务一"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"完成任务一，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.println(<span class="string">"开始做任务二"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"完成任务二，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.println(<span class="string">"开始做任务三"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"完成任务三，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-同步调用"><a href="#2-同步调用" class="headerlink" title="2. 同步调用"></a>2. 同步调用</h2><p>下面通过一个简单示例来直观的理解什么是同步调用：</p><ul><li>定义 <code>Task</code> 类，继承 <code>AbstractTask</code>，三个处理函数分别模拟三个执行任务的操作，操作消耗时间随机取（<code>10</code> 秒内）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>Task</code> 对象，并在测试用例中执行 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Task task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSyncTasks</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        task.doTaskOne();</span><br><span class="line">        task.doTaskTwo();</span><br><span class="line">        task.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行单元测试，可以看到类似如下输出：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">完成任务一，耗时：4059毫秒</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：6316毫秒</span><br><span class="line">开始做任务三</span><br><span class="line">完成任务三，耗时：1973毫秒</span><br></pre></td></tr></table></figure><p>任务一、任务二、任务三顺序的执行完了，换言之 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法顺序的执行完成。</p><h2 id="3-异步调用"><a href="#3-异步调用" class="headerlink" title="3. 异步调用"></a>3. 异步调用</h2><p>上述的 <strong>同步调用</strong> 虽然顺利的执行完了三个任务，但是可以看到 <strong>执行时间比较长</strong>，若这三个任务本身之间 <strong>不存在依赖关系</strong>，可以 <strong>并发执行</strong> 的话，同步调用在 <strong>执行效率</strong> 方面就比较差，可以考虑通过 <strong>异步调用</strong> 的方式来 <strong>并发执行</strong>。</p><ul><li>创建 <code>AsyncTask</code>类，分别在方法上配置 <code>@Async</code> 注解，将原来的 <strong>同步方法</strong> 变为 <strong>异步方法</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskTwo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>AsyncTask</code> 对象，并在测试用例中执行 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTask task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncTasks</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        task.doTaskOne();</span><br><span class="line">        task.doTaskTwo();</span><br><span class="line">        task.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行单元测试，可以看到类似如下输出：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始做任务三</span><br><span class="line">开始做任务一</span><br><span class="line">开始做任务二</span><br></pre></td></tr></table></figure><p>如果反复执行单元测试，可能会遇到各种不同的结果，比如：</p><ol><li>没有任何任务相关的输出</li><li>有部分任务相关的输出</li><li>乱序的任务相关的输出</li></ol><p>原因是目前 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 这三个方法已经 <strong>异步执行</strong> 了。主程序在 <strong>异步调用</strong> 之后，主程序并不会理会这三个函数是否执行完成了，由于没有其他需要执行的内容，所以程序就 <strong>自动结束</strong> 了，导致了 <strong>不完整</strong> 或是 <strong>没有输出任务</strong> 相关内容的情况。</p><blockquote><p>注意：@Async所修饰的函数不要定义为static类型，这样异步调用不会生效。</p></blockquote><h3 id="4-异步回调"><a href="#4-异步回调" class="headerlink" title="4. 异步回调"></a>4. 异步回调</h3><p>为了让 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 能正常结束，假设我们需要统计一下三个任务 <strong>并发执行</strong> 共耗时多少，这就需要等到上述三个函数都完成动用之后记录时间，并计算结果。</p><p>那么我们如何判断上述三个 <strong>异步调用</strong> 是否已经执行完成呢？我们需要使用 <code>Future&lt;T&gt;</code> 来返回 <strong>异步调用</strong> 的 <strong>结果</strong>。</p><ul><li>创建 <code>AsyncCallBackTask</code> 类，声明 <code>doTaskOneCallback()</code>，<code>doTaskTwoCallback()</code>，<code>doTaskThreeCallback()</code> 三个方法，对原有的三个方法进行包装。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCallBackTask</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">doTaskOneCallback</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskOne();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务一完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">doTaskTwoCallback</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskTwo();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务二完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">doTaskThreeCallback</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskThree();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务三完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>AsyncCallBackTask</code> 对象，并在测试用例中执行 <code>doTaskOneCallback()</code>，<code>doTaskTwoCallback()</code>，<code>doTaskThreeCallback()</code> 三个方法。循环调用 <code>Future</code> 的 <code>isDone()</code> 方法等待三个 <strong>并发任务</strong> 执行完成，记录最终执行时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCallBackTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncCallBackTask task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncCallbackTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        Future&lt;String&gt; task1 = task.doTaskOneCallback();</span><br><span class="line">        Future&lt;String&gt; task2 = task.doTaskTwoCallback();</span><br><span class="line">        Future&lt;String&gt; task3 = task.doTaskThreeCallback();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三个任务都调用完成，退出循环等待</span></span><br><span class="line">        <span class="keyword">while</span> (!task1.isDone() || !task2.isDone() || !task3.isDone()) &#123;</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"任务全部完成，总耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看都做了哪些改变：</p><ul><li>在测试用例一开始记录开始时间；</li><li>在调用三个异步函数的时候，返回Future<string>类型的结果对象；</string></li><li>在调用完三个异步函数之后，开启一个循环，根据返回的Future<string>对象来判断三个异步函数是否都结束了。若都结束，就结束循环；若没有都结束，就等1秒后再判断。</string></li><li>跳出循环之后，根据结束时间 - 开始时间，计算出三个任务并发执行的总耗时。</li></ul><p>执行一下上述的单元测试，可以看到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">开始做任务三</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：4882毫秒</span><br><span class="line">完成任务三，耗时：6484毫秒</span><br><span class="line">完成任务一，耗时：8748毫秒</span><br><span class="line">任务全部完成，总耗时：9043毫秒</span><br></pre></td></tr></table></figure><p>可以看到，通过 <strong>异步调用</strong>，让任务一、任务二、任务三 <strong>并发执行</strong>，有效的 <strong>减少</strong> 了程序的 <strong>运行总时间</strong>。</p><h2 id="5-定义线程池"><a href="#5-定义线程池" class="headerlink" title="5. 定义线程池"></a>5. 定义线程池</h2><p>在上述操作中，创建一个 <strong>线程池配置类</strong> <code>TaskConfiguration</code> ，并配置一个 <strong>任务线程池对象</strong> <code>taskExecutor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"taskExecutor-"</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们通过使用 <code>ThreadPoolTaskExecutor</code> 创建了一个 <strong>线程池</strong>，同时设置了以下这些参数：</p><table><thead><tr><th style="text-align:left">线程池属性</th><th style="text-align:left">属性的作用</th><th style="text-align:center">设置初始值</th></tr></thead><tbody><tr><td style="text-align:left">核心线程数</td><td style="text-align:left">线程池创建时候初始化的线程数</td><td style="text-align:center">10</td></tr><tr><td style="text-align:left">最大线程数</td><td style="text-align:left">线程池最大的线程数，只有在缓冲队列满了之后，才会申请超过核心线程数的线程</td><td style="text-align:center">20</td></tr><tr><td style="text-align:left">缓冲队列</td><td style="text-align:left">用来缓冲执行任务的队列</td><td style="text-align:center">200</td></tr><tr><td style="text-align:left">允许线程的空闲时间</td><td style="text-align:left">当超过了核心线程之外的线程，在空闲时间到达之后会被销毁</td><td style="text-align:center">60秒</td></tr><tr><td style="text-align:left">线程池名的前缀</td><td style="text-align:left">可以用于定位处理任务所在的线程池</td><td style="text-align:center">taskExecutor-</td></tr><tr><td style="text-align:left">线程池对拒绝任务的处理策略</td><td style="text-align:left">这里采用CallerRunsPolicy策略，当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务</td><td style="text-align:center">CallerRunsPolicy</td></tr></tbody></table><ul><li>创建 <code>AsyncExecutorTask</code>类，三个任务的配置和 <code>AsyncTask</code> 一样，不同的是 <code>@Async</code> 注解需要指定前面配置的 <strong>线程池的名称</strong> <code>taskExecutor</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExecutorTask</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskOne();</span><br><span class="line">        out.println(<span class="string">"任务一，当前线程："</span> + currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskTwo();</span><br><span class="line">        out.println(<span class="string">"任务二，当前线程："</span> + currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskThree();</span><br><span class="line">        out.println(<span class="string">"任务三，当前线程："</span> + currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>AsyncExecutorTask</code> 对象，并在测试用例中执行 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExecutorTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncExecutorTask task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncExecutorTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        task.doTaskOne();</span><br><span class="line">        task.doTaskTwo();</span><br><span class="line">        task.doTaskThree();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">30</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下上述的 <strong>单元测试</strong>，可以看到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">开始做任务三</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：3905毫秒</span><br><span class="line">任务二，当前线程：taskExecutor-2</span><br><span class="line">完成任务一，耗时：6184毫秒</span><br><span class="line">任务一，当前线程：taskExecutor-1</span><br><span class="line">完成任务三，耗时：9737毫秒</span><br><span class="line">任务三，当前线程：taskExecutor-3</span><br></pre></td></tr></table></figure><p>执行上面的单元测试，观察到 <strong>任务线程池</strong> 的 <strong>线程池名的前缀</strong> 被打印，说明 <strong>线程池</strong> 成功执行 <strong>异步任务</strong>！</p><h2 id="6-优雅地关闭线程池"><a href="#6-优雅地关闭线程池" class="headerlink" title="6. 优雅地关闭线程池"></a>6. 优雅地关闭线程池</h2><blockquote><p>由于在应用关闭的时候异步任务还在执行，导致类似 <strong>数据库连接池</strong> 这样的对象一并被 <strong>销毁了</strong>，当 <strong>异步任务</strong> 中对 <strong>数据库</strong> 进行操作就会出错。</p></blockquote><p>解决方案如下，重新设置线程池配置对象，新增线程池 <code>setWaitForTasksToCompleteOnShutdown()</code> 和 <code>setAwaitTerminationSeconds()</code> 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadPoolTaskScheduler executor = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">    executor.setPoolSize(<span class="number">20</span>);</span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">"taskExecutor-"</span>);</span><br><span class="line">    executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">    executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>setWaitForTasksToCompleteOnShutdown(true):</strong> 该方法用来设置 <strong>线程池关闭</strong> 的时候 <strong>等待</strong> 所有任务都完成后，再继续 <strong>销毁</strong> 其他的 <code>Bean</code>，这样这些 <strong>异步任务</strong> 的 <strong>销毁</strong> 就会先于 <strong>数据库连接池对象</strong> 的销毁。</p></li><li><p><strong>setAwaitTerminationSeconds(60):</strong> 该方法用来设置线程池中 <strong>任务的等待时间</strong>，如果超过这个时间还没有销毁就 <strong>强制销毁</strong>，以确保应用最后能够被关闭，而不是阻塞住。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了在 <code>Spring Boot</code> 中如何使用 <code>@Async</code> 注解配置 <strong>异步任务</strong>、<strong>异步回调任务</strong>，包括结合 <strong>任务线程池</strong> 的使用，以及如何 <strong>正确</strong> 并 <strong>优雅</strong> 地关闭 <strong>任务线程池</strong>。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;异步调用&lt;/strong&gt; 对应的是 &lt;strong&gt;同步调用&lt;/strong&gt;，&lt;strong&gt;同步调用&lt;/strong&gt; 指程序按照 &lt;strong&gt;定义顺序&lt;/strong&gt; 依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行；&lt;strong&gt;异步调用&lt;/strong&gt; 指程序在顺序执行时，&lt;strong&gt;不等待&lt;/strong&gt; 异步调用的语句 &lt;strong&gt;返回结果&lt;/strong&gt; 就执行后面的程序。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="异步" scheme="https://ostenant.coding.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(二) - 全局异常处理和测试</title>
    <link href="https://ostenant.coding.me/2018/06/16/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%BA%8C)%20-%20%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%92%8C%E6%B5%8B%E8%AF%95/"/>
    <id>https://ostenant.coding.me/2018/06/16/实战Spring Boot 2.0系列(二) - 全局异常处理和测试/</id>
    <published>2018-06-16T07:35:00.000Z</published>
    <updated>2018-06-18T01:57:50.010Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常 <code>web</code> 开发中发生了异常，往往需要通过一个统一的 <strong>异常处理</strong>，来保证客户端能够收到友好的提示。本文将会介绍 <code>Spring Boot</code> 中的 <strong>全局统一异常处理</strong>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBootAll.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-global-exception-handle</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    compile(<span class="string">'org.projectlombok:lombok'</span>)</span><br><span class="line">    compile(<span class="string">'org.apache.commons:commons-lang3:3.1'</span>)</span><br><span class="line">    compile(<span class="string">'com.google.guava:guava:19.0'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-配置入口类"><a href="#2-配置入口类" class="headerlink" title="2. 配置入口类"></a>2. 配置入口类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-配置实体类"><a href="#3-配置实体类" class="headerlink" title="3. 配置实体类"></a>3. 配置实体类</h2><p>首先安装 <code>Intellij Idea</code> 的 <code>lombok</code> 插件，这里不做详细的介绍。切记，需要在设置中将 <code>Enable annotation processing</code> 勾选上，否则 <strong>测试代码</strong> 在 <strong>编译时</strong> 会无法对 <code>lombok</code> 插件配置的 <strong>注解</strong> 进行处理。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Annotation_Process.png" alt=""></p><p>使用 <code>lombok</code> 工具提供的 <strong>注解</strong> 配置一个实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String accountName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-配置异常响应实体"><a href="#4-配置异常响应实体" class="headerlink" title="4. 配置异常响应实体"></a>4. 配置异常响应实体</h2><p><code>ErrorMessage</code> 实体用于记录具体的 <strong>异常信息</strong>，并响应 <strong>客户端</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorMessage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer OK = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ERROR = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-配置相关异常类"><a href="#5-配置相关异常类" class="headerlink" title="5. 配置相关异常类"></a>5. 配置相关异常类</h2><p>SessionNotFoundException.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionNotFoundException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionNotFoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setMessage(<span class="string">"Session is not found!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionNotFoundException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NullOrEmptyException.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullOrEmptyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullOrEmptyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setMessage(<span class="string">"Parameter is null or empty!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullOrEmptyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IllegalPropertiesException.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IllegalPropertiesException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalPropertiesException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setMessage(<span class="string">"Prop is illegal!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalPropertiesException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        setMessage(String.format(<span class="string">"Prop: %s is illegal!"</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-配置全局异常通知"><a href="#6-配置全局异常通知" class="headerlink" title="6. 配置全局异常通知"></a>6. 配置全局异常通知</h2><p>从 <code>spring 3.2</code> 开始，新增了 <code>@ControllerAdvice</code> 注解，可以用于定义 <code>@ExceptionHandler</code>，并应用到配置了 <code>@RequestMapping</code> 的控制器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(SessionNotFoundException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">sessionNotFoundExceptionHandler</span><span class="params">(HttpServletRequest request, SessionNotFoundException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullOrEmptyException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">nullOrEmptyExceptionHandler</span><span class="params">(HttpServletRequest request, NullOrEmptyException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(IllegalPropertiesException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">illegalPropExceptionHandler</span><span class="params">(HttpServletRequest request, IllegalPropertiesException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">exceptionHandler</span><span class="params">(HttpServletRequest request, Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ErrorMessage&lt;String&gt; <span class="title">handleErrorInfo</span><span class="params">(HttpServletRequest request, String message, Exception exception)</span> </span>&#123;</span><br><span class="line">        ErrorMessage&lt;String&gt; errorMessage = <span class="keyword">new</span> ErrorMessage&lt;&gt;();</span><br><span class="line">        errorMessage.setMessage(message);</span><br><span class="line">        errorMessage.setCode(ErrorMessage.ERROR);</span><br><span class="line">        errorMessage.setData(message);</span><br><span class="line">        errorMessage.setUrl(request.getRequestURL().toString());</span><br><span class="line">        <span class="keyword">return</span> errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码指定了 <code>3</code> 个 <strong>特定</strong> 的异常处理器和 <code>1</code> 个 <strong>默认</strong> 的异常处理器。当请求处理出现异常时，会根据 <strong>异常处理器</strong> 的 <strong>配置顺序</strong> 依次尝试 <strong>异常匹配</strong> 和 <strong>处理</strong>。</p><p>当异常不在 SessionNotFoundException、NullOrEmptyException、IllegalPropertiesException 中时，<code>Spring</code> 会委托 <strong>默认</strong> 的 <code>exceptionHandler</code> 进行处理。</p><h2 id="7-配置控制器"><a href="#7-配置控制器" class="headerlink" title="7. 配置控制器"></a>7. 配置控制器</h2><p>根据请求数据的差异，控制器能覆盖以上 <code>3</code> 种异常处理路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; save(HttpServletRequest request, HttpSession session) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String sessionId = (String) session.getAttribute(<span class="string">"sessionId"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sessionId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SessionNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String userPlainText = request.getParameter(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(userPlainText) || StringUtils.equalsIgnoreCase(<span class="string">"&#123;&#125;"</span>, userPlainText)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullOrEmptyException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        User user = objectMapper.readValue(userPlainText, User.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalPropertiesException(<span class="string">"username"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getAccountName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalPropertiesException(<span class="string">"accountName"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">"Successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-配置Mock测试类"><a href="#8-配置Mock测试类" class="headerlink" title="8. 配置Mock测试类"></a>8. 配置Mock测试类</h2><p><code>Spring Mock</code> 的相关配置这里就不详细介绍了，以下测试类覆盖了 <code>UserController</code> 的所有执行路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"UserControllerTester"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    <span class="keyword">private</span> MockHttpSession session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImmutableMap&lt;Long, Pair&lt;String, String&gt;&gt; map = <span class="keyword">new</span> ImmutableMap.Builder&lt;Long, Pair&lt;String, String&gt;&gt;()</span><br><span class="line">            .put(<span class="number">0x00001L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">""</span>))</span><br><span class="line">            .put(<span class="number">0x00002L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;&#125;"</span>))</span><br><span class="line">            .put(<span class="number">0x00003L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;\"username\": \"\", \"accountName\": \"\"&#125;"</span>))</span><br><span class="line">            .put(<span class="number">0x00004L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;\"username\": \"Harrison\", \"accountName\": \"\"&#125;"</span>))</span><br><span class="line">            .put(<span class="number">0x00005L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;\"username\": \"Harrison\", \"accountName\": \"ostenant\"&#125;"</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> singleRunner = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (singleRunner) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mockMvc = MockMvcBuilders.standaloneSetup(userController).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">        &#125;</span><br><span class="line">        session = <span class="keyword">new</span> MockHttpSession();</span><br><span class="line">        session.setAttribute(<span class="string">"sessionId"</span>, StringUtils.replace(UUID.randomUUID().toString(), <span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">        log.debug(<span class="string">"sessionId: &#123;&#125;"</span>, session.getAttribute(<span class="string">"sessionId"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试SessionNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSessionNotFoundException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        session.clearAttributes();</span><br><span class="line">        <span class="comment">// 模拟发送请求</span></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00005L</span>).getKey(), map.get(<span class="number">0x00005L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试NullOrEmptyException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNullOrEmptyException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00001L</span>).getKey(), map.get(<span class="number">0x00001L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00002L</span>).getKey(), map.get(<span class="number">0x00002L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试IllegalPropException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIllegalPropException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00003L</span>).getKey(), map.get(<span class="number">0x00003L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00004L</span>).getKey(), map.get(<span class="number">0x00004L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试正常运行的情况</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNormal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00005L</span>).getKey(), map.get(<span class="number">0x00005L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-测试结果"><a href="#9-测试结果" class="headerlink" title="9. 测试结果"></a>9. 测试结果</h2><p>批量运行测试，测试结果如下，所有的测试用例全部通过。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Spring_Boot_Exception_Handler_Result.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>使用 <code>@ControllerAdvice</code> 处理异常也有一定的 <strong>局限性</strong>。只有进入 <code>Controller</code> 层的错误，才会由 <code>@ControllerAdvice</code> 处理。<strong>拦截器</strong> 抛出的错误，以及 <strong>访问错误地址</strong> 的情况 <code>@ControllerAdvice</code> 处理不了，由 <code>Spring Boot</code> 默认的 <strong>异常处理机制</strong> 处理。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在日常 &lt;code&gt;web&lt;/code&gt; 开发中发生了异常，往往需要通过一个统一的 &lt;strong&gt;异常处理&lt;/strong&gt;，来保证客户端能够收到友好的提示。本文将会介绍 &lt;code&gt;Spring Boot&lt;/code&gt; 中的 &lt;strong&gt;全局统一异常处理&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(一) - 使用Gradle构建Docker镜像</title>
    <link href="https://ostenant.coding.me/2018/06/14/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%B8%80)%20-%20%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F/"/>
    <id>https://ostenant.coding.me/2018/06/14/实战Spring Boot 2.0系列(一) - 使用Gradle构建Docker镜像/</id>
    <published>2018-06-14T11:35:00.000Z</published>
    <updated>2018-06-21T05:42:28.292Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常我们使用 <code>Dockerfile</code> 来构建项目的 <code>Docker</code> 镜像。但是也有使用 <code>gradle</code> 在编译项目的时候一起把镜像给 <strong>构建</strong> 并 <strong>上传</strong> 的需求。本文将会讲解如何使用 <code>gradle</code> 编写并配置 <code>Dockerfile</code> 并生成 <strong>镜像</strong>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBootAll.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-gradle-for-docker</code>，创建时添加一个 <code>web</code> 依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'1.0'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-配置入口类"><a href="#2-配置入口类" class="headerlink" title="2. 配置入口类"></a>2. 配置入口类</h2><p>为了方便容器部署的测试，在 <code>Spring Boot</code> 启动类上配置一个控制器，响应当前的系统时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd hh:mm:ss"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">retrieveTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-添加插件"><a href="#3-添加插件" class="headerlink" title="3. 添加插件"></a>3. 添加插件</h2><p>这里使用 <a href="https://github.com/Transmode/gradle-docker" target="_blank" rel="noopener"><code>gradle-docker</code></a> <strong>插件</strong> 来实现 <code>docker</code> 镜像构建。这样，我们就可以直接在 <code>Gradle</code> 的脚本里配置 <code>Dockerfile</code> 达到 <strong>构建镜像</strong> 功能的目的。</p><p><code>gradle-docker</code> 插件已经被上传到 <code>jCenter</code> 和 <code>MavenCentral</code> 上。所以只需要在 <code>dependencies</code> 添加依赖 <code>se.transmode.gradle:gradle-docker:1.2</code> 就能使用 <code>docker</code> 插件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">        classpath(<span class="string">"se.transmode.gradle:gradle-docker:1.2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-应用插件"><a href="#4-应用插件" class="headerlink" title="4. 应用插件"></a>4. 应用插件</h2><p>添加以下代码到 <code>build.gradle</code>中</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'docker'</span></span><br></pre></td></tr></table></figure><p>如果添加了 <code>application</code> 插件的话，默认 <code>gradle-docker</code> 插件会添加一个 <code>distDocker</code> 的 <code>gradle task</code>，用来构建一个 <strong>包含所有程序文件</strong> 的 <code>docker</code> 镜像。</p><h2 id="5-配置镜像构建信息"><a href="#5-配置镜像构建信息" class="headerlink" title="5. 配置镜像构建信息"></a>5. 配置镜像构建信息</h2><h3 id="5-1-配置group"><a href="#5-1-配置group" class="headerlink" title="5.1. 配置group"></a>5.1. 配置group</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br></pre></td></tr></table></figure><h3 id="5-2-配置镜像名称和版本号"><a href="#5-2-配置镜像名称和版本号" class="headerlink" title="5.2. 配置镜像名称和版本号"></a>5.2. 配置镜像名称和版本号</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    baseName = <span class="string">"spring-boot-gradle-for-docker"</span></span><br><span class="line">    version = <span class="number">1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中镜像的 <code>tag</code> 默认的构成为：<strong>项目组/应用名称:版本号</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag = <span class="string">"$&#123;project.group&#125;/$&#123;applicationName&#125;:$&#123;tagVersion&#125;"</span></span><br></pre></td></tr></table></figure><ul><li><p>project.group：标准的 <code>gradle</code> 属性，如果不进行定义，插件默认会 <strong>省略</strong> <code>${project.group}</code> 这个属性。</p></li><li><p>applicationName：应用被容器化时的 <strong>名称</strong>。</p></li><li><p>tagVersion：可选属性，会作为镜像的 <strong>标签</strong>。默认值为 <code>project.version</code>，如果未指定 <code>project.version</code>，则使用 <code>latest</code> 作为标记。</p></li></ul><h3 id="5-3-配置docker构建基础信息"><a href="#5-3-配置docker构建基础信息" class="headerlink" title="5.3. 配置docker构建基础信息"></a>5.3. 配置docker构建基础信息</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">distDocker &#123;</span><br><span class="line">    baseImage = <span class="string">"openjdk"</span></span><br><span class="line">    maintainer = <span class="string">"harrison"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>baseImage</code> 相当于 <code>Dockerfile</code> 中声明的 <code>FROM</code>。声明了在 <strong>构建镜像</strong> 是基于的 <code>Image</code>，<code>maintainer</code> 相当于 <code>MAINTAINER</code> ，声明了 <strong>镜像作者</strong>。如果声明了 <code>registry</code> 地址，插件在 <strong>镜像射生成后</strong> 可以自动 <code>push</code> 到该地址。其他的配置还包括 <code>docker hub</code> 的 <strong>地址</strong>、<strong>用户名</strong> 和 <strong>密码</strong>。</p><p>更详细的配置案例如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker &#123;</span><br><span class="line">    baseImage <span class="string">'openjdk'</span></span><br><span class="line">    maintainer <span class="string">'harrison'</span></span><br><span class="line">    useApi <span class="literal">true</span></span><br><span class="line">    hostUrl <span class="string">'http://myserver:4243'</span></span><br><span class="line">    apiUsername <span class="string">'user'</span></span><br><span class="line">    apiPassword <span class="string">'password'</span></span><br><span class="line">    apiEmail <span class="string">'me@mycompany.com'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-添加task任务"><a href="#6-添加task任务" class="headerlink" title="6. 添加task任务"></a>6. 添加task任务</h2><p>完成了基本的配置，我们还需要添加一个 <code>task</code> 用来在 <code>gradle</code> 编译的时候 <strong>执行镜像构建</strong>。</p><p>插件提供了一些 <strong>转换方法</strong>，用来指代 <code>Dockerfile</code> 中的 <strong>关键词语法</strong>，如下表，可以按照需求对照着来：</p><table><thead><tr><th style="text-align:left">Dockerfile关键词</th><th style="text-align:left">gradle task方法</th></tr></thead><tbody><tr><td style="text-align:left">ADD</td><td style="text-align:left">addFile(Closure copySpec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">addFile(String source, String dest)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">addFile(File source, String dest)</td></tr><tr><td style="text-align:left">CMD</td><td style="text-align:left">defaultCommand(List cmd)</td></tr><tr><td style="text-align:left">ENTRYPOINT</td><td style="text-align:left">entryPoint(List entryPoint)</td></tr><tr><td style="text-align:left">ENV</td><td style="text-align:left">setEnvironment(String key, String val)</td></tr><tr><td style="text-align:left">EXPOSE</td><td style="text-align:left">exposePort(Integer port)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">exposePort(String port)</td></tr><tr><td style="text-align:left">RUN</td><td style="text-align:left">runCommand(String cmd)</td></tr><tr><td style="text-align:left">USER</td><td style="text-align:left">switchUser(String userNameOrUid)</td></tr><tr><td style="text-align:left">VOLUME</td><td style="text-align:left">volume(String… paths)</td></tr><tr><td style="text-align:left">WORKDIR</td><td style="text-align:left">workingDir(String dir)</td></tr></tbody></table><p>下面是本项目的 <code>taskBuilder</code> 的任务配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task dockerBuilder(<span class="string">type:</span> Docker) &#123;</span><br><span class="line">    applicationName = jar.baseName</span><br><span class="line">    tagVersion = jar.version</span><br><span class="line">    volume(<span class="string">'/tmp'</span>)</span><br><span class="line">    addFile(<span class="string">"$&#123;jar.baseName&#125;-$&#123;jar.version&#125;.jar"</span>, <span class="string">"app.jar"</span>)</span><br><span class="line">    entryPoint([<span class="string">"java"</span>, <span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>, <span class="string">"-jar"</span>, <span class="string">'app.jar'</span>])</span><br><span class="line">    exposePort(<span class="number">8080</span>)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from jar</span><br><span class="line">            into stageDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建完成y以后，项目根目录的 <code>build/docker</code> 文件夹下面会出现 <code>Dockerfile</code> 和 <code>spring-boot-gradle-for-docker-1.0.jar</code> 文件。其中，以上的 <code>task</code> 等同于以下的 <code>Dockerfile</code>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> aglover/java8-pier</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/tmp"</span>]</span></span><br><span class="line"><span class="bash">ADD spring-boot-gradle-for-docker-1.0.jar app.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>, <span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>, <span class="string">"-jar"</span>, <span class="string">"app.jar"</span>]</span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br></pre></td></tr></table></figure><p>如果觉的在 <code>task</code> 中编写 <code>Dockerfile</code> <strong>替换脚本</strong> 非常别扭，也可以直接在 <code>task</code> 中指定 <code>Dockfile</code> 的 <strong>文件路径</strong>，直接使用已有的文件来生成镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task buildDocker(type: Docker) &#123;</span><br><span class="line">    applicationName = jar.baseName</span><br><span class="line">    tagVersion = jar.version</span><br><span class="line">    dockerfile = file(<span class="string">'Dockerfile'</span>)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        <span class="keyword">copy</span><span class="bash"> &#123;</span></span><br><span class="line"><span class="bash">            from jar</span></span><br><span class="line"><span class="bash">            into stageDir</span></span><br><span class="line"><span class="bash">        &#125;</span></span><br><span class="line"><span class="bash">    &#125;</span></span><br><span class="line"><span class="bash">&#125;</span></span><br></pre></td></tr></table></figure><p>通过 <code>file()</code> 指定 <code>task</code> 使用位于 <strong>项目根目录</strong> 的 <code>Dockerfile</code> 来生产镜像。</p><h2 id="7-编译并构建Docker镜像"><a href="#7-编译并构建Docker镜像" class="headerlink" title="7. 编译并构建Docker镜像"></a>7. 编译并构建Docker镜像</h2><p>进入项目根目录，运行 <code>gradle</code> 命令进行打包构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew clean build dockerBuilder --info</span><br></pre></td></tr></table></figure><p><code>gradle</code> 首先会运行 <strong>本地测试</strong>，然后进行 <strong>项目打包</strong>，进一步根据 <code>docker-gradle</code> 插件进行 <strong>镜像构建</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/gradle_build_docker_image_2.png" alt=""></p><p>等待出现 <code>BUILD SUCCESSFUL</code> 就表明任务运行成功。可以观察到镜像的名称为</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.ostenant.springboot.sample/spring-boot-gradle-<span class="keyword">for</span>-<span class="string">docker:</span><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>运行 <code>docker images</code> 查看本地镜像，进一步验证镜像构建成功。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/gradle_bulld_docker_images.png" alt=""></p><p>下面给出 <code>build.gradle</code> <strong>完整的</strong> 配置文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">        classpath(<span class="string">"se.transmode.gradle:gradle-docker:1.2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'docker'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'1.0'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line">targetCompatibility = <span class="number">1.8</span></span><br><span class="line">mainClassName = <span class="string">"io.ostenant.springboot.sample.Application"</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    baseName <span class="string">'spring-boot-gradle-for-docker'</span></span><br><span class="line">    version <span class="string">'1.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">distDocker &#123;</span><br><span class="line">    baseImage <span class="string">'openjdk'</span></span><br><span class="line">    maintainer <span class="string">'harrison'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task dockerBuilder(<span class="string">type:</span> Docker) &#123;</span><br><span class="line">    applicationName = jar.baseName</span><br><span class="line">    tagVersion = jar.version</span><br><span class="line">    volume(<span class="string">'/tmp'</span>)</span><br><span class="line">    addFile(<span class="string">"$&#123;jar.baseName&#125;-$&#123;jar.version&#125;.jar"</span>, <span class="string">"app.jar"</span>)</span><br><span class="line">    entryPoint([<span class="string">"java"</span>, <span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>, <span class="string">"-jar"</span>, <span class="string">'app.jar'</span>])</span><br><span class="line">    exposePort(<span class="number">8080</span>)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from jar</span><br><span class="line">            into stageDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-使用镜像启动容器"><a href="#8-使用镜像启动容器" class="headerlink" title="8. 使用镜像启动容器"></a>8. 使用镜像启动容器</h2><p>运行如下命令，根据镜像启动容器，对外暴露 <code>8080</code> 访问端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name gradle-boot -p 8080:8080 io.ostenant.springboot.sample/spring-boot-gradle-for-docker:1.0</span><br></pre></td></tr></table></figure><p>访问 <code>http://127.0.0.1:8080/</code> ，页面会输出当前系统时间，如图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/gradle_build_docker_image_2_web.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>gradle-docker</code> 插件还提供了配置 <strong>镜像仓库地址</strong>、配置使用 <code>Docker Remote Api</code> 和 <code>Docker Hub</code> 等用法，可以参考该项目的 <code>GitHub</code> 地址来进行配置使用：<br><a href="https://github.com/Transmode/gradle-docker" target="_blank" rel="noopener">https://github.com/Transmode/gradle-docker</a>。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通常我们使用 &lt;code&gt;Dockerfile&lt;/code&gt; 来构建项目的 &lt;code&gt;Docker&lt;/code&gt; 镜像。但是也有使用 &lt;code&gt;gradle&lt;/code&gt; 在编译项目的时候一起把镜像给 &lt;strong&gt;构建&lt;/strong&gt; 并 &lt;strong&gt;上传&lt;/strong&gt; 的需求。本文将会讲解如何使用 &lt;code&gt;gradle&lt;/code&gt; 编写并配置 &lt;code&gt;Dockerfile&lt;/code&gt; 并生成 &lt;strong&gt;镜像&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
      <category term="Gradle" scheme="https://ostenant.coding.me/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>微服务的反模式和陷阱(三) - 共享反模式</title>
    <link href="https://ostenant.coding.me/2018/06/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%99%B7%E9%98%B1(%E4%B8%89)%20-%20%E5%85%B1%E4%BA%AB%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ostenant.coding.me/2018/06/12/微服务的反模式和陷阱(三) - 共享反模式/</id>
    <published>2018-06-12T11:40:00.000Z</published>
    <updated>2018-06-18T01:58:34.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微服务是一种 <strong>无共享的架构</strong>，另一层意思是 <strong>“尽量不共享”</strong> 模式(<code>share-as-little-as-possible</code>)， 因为总有一些 <strong>代码</strong> 会在微服务之间共享。然后如果太过频繁的使用 <strong>共享代码</strong> 最终会出现 <strong>依赖噩梦</strong>，这就是共享反模式。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="共享反模式"><a href="#共享反模式" class="headerlink" title="共享反模式"></a>共享反模式</h2><p>微服务是一种 <strong>无共享的架构</strong>，另一层意思是 <strong>“尽量不共享”</strong> 模式(<code>share-as-little-as-possible</code>)， 因为总有一些 <strong>代码</strong> 会在微服务之间共享。比如 <strong>不提供一个身份验证的微服务</strong>，而是将身份验证的代码打包成一个 <code>jar</code> 文件：<code>security.jar</code>，保证其它服务都能使用。如果安全检查是 <strong>服务级别</strong> 的功能，每个服务接收到请求都会检查安全性，这种方式可以很好的提高性能。</p><p>然后如果太过频繁的使用最终会出现 <strong>依赖噩梦</strong>，如图 <code>1-1</code> 所示，其中每个服务都依赖于 <strong>多个自定义共享库</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Non_Share1.png" alt=""></p><p>这种共享级别不仅破坏了每个 <strong>服务的限界上下文</strong>，而且还引入了几个问题，包括整体 <strong>可靠性</strong>、<strong>变更控制</strong>、<strong>可测试性</strong> 和 <strong>部署能力</strong>。</p><h3 id="1-过多依赖"><a href="#1-过多依赖" class="headerlink" title="1. 过多依赖"></a>1. 过多依赖</h3><p>在面向对象的软件开发过程中，经常会遇到 <strong>共享</strong> 的问题，特别是从 <strong>单一分层</strong> 结构迁移到 <strong>微服务结构</strong> 时，图 <code>1-2</code> 展示 <strong>抽象类和共享</strong>，它们最终在多数单块分层体系结构中共享。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Non_Share2.png" alt=""></p><p><strong>微服务架构</strong> 的主要目标就是共享要尽可能的少，这有助于维护服务的 <strong>限界上下文</strong>，使我们能够快速的 <strong>测试</strong> 和 <strong>布署</strong>。服务之间 <strong>依赖越强</strong>，<strong>服务隔离</strong> 也就 <strong>越困难</strong>，因此也就越难单独进行 <strong>测试</strong> 和 <strong>布署</strong>。</p><p>创建 <strong>抽象类</strong> 和 <strong>接口</strong> 是 <strong>面向对象编程</strong> 的最重要做法，那我们如何来处理数百个服务共享的代码？</p><h3 id="2-共享代码的技术"><a href="#2-共享代码的技术" class="headerlink" title="2. 共享代码的技术"></a>2. 共享代码的技术</h3><p>要避免这个 <strong>反模式</strong> 的最好办法就是 <strong>代码不共享</strong>，但是实际工作中总会有一些代码需要进行共享，那这些共享代码应该放到哪里呢？</p><p>图 <code>1-3</code> 给了四个最基本的技术：</p><ul><li>共享项目</li><li>共享库</li><li>复制</li><li>服务合并</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Non_Share3.png" alt=""></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="">微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</a></li><li><a href="">微服务的反模式和陷阱(二) - 超时反模式</a></li><li><a href="">微服务的反模式和陷阱(三) - 共享反模式</a></li><li><a href="">微服务的反模式和陷阱(四) - 到达报告反模式</a></li><li><a href="">微服务的反模式和陷阱(五) - 沙粒陷阱</a></li><li><a href="">微服务的反模式和陷阱(六) - 无因的开发者陷阱</a></li><li><a href="">微服务的反模式和陷阱(七) - 随大流陷阱</a></li><li><a href="">微服务的反模式和陷阱(八) - 其它架构模式</a></li><li><a href="">微服务的反模式和陷阱(九) - 静态契约陷阱</a></li><li><a href="">微服务的反模式和陷阱(十) - 通信协议使用的陷阱</a></li></ol><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;微服务是一种 &lt;strong&gt;无共享的架构&lt;/strong&gt;，另一层意思是 &lt;strong&gt;“尽量不共享”&lt;/strong&gt; 模式(&lt;code&gt;share-as-little-as-possible&lt;/code&gt;)， 因为总有一些 &lt;strong&gt;代码&lt;/strong&gt; 会在微服务之间共享。然后如果太过频繁的使用 &lt;strong&gt;共享代码&lt;/strong&gt; 最终会出现 &lt;strong&gt;依赖噩梦&lt;/strong&gt;，这就是共享反模式。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="微服务" scheme="https://ostenant.coding.me/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="反模式" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微服务的反模式和陷阱(二) - 超时反模式</title>
    <link href="https://ostenant.coding.me/2018/06/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%99%B7%E9%98%B1(%E4%BA%8C)%20-%20%E8%B6%85%E6%97%B6%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ostenant.coding.me/2018/06/11/微服务的反模式和陷阱(二) - 超时反模式/</id>
    <published>2018-06-11T11:40:00.000Z</published>
    <updated>2018-07-05T12:46:16.012Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分布式应用的挑战之一就是如何管理 <strong>远程服务</strong> 的 <strong>可用性</strong> 和它们的 <strong>响应</strong>。虽然服务可用性和服务响应都涉及到服务的通信，但它们是两个完全不同的东西。<strong>服务可用性</strong> 是服务消费者 <strong>连接服务</strong> 并能够 <strong>发送请求</strong> 的能力，<strong>服务响应</strong> 则关注服务的 <strong>响应时间</strong>。这里就涉及微服务中的 <strong>超时反模式</strong>。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="超时反模式"><a href="#超时反模式" class="headerlink" title="超时反模式"></a>超时反模式</h2><p>微服务是一种 <strong>分布式的架构</strong>，它所有的组件（也就是服务）会被部署为单独的应用程序，并通过某种 <strong>远程访问协议</strong> 进行通讯。分布式应用的挑战之一就是如何管理 <strong>远程服务</strong> 的 <strong>可用性</strong> 和它们的 <strong>响应</strong>。虽然服务可用性和服务响应都涉及到服务的通信，但它们是两个完全不同的东西。<strong>服务可用性</strong> 是服务消费者 <strong>连接服务</strong> 并能够 <strong>发送请求</strong> 的能力，<strong>服务响应</strong> 则关注服务的 <strong>响应时间</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Timeout1.png" alt="图1-1"></p><p>如图 <code>1-1</code> 的所示，如果此时服务消费者 <strong>无法连接</strong> 到服务提供者的时候，通过会在毫秒级的时间里得到通知和反馈。这时候 <strong>服务消费者</strong> 可以选择是 <strong>直接返回错误信息</strong> 还是 <strong>进行重试</strong>。但是如果服务提供者接收了请求却 <strong>不进行响应</strong> 该怎么办？在这种情况下服务消费者可以选择 <strong>无限期等待</strong> 或者 <strong>设置超时时间</strong>，使用超时时间看起来是个好办法，但是它会导致 <strong>超时反模式</strong>。</p><h3 id="1-使用超时"><a href="#1-使用超时" class="headerlink" title="1. 使用超时"></a>1. 使用超时</h3><p>你可能感觉非常困惑，难道设置一个超时时间不是一件好事吗？在大部分的情况下超时时间的错误设置都会带来问题。比如当你上网购物的时候，你提交了订单，服务一直在处理没有返回，你在超时的时候再提交订单，显然服务器需要更复杂的逻辑来处理重复提交订单的问题。</p><p>那么超时时间设置多少合适呢？</p><ul><li>第一种是基于 <strong>数据库的超时</strong> 来计算服务的超时时间。</li><li>第二种是计算 <strong>负载下最长的处理时间</strong>，把它乘以 <code>2</code> 作为 <strong>超时时间</strong>。</li></ul><p>在图 <code>2-2</code> 中，通常的情况下 <strong>平均响应时间</strong> 是 <code>2</code> 秒，在 <strong>高并发</strong> 的情况下 <strong>最长时间</strong> 是 <code>5</code> 秒，因为可以使用加倍技术服务的超时时间设置为 <code>10</code> 秒。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_timeout2.png" alt="图1-2"></p><p>图 <code>1-2</code> 的解决方案似乎看起来很完美，它使每一个服务消费者必须等待 <code>10</code> 秒，其实只是为了 <strong>判断服务没有响应</strong>。在大多数情况下，用户在等待提交按钮或放弃和关闭屏幕之前不会等待超过 <code>2</code> 到 <code>3</code> 秒。那就必须要有更好的办法来解决。</p><h2 id="2-使用断路器模式"><a href="#2-使用断路器模式" class="headerlink" title="2. 使用断路器模式"></a>2. 使用断路器模式</h2><p>与上面 <strong>超时</strong> 的方法相比，使用 <strong>断路器</strong> 的方式更为稳妥。这种设计模式就像家里的电器的保险丝一样，当负载过大，或者电路发生故障或异常时，电流会不断升高，为防止升高的电流有可能损坏电路中的某些重要器件或贵重器件，烧毁电路甚至造成火灾。保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，从而起到保护电路安全运行的作用。</p><p>图 <code>1-3</code> 说明了 <strong>断路器模式</strong> 是如何工作的。当服务保持响应时，断路器将关闭，允许通过请求。如果远程服务突然变得不能响应，断路器就会打开，从而阻止请求通过，直到服务再次响应。当然这并不像你家中的保险丝，<strong>断路器</strong> 本身可以 <strong>持续监测服务</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_timeout3.png" alt="图1-3"></p><p><strong>断路器模式</strong> 相比 <strong>设置超时</strong> 的优点是，使用者可以 <strong>立即</strong> 知道服务已变得不响应，而不必等待超时，使用者将在 <strong>毫秒内</strong> 服务不响应，而不是等待 <code>10</code> 秒获得相同的信息。</p><p>另外断路器可以通过几种方式进行 <strong>监控</strong>。最简单的方法是 <strong>对远程服务</strong> 进行简单的 <strong>心跳检查</strong>，这种方式只是告诉断路器服务是活的，但是要想获取服务存活的详细信息，就需要 <strong>定期</strong>（比如 <code>10</code> 秒）获取一次服务的详细信息。还有一种方式是 <strong>实时用户监控</strong>，这种方式可以 <strong>动态调整</strong>，一旦达到 <strong>阈值</strong>，断路器可以进入 <strong>半开放状态</strong>，可以设置 <strong>一定数量的请求是通过</strong>（说 <code>10</code> 个请求中有 <code>8</code> 个通过）。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="">微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</a></li><li><a href="">微服务的反模式和陷阱(二) - 超时反模式</a></li><li><a href="">微服务的反模式和陷阱(三) - 共享反模式</a></li><li><a href="">微服务的反模式和陷阱(四) - 到达报告反模式</a></li><li><a href="">微服务的反模式和陷阱(五) - 沙粒陷阱</a></li><li><a href="">微服务的反模式和陷阱(六) - 无因的开发者陷阱</a></li><li><a href="">微服务的反模式和陷阱(七) - 随大流陷阱</a></li><li><a href="">微服务的反模式和陷阱(八) - 其它架构模式</a></li><li><a href="">微服务的反模式和陷阱(九) - 静态契约陷阱</a></li><li><a href="">微服务的反模式和陷阱(十) - 通信协议使用的陷阱</a></li></ol><hr><p>欢迎关注技术公众号： <strong>零壹技术栈</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;分布式应用的挑战之一就是如何管理 &lt;strong&gt;远程服务&lt;/strong&gt; 的 &lt;strong&gt;可用性&lt;/strong&gt; 和它们的 &lt;strong&gt;响应&lt;/strong&gt;。虽然服务可用性和服务响应都涉及到服务的通信，但它们是两个完全不同的东西。&lt;strong&gt;服务可用性&lt;/strong&gt; 是服务消费者 &lt;strong&gt;连接服务&lt;/strong&gt; 并能够 &lt;strong&gt;发送请求&lt;/strong&gt; 的能力，&lt;strong&gt;服务响应&lt;/strong&gt; 则关注服务的 &lt;strong&gt;响应时间&lt;/strong&gt;。这里就涉及微服务中的 &lt;strong&gt;超时反模式&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="微服务" scheme="https://ostenant.coding.me/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="反模式" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</title>
    <link href="https://ostenant.coding.me/2018/06/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%99%B7%E9%98%B1(%E4%B8%80)%20-%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%BF%81%E7%A7%BB%E5%8F%8D%E6%A8%A1%E5%BC%8F%08/"/>
    <id>https://ostenant.coding.me/2018/06/10/微服务的反模式和陷阱(一) - 数据驱动的迁移反模式/</id>
    <published>2018-06-10T10:20:00.000Z</published>
    <updated>2018-06-18T01:58:16.876Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>采用 <strong>数据驱动迁移反模式</strong> 主要发生在当你从一个 <strong>单体应用</strong> 向 <strong>微服务架构</strong> 做迁移的时候。之所以称之为反模式主要原因是，刚开始我们觉得创建微服务是一个不错的主意，<strong>服务和相应的数据</strong> 都独立成 <strong>微服务</strong>，但这可能会将你带向一个错误的道路上，导致高风险、过剩成本和额外的迁移工作。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="数据驱动的迁移反模式"><a href="#数据驱动的迁移反模式" class="headerlink" title="数据驱动的迁移反模式"></a>数据驱动的迁移反模式</h2><p>微服务会创建 <strong>大量小的</strong>、<strong>分布式的</strong>、<strong>单一用途</strong> 的服务，每个服务拥有自己的数据。这种 <strong>服务和数据耦合</strong> 支持一个 <strong>有界的上下文</strong> 和 <strong>一个无共享数据</strong> 的架构。其中，每个服务及其对应的数据是独立一块，完全独立于所有其他服务。服务只暴露了一个明确的接口（服务契约）。有界的上下文可以允许开发者以最小的依赖快速轻松地开发，测试和部署。</p><p>采用 <strong>数据驱动迁移反模式</strong> 主要发生在当你从一个 <strong>单体应用</strong> 向 <strong>微服务架构</strong> 做迁移的时候。我们之所以称之为反模式主要原因是，刚开始我们觉得创建微服务是一个不错的主意，<strong>服务和相应的数据</strong> 都独立成 <strong>微服务</strong>，但这可能会将你带向一个错误的道路上，导致高风险、过剩成本和额外的迁移工作。</p><p>单体应用迁移到微服务架构有两个主要目标：</p><ol><li><p>第一个目标是单体应用程序的 <strong>功能</strong> 分割成 <strong>小的</strong>，<strong>单一用途</strong> 的服务。</p></li><li><p>第二个目标是单体应用的 <strong>数据</strong> 迁移到每个服务自己 <strong>独占的小数据库</strong>（或独立的服务）。</p></li></ol><p>下图展示了一个典型的迁移，看起来像服务代码和相应的数据同时进行迁移。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/data_driven_back_pattern.png" alt="图1-1"></p><p>上图中有三个服务是从单体应用中划分而来，并且还划分独立的三个数据库，这是一个自然演变的过程，因为在每个 <strong>服务</strong> 和 <strong>数据库</strong> 之间都使用了最为关键的 <strong>限界上下文</strong>，然而我们遇到的问题也正是基于这一过程将带领我们进入 <strong>数据迁移的反模式</strong>。</p><h3 id="1-太多的数据迁移"><a href="#1-太多的数据迁移" class="headerlink" title="1. 太多的数据迁移"></a>1. 太多的数据迁移</h3><p>这种迁移路径的主要问题是，我们很难在一次就能够划分清楚每个服务的粒度。从一个 <strong>更粗粒度</strong> 的服务开始着手，一步步的进行 <strong>细化工作</strong>，并且要多了解相关业务知识，不断的 <strong>对服务的粒度进行调整</strong>。</p><p>我们来看图 <code>1-1</code> 发现最左边的 <strong>服务粒度太粗</strong>，需要再 <strong>拆分</strong> 成二个小的服务，或者你发现左边的二个 <strong>服务粒度划分的太细</strong>，需要进行 <strong>合并</strong>。而 <strong>数据迁移</strong> 要比 <strong>源代码迁移</strong> 更复杂，更容易出错，我们最好只为数据进行一次迁移工作，因为数据迁移是一个 <strong>高风险</strong> 的工作。</p><p>我们的微服务划分也就是应用代码的迁移和数据的迁移。如图 <code>1-2</code> 所示。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/data_drive_back_pattern2.png" alt="图1-2"></p><h3 id="2-功能分割优先，数据迁移最后"><a href="#2-功能分割优先，数据迁移最后" class="headerlink" title="2. 功能分割优先，数据迁移最后"></a>2. 功能分割优先，数据迁移最后</h3><p>此模式主要采用的是一种避免的手段，以 <strong>迁移服务的功能</strong> 为第一，同时也需要注意服务和数据之间的 <strong>限界上下文</strong>。我们可以通过 <strong>合并</strong> 与 <strong>拆分</strong> 的手段对服务进行调整直到满意为止，这时候就可以进行 <strong>数据迁移</strong>。</p><p>如图 <code>1-3</code> 所示，左边所有三个服务都已经进行了 <strong>迁移</strong> 和 <strong>拆分</strong>，但是所有服务仍然使用的是 <strong>同一个数据库</strong>。如果这是一个临时中间方案还可以作为一个选择，这时候我们就需要更多的了解服务如何使用，以及接受什么类型的请求数据等。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/data_driven_back_pattern3.png" alt=""></p><p>在图 <code>1-3</code> 中，我们要注意最左边的服务是如何发现 <strong>粒度太粗</strong> 而 <strong>拆分</strong> 成两个服务的。服务粒度最终确定完成之后，下一步就开始 <strong>迁移数据</strong> 了，采用这种方式可以避免重复的数据迁移。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="">微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</a></li><li><a href="">微服务的反模式和陷阱(二) - 超时反模式</a></li><li><a href="">微服务的反模式和陷阱(三) - 共享反模式</a></li><li><a href="">微服务的反模式和陷阱(四) - 到达报告反模式</a></li><li><a href="">微服务的反模式和陷阱(五) - 沙粒陷阱</a></li><li><a href="">微服务的反模式和陷阱(六) - 无因的开发者陷阱</a></li><li><a href="">微服务的反模式和陷阱(七) - 随大流陷阱</a></li><li><a href="">微服务的反模式和陷阱(八) - 其它架构模式</a></li><li><a href="">微服务的反模式和陷阱(九) - 静态契约陷阱</a></li><li><a href="">微服务的反模式和陷阱(十) - 通信协议使用的陷阱</a></li></ol><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;采用 &lt;strong&gt;数据驱动迁移反模式&lt;/strong&gt; 主要发生在当你从一个 &lt;strong&gt;单体应用&lt;/strong&gt; 向 &lt;strong&gt;微服务架构&lt;/strong&gt; 做迁移的时候。之所以称之为反模式主要原因是，刚开始我们觉得创建微服务是一个不错的主意，&lt;strong&gt;服务和相应的数据&lt;/strong&gt; 都独立成 &lt;strong&gt;微服务&lt;/strong&gt;，但这可能会将你带向一个错误的道路上，导致高风险、过剩成本和额外的迁移工作。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="微服务" scheme="https://ostenant.coding.me/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="反模式" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose搭建MySQL主从复制集群</title>
    <link href="https://ostenant.coding.me/2018/06/10/Docker%20Compose%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/"/>
    <id>https://ostenant.coding.me/2018/06/10/Docker Compose搭建MySQL主从集群/</id>
    <published>2018-06-10T02:33:00.000Z</published>
    <updated>2018-06-18T01:46:07.184Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着应用业务数据不断的增大，应用的 <strong>响应速度不断下降</strong>，在检测过程中我们不难发现大多数的请求都是 <strong>查询操作</strong>。此时，我们可以将数据库扩展成 <strong>主从复制模式</strong>，将 <strong>读操作</strong> 和 <strong>写操作</strong> 分离开来，多台数据库 <strong>分摊请求</strong>，从而 <strong>减少单库</strong> 的 <strong>访问压力</strong>，进而应用得到优化。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="主从复制的方式"><a href="#主从复制的方式" class="headerlink" title="主从复制的方式"></a>主从复制的方式</h2><p><code>MySQL 5.6</code> 开始主从复制有两种方式：<strong>基于日志</strong>（<code>binlog</code>）和 <strong>基于</strong> <code>GTID</code>（<strong>全局事务标示符</strong>）。 </p><p>本文只涉及基于日志 <code>binlog</code> 的 <strong>主从配置</strong>。</p><h2 id="主从复制的流程"><a href="#主从复制的流程" class="headerlink" title="主从复制的流程"></a>主从复制的流程</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/MySQL_Master_Slave.png" alt=""></p><p><code>MySQL</code> 同步操作通过 <code>3</code> 个线程实现，其基本步骤如下：</p><ol><li><p><strong>主服务器</strong> 将数据的更新记录到 <strong>二进制日志</strong>（<code>Binary log</code>）中，用于记录二进制日志事件，这一步由 <strong>主库线程</strong> 完成；</p></li><li><p><strong>从库</strong> 将 <strong>主库</strong> 的 <strong>二进制日志</strong> 复制到本地的 <strong>中继日志</strong>（<code>Relay log</code>），这一步由 <strong>从库</strong> <code>I/O</code> <strong>线程</strong> 完成；</p></li><li><p><strong>从库</strong> 读取 <strong>中继日志</strong> 中的 <strong>事件</strong>，将其重放到数据中，这一步由 <strong>从库</strong> <code>SQL</code> <strong>线程</strong> 完成。</p></li></ol><h2 id="主从模式的优点"><a href="#主从模式的优点" class="headerlink" title="主从模式的优点"></a>主从模式的优点</h2><h4 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1. 负载均衡"></a>1. 负载均衡</h4><p>通常情况下，会使用 <strong>主服务器</strong> 对数据进行 <strong>更新</strong>、<strong>删除</strong> 和 <strong>新建</strong> 等操作，而将 <strong>查询</strong> 工作落到 <strong>从库</strong> 头上。</p><h4 id="2-异地容灾备份"><a href="#2-异地容灾备份" class="headerlink" title="2. 异地容灾备份"></a>2. 异地容灾备份</h4><p>可以将主服务器上的数据同步到 <strong>异地从服务器</strong> 上，极大地提高了 <strong>数据安全性</strong>。</p><h4 id="3-高可用"><a href="#3-高可用" class="headerlink" title="3. 高可用"></a>3. 高可用</h4><p>数据库的复制功能实现了 <strong>主服务器</strong> 与 <strong>从服务器间</strong> 的数据同步，一旦主服务器出了 <strong>故障</strong>，从服务器立即担当起主服务器的角色，保障系统持续稳定运作。</p><h4 id="4-高扩展性"><a href="#4-高扩展性" class="headerlink" title="4. 高扩展性"></a>4. 高扩展性</h4><p><strong>主从复制</strong> 模式支持 <code>2</code> 种扩展方式: </p><ul><li><strong>scale-up</strong></li></ul><p>向上扩展或者 <strong>纵向扩展</strong>，主要是提供比现在服务器 <strong>性能更好</strong> 的服务器，比如 <strong>增加</strong> <code>CPU</code> 和 <strong>内存</strong> 以及 <strong>磁盘阵列</strong>等，因为有多台服务器，所以可扩展性比单台更大。</p><ul><li><strong>scale-out</strong></li></ul><p>向外扩展或者 <strong>横向扩展</strong>，是指增加 <strong>服务器数量</strong> 的扩展，这样主要能分散各个服务器的压力。</p><h2 id="主从模式的缺点"><a href="#主从模式的缺点" class="headerlink" title="主从模式的缺点"></a>主从模式的缺点</h2><h4 id="1-成本增加"><a href="#1-成本增加" class="headerlink" title="1. 成本增加"></a>1. 成本增加</h4><p>搭建主从肯定会增加成本，毕竟一台服务器和两台服务器的成本完全不同，另外由于主从必须要开启 <strong>二进制日志</strong>，所以也会造成额外的 <strong>性能消耗</strong>。</p><h4 id="2-数据延迟"><a href="#2-数据延迟" class="headerlink" title="2. 数据延迟"></a>2. 数据延迟</h4><p><strong>从库</strong> 从 <strong>主库</strong> 复制数据肯定是会有一定的 <strong>数据延迟</strong> 的。所以当刚插入就出现查询的情况，可能查询不出来。当然如果是插入者自己查询，那么可以直接从 <strong>主库</strong> 中查询出来，当然这个也是需要用代码来控制的。</p><h4 id="3-写入更慢"><a href="#3-写入更慢" class="headerlink" title="3. 写入更慢"></a>3. 写入更慢</h4><p><strong>主从复制</strong> 主要是针对 <strong>读远大于写</strong> 或者对 <strong>数据备份实时性</strong> 要求较高的系统中。因为 <strong>主服务器</strong> 在写中需要更多操作，而且 <strong>只有一台</strong> 可以写入的 <strong>主库</strong>，所以写入的压力并不能被分散。</p><h2 id="主从复制的前提条件"><a href="#主从复制的前提条件" class="headerlink" title="主从复制的前提条件"></a>主从复制的前提条件</h2><ol><li><p>主从服务器 <strong>操作系统版本</strong> 和 <strong>位数</strong> 一致。</p></li><li><p>主数据库和从数据库的 <strong>版本</strong> 要一致。</p></li><li><p>主数据库和从数据库中的 <strong>数据</strong> 要一致。</p></li><li><p><strong>主数据库</strong> 开启 <strong>二进制日志</strong>，主数据库和从数据库的 <code>server_id</code> 在局域网内必须 <strong>唯一</strong>。</p></li></ol><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">版本号</th></tr></thead><tbody><tr><td style="text-align:left">Docker</td><td style="text-align:left">18.03.1-ce</td></tr><tr><td style="text-align:left">Docker Compose</td><td style="text-align:left">1.21.1</td></tr><tr><td style="text-align:left">MySQL</td><td style="text-align:left">5.7.17</td></tr></tbody></table><h3 id="2-配置docker-compose-yml"><a href="#2-配置docker-compose-yml" class="headerlink" title="2. 配置docker-compose.yml"></a>2. 配置docker-compose.yml</h3><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  mysql-master:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">master/Dockerfile</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql-slave</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"33065:3306"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">mysql-master</span></span><br><span class="line"><span class="attr">  mysql-slave:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">slave/Dockerfile</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"33066:3306"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">mysql-slave</span></span><br></pre></td></tr></table></figure><h3 id="3-主数据库配置"><a href="#3-主数据库配置" class="headerlink" title="3. 主数据库配置"></a>3. 主数据库配置</h3><h4 id="3-1-配置Dockerfile"><a href="#3-1-配置Dockerfile" class="headerlink" title="3.1. 配置Dockerfile"></a>3.1. 配置Dockerfile</h4><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> harrison</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./master/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure><h4 id="3-2-配置my-cnf文件"><a href="#3-2-配置my-cnf文件" class="headerlink" title="3.2. 配置my.cnf文件"></a>3.2. 配置my.cnf文件</h4><p>my.cnf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，一般设置为IP，注意要唯一</span></span><br><span class="line">server_id=100  </span><br><span class="line"><span class="comment">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）</span></span><br><span class="line"><span class="built_in">log</span>-bin=replicas-mysql-bin  </span><br><span class="line"><span class="comment">## 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="comment">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure><h3 id="4-从数据库配置"><a href="#4-从数据库配置" class="headerlink" title="4. 从数据库配置"></a>4. 从数据库配置</h3><h4 id="4-1-配置Dockerfile"><a href="#4-1-配置Dockerfile" class="headerlink" title="4.1. 配置Dockerfile"></a>4.1. 配置Dockerfile</h4><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> harrison</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./slave/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure><h4 id="4-2-配置my-cnf文件"><a href="#4-2-配置my-cnf文件" class="headerlink" title="4.2. 配置my.cnf文件"></a>4.2. 配置my.cnf文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，一般设置为IP，注意要唯一</span></span><br><span class="line">server_id=101  </span><br><span class="line"><span class="comment">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span></span><br><span class="line"><span class="built_in">log</span>-bin=replicas-mysql-slave1-bin  </span><br><span class="line"><span class="comment">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="comment">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line"><span class="comment">## relay_log配置中继日志</span></span><br><span class="line">relay_log=replicas-mysql-relay-bin  </span><br><span class="line"><span class="comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span><br><span class="line">log_slave_updates=1  </span><br><span class="line"><span class="comment">## 防止改变数据(除了特殊的线程)</span></span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure><h3 id="5-创建容器"><a href="#5-创建容器" class="headerlink" title="5. 创建容器"></a>5. 创建容器</h3><p>进入 <code>docker</code> 目录，运行 <code>docker-compose</code> 启动命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure><p>如图所示，<code>MySQL</code> <strong>主数据库</strong> 和 <strong>从数据库</strong> 的容器创建成功。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Docker_Compose_MySQL.png" alt=""></p><p>分别配置 <strong>主数据库</strong> 和 <strong>从数据库</strong> 的连接信息如下：</p><ul><li>主数据库</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/MySQL_Master.png" alt=""></p><ul><li>从数据库</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/MySQL_Slave.png" alt=""><br></p><h3 id="6-配置从数据库"><a href="#6-配置从数据库" class="headerlink" title="6. 配置从数据库"></a>6. 配置从数据库</h3><h4 id="检查从库的起始状态"><a href="#检查从库的起始状态" class="headerlink" title="检查从库的起始状态"></a>检查从库的起始状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show master status;</span><br></pre></td></tr></table></figure><p>如图所示，从数据库处于 <strong>未同步复制状态</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Slave_Status.png" alt=""></p><h4 id="检查主库的状态"><a href="#检查主库的状态" class="headerlink" title="检查主库的状态"></a>检查主库的状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show master status;</span><br></pre></td></tr></table></figure><p>记录 <strong>主数据库</strong> <code>binary-log</code> 的 <strong>文件名称</strong> 和 <strong>数据同步起始位置</strong>。</p><ul><li>File: replicas-mysql-bin.000003</li><li>Position: 154</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/Master_Status.png" alt=""></p><h4 id="从库配置主库信息"><a href="#从库配置主库信息" class="headerlink" title="从库配置主库信息"></a>从库配置主库信息</h4><p>在 <strong>从数据库</strong> 上运行 <strong>主数据库</strong> 的相关配置 <code>sql</code> 进行主从关联</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">    MASTER_HOST=<span class="string">'mysql-master'</span>,</span><br><span class="line">    MASTER_USER=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_PASSWORD=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_LOG_FILE=<span class="string">'replicas-mysql-bin.000003'</span>,</span><br><span class="line">    MASTER_LOG_POS=<span class="number">154</span>;</span><br></pre></td></tr></table></figure><p>重新启动 <code>slave</code> 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ stop slave</span><br><span class="line">$ start slave</span><br></pre></td></tr></table></figure><p>进一步检查 <strong>从数据库</strong> 的状态信息，两者已经进行 <strong>数据同步</strong> 关联。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Slave_Status3.png" alt=""></p><h3 id="7-创建目标表"><a href="#7-创建目标表" class="headerlink" title="7. 创建目标表"></a>7. 创建目标表</h3><p>在 <strong>主数据库</strong> 中创建一张测试数据表 <code>course</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for course</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`course`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lesson_period`</span> <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span> <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p><strong>主数据库</strong> 和 <strong>从数据库</strong> 的 数据处于 <strong>同步状态</strong>，主从复制集群搭建完成。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Master_Slave_Sync.png" alt=""></p><h2 id="MySQL的复制类型"><a href="#MySQL的复制类型" class="headerlink" title="MySQL的复制类型"></a>MySQL的复制类型</h2><h3 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h3><p>主服务器上面执行的语句在从服务器上面再执行一遍，在 <code>MySQL-3.23</code> 版本以后支持。</p><blockquote><p>问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户。</p></blockquote><h3 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h3><p>把主服务器上面改变后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在 <code>MySQL-5.0</code> 版本以后引入。</p><blockquote><p>问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。</p></blockquote><h3 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h3><p><code>MySQL</code> 默认使用 <strong>基于语句的复制</strong>，当 <strong>基于语句的复制</strong> 会引发问题的时候就会使用 <strong>基于行的复制</strong>，<code>MySQL</code> 会自动进行选择。</p><hr><p>欢迎关注公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着应用业务数据不断的增大，应用的 &lt;strong&gt;响应速度不断下降&lt;/strong&gt;，在检测过程中我们不难发现大多数的请求都是 &lt;strong&gt;查询操作&lt;/strong&gt;。此时，我们可以将数据库扩展成 &lt;strong&gt;主从复制模式&lt;/strong&gt;，将 &lt;strong&gt;读操作&lt;/strong&gt; 和 &lt;strong&gt;写操作&lt;/strong&gt; 分离开来，多台数据库 &lt;strong&gt;分摊请求&lt;/strong&gt;，从而 &lt;strong&gt;减少单库&lt;/strong&gt; 的 &lt;strong&gt;访问压力&lt;/strong&gt;，进而应用得到优化。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL学习系列" scheme="https://ostenant.coding.me/categories/MySQL%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Docker Compose" scheme="https://ostenant.coding.me/tags/Docker-Compose/"/>
    
      <category term="MySQL" scheme="https://ostenant.coding.me/tags/MySQL/"/>
    
      <category term="主从复制" scheme="https://ostenant.coding.me/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>并发三剑客之限流方案总结</title>
    <link href="https://ostenant.coding.me/2018/06/09/%E5%B9%B6%E5%8F%91%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8B%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
    <id>https://ostenant.coding.me/2018/06/09/并发三剑客之限流方案总结/</id>
    <published>2018-06-09T00:20:00.000Z</published>
    <updated>2018-06-18T01:58:05.210Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于高并发的系统，有三把利器用来保护系统：<strong>缓存</strong>、<strong>降级</strong> 和 <strong>限流</strong>。限流常见的应用场景是秒杀、下单和评论等 <strong>突发性</strong> 并发问题。</p><a id="more"></a><ol><li><p><strong>缓存</strong> 的目的是提升 <strong>系统访问速度</strong> 和 <strong>系统吞吐量</strong>。</p></li><li><p><strong>降级</strong> 是当服务 <strong>出问题</strong> 或者影响到核心流程的性能，则需要 <strong>暂时屏蔽掉</strong>，待 <strong>高峰</strong> 或者 <strong>问题解决后</strong> 再打开。</p></li><li><p>有些场景并不能用 <strong>缓存</strong> 和 <strong>降级</strong> 来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（最新的评论）。因此需有一种手段来限制这些场景的 <strong>并发/请求量</strong>，即 <strong>限流</strong>。</p></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="限流的目的"><a href="#限流的目的" class="headerlink" title="限流的目的"></a>限流的目的</h2><p>限流的目的是通过对 <strong>并发访问/请求进行</strong> 限速，或者一个 <strong>时间窗口</strong> 内的的请求进行限速来 <strong>保护系统</strong>，一旦达到限制速率则可以 <strong>拒绝服务</strong>（定向到错误页或告知资源没有了）、<strong>排队</strong> 或 <strong>等待</strong>（比如秒杀、评论、下单）、降级（返回托底数据或默认数据，如商品详情页库存默认有货）。</p><h2 id="限流的方式"><a href="#限流的方式" class="headerlink" title="限流的方式"></a>限流的方式</h2><ol><li><p>限制 <strong>总并发数</strong>（比如 <strong>数据库连接池</strong>、<strong>线程池</strong>）</p></li><li><p>限制 <strong>瞬时并发数</strong>（如 <code>nginx</code> 的 <code>limit_conn</code> 模块，用来限制 <strong>瞬时并发连接数</strong>）</p></li><li><p>限制 <strong>时间窗口内的平均速率</strong>（如 <code>Guava</code> 的 <code>RateLimiter</code>、<code>nginx</code> 的 <code>limit_req</code> 模块，限制每秒的平均速率）</p></li><li><p>限制 <strong>远程接口</strong> 调用速率</p></li><li><p>限制 <code>MQ</code> 的消费速率</p></li><li><p>可以根据 <strong>网络连接数</strong>、<strong>网络流量</strong>、<code>CPU</code> 或 <strong>内存负载</strong> 等来限流</p></li></ol><h2 id="限流的算法"><a href="#限流的算法" class="headerlink" title="限流的算法"></a>限流的算法</h2><h3 id="1-令牌桶"><a href="#1-令牌桶" class="headerlink" title="1. 令牌桶"></a>1. 令牌桶</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/token_bucket.png" alt=""></p><h3 id="2-漏桶"><a href="#2-漏桶" class="headerlink" title="2. 漏桶"></a>2. 漏桶</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/bucket.jpg" alt=""></p><h3 id="3-计数器"><a href="#3-计数器" class="headerlink" title="3. 计数器"></a>3. 计数器</h3><p>有时候还可以使用 <strong>计数器</strong> 来进行限流，主要用来限制 <strong>总并发数</strong>，比如 <strong>数据库连接池</strong>、<strong>线程池</strong>、<strong>秒杀的并发数</strong>。通过 <strong>全局总请求数</strong> 或者 <strong>一定时间段的总请求数</strong> 设定的 <strong>阀值</strong> 来限流。这是一种 <strong>简单粗暴</strong> 的限流方式，而不是 <strong>平均速率限流</strong>。</p><h3 id="令牌桶-vs-漏桶"><a href="#令牌桶-vs-漏桶" class="headerlink" title="令牌桶 vs 漏桶"></a>令牌桶 vs 漏桶</h3><p>令牌桶限制的是 <strong>平均流入速率</strong>，允许突发请求，并允许一定程度 <strong>突发流量</strong>。</p><p>漏桶限制的是 <strong>常量流出速率</strong>，从而平滑 <strong>突发流入速率</strong>。</p><h2 id="应用级别限流"><a href="#应用级别限流" class="headerlink" title="应用级别限流"></a>应用级别限流</h2><h3 id="1-限流总资源数"><a href="#1-限流总资源数" class="headerlink" title="1. 限流总资源数"></a>1. 限流总资源数</h3><p>可以使用池化技术来限制总资源数：<strong>连接池</strong>、<strong>线程池</strong>。比如分配给每个应用的数据库连接是 <code>100</code>，那么本应用最多可以使用 <code>100</code> 个资源，超出了可以 <strong>等待</strong> 或者 <strong>抛异常</strong>。</p><h3 id="2-限流总并发-连接-请求数"><a href="#2-限流总并发-连接-请求数" class="headerlink" title="2. 限流总并发/连接/请求数"></a>2. 限流总并发/连接/请求数</h3><p>如果你使用过 <code>Tomcat</code>，其 <code>Connector</code> 其中一种配置有如下几个参数:</p><ul><li><p>maxThreads: <code>Tomcat</code> 能启动用来处理请求的 <strong>最大线程数</strong>，如果请求处理量一直远远大于最大线程数，可能会僵死。</p></li><li><p>maxConnections: <strong>瞬时最大连接数</strong>，超出的会 <strong>排队等待</strong>。</p></li><li><p>acceptCount: 如果 <code>Tomcat</code> 的线程都忙于响应，新来的连接会进入 <strong>队列排队</strong>，如果 <strong>超出排队大小</strong>，则 <strong>拒绝连接</strong>。</p></li></ul><h3 id="3-限流某个接口的总并发-请求数"><a href="#3-限流某个接口的总并发-请求数" class="headerlink" title="3. 限流某个接口的总并发/请求数"></a>3. 限流某个接口的总并发/请求数</h3><p>使用 <code>Java</code> 中的 <code>AtomicLong</code>，示意代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(atomic.incrementAndGet() &gt; 限流数) &#123;</span><br><span class="line">        <span class="comment">//拒绝请求</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//处理请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    atomic.decrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-限流某个接口的时间窗请求数"><a href="#4-限流某个接口的时间窗请求数" class="headerlink" title="4. 限流某个接口的时间窗请求数"></a>4. 限流某个接口的时间窗请求数</h3><p>使用 <code>Guava</code> 的 <code>Cache</code>，示意代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache counter = CacheBuilder.newBuilder()</span><br><span class="line">    .expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">    .build(newCacheLoader() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AtomicLong <span class="title">load</span><span class="params">(Long seconds)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newAtomicLong(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">longlimit =<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 得到当前秒</span></span><br><span class="line">    <span class="keyword">long</span> currentSeconds = System.currentTimeMillis() /<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span>(counter.get(currentSeconds).incrementAndGet() &gt; limit) &#123;</span><br><span class="line">        System.out.println(<span class="string">"限流了: "</span> + currentSeconds);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-平滑限流某个接口的请求数"><a href="#5-平滑限流某个接口的请求数" class="headerlink" title="5. 平滑限流某个接口的请求数"></a>5. 平滑限流某个接口的请求数</h3><p>之前的限流方式都不能很好地应对 <strong>突发请求</strong>，即 <strong>瞬间请求</strong> 可能都被允许从而导致一些问题。因此在一些场景中需要对突发请求进行改造，改造为 <strong>平均速率</strong> 请求处理。</p><p><code>Guava RateLimiter</code> 提供了 <strong>令牌桶算法实现</strong>：</p><ol><li><p>平滑突发限流 (<code>SmoothBursty</code>)</p></li><li><p>平滑预热限流 (<code>SmoothWarmingUp</code>) 实现</p></li></ol><h4 id="平滑突发限流-SmoothBursty"><a href="#平滑突发限流-SmoothBursty" class="headerlink" title="平滑突发限流(SmoothBursty)"></a>平滑突发限流(SmoothBursty)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter limiter = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br></pre></td></tr></table></figure><p>将得到类似如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br><span class="line">0.198239</span><br><span class="line">0.196083</span><br><span class="line">0.200609</span><br><span class="line">0.199599</span><br><span class="line">0.19961</span><br></pre></td></tr></table></figure><h4 id="平滑预热限流-SmoothWarmingUp"><a href="#平滑预热限流-SmoothWarmingUp" class="headerlink" title="平滑预热限流(SmoothWarmingUp)"></a>平滑预热限流(SmoothWarmingUp)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter limiter = RateLimiter.create(<span class="number">5</span>, <span class="number">1000</span>,  TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">for</span>(inti = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(limiter.acquire());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"><span class="keyword">for</span>(inti = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(limiter.acquire());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将得到类似如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br><span class="line">0.51767</span><br><span class="line">0.357814</span><br><span class="line">0.219992</span><br><span class="line">0.199984</span><br><span class="line">0.0</span><br><span class="line">0.360826</span><br><span class="line">0.220166</span><br><span class="line">0.199723</span><br><span class="line">0.199555</span><br></pre></td></tr></table></figure><p><code>SmoothWarmingUp</code> 的创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter.create(doublepermitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit);</span><br></pre></td></tr></table></figure><ul><li>permitsPerSecond: 表示 <strong>每秒新增</strong> 的令牌数</li><li>warmupPeriod: 表示在从 <strong>冷启动速率</strong> 过渡到 <strong>平均速率</strong> 的时间间隔</li></ul><p>速率是 <strong>梯形上升</strong> 速率的，也就是说 <strong>冷启动</strong> 时会以一个比较大的速率慢慢到平均速率；然后趋于 <strong>平均速率</strong>（梯形下降到平均速率）。可以通过调节 <code>warmupPeriod</code> 参数实现一开始就是平滑固定速率。</p><h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><p>分布式限流最关键的是要将 <strong>限流服务</strong> 做成 <strong>原子化</strong>，而解决方案可以使用 <code>redis + lua</code> 或者 <code>nginx + lua</code> 技术进行实现。</p><h2 id="接入层限流"><a href="#接入层限流" class="headerlink" title="接入层限流"></a>接入层限流</h2><p><strong>接入层</strong> 通常指请求流量的入口，该层的主要目的有：</p><ul><li>负载均衡</li><li>非法请求过滤</li><li>请求聚合</li><li>缓存、降级、限流</li><li>A/B测试</li><li>服务质量监控</li></ul><p>对于 <code>Nginx</code> <strong>接入层限流</strong> 可以使用 <code>Nginx</code> 自带了两个模块：<strong>连接数限流模块</strong> <code>ngx_http_limit_conn_module</code> 和 <strong>漏桶</strong> 算法实现的 <strong>请求限流模块</strong> <code>ngx_http_limit_req_module</code>。还可以使用 <code>OpenResty</code> 提供的 <code>Lua</code> 限流模块 <code>lua-resty-limit-traffic</code> 进行 <strong>更复杂的</strong> 限流场景。</p><ul><li><p>limit_conn: 用来对某个 <code>KEY</code> 对应的 <strong>总的网络连接数</strong> 进行限流，可以按照如 <code>IP</code>、<strong>域名维度</strong> 进行限流。</p></li><li><p>limit_req: 用来对某个 <code>KEY</code> 对应的 <strong>请求的平均速率</strong> 进行限流，并有两种用法：<strong>平滑模式</strong>（<code>delay</code>）和 <strong>允许突发模式</strong> (<code>nodelay</code>)。</p></li></ul><p><code>OpenResty</code> 提供的 <code>Lua</code> 限流模块 <code>lua-resty-limit-traffic</code> 可以进行更复杂的限流场景。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于高并发的系统，有三把利器用来保护系统：&lt;strong&gt;缓存&lt;/strong&gt;、&lt;strong&gt;降级&lt;/strong&gt; 和 &lt;strong&gt;限流&lt;/strong&gt;。限流常见的应用场景是秒杀、下单和评论等 &lt;strong&gt;突发性&lt;/strong&gt; 并发问题。&lt;/p&gt;
    
    </summary>
    
      <category term="高并发系统系列" scheme="https://ostenant.coding.me/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="高并发" scheme="https://ostenant.coding.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="限流" scheme="https://ostenant.coding.me/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(六) - 一致性协议Raft</title>
    <link href="https://ostenant.coding.me/2018/06/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E5%85%AD)%20-%20%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AERaft/"/>
    <id>https://ostenant.coding.me/2018/06/05/分布式理论(六) - 一致性协议Raft/</id>
    <published>2018-06-05T13:20:00.000Z</published>
    <updated>2018-06-18T01:54:52.119Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Raft</code> 也是一个 <strong>一致性算法</strong>，和 <code>Paxos</code> 目标相同。但它还有另一个名字 - <strong>易于理解的一致性算法</strong>。<code>Paxos</code> 和 <code>Raft</code> 都是为了实现 <strong>一致性</strong> 产生的。这个过程如同选举一样，<strong>参选者</strong> 需要说服 <strong>大多数选民</strong> (服务器) 投票给他，一旦选定后就跟随其操作。<code>Paxos</code> 和 <code>Raft</code> 的区别在于选举的 <strong>具体过程</strong> 不同。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>在进入正题前，给大家分享一个《数学发散思维》中的一个故事，站在不同思维角度上，了解对一个问题理解的差异性。</p><blockquote><p>问题: 甲乙两人轮流在一张圆桌上平放黑白围棋子，每次放一子，棋子不许重叠，谁先没有地方放就输。请问怎样放才能赢？</p></blockquote><p>这个问题有两层意思，第一，有没有一种放法保证必赢？第二，如果有怎么证明？</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_prepare.png" alt=""></p><p>上图回答了这个问题，那就是先行者必胜，这里使用了三种不同的思维方式来阐述: </p><ol><li><p>假如桌子只有一个围棋子那么大。</p></li><li><p>假如桌子无限大，先行者先占住圆心。由于圆是对称图形，所以只要对手还能找到位置放，你总能在对称的另一面找到位置放。</p></li><li><p>一个圆中可画单数个直径相等且互切的小圆。</p></li></ol><p>三种不同的思维方式在可理解性难度上逐渐加深。</p><ol><li><p>第一种是 <strong>极简化思维</strong>，但数学上是 <strong>不严谨</strong> 的。</p></li><li><p>第二种是 <strong>极限思维</strong>，和第一种结合起来就是 <strong>数学归纳法</strong>，在数学上是 <strong>严谨</strong> 的。</p></li><li><p>第三种是 <strong>形象思维</strong>，使用了 <strong>几何学概念</strong>，但对于没有几何学基础知识的人就很难理解了。</p></li></ol><h2 id="什么是Raft协议"><a href="#什么是Raft协议" class="headerlink" title="什么是Raft协议"></a>什么是Raft协议</h2><p><code>Raft</code> 协议将 <code>Server</code> 进程分成三类，分别是 <code>Leader</code>，<code>Candidate</code>，<code>Follower</code>。一个 <code>Server</code> 进程在某一时刻，只能是其中 <strong>一种类型</strong>，但这不是固定的。不同的时刻，它可能拥有不同的类型，一个 <code>Server</code> 进程的类型是如何改变的，后面会有解释。</p><p>在一个由 <code>Raft</code> 协议组织的集群中有三类角色：</p><ul><li><strong>Leader（领袖）</strong></li><li><strong>Follower（群众）</strong></li><li><strong>Candidate（候选人）</strong></li></ul><p>就像一个民主社会，领袖由民众投票选出。刚开始没有 <strong>领袖</strong>，所有集群中的 <strong>参与者</strong> 都是 <strong>群众</strong>，那么首先开启一轮大选。在大选期间 <strong>所有群众</strong> 都能参与竞选，这时所有群众的角色就变成了 <strong>候选人</strong>，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除 <strong>领袖</strong> 的 <strong>候选人</strong> 又变回 <strong>群众角色</strong> 服从领袖领导。</p><p>这里提到一个概念 <strong>「任期」</strong>，用术语 <code>Term</code> 表达。关于 <code>Raft</code> 协议的核心概念和术语就这么多，而且和现实民主制度非常匹配，所以很容易理解。</p><p>三类角色的变迁图如下，结合后面的选举过程来看很容易理解。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_workflow.png" alt=""></p><h2 id="Leader选举过程"><a href="#Leader选举过程" class="headerlink" title="Leader选举过程"></a>Leader选举过程</h2><p>在极简的思维下，一个最小的 <code>Raft</code> 民主集群需要 <strong>三个参与者</strong>（如下图：<code>A</code>、<code>B</code>、<code>C</code>），这样才可能投出多数票。</p><p>初始状态 <code>ABC</code> 都是 <code>Follower</code>，然后发起选举这时有 <strong>三种</strong> 可能的情形发生。下图中前二种都能选出 <code>Leader</code>，第三种则表明 <strong>本轮投票无效</strong>（<code>Split Votes</code>）。对于第三种，每方都投给了自己，结果没有任何一方获得多数票。之后 <strong>每个参与方</strong> 随机休息一阵（<code>Election Timeout</code>）重新发起投票直到一方获得多数票。这里的关键就是随机 <code>timeout</code>，最先从 <code>timeout</code> 中恢复发起投票的一方，向还在 <code>timeout</code> 中的另外两方 <strong>请求投票</strong>，这时它就只能投给自己，导致很快达成一致。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_election.png" alt=""></p><p>选出 <code>Leader</code> 后，<code>Leader</code> 通过 <strong>定期</strong> 向所有 <code>Follower</code> 发送 <strong>心跳信息</strong> 维持其统治。若 <code>Follower</code> 一段时间未收到 <code>Leader</code> 的 <strong>心跳</strong>，则认为 <code>Leader</code> 可能已经挂了，然后再次发起 <strong>选举</strong> 过程。</p><h2 id="Leader对一致性的影响"><a href="#Leader对一致性的影响" class="headerlink" title="Leader对一致性的影响"></a>Leader对一致性的影响</h2><p><code>Raft</code> 协议 <strong>强依赖</strong> <code>Leader</code> 节点的 <strong>可用性</strong>，以确保集群 <strong>数据的一致性</strong>。<strong>数据的流向</strong> 只能从 <code>Leader</code> 节点向 <code>Follower</code> 节点转移。具体过程如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_leader_consistence.png" alt=""></p><ol><li><p>当 <code>Client</code> 向集群 <code>Leader</code> 节点 <strong>提交数据</strong> 后，<code>Leader</code> 节点 <strong>接收到的数据</strong> 处于 <strong>未提交状态</strong>（<code>Uncommitted</code>）。</p></li><li><p>接着 <code>Leader</code> 节点会 <strong>并发地</strong> 向所有 <code>Follower</code> 节点 <strong>复制数据</strong> 并 <strong>等待接收响应</strong>。</p></li><li><p>集群中至少 <strong>超过半数</strong> 的节点 <strong>已接收</strong> 到数据后， <code>Leader</code> 再向 <code>Client</code> 确认数据 <strong>已接收</strong>。</p></li><li><p>一旦向 <code>Client</code> 发出数据接收 <code>Ack</code> 响应后，表明此时 <strong>数据状态</strong> 进入 <strong>已提交</strong>（<code>Committed</code>），<code>Leader</code> 节点再向 <code>Follower</code> 节点发通知告知该 <strong>数据状态已提交</strong>。</p></li></ol><p>在这个过程中，<strong>主节点</strong> 可能在 <strong>任意阶段</strong> 挂掉，看下 <code>Raft</code> 协议如何针对不同阶段保障 <strong>数据一致性</strong> 的。</p><h3 id="1-情形1"><a href="#1-情形1" class="headerlink" title="1. 情形1"></a>1. 情形1</h3><blockquote><p>数据到达 Leader 节点前，这个阶段 Leader 挂掉不影响一致性，不用多说。</p></blockquote><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_1.png" alt=""></p><h3 id="2-情形2"><a href="#2-情形2" class="headerlink" title="2. 情形2"></a>2. 情形2</h3><blockquote><p>数据到达 Leader 节点，但未复制到 Follower 节点。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，数据属于 <strong>未提交状态</strong>，<code>Client</code> 不会收到 <code>Ack</code> 会认为 <strong>超时失败</strong> 可安全发起 <strong>重试</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_2.png" alt=""></p><p><code>Follower</code> 节点上没有该数据，<strong>重新选主</strong> 后 <code>Client</code> 重试 <strong>重新提交</strong> 可成功。原来的 <code>Leader</code> 节点 <strong>恢复</strong> 后作为 <code>Follower</code> 加入集群，重新从 <strong>当前任期</strong> 的新 <code>Leader</code> 处 <strong>同步数据</strong>，强制保持和 <code>Leader</code> <strong>数据一致</strong>。</p><h3 id="3-情形3"><a href="#3-情形3" class="headerlink" title="3. 情形3"></a>3. 情形3</h3><blockquote><p>数据到达 Leader 节点，成功复制到 Follower 所有节点，但 Follower 还未向 Leader 响应接收。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，虽然数据在 <code>Follower</code> 节点处于 <strong>未提交状态</strong>（<code>Uncommitted</code>），但是 <strong>保持一致</strong> 的。重新选出 <code>Leader</code> 后可完成 <strong>数据提交</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_3.png" alt=""></p><p>此时 <code>Client</code> 由于不知到底提交成功没有，可重试提交。针对这种情况 <code>Raft</code> 要求 <code>RPC</code> 请求实现 <strong>幂等性</strong>，也就是要实现 <strong>内部去重机制</strong>。</p><h3 id="4-情形4"><a href="#4-情形4" class="headerlink" title="4. 情形4"></a>4. 情形4</h3><blockquote><p>数据到达 Leader 节点，成功复制到 Follower 的部分节点，但这部分 Follower 节点还未向 Leader 响应接收。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，数据在 <code>Follower</code> 节点处于 <strong>未提交状态</strong>（<code>Uncommitted</code>）且 <strong>不一致</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_4.png" alt=""></p><p><code>Raft</code> 协议要求投票只能投给拥有 <strong>最新数据</strong> 的节点。所以拥有最新数据的节点会被选为 <code>Leader</code>，然后再 <strong>强制同步数据</strong> 到其他 <code>Follower</code>，保证 <strong>数据不会丢失</strong>并 <strong>最终一致</strong>。</p><h3 id="5-情形5"><a href="#5-情形5" class="headerlink" title="5. 情形5"></a>5. 情形5</h3><blockquote><p>数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在 Leader 处于已提交状态，但在 Follower 处于未提交状态。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，<strong>重新选出</strong> 新的 <code>Leader</code> 后的处理流程和阶段 <code>3</code> 一样。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_5.png" alt=""></p><h3 id="6-情形6"><a href="#6-情形6" class="headerlink" title="6. 情形6"></a>6. 情形6</h3><blockquote><p>数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client。</p></blockquote><p>这个阶段 <code>Leader</code> 挂掉，集群内部数据其实已经是 <strong>一致的</strong>，<code>Client</code> 重复重试基于幂等策略对 <strong>一致性无影响</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_6.png" alt=""></p><h3 id="7-情形7"><a href="#7-情形7" class="headerlink" title="7. 情形7"></a>7. 情形7</h3><blockquote><p>网络分区导致的脑裂情况，出现双 Leader 的现象。</p></blockquote><p><strong>网络分区</strong> 将原先的 <code>Leader</code> 节点和 <code>Follower</code> 节点分隔开，<code>Follower</code> 收不到 <code>Leader</code> 的 <strong>心跳</strong> 将 <strong>重新</strong> 发起选举产生新的 <code>Leader</code>，这时就产生了 <strong>双Leader</strong> 现象。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Raft_failure_7.png" alt=""></p><p>原先的 <code>Leader</code> 独自在一个区，向它提交数据不可能复制到多数节点所以永远提交不成功。向新的 <code>Leader</code> 提交数据可以提交成功。</p><p><strong>网络恢复</strong> 后，旧的 <code>Leader</code> 发现集群中有 <strong>更新任期</strong>（<code>Term</code>）的新 <code>Leader</code> ，则 <strong>自动降级</strong> 为 <code>Follower</code> 并从新 <code>Leader</code> 处 <strong>同步数据</strong> 达成集群 <strong>数据一致</strong>。</p><h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><p>综上穷举分析了 <strong>最小集群</strong>（<code>3</code> 节点）面临的所有情况，可以看出 <code>Raft</code> 协议都能很好的应对 <strong>一致性问题</strong>，并且很容易理解。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>Paxos</code> 算法是 <code>Leslie Lamport</code> 在 <code>1990</code> 年就公开发表在了自己的网站上，想想我们是什么时候才听说的？什么时候才有一个可用的实现？而 <code>Raft</code> 算法是 <code>2013</code> 年发表的，大家在参考 <a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">Raft开源实现库</a>，可以看到有很多基于不同语言的 <strong>开源实现库</strong>，这就是 <strong>可理解性</strong> 的重要性。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Raft&lt;/code&gt; 也是一个 &lt;strong&gt;一致性算法&lt;/strong&gt;，和 &lt;code&gt;Paxos&lt;/code&gt; 目标相同。但它还有另一个名字 - &lt;strong&gt;易于理解的一致性算法&lt;/strong&gt;。&lt;code&gt;Paxos&lt;/code&gt; 和 &lt;code&gt;Raft&lt;/code&gt; 都是为了实现 &lt;strong&gt;一致性&lt;/strong&gt; 产生的。这个过程如同选举一样，&lt;strong&gt;参选者&lt;/strong&gt; 需要说服 &lt;strong&gt;大多数选民&lt;/strong&gt; (服务器) 投票给他，一旦选定后就跟随其操作。&lt;code&gt;Paxos&lt;/code&gt; 和 &lt;code&gt;Raft&lt;/code&gt; 的区别在于选举的 &lt;strong&gt;具体过程&lt;/strong&gt; 不同。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Raft" scheme="https://ostenant.coding.me/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(五) - 一致性算法Paxos</title>
    <link href="https://ostenant.coding.me/2018/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%BA%94)%20-%20%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos/"/>
    <id>https://ostenant.coding.me/2018/06/03/分布式理论(五) - 一致性算法Paxos/</id>
    <published>2018-06-03T13:30:00.000Z</published>
    <updated>2018-06-18T01:54:36.736Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>世界上只有一种一致性算法，就是 <code>Paxos</code>。出自一位 <code>Google</code> 大神之口。<code>Paxos</code> 也是出名的 <strong>晦涩难懂</strong>，推理过程极其复杂。</p><a id="more"></a><p><code>Paxos</code> 有点类似之前说的 <code>2PC</code>，<code>3PC</code>，但是解决了这两种算法各种硬伤。该算法在很多大厂都得到了工程实践，比如阿里的 <code>OceanBase</code> 的 <strong>分布式数据库</strong>，底层就是使用的 <code>Paxos</code> 算法。再比如 <code>Google</code> 的 <code>chubby</code> <strong>分布式锁</strong> 也是用的这个算法。可见该算法在分布式系统中的地位，甚至于，<code>Paxos</code> 就是 <strong>分布式一致性</strong> 的代名词。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-Paxos算法是什么"><a href="#1-Paxos算法是什么" class="headerlink" title="1. Paxos算法是什么"></a>1. Paxos算法是什么</h2><p><code>Paxos</code> 算法是 <strong>基于消息传递</strong> 且具有 <strong>高效容错特性</strong> 的一致性算法，目前公认的解决 <strong>分布式一致性问题</strong> 最有效的算法之一.</p><h2 id="2-Paxos算法产生背景"><a href="#2-Paxos算法产生背景" class="headerlink" title="2. Paxos算法产生背景"></a>2. Paxos算法产生背景</h2><h3 id="2-1-拜占庭将军问题"><a href="#2-1-拜占庭将军问题" class="headerlink" title="2.1. 拜占庭将军问题"></a>2.1. 拜占庭将军问题</h3><p>拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于信使中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。</p><h3 id="2-2-Paxos算法由来"><a href="#2-2-Paxos算法由来" class="headerlink" title="2.2. Paxos算法由来"></a>2.2. Paxos算法由来</h3><p>故事背景是古希腊 <code>Paxos</code> 岛上的多个法官在一个大厅内对一个议案进行表决，如何达成统一的结果。他们之间通过服务人员来传递纸条，但法官可能离开或进入大厅，服务人员可能偷懒去睡觉。</p><h3 id="2-3-产生背景"><a href="#2-3-产生背景" class="headerlink" title="2.3 产生背景"></a>2.3 产生背景</h3><p>在常见的 <strong>分布式系统</strong> 中，总会发生 <strong>节点宕机</strong> 或 <strong>网络异常</strong> (包括消息的 <strong>重复</strong>、<strong>丢失</strong>、<strong>延迟</strong>、<strong>乱序</strong>、<strong>网络分区</strong>) 等情况。</p><p><code>Paxos</code> 算法主要就是解决如何在一个 <strong>发生如上故障</strong> 的分布式系统中，快速正确的在集群内 <strong>对某个值达成一致</strong>，并且保证 <strong>整个系统的一致性</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/paxos_background.png" alt=""></p><h2 id="3-算法详解"><a href="#3-算法详解" class="headerlink" title="3. 算法详解"></a>3. 算法详解</h2><h3 id="3-1-角色-amp-提案"><a href="#3-1-角色-amp-提案" class="headerlink" title="3.1 角色 &amp; 提案"></a>3.1 角色 &amp; 提案</h3><h4 id="提案-Proposal"><a href="#提案-Proposal" class="headerlink" title="提案 (Proposal)"></a>提案 (Proposal)</h4><blockquote><p>注意：提案的范围&gt;value.后面会讲到，[提案=编号+Value].也可表示为[M,V].<br>以下描述中暂定: 提案=P，Value=V.</p></blockquote><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ol><li><p><strong>Proposer</strong> : <code>Proposer</code> 可以 <strong>提出提案</strong> (<code>Proposal</code>)。</p></li><li><p><strong>Accecptor</strong> : <code>Acceptor</code> 可以 <strong>接受提案</strong>。一旦接受提案，<strong>提案</strong> 里面的 <code>value</code> 值就被选定了。</p></li><li><p><strong>Learner</strong> : <code>Acceptor</code> 告诉 <code>Learner</code> 哪个提案被选定了，那么 <code>Learner</code> 就学习这个被选择的 <code>value</code>。</p></li></ol><p><img src="http://ols3fdyll.bkt.clouddn.com/propose_acceptor_learner.png" alt=""></p><blockquote><p>在具体的实现中，一个进程即可能是Proposer,也可能是Acceptor，也可能是Learner。</p></blockquote><h3 id="3-2-问题描述"><a href="#3-2-问题描述" class="headerlink" title="3.2. 问题描述"></a>3.2. 问题描述</h3><p><code>Paxos</code> 算法的核心是 <strong>一致性</strong>。所以将从一致性问题的描述来讲解该算法怎么解决实际问题。</p><h4 id="3-2-1-一致性算法的前置条件"><a href="#3-2-1-一致性算法的前置条件" class="headerlink" title="3.2.1. 一致性算法的前置条件"></a>3.2.1. 一致性算法的前置条件</h4><ol><li>在被提出的 <code>P</code> 中，只有一个 <code>V</code> 被选中。</li><li>如果没有 <code>P</code> 被提出，就没有 <code>V</code> 被选中。</li><li>在 <code>P</code> 被选定后，进程都可以学习被选中的 <code>P</code>。</li></ol><h4 id="3-2-2-不同角色通过发送消息进行通信"><a href="#3-2-2-不同角色通过发送消息进行通信" class="headerlink" title="3.2.2. 不同角色通过发送消息进行通信"></a>3.2.2. 不同角色通过发送消息进行通信</h4><ol><li><p>每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个 <code>value</code> 被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值。</p></li><li><p>消息在传递过程中可能出现 <strong>任意时长的延迟</strong>，可能会 <strong>重复</strong>，也可能 <strong>丢失</strong>，但是消息不会被 <strong>损坏</strong>。</p></li></ol><h3 id="3-3-推导过程"><a href="#3-3-推导过程" class="headerlink" title="3.3. 推导过程"></a>3.3. 推导过程</h3><h4 id="3-3-1-只有一个Acceptor"><a href="#3-3-1-只有一个Acceptor" class="headerlink" title="3.3.1. 只有一个Acceptor"></a>3.3.1. 只有一个Acceptor</h4><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_1.png" alt=""></p><p>一个 <code>Acceptor</code> 接受一个 <code>P</code>，那么只有一个 <code>V</code> 被选定。</p><blockquote><p>问题：如果这个 Acceptor 宕机，那么整个系统服务不可用。</p></blockquote><h3 id="3-3-2-多个Acceptor"><a href="#3-3-2-多个Acceptor" class="headerlink" title="3.3.2. 多个Acceptor"></a>3.3.2. 多个Acceptor</h3><p><img src="http://ols3fdyll.bkt.clouddn.com/Multi_Acceptor.png" alt=""></p><blockquote><p>问题：如何在多 Proposer 和多 Acceptor 情况下，选定一个 value？</p></blockquote><p>讲解步骤分两阶段：<strong>约定</strong> <code>P1</code> 和 <strong>约定</strong> <code>P2</code>。</p><h4 id="3-3-2-1-约定P1"><a href="#3-3-2-1-约定P1" class="headerlink" title="3.3.2.1. 约定P1"></a>3.3.2.1. 约定P1</h4><blockquote><p><strong>P1</strong> ：一个 Acceptor 必须接受一个它收到的第一个 P。</p></blockquote><p>如果每个 Proposer 会产生不同的 P，那么多个 Proposer 必定产生多个 P，发给多个 Acceptor。根据 <strong>约定</strong> <code>P1</code>，<code>Acceptor</code> 分别接受到 <code>P</code>，就会导致不同的 <code>V</code> 被选定，如下图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_2.png" alt=""></p><p>如上图所示，<code>P1</code> 会产生的问题: <code>v1</code>、<code>v2</code>、<code>v3</code> 都没有被选定，因为他们只有被一个 <code>Acceptor</code> 接受。</p><p>对于上述问题，我们需要一个额外的约定: </p><blockquote><p><strong>P1a</strong> : 一个提案 P 被选定，需要被半数以上 Acceptor 接受.</p></blockquote><p>对于 <code>P1a</code>，其实就意味着 <strong>一个Acceptor必须接受不止一个提案</strong>。</p><p>显然，这与 <code>P1</code> 相矛盾，所以需要重新设计提案。原来的设计是: <code>[提案P = value]</code>，现在重新设计 <code>[提案P = 提案编号 + value]</code>，可表示为 <code>[M，V]</code>。</p><blockquote><p>新问题：多提案被选定，如何保证被选定的提案 P 具有相同的value?</p></blockquote><h4 id="3-3-2-2-约定P2"><a href="#3-3-2-2-约定P2" class="headerlink" title="3.3.2.2. 约定P2"></a>3.3.2.2. 约定P2</h4><blockquote><p><strong>P2</strong> : 如果提案 P[M0,V0] 被选定了，那么所有比 M0 编号更高的，且被选定的 P，其 value 的值也是 V0。</p></blockquote><p>对于 <code>P2</code> 中的 “<strong>被选定</strong>”：一个提案要被选定，首先至少要被一个 <code>Acceptor</code> 批准。因此，可以理解 <code>P2</code> 为：</p><blockquote><p><strong>P2a</strong> : 如果提案 P[M0,V0] 被选定了，那么所有比 M0 编号更高的，且 [被Acceptor批准] 的P，其 value 值也是 V0。</p></blockquote><p>只要满足 <code>P2a</code>，就能满足 <code>P2</code>。<strong>多提案被选择</strong> 的问题解决了，但是由于 <strong>网络不稳定</strong> 或者 <strong>宕机</strong> 的原因（不可避免），会产生新问题：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_4.png" alt=""></p><p>假设有 <code>5</code> 个 <code>Acceptor</code>。<code>Proposer2</code> 提出 <code>[M1,V1]</code>的提案，<code>Acceptor2~5</code>（<strong>半数以上</strong>）均接受了该提案，于是对于 <code>Acceptor2~5</code> 和 <code>Proposer2</code> 来讲，它们都认为 <code>V1</code> 被选定。<code>Acceptor1</code> 刚刚从 <strong>宕机状态</strong> 恢复过来（之前 <code>Acceptor1</code> 没有收到过任何提案），此时 <code>Proposer1</code> 向 <code>Acceptor1</code> 发送了 <code>[M2,V2]</code> 的提案 <strong>（V2≠V1且M2&gt;M1）</strong>。对于 <code>Acceptor1</code> 来讲，这是它收到的 <strong>第一个提案</strong>。根据 <code>P1</code>（一个 <code>Acceptor</code> 必须接受它收到的 <strong>第一个提案</strong>），<code>Acceptor1</code> 必须接受该提案。同时 <code>Acceptor1</code> 认为 <code>V2</code> 被选定。</p><p>这就出现了两个问题：</p><ol><li><p><code>Acceptor1</code> 认为 <code>V2</code> 被选定，<code>Acceptor2~5</code> 和<code>Proposer2</code> 认为 <code>V1</code> 被选定。出现了<strong>不一致</strong>。</p></li><li><p><code>V1</code> 被选定了，但是 <strong>编号更高</strong> 的被 <code>Acceptor1</code> 接受的提案 <code>[M2,V2]</code> 的 <code>value</code> 为 <code>V2</code>，且 <strong>V2≠V1</strong>。这就跟 <code>P2a</code>（如果某个 <code>value</code> 为 <code>v</code>的提案被选定了，那么每个 <strong>编号更高</strong> 的被 <code>Acceptor</code> 接受的提案的 <code>value</code> 必须也是 <code>v</code>）<strong>矛盾</strong>了。</p></li></ol><p>基于以上问题，所有就有了 <code>P2b</code>:</p><blockquote><p><strong>P2b</strong> : 如果 P[M0,V0] 被选定后，任何 Proposer 产生的 P，其值也是 V0。</p></blockquote><p>对于 <code>P2b</code> 中的描述，怎样保证 <strong>任何Proposer产生的P，其值也是V0</strong> ？只要满足 <code>P2c</code> 即可：</p><blockquote><p><strong>P2c</strong>: 对于任意的 M、V，如果 [M,V] 被提出，那么存在一个半数以上的 Acceptor 组成的组合 S，满足以下两个条件中的任何一个：<br>① S 中没有一个接受过编号小于 M 的提案。<br>② S 中的 Acceptor 接受过的最大编号的提案的 value 为 V。</p></blockquote><p>推导完毕。。。</p><h3 id="3-4-算法流程"><a href="#3-4-算法流程" class="headerlink" title="3.4. 算法流程"></a>3.4. 算法流程</h3><h4 id="3-4-1-Proposer提出提案"><a href="#3-4-1-Proposer提出提案" class="headerlink" title="3.4.1. Proposer提出提案"></a>3.4.1. Proposer提出提案</h4><p>总体思路如下：</p><h5 id="一-学习阶段：Prepare请求"><a href="#一-学习阶段：Prepare请求" class="headerlink" title="(一). 学习阶段：Prepare请求"></a>(一). 学习阶段：Prepare请求</h5><p><code>Proposer</code> 选择一个新的提案 <code>P[MN,?]</code> 向 <code>Acceptor</code> 集合 <code>S</code>（数目在<strong>半数以上</strong>）发送请求，要求 <code>S</code> 中的每一个 <code>Acceptor</code> 做出如下响应：</p><ol><li><p>如果 <code>Acceptor</code> 没有接受过提案，则向 <code>Proposer</code> 保证 <strong>不再接受编号小于N的提案</strong>。</p></li><li><p>如果 <code>Acceptor</code> 接受过请求，则向 <code>Proposer</code> 返回 <strong>已经接受过的编号小于N的编号最大的提案</strong>。</p></li></ol><h5 id="二-接受阶段：Acceptor请求"><a href="#二-接受阶段：Acceptor请求" class="headerlink" title="(二). 接受阶段：Acceptor请求"></a>(二). 接受阶段：Acceptor请求</h5><ol><li><p>如果 <code>Proposer</code> 收到 <strong>半数以上</strong> 的 <code>Acceptor</code> 响应，则 <strong>生成编号为</strong> <code>N</code>，<code>value</code> 为 <code>V</code> 的提案 <code>[MN,V]</code>，<code>V</code> 为所有响应中 <strong>编号最大</strong> 的提案的 <code>value</code>。</p></li><li><p>如果 <code>Proposer</code> 收到的响应中 <strong>没有提案</strong>，那么 <code>value</code> 由 <code>Proposer</code> <strong>自己生成</strong>，生成后将此提案发给 <code>S</code>，并期望 <code>Acceptor</code> 能接受此提案。</p></li></ol><h4 id="3-4-2-Acceptor接受提案"><a href="#3-4-2-Acceptor接受提案" class="headerlink" title="3.4.2. Acceptor接受提案"></a>3.4.2. Acceptor接受提案</h4><p><code>Acceptor</code> 可以忽略任何请求（包括 <code>Prepare</code> 请求和 <code>Accept</code> 请求）而不用担心破坏 <strong>算法的安全性</strong>。因此，我们这里要讨论的是什么时候 <code>Acceptor</code> 可以响应一个请求。</p><p>对 <code>Acceptor</code> 接受提案给出如下约束：</p><blockquote><p><strong>P1b</strong>：一个 Acceptor 只要尚未响应过任何编号大于 N 的 Prepare 请求，那么就可以接受这个编号为 N 的提案。</p></blockquote><p>如果 <code>Acceptor</code> 收到一个编号为 <code>N</code> 的 <code>Prepare</code> 请求，在此之前它已经 <strong>响应过</strong> 编号大于 <code>N</code> 的 <code>Prepare</code> 请求。根据 <code>P1b</code>，该 <code>Acceptor</code> 不可能接受编号为 <code>N</code> 的提案。因此，该 <code>Acceptor</code> 可以 <strong>忽略</strong> 编号为 <code>N</code> 的 <code>Prepare</code> 请求。当然，也可以回复一个 <code>error</code>，让 <code>Proposer</code> 尽早知道自己的提案 <strong>不会被接受</strong>。</p><p>因此，一个 <code>Acceptor</code> 只需记住：</p><ol><li>已接受的编号最大的提案；</li><li>已响应的请求的最大编号。</li></ol><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_5.png" alt=""></p><h2 id="4-Paxos算法描述"><a href="#4-Paxos算法描述" class="headerlink" title="4. Paxos算法描述"></a>4. Paxos算法描述</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_6.png" alt=""></p><h2 id="5-Learner学习提案"><a href="#5-Learner学习提案" class="headerlink" title="5. Learner学习提案"></a>5. Learner学习提案</h2><p><code>Learner</code> 学习（获取）被选定的 <code>value</code> 有如下三种方案:</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_7.png" alt=""></p><h2 id="6-如何保证Paxos算法的活性"><a href="#6-如何保证Paxos算法的活性" class="headerlink" title="6. 如何保证Paxos算法的活性"></a>6. 如何保证Paxos算法的活性</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/Paxos_Prove_8.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>Paxos</code> 在 <strong>节点宕机恢复</strong>、<strong>消息无序或丢失</strong>、<strong>网络分化</strong> 的场景下能保证 <strong>数据的一致性</strong>。而 <code>Paxos</code> 的描述侧重于 <strong>理论</strong>，在实际项目应用中，处理了 <code>N</code> 多实际细节后，可能已经变成了另外一种算法，这时候正确性已经无法得到理论的保证。</p><p>要证明分布式一致性算法的正确性通常比实现算法还困难。所以很多系统实际中使用的都是以 <code>Paxos</code> <strong>理论</strong> 为基础而 <strong>衍生</strong> 出来的变种和简化版。例如 <code>Google</code> 的 <code>Chubby</code>、<code>MegaStore</code>、<code>Spanner</code> 等系统，<code>ZooKeeper</code> 的 <code>ZAB</code> 协议，还有更加容易理解的 <code>Raft</code> 协议。</p><p>大部分系统都是靠在实践中运行很长一段时间，经过验证发现系统已可以基本运行，没有发现大的问题才能上生产环境。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;世界上只有一种一致性算法，就是 &lt;code&gt;Paxos&lt;/code&gt;。出自一位 &lt;code&gt;Google&lt;/code&gt; 大神之口。&lt;code&gt;Paxos&lt;/code&gt; 也是出名的 &lt;strong&gt;晦涩难懂&lt;/strong&gt;，推理过程极其复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Paxos" scheme="https://ostenant.coding.me/tags/Paxos/"/>
    
  </entry>
  
  <entry>
    <title>单元测试利器Mockito框架</title>
    <link href="https://ostenant.coding.me/2018/05/31/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%08%E5%88%A9%E5%99%A8Mockito%E6%A1%86%E6%9E%B6/"/>
    <id>https://ostenant.coding.me/2018/05/31/单元测试利器Mockito框架/</id>
    <published>2018-05-31T15:30:00.000Z</published>
    <updated>2018-06-18T01:55:40.276Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Mockito</code> 是当前最流行的 <strong>单元测试</strong> <code>Mock</code> 框架。采用 <code>Mock</code> 框架，我们可以 <strong>虚拟</strong> 出一个 <strong>外部依赖</strong>，降低测试 <strong>组件</strong> 之间的 <strong>耦合度</strong>，只注重代码的 <strong>流程与结果</strong>，真正地实现测试目的。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是Mock"><a href="#什么是Mock" class="headerlink" title="什么是Mock"></a>什么是Mock</h2><p><code>Mock</code> 的中文译为仿制的，模拟的，虚假的。对于测试框架来说，即构造出一个模拟/虚假的对象，使我们的测试能顺利进行下去。</p><p><code>Mock</code> 测试就是在测试过程中，对于某些 <strong>不容易构造</strong>（如 <code>HttpServletRequest</code> 必须在 <code>Servlet</code> 容器中才能构造出来）或者不容易获取 <strong>比较复杂</strong> 的对象（如 <code>JDBC</code> 中的 <code>ResultSet</code> 对象），用一个 <strong>虚拟</strong> 的对象（<code>Mock</code> 对象）来创建，以便测试方法。</p><h2 id="为什么使用Mock测试"><a href="#为什么使用Mock测试" class="headerlink" title="为什么使用Mock测试"></a>为什么使用Mock测试</h2><p><strong>单元测试</strong> 是为了验证我们的代码运行正确性，我们注重的是代码的流程以及结果的正确与否。</p><p>对比真实运行代码，可能其中有一些 <strong>外部依赖</strong> 的构建步骤相对麻烦，如果我们还是按照真实代码的构建规则构造出外部依赖，会大大增加单元测试的工作，代码也会参杂太多非测试部分的内容，测试用例显得复杂难懂。</p><p>采用 <code>Mock</code> 框架，我们可以 <strong>虚拟</strong> 出一个 <strong>外部依赖</strong>，只注重代码的 <strong>流程与结果</strong>，真正地实现测试目的。</p><h2 id="Mock测试框架的好处"><a href="#Mock测试框架的好处" class="headerlink" title="Mock测试框架的好处"></a>Mock测试框架的好处</h2><ol><li>可以很简单的虚拟出一个复杂对象（比如虚拟出一个接口的实现类）；</li><li>可以配置 <code>mock</code> 对象的行为；</li><li>可以使测试用例只注重测试流程与结果；</li><li>减少外部类、系统和依赖给单元测试带来的耦合。</li></ol><h2 id="Mockito的流程"><a href="#Mockito的流程" class="headerlink" title="Mockito的流程"></a>Mockito的流程</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/mokito.png" alt=""></p><p>如图所示，使用 <code>Mockito</code> 的大致流程如下:</p><ol><li><p>创建 <strong>外部依赖</strong> 的 <code>Mock</code> 对象, 然后将此 <code>Mock</code> 对象注入到 <strong>测试类</strong> 中；</p></li><li><p>执行 <strong>测试代码</strong>；</p></li><li><p>校验 <strong>测试代码</strong> 是否执行正确。</p></li></ol><h2 id="Mockito的使用"><a href="#Mockito的使用" class="headerlink" title="Mockito的使用"></a>Mockito的使用</h2><p>在 <code>Module</code> 的 <code>build.gradle</code> 中添加如下内容：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//Mockito for unit tests</span></span><br><span class="line">    testImplementation <span class="string">"org.mockito:mockito-core:2.+"</span></span><br><span class="line">    <span class="comment">//Mockito for Android tests</span></span><br><span class="line">    androidTestImplementation <span class="string">'org.mockito:mockito-android:2.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里稍微解释下：</p><ul><li><code>mockito-core</code>: 用于 <strong>本地单元测试</strong>，其测试代码路径位于 <code>module-name/src/test/java/</code></li><li><code>mockito-android</code>: 用于 <strong>设备测试</strong>，即需要运行 <code>android</code> 设备进行测试，其测试代码路径位于 <code>module-name/src/androidTest/java/</code></li></ul><blockquote><p>mockito-core最新版本可以在 Maven 中查询：mockito-core。<br>mockito-android最新版本可以在 Maven 中查询：mockito-android</p></blockquote><h3 id="Mockito的使用示例"><a href="#Mockito的使用示例" class="headerlink" title="Mockito的使用示例"></a>Mockito的使用示例</h3><p>普通单元测试使用 <code>mockito（mockito-core）</code>，路径：<code>module-name/src/test/java/</code></p><p>这里摘用官网的 <code>Demo</code>:</p><h4 id="检验调对象相关行为是否被调用"><a href="#检验调对象相关行为是否被调用" class="headerlink" title="检验调对象相关行为是否被调用"></a>检验调对象相关行为是否被调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mock creation</span></span><br><span class="line">List mockedList = mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use mock object - it does not throw any "unexpected interaction" exception</span></span><br><span class="line">mockedList.add(<span class="string">"one"</span>); <span class="comment">//调用了add("one")行为</span></span><br><span class="line">mockedList.clear(); <span class="comment">//调用了clear()行为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Selective, explicit, highly readable verification</span></span><br><span class="line">verify(mockedList).add(<span class="string">"one"</span>); <span class="comment">// 检验add("one")是否已被调用</span></span><br><span class="line">verify(mockedList).clear(); <span class="comment">// 检验clear()是否已被调用</span></span><br></pre></td></tr></table></figure><p>这里 <code>mock</code> 了一个 <code>List</code>（这里只是为了用作 <code>Demo</code> 示例，通常对于 <code>List</code> 这种简单的类对象创建而言，直接 <code>new</code> 一个真实的对象即可，无需进行 <code>mock</code>），<code>verify()</code> 会检验对象是否在前面已经执行了相关行为，这里 <code>mockedList</code> 在 <code>verify</code> 之前已经执行了 <code>add(&quot;one&quot;)</code> 和 <code>clear()</code> 行为，所以<code>verify()</code> 会通过。</p><h4 id="配置-方法行为"><a href="#配置-方法行为" class="headerlink" title="配置/方法行为"></a>配置/方法行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// you can mock concrete classes, not only interfaces</span></span><br><span class="line">LinkedList mockedList = mock(LinkedList.class);</span><br><span class="line"><span class="comment">// stubbing appears before the actual execution</span></span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">"first"</span>);</span><br><span class="line"><span class="comment">// the following prints "first"</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// the following prints "null" because get(999) was not stubbed</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br></pre></td></tr></table></figure><p>这里对几个比较重要的点进行解析：</p><blockquote><p>when(mockedList.get(0)).thenReturn(“first”)</p></blockquote><p>这句话 <code>Mockito</code> 会解析为：当对象 <code>mockedList</code> 调用 <code>get()</code>方法，并且参数为 <code>0</code> 时，返回结果为<code>&quot;first&quot;</code>，这相当于定制了我们 <code>mock</code> 对象的行为结果（<code>mock LinkedList</code> 对象为 <code>mockedList</code>，指定其行为 <code>get(0)</code>，则返回结果为 <code>&quot;first&quot;</code>)。</p><blockquote><p>mockedList.get(999)</p></blockquote><p>由于 <code>mockedList</code> 没有指定 <code>get(999)</code> 的行为，所以其结果为 <code>null</code>。因为 <code>Mockito</code> 的底层原理是使用 <code>cglib</code> 动态生成一个 <strong>代理类对象</strong>，因此，<code>mock</code> 出来的对象其实质就是一个 <strong>代理</strong>，该代理在 <strong>没有配置/指定行为</strong> 的情况下，默认返回 <strong>空值</strong>。</p><p>上面的 <code>Demo</code> 使用的是 <strong>静态方法</strong> <code>mock()</code> 模拟出一个实例，我们还可以通过注解 <code>@Mock</code> 也模拟出一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> Intent mIntent;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> MockitoRule mockitoRule = MockitoJUnit.rule();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockAndroid</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Intent intent = mockIntent();</span><br><span class="line">    assertThat(intent.getAction()).isEqualTo(<span class="string">"com.yn.test.mockito"</span>);</span><br><span class="line">    assertThat(intent.getStringExtra(<span class="string">"Name"</span>)).isEqualTo(<span class="string">"Whyn"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">mockIntent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    when(mIntent.getAction()).thenReturn(<span class="string">"com.yn.test.mockito"</span>);</span><br><span class="line">    when(mIntent.getStringExtra(<span class="string">"Name"</span>)).thenReturn(<span class="string">"Whyn"</span>);</span><br><span class="line">    <span class="keyword">return</span> mIntent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于标记有 <code>@Mock</code>, <code>@Spy</code>, <code>@InjectMocks</code> 等注解的成员变量的 <strong>初始化</strong> 到目前为止有 <code>2</code> 种方法：</p><ol><li><p>对 <code>JUnit</code> 测试类添加 <code>@RunWith(MockitoJUnitRunner.class)</code></p></li><li><p>在标示有 <code>@Before</code> 方法内调用初始化方法：<code>MockitoAnnotations.initMocks(Object)</code></p></li></ol><p>上面的测试用例，对于 <code>@Mock</code> 等注解的成员变量的初始化又多了一种方式 <code>MockitoRule</code>。规则 <code>MockitoRule</code> 会自动帮我们调用 <code>MockitoAnnotations.initMocks(this)</code> 去 <strong>实例化</strong> 出 <strong>注解</strong> 的成员变量，我们就无需手动进行初始化了。</p><h2 id="Mockito的重要方法"><a href="#Mockito的重要方法" class="headerlink" title="Mockito的重要方法"></a>Mockito的重要方法</h2><h3 id="实例化虚拟对象"><a href="#实例化虚拟对象" class="headerlink" title="实例化虚拟对象"></a>实例化虚拟对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You can mock concrete classes, not just interfaces</span></span><br><span class="line">LinkedList mockedList = mock(LinkedList.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stubbing</span></span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">"first"</span>);</span><br><span class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> RuntimeException());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Following prints "first"</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// Following throws runtime exception</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// Following prints "null" because get(999) was not stubbed</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Although it is possible to verify a stubbed invocation, usually it's just redundant</span></span><br><span class="line"><span class="comment">// If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).</span></span><br><span class="line"><span class="comment">// If your code doesn't care what get(0) returns, then it should not be stubbed. Not convinced? See here.</span></span><br><span class="line">verify(mockedList).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p>对于所有方法，<code>mock</code> 对象默认返回 <code>null</code>，<strong>原始类型/原始类型包装类</strong> 默认值，或者 <strong>空集合</strong>。比如对于 <code>int/Integer</code> 类型，则返回 <code>0</code>，对于 <code>boolean/Boolean</code> 则返回 <code>false</code>。</p></li><li><p>行为配置（<code>stub</code>）是可以被复写的：比如通常的对象行为是具有一定的配置，但是测试方法可以复写这个行为。请谨记行为复写可能表明潜在的行为太多了。</p></li><li><p>一旦配置了行为，方法总是会返回 <strong>配置值</strong>，无论该方法被调用了多少次。</p></li><li><p>最后一次行为配置是更加重要的，当你为一个带有相同参数的相同方法配置了很多次，最后一次起作用。</p></li></ul><h3 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h3><p><code>Mockito</code> 通过参数对象的 <code>equals()</code> 方法来验证参数是否一致，当需要更多的灵活性时，可以使用参数匹配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stubbing using built-in anyInt() argument matcher</span></span><br><span class="line">when(mockedList.get(anyInt())).thenReturn(<span class="string">"element"</span>);</span><br><span class="line"><span class="comment">// Stubbing using custom matcher (let's say isValid() returns your own matcher implementation):</span></span><br><span class="line">when(mockedList.contains(argThat(isValid()))).thenReturn(<span class="string">"element"</span>);</span><br><span class="line"><span class="comment">// Following prints "element"</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"><span class="comment">// You can also verify using an argument matcher</span></span><br><span class="line">verify(mockedList).get(anyInt());</span><br><span class="line"><span class="comment">// Argument matchers can also be written as Java 8 Lambdas</span></span><br><span class="line">verify(mockedList).add(argThat(someString -&gt; someString.length() &gt; <span class="number">5</span>));</span><br></pre></td></tr></table></figure><p><strong>参数匹配器</strong> 允许更加灵活的 <strong>验证</strong> 和 <strong>行为配置</strong>。更多 <strong>内置匹配器</strong> 和 <strong>自定义参数匹配器</strong> 例子请参考：<code>ArgumentMatchers</code>，<code>MockitoHamcrest</code></p><blockquote><p>注意：如果使用了参数匹配器，那么所有的参数都需要提供一个参数匹配器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verify(mock).someMethod(anyInt(), anyString(), eq(<span class="string">"third argument"</span>));</span><br><span class="line"><span class="comment">// Above is correct - eq() is also an argument matcher</span></span><br><span class="line">verify(mock).someMethod(anyInt(), anyString(), <span class="string">"third argument"</span>);</span><br><span class="line"><span class="comment">// Above is incorrect - exception will be thrown because third argument is given without an argument matcher.</span></span><br></pre></td></tr></table></figure><p>类似 <code>anyObject()</code>，<code>eq()</code> 这类匹配器并不返回匹配数值。他们内部记录一个 <strong>匹配器堆栈</strong> 并返回一个空值（通常为 <code>null</code>）。这个实现是为了匹配 <code>java</code> 编译器的 <strong>静态类型安全</strong>，这样做的后果就是你不能在 <strong>检验/配置方法</strong> 外使用 <code>anyObject()</code>，<code>eq()</code> 等方法。</p><h3 id="校验次数"><a href="#校验次数" class="headerlink" title="校验次数"></a>校验次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LinkedList mockedList = mock(LinkedList.class);</span><br><span class="line"><span class="comment">// Use mock</span></span><br><span class="line">mockedList.add(<span class="string">"once"</span>);</span><br><span class="line">mockedList.add(<span class="string">"twice"</span>);</span><br><span class="line">mockedList.add(<span class="string">"twice"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Follow two verifications work exactly the same - times(1) is used by default</span></span><br><span class="line">verify(mockedList).add(<span class="string">"once"</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">"once"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exact number of invocations verification</span></span><br><span class="line">verify(mockedList, times(<span class="number">2</span>)).add(<span class="string">"twice"</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">"three times"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verification using never(). never() is an alias to times(0)</span></span><br><span class="line">verify(mockedList, never()).add(<span class="string">"never happened"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verification using atLeast()/atMost()</span></span><br><span class="line">verify(mockedList, atLeastOnce()).add(<span class="string">"three times"</span>);</span><br><span class="line">verify(mockedList, atLeast(<span class="number">2</span>)).add(<span class="string">"three times"</span>);</span><br><span class="line">verify(mockedList, atMost(<span class="number">5</span>)).add(<span class="string">"three times"</span>);</span><br></pre></td></tr></table></figure><p>校验次数方法常用的有如下几个：</p><table><thead><tr><th style="text-align:left">Method</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">times(n)</td><td style="text-align:left">次数为n，默认为1（times(1)）</td></tr><tr><td style="text-align:left">never()</td><td style="text-align:left">次数为0，相当于times(0)</td></tr><tr><td style="text-align:left">atLeast(n)</td><td style="text-align:left">最少n次</td></tr><tr><td style="text-align:left">atLeastOnce()</td><td style="text-align:left">最少一次</td></tr><tr><td style="text-align:left">atMost(n)</td><td style="text-align:left">最多n次</td></tr></tbody></table><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</span><br><span class="line"><span class="comment">// following throws RuntimeException</span></span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure><h3 id="按顺序校验"><a href="#按顺序校验" class="headerlink" title="按顺序校验"></a>按顺序校验</h3><p>有时对于一些行为，有先后顺序之分，所以，当我们在校验时，就需要考虑这个行为的先后顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A. Single mock whose methods must be invoked in a particular order</span></span><br><span class="line">List singleMock = mock(List.class);</span><br><span class="line"><span class="comment">// Use a single mock</span></span><br><span class="line">singleMock.add(<span class="string">"was added first"</span>);</span><br><span class="line">singleMock.add(<span class="string">"was added second"</span>);</span><br><span class="line"><span class="comment">// Create an inOrder verifier for a single mock</span></span><br><span class="line">InOrder inOrder = inOrder(singleMock);</span><br><span class="line"><span class="comment">// Following will make sure that add is first called with "was added first, then with "was added second"</span></span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">"was added first"</span>);</span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">"was added second"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B. Multiple mocks that must be used in a particular order</span></span><br><span class="line">List firstMock = mock(List.class);</span><br><span class="line">List secondMock = mock(List.class);</span><br><span class="line"><span class="comment">// Use mocks</span></span><br><span class="line">firstMock.add(<span class="string">"was called first"</span>);</span><br><span class="line">secondMock.add(<span class="string">"was called second"</span>);</span><br><span class="line"><span class="comment">// Create inOrder object passing any mocks that need to be verified in order</span></span><br><span class="line">InOrder inOrder = inOrder(firstMock, secondMock);</span><br><span class="line"><span class="comment">// Following will make sure that firstMock was called before secondMock</span></span><br><span class="line">inOrder.verify(firstMock).add(<span class="string">"was called first"</span>);</span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">"was called second"</span>);</span><br></pre></td></tr></table></figure><h3 id="存根连续调用"><a href="#存根连续调用" class="headerlink" title="存根连续调用"></a>存根连续调用</h3><p>对于同一个方法，如果我们想让其在 <strong>多次调用</strong> 中分别 <strong>返回不同</strong> 的数值，那么就可以使用存根连续调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">when(mock.someMethod(<span class="string">"some arg"</span>))</span><br><span class="line">    .thenThrow(<span class="keyword">new</span> RuntimeException())</span><br><span class="line">    .thenReturn(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// First call: throws runtime exception:</span></span><br><span class="line">mock.someMethod(<span class="string">"some arg"</span>);</span><br><span class="line"><span class="comment">// Second call: prints "foo"</span></span><br><span class="line">System.out.println(mock.someMethod(<span class="string">"some arg"</span>));</span><br><span class="line"><span class="comment">// Any consecutive call: prints "foo" as well (last stubbing wins).</span></span><br><span class="line">System.out.println(mock.someMethod(<span class="string">"some arg"</span>));</span><br></pre></td></tr></table></figure><p>也可以使用下面更简洁的存根连续调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">when(mock.someMethod(<span class="string">"some arg"</span>)).thenReturn(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：存根连续调用要求必须使用链式调用，如果使用的是同个方法的多个存根配置，那么只有最后一个起作用（覆盖前面的存根配置）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All mock.someMethod("some arg") calls will return "two"</span></span><br><span class="line">when(mock.someMethod(<span class="string">"some arg"</span>).thenReturn(<span class="string">"one"</span>)</span><br><span class="line">when(mock.someMethod(<span class="string">"some arg"</span>).thenReturn(<span class="string">"two"</span>)</span><br></pre></td></tr></table></figure><h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>对于 <strong>返回类型</strong> 为 <code>void</code> 的方法，存根要求使用另一种形式的 <code>when(Object)</code> 函数，因为编译器要求括号内不能存在 <code>void</code> 方法。</p><p>例如，存根一个返回类型为 <code>void</code> 的方法，要求调用时抛出一个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</span><br><span class="line"><span class="comment">// Following throws RuntimeException:</span></span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure><h3 id="监视真实对象"><a href="#监视真实对象" class="headerlink" title="监视真实对象"></a>监视真实对象</h3><p>前面使用的都是 <code>mock</code> 出来一个对象。这样，当 <strong>没有配置/存根</strong> 其具体行为的话，结果就会返回 <strong>空类型</strong>。而如果使用 <strong>特务对象</strong>（<code>spy</code>），那么对于 <strong>没有存根</strong> 的行为，它会调用 <strong>原来对象</strong> 的方法。可以把 <code>spy</code> 想象成局部 <code>mock</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally, you can stub out some methods:</span></span><br><span class="line">when(spy.size()).thenReturn(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// Use the spy calls *real* methods</span></span><br><span class="line">spy.add(<span class="string">"one"</span>);</span><br><span class="line">spy.add(<span class="string">"two"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints "one" - the first element of a list</span></span><br><span class="line">System.out.println(spy.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// Size() method was stubbed - 100 is printed</span></span><br><span class="line">System.out.println(spy.size());</span><br><span class="line"><span class="comment">// Optionally, you can verify</span></span><br><span class="line">verify(spy).add(<span class="string">"one"</span>);</span><br><span class="line">verify(spy).add(<span class="string">"two"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：由于 spy 是局部 mock，所以有时候使用 when(Object) 时，无法做到存根作用。此时，就可以考虑使用 doReturn() | Answer() | Throw() 这类方法进行存根：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"><span class="comment">// Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)</span></span><br><span class="line">when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">"foo"</span>);</span><br><span class="line"><span class="comment">// You have to use doReturn() for stubbing</span></span><br><span class="line">doReturn(<span class="string">"foo"</span>).when(spy).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>spy</code> 并不是 <strong>真实对象</strong> 的 <strong>代理</strong>。相反的，它对传递过来的 <strong>真实对象</strong> 进行 <strong>克隆</strong>。所以，对 <strong>真实对象</strong> 的任何操作，<code>spy</code> 对象并不会感知到。同理，对 <code>spy</code> 对象的任何操作，也不会影响到 <strong>真实对象</strong>。</p><p>当然，如果使用 <code>mock</code> 进行对象的 <strong>局部</strong> <code>mock</code>，通过 <code>doCallRealMethod() | thenCallRealMethod()</code> 方法也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You can enable partial mock capabilities selectively on mocks:</span></span><br><span class="line">Foo mock = mock(Foo.class);</span><br><span class="line"><span class="comment">// Be sure the real implementation is 'safe'.</span></span><br><span class="line"><span class="comment">// If real implementation throws exceptions or depends on specific state of the object then you're in trouble.</span></span><br><span class="line">when(mock.someMethod()).thenCallRealMethod();</span><br></pre></td></tr></table></figure><h3 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h3><p>以 <strong>行为驱动开发</strong> 的格式使用 //given //when //then 注释为测试用法基石编写测试用例，这正是 <code>Mockito</code> 官方编写测试用例方法，强烈建议使用这种方式测试编写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line">Seller seller = mock(Seller.class);</span><br><span class="line">Shop shop = <span class="keyword">new</span> Shop(seller);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldBuyBread</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Given</span></span><br><span class="line">    given(seller.askForBread()).willReturn(<span class="keyword">new</span> Bread());</span><br><span class="line">    <span class="comment">// When</span></span><br><span class="line">    Goods goods = shop.buyBread();</span><br><span class="line">    <span class="comment">// Then</span></span><br><span class="line">    assertThat(goods, containBread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义错误校验输出信息"><a href="#自定义错误校验输出信息" class="headerlink" title="自定义错误校验输出信息"></a>自定义错误校验输出信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Will print a custom message on verification failure</span></span><br><span class="line">verify(mock, description(<span class="string">"This will print on failure"</span>)).someMethod();</span><br><span class="line"><span class="comment">// Will work with any verification mode</span></span><br><span class="line">verify(mock, times(<span class="number">2</span>).description(<span class="string">"someMethod should be called twice"</span>)).someMethod();</span><br></pre></td></tr></table></figure><h3 id="InjectMock"><a href="#InjectMock" class="headerlink" title="@InjectMock"></a>@InjectMock</h3><p>构造器，方法，成员变量依赖注入<br>使用 <code>@InjectMock</code> 注解时，<code>Mockito</code> 会检查 <strong>类构造器</strong>，<strong>方法</strong> 或 <strong>成员变量</strong>，依据它们的 <strong>类型</strong> 进行自动 <code>mock</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectMockTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> ArticleDatabase database;</span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> ArticleManager manager;</span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> MockitoRule mockitoRule = MockitoJUnit.rule();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInjectMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Calls addListener with an instance of ArticleListener</span></span><br><span class="line">        manager.initialize();</span><br><span class="line">        <span class="comment">// Validate that addListener was called</span></span><br><span class="line">        verify(database).addListener(any(ArticleListener.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> User user;</span><br><span class="line">        <span class="keyword">private</span> ArticleDatabase database;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ArticleManager</span><span class="params">(User user, ArticleDatabase database)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.user = user;</span><br><span class="line">            <span class="keyword">this</span>.database = database;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            database.addListener(<span class="keyword">new</span> ArticleListener());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListener</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDatabase</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(ArticleListener listener)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量 <code>manager</code> 类型为 <code>ArticleManager</code>，它的上面标识别了 <code>@InjectMocks</code>。这意味着要 <code>mock</code> 出 <code>manager</code>，<code>Mockito</code> 需要先自动 <code>mock</code> 出 <code>ArticleManager</code> 所需的 <strong>构造参数</strong>（即：<code>user</code> 和 <code>database</code>），最终 <code>mock</code> 得到一个 <code>ArticleManager</code>，赋值给 <code>manager</code>。</p><h3 id="参数捕捉"><a href="#参数捕捉" class="headerlink" title="参数捕捉"></a>参数捕捉</h3><p><code>ArgumentCaptor</code> 允许在 <code>verify</code> 的时候获取 <strong>方法参数内容</strong>，这使得我们能在 <strong>测试过程</strong> 中能对 <strong>调用方法参数</strong> 进行 <strong>捕捉</strong> 并 <strong>测试</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> MockitoRule mockitoRule = MockitoJUnit.rule();</span><br><span class="line"><span class="meta">@Captor</span></span><br><span class="line"><span class="keyword">private</span> ArgumentCaptor&lt;List&lt;String&gt;&gt; captor;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArgumentCaptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; asList = Arrays.asList(<span class="string">"someElement_test"</span>, <span class="string">"someElement"</span>);</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; mockedList = mock(List.class);</span><br><span class="line">    mockedList.addAll(asList);</span><br><span class="line"></span><br><span class="line">    verify(mockedList).addAll(captor.capture()); <span class="comment">// When verify,you can capture the arguments of the calling method</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; capturedArgument = captor.getValue();</span><br><span class="line">    assertThat(capturedArgument, hasItem(<span class="string">"someElement"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mocktio的局限"><a href="#Mocktio的局限" class="headerlink" title="Mocktio的局限"></a>Mocktio的局限</h2><ol><li>不能 <code>mock</code> 静态方法；</li><li>不能 <code>mock</code> 构造器；</li><li>不能 <code>mock</code> <code>equals()</code> 和 <code>hashCode()</code> 方法。</li></ol><hr><p>欢迎关注技术公众号：零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Mockito&lt;/code&gt; 是当前最流行的 &lt;strong&gt;单元测试&lt;/strong&gt; &lt;code&gt;Mock&lt;/code&gt; 框架。采用 &lt;code&gt;Mock&lt;/code&gt; 框架，我们可以 &lt;strong&gt;虚拟&lt;/strong&gt; 出一个 &lt;strong&gt;外部依赖&lt;/strong&gt;，降低测试 &lt;strong&gt;组件&lt;/strong&gt; 之间的 &lt;strong&gt;耦合度&lt;/strong&gt;，只注重代码的 &lt;strong&gt;流程与结果&lt;/strong&gt;，真正地实现测试目的。&lt;/p&gt;
    
    </summary>
    
      <category term="测试框架系列" scheme="https://ostenant.coding.me/categories/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Mockito" scheme="https://ostenant.coding.me/tags/Mockito/"/>
    
  </entry>
  
  <entry>
    <title>2018服务端架构师技术图谱</title>
    <link href="https://ostenant.coding.me/2018/05/30/2018%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    <id>https://ostenant.coding.me/2018/05/30/2018服务端架构师技术图谱/</id>
    <published>2018-05-30T14:46:00.000Z</published>
    <updated>2018-06-18T01:47:17.430Z</updated>
    
    <content type="html"><![CDATA[<hr><p>本文摘自 <code>github</code> 上的一篇长约 <code>10</code> 万字服务端架构师技术总结归纳文档，覆盖广度包括数据结构、算法、并发、操作系统、设计模式、运维、中间件、网络、数据库、搜索引擎、性能、大数据、安全、常见开源框架、分布式、设计思想、项目管理和技术资源等。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#数据结构">数据结构</a><ul><li><a href="#队列">队列</a></li><li><a href="#集合">集合</a></li><li><a href="#链表数组">链表、数组</a></li><li><a href="#字典关联数组">字典、关联数组</a></li><li><a href="#栈">栈</a></li><li><a href="#树">树</a><ul><li><a href="#二叉树">二叉树</a></li><li><a href="#完全二叉树">完全二叉树</a></li><li><a href="#平衡二叉树">平衡二叉树</a></li><li><a href="#二叉查找树bst">二叉查找树（BST）</a></li><li><a href="#红黑树">红黑树</a></li><li><a href="#b-bb树">B-，B+，B*树</a></li><li><a href="#lsm-树">LSM 树</a></li></ul></li><li><a href="#bitset">BitSet</a></li></ul></li><li><a href="#常用算法">常用算法</a><ul><li><a href="#排序查找算法">排序、查找算法</a><ul><li><a href="#选择排序">选择排序</a></li><li><a href="#冒泡排序">冒泡排序</a></li><li><a href="#插入排序">插入排序</a></li><li><a href="#快速排序">快速排序</a></li><li><a href="#归并排序">归并排序</a></li><li><a href="#希尔排序">希尔排序</a></li><li><a href="#堆排序">堆排序</a></li><li><a href="#计数排序">计数排序</a></li><li><a href="#桶排序">桶排序</a></li><li><a href="#基数排序">基数排序</a></li><li><a href="#二分查找">二分查找</a></li><li><a href="#java-中的排序工具">Java 中的排序工具</a></li></ul></li><li><a href="#布隆过滤器">布隆过滤器</a></li><li><a href="#字符串比较">字符串比较</a><ul><li><a href="#kmp-算法">KMP 算法</a></li></ul></li><li><a href="#深度优先广度优先">深度优先、广度优先</a></li><li><a href="#贪心算法">贪心算法</a></li><li><a href="#回溯算法">回溯算法</a></li><li><a href="#剪枝算法">剪枝算法</a></li><li><a href="#动态规划">动态规划</a></li><li><a href="#朴素贝叶斯">朴素贝叶斯</a></li><li><a href="#推荐算法">推荐算法</a></li><li><a href="#最小生成树算法">最小生成树算法</a></li><li><a href="#最短路径算法">最短路径算法</a></li></ul></li><li><a href="#并发">并发</a><ul><li><a href="#多线程">多线程</a></li><li><a href="#线程安全">线程安全</a></li><li><a href="#一致性事务">一致性、事务</a><ul><li><a href="#事务-acid-特性">事务 ACID 特性</a></li><li><a href="#事务的隔离级别">事务的隔离级别</a></li><li><a href="#mvcc">MVCC</a></li></ul></li><li><a href="#锁">锁</a><ul><li><a href="#java中的锁和同步类">Java中的锁和同步类</a></li><li><a href="#公平锁--非公平锁">公平锁 &amp; 非公平锁</a></li><li><a href="#悲观锁">悲观锁</a></li><li><a href="#乐观锁--cas">乐观锁 &amp; CAS</a></li><li><a href="#aba-问题">ABA 问题</a></li><li><a href="#copyonwrite容器">CopyOnWrite容器</a></li><li><a href="#ringbuffer">RingBuffer</a></li><li><a href="#可重入锁--不可重入锁">可重入锁 &amp; 不可重入锁</a></li><li><a href="#互斥锁--共享锁">互斥锁 &amp; 共享锁</a></li><li><a href="#死锁">死锁</a></li></ul></li></ul></li><li><a href="#操作系统">操作系统</a><ul><li><a href="#计算机原理">计算机原理</a></li><li><a href="#cpu">CPU</a><ul><li><a href="#多级缓存">多级缓存</a></li></ul></li><li><a href="#进程">进程</a></li><li><a href="#线程">线程</a></li><li><a href="#协程">协程</a></li><li><a href="#linux">Linux</a></li></ul></li><li><a href="#设计模式">设计模式</a><ul><li><a href="#设计模式的六大原则">设计模式的六大原则</a></li><li><a href="#23种常见设计模式">23种常见设计模式</a></li><li><a href="#应用场景">应用场景</a></li><li><a href="#单例模式">单例模式</a></li><li><a href="#责任链模式">责任链模式</a></li><li><a href="#mvc">MVC</a></li><li><a href="#ioc">IOC</a></li><li><a href="#aop">AOP</a></li><li><a href="#uml">UML</a></li><li><a href="#微服务思想">微服务思想</a><ul><li><a href="#康威定律">康威定律</a></li></ul></li></ul></li><li><a href="#运维--统计--技术支持">运维 &amp; 统计 &amp; 技术支持</a><ul><li><a href="#常规监控">常规监控</a></li><li><a href="#apm">APM</a></li><li><a href="#统计分析">统计分析</a></li><li><a href="#持续集成cicd">持续集成(CI/CD)</a><ul><li><a href="#jenkins">Jenkins</a></li><li><a href="#环境分离">环境分离</a></li></ul></li><li><a href="#自动化运维">自动化运维</a><ul><li><a href="#ansible">Ansible</a></li><li><a href="#puppet">puppet</a></li><li><a href="#chef">chef</a></li></ul></li><li><a href="#测试">测试</a><ul><li><a href="#tdd-理论">TDD 理论</a></li><li><a href="#单元测试">单元测试</a></li><li><a href="#压力测试">压力测试</a></li><li><a href="#全链路压测">全链路压测</a></li><li><a href="#ab-灰度蓝绿测试">A/B 、灰度、蓝绿测试</a></li></ul></li><li><a href="#虚拟化">虚拟化</a><ul><li><a href="#kvm">KVM</a></li><li><a href="#xen">Xen</a></li><li><a href="#openvz">OpenVZ</a></li></ul></li><li><a href="#容器技术">容器技术</a><ul><li><a href="#docker">Docker</a></li></ul></li><li><a href="#云技术">云技术</a><ul><li><a href="#openstack">OpenStack</a></li></ul></li><li><a href="#devops">DevOps</a></li><li><a href="#文档管理">文档管理</a></li></ul></li><li><a href="#中间件">中间件</a><ul><li><a href="#web-server">Web Server</a><ul><li><a href="#nginx">Nginx</a></li><li><a href="#openresty">OpenResty</a></li><li><a href="#apache-httpd">Apache Httpd</a></li><li><a href="#tomcat">Tomcat</a><ul><li><a href="#架构原理">架构原理</a></li><li><a href="#调优方案">调优方案</a></li></ul></li><li><a href="#jetty">Jetty</a></li></ul></li><li><a href="#缓存">缓存</a><ul><li><a href="#本地缓存">本地缓存</a></li></ul></li><li><a href="#客户端缓存">客户端缓存</a></li><li><a href="#服务端缓存">服务端缓存</a><ul><li><a href="#web缓存">Web缓存</a></li><li><a href="#memcached">Memcached</a></li><li><a href="#redis">Redis</a><ul><li><a href="#架构">架构</a></li><li><a href="#回收策略">回收策略</a></li></ul></li><li><a href="#tair">Tair</a></li></ul></li><li><a href="#消息队列">消息队列</a><ul><li><a href="#消息总线">消息总线</a></li><li><a href="#消息的顺序">消息的顺序</a></li><li><a href="#rabbitmq">RabbitMQ</a></li><li><a href="#rocketmq">RocketMQ</a></li><li><a href="#activemq">ActiveMQ</a></li><li><a href="#kafka">Kafka</a></li><li><a href="#redis-消息推送">Redis 消息推送</a></li><li><a href="#zeromq">ZeroMQ</a></li></ul></li><li><a href="#定时调度">定时调度</a><ul><li><a href="#单机定时调度">单机定时调度</a></li><li><a href="#分布式定时调度">分布式定时调度</a></li></ul></li><li><a href="#rpc">RPC</a><ul><li><a href="#dubbo">Dubbo</a></li><li><a href="#thrift">Thrift</a></li><li><a href="#grpc">gRPC</a></li></ul></li><li><a href="#数据库中间件">数据库中间件</a><ul><li><a href="#sharding-jdbc">Sharding Jdbc</a></li></ul></li><li><a href="#日志系统">日志系统</a><ul><li><a href="#日志搜集">日志搜集</a></li></ul></li><li><a href="#配置中心">配置中心</a></li><li><a href="#api-网关">API 网关</a></li></ul></li><li><a href="#网络">网络</a><ul><li><a href="#协议">协议</a><ul><li><a href="#osi-七层协议">OSI 七层协议</a></li><li><a href="#tcpip">TCP/IP</a></li><li><a href="#http">HTTP</a></li><li><a href="#http20">HTTP2.0</a></li><li><a href="#https">HTTPS</a></li></ul></li><li><a href="#网络模型">网络模型</a><ul><li><a href="#epoll">Epoll</a></li><li><a href="#java-nio">Java NIO</a></li><li><a href="#kqueue">kqueue</a></li></ul></li><li><a href="#连接和短连接">连接和短连接</a></li><li><a href="#框架">框架</a></li><li><a href="#零拷贝zero-copy">零拷贝（Zero-copy）</a></li><li><a href="#序列化二进制协议">序列化(二进制协议)</a><ul><li><a href="#hessian">Hessian</a></li><li><a href="#protobuf">Protobuf</a></li></ul></li></ul></li><li><a href="#数据库">数据库</a><ul><li><a href="#基础理论">基础理论</a><ul><li><a href="#数据库设计的三大范式">数据库设计的三大范式</a></li></ul></li><li><a href="#mysql">MySQL</a><ul><li><a href="#原理">原理</a></li><li><a href="#innodb">InnoDB</a></li><li><a href="#优化">优化</a></li><li><a href="#索引">索引</a><ul><li><a href="#聚集索引-非聚集索引">聚集索引, 非聚集索引</a></li><li><a href="#复合索引">复合索引</a></li><li><a href="#自适应哈希索引ahi">自适应哈希索引(AHI)</a></li></ul></li><li><a href="#explain">explain</a></li></ul></li><li><a href="#nosql">NoSQL</a><ul><li><a href="#mongodb">MongoDB</a></li><li><a href="#hbase">Hbase</a></li></ul></li></ul></li><li><a href="#搜索引擎">搜索引擎</a><ul><li><a href="#搜索引擎原理">搜索引擎原理</a></li><li><a href="#lucene">Lucene</a></li><li><a href="#elasticsearch">Elasticsearch</a></li><li><a href="#solr">Solr</a></li><li><a href="#sphinx">sphinx</a></li></ul></li><li><a href="#性能">性能</a><ul><li><a href="#性能优化方法论">性能优化方法论</a></li><li><a href="#容量评估">容量评估</a></li><li><a href="#cdn-网络">CDN 网络</a></li><li><a href="#连接池">连接池</a></li><li><a href="#性能调优">性能调优</a></li></ul></li><li><a href="#大数据">大数据</a><ul><li><a href="#流式计算">流式计算</a><ul><li><a href="#storm">Storm</a></li><li><a href="#flink">Flink</a></li><li><a href="#kafka-stream">Kafka Stream</a></li><li><a href="#应用场景-1">应用场景</a></li></ul></li><li><a href="#hadoop">Hadoop</a><ul><li><a href="#hdfs">HDFS</a></li><li><a href="#mapreduce">MapReduce</a></li><li><a href="#yarn">Yarn</a></li></ul></li><li><a href="#spark">Spark</a></li></ul></li><li><a href="#安全">安全</a><ul><li><a href="#web-安全">web 安全</a><ul><li><a href="#xss">XSS</a></li><li><a href="#csrf">CSRF</a></li><li><a href="#sql-注入">SQL 注入</a></li><li><a href="#hash-dos">Hash Dos</a></li><li><a href="#脚本注入">脚本注入</a></li><li><a href="#漏洞扫描工具">漏洞扫描工具</a></li><li><a href="#验证码">验证码</a></li></ul></li><li><a href="#ddos-防范">DDoS 防范</a></li><li><a href="#用户隐私信息保护">用户隐私信息保护</a></li><li><a href="#序列化漏洞">序列化漏洞</a></li><li><a href="#加密解密">加密解密</a><ul><li><a href="#对称加密">对称加密</a></li><li><a href="#哈希算法">哈希算法</a></li><li><a href="#非对称加密">非对称加密</a></li></ul></li><li><a href="#服务器安全">服务器安全</a></li><li><a href="#数据安全">数据安全</a><ul><li><a href="#数据备份">数据备份</a></li></ul></li><li><a href="#网络隔离">网络隔离</a><ul><li><a href="#内外网分离">内外网分离</a></li><li><a href="#登录跳板机">登录跳板机</a></li></ul></li><li><a href="#授权认证">授权、认证</a><ul><li><a href="#rbac">RBAC</a></li><li><a href="#oauth20">OAuth2.0</a></li><li><a href="#双因素认证2fa">双因素认证（2FA）</a></li><li><a href="#单点登录sso">单点登录(SSO)</a></li></ul></li></ul></li><li><a href="#常用开源框架">常用开源框架</a><ul><li><a href="#开源协议">开源协议</a></li><li><a href="#日志框架">日志框架</a><ul><li><a href="#log4jlog4j2">Log4j、Log4j2</a></li><li><a href="#logback">Logback</a></li></ul></li><li><a href="#orm">ORM</a></li><li><a href="#网络框架">网络框架</a></li><li><a href="#web-框架">Web 框架</a><ul><li><a href="#spring-家族">Spring 家族</a></li></ul></li><li><a href="#工具框架">工具框架</a></li></ul></li><li><a href="#分布式设计">分布式设计</a><ul><li><a href="#扩展性设计">扩展性设计</a></li><li><a href="#稳定性--高可用">稳定性 &amp; 高可用</a><ul><li><a href="#硬件负载均衡">硬件负载均衡</a></li><li><a href="#软件负载均衡">软件负载均衡</a></li><li><a href="#限流">限流</a></li><li><a href="#应用层容灾">应用层容灾</a></li><li><a href="#跨机房容灾">跨机房容灾</a></li><li><a href="#容灾演练流程">容灾演练流程</a></li><li><a href="#平滑启动">平滑启动</a></li></ul></li><li><a href="#数据库扩展">数据库扩展</a><ul><li><a href="#读写分离模式">读写分离模式</a></li><li><a href="#分片模式">分片模式</a></li></ul></li><li><a href="#服务治理">服务治理</a><ul><li><a href="#服务注册与发现">服务注册与发现</a></li><li><a href="#服务路由控制">服务路由控制</a></li></ul></li><li><a href="#分布式一致">分布式一致</a><ul><li><a href="#cap-与-base-理论">CAP 与 BASE 理论</a></li><li><a href="#分布式锁">分布式锁</a></li><li><a href="#分布式一致性算法">分布式一致性算法</a><ul><li><a href="#paxos">PAXOS</a></li><li><a href="#zab">Zab</a></li><li><a href="#raft">Raft</a></li><li><a href="#gossip">Gossip</a></li><li><a href="#两阶段提交多阶段提交">两阶段提交、多阶段提交</a></li></ul></li><li><a href="#幂等">幂等</a></li><li><a href="#分布式一致方案">分布式一致方案</a></li><li><a href="#分布式-leader-节点选举">分布式 Leader 节点选举</a></li><li><a href="#tcctryconfirmcancel-柔性事务">TCC(Try/Confirm/Cancel) 柔性事务</a></li></ul></li><li><a href="#分布式文件系统">分布式文件系统</a></li><li><a href="#唯一id-生成">唯一ID 生成</a><ul><li><a href="#全局唯一id">全局唯一ID</a></li></ul></li><li><a href="#一致性hash算法">一致性Hash算法</a></li></ul></li><li><a href="#设计思想--开发模式">设计思想 &amp; 开发模式</a><ul><li><a href="#ddddomain-driven-design---领域驱动设计">DDD(Domain-driven Design - 领域驱动设计)</a><ul><li><a href="#命令查询职责分离cqrs">命令查询职责分离(CQRS)</a></li><li><a href="#贫血充血模型">贫血，充血模型</a></li></ul></li><li><a href="#actor-模式">Actor 模式</a></li><li><a href="#响应式编程">响应式编程</a><ul><li><a href="#reactor">Reactor</a></li><li><a href="#rxjava">RxJava</a></li><li><a href="#vertx">Vert.x</a></li></ul></li><li><a href="#dodaf20">DODAF2.0</a></li><li><a href="#serverless">Serverless</a></li><li><a href="#service-mesh">Service Mesh</a></li></ul></li><li><a href="#项目管理">项目管理</a><ul><li><a href="#架构评审">架构评审</a></li><li><a href="#重构">重构</a></li><li><a href="#代码规范">代码规范</a></li><li><a href="#代码-review">代码 Review</a></li><li><a href="#rup">RUP</a></li><li><a href="#看板管理">看板管理</a></li><li><a href="#scrum">SCRUM</a></li><li><a href="#敏捷开发">敏捷开发</a></li><li><a href="#极限编程xp">极限编程（XP）</a></li><li><a href="#结对编程">结对编程</a></li><li><a href="#fmea管理模式">FMEA管理模式</a></li></ul></li><li><a href="#通用业务术语">通用业务术语</a></li><li><a href="#技术趋势">技术趋势</a></li><li><a href="#政策法规">政策、法规</a><ul><li><a href="#法律">法律</a><ul><li><a href="#严格遵守刑法253法条">严格遵守刑法253法条</a></li></ul></li></ul></li><li><a href="#架构师素质">架构师素质</a></li><li><a href="#团队管理">团队管理</a><ul><li><a href="#招聘">招聘</a></li></ul></li><li><a href="#资讯">资讯</a><ul><li><a href="#行业资讯">行业资讯</a></li><li><a href="#公众号列表">公众号列表</a></li><li><a href="#博客">博客</a><ul><li><a href="#团队博客">团队博客</a></li><li><a href="#个人博客">个人博客</a></li></ul></li><li><a href="#综合门户社区">综合门户、社区</a></li><li><a href="#问答讨论类社区">问答、讨论类社区</a></li><li><a href="#行业数据分析">行业数据分析</a></li><li><a href="#专项网站">专项网站</a></li><li><a href="#其他类">其他类</a></li><li><a href="#推荐参考书">推荐参考书</a><ul><li><a href="#在线电子书">在线电子书</a></li><li><a href="#纸质书">纸质书</a><ul><li><a href="#开发方面">开发方面</a></li><li><a href="#架构方面">架构方面</a></li><li><a href="#技术管理方面">技术管理方面</a></li><li><a href="#基础理论-1">基础理论</a></li><li><a href="#工具方面">工具方面</a></li><li><a href="#大数据方面">大数据方面</a></li></ul></li></ul></li></ul></li><li><a href="#技术资源">技术资源</a><ul><li><a href="#开源资源">开源资源</a></li><li><a href="#手册文档教程">手册、文档、教程</a></li><li><a href="#在线课堂">在线课堂</a></li><li><a href="#会议活动">会议、活动</a></li><li><a href="#常用app">常用APP</a></li><li><a href="#找工作">找工作</a></li><li><a href="#工具">工具</a></li><li><a href="#代码托管">代码托管</a></li><li><a href="#文件服务">文件服务</a></li></ul></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li><p><a href="https://www.cnblogs.com/lemon-flm/p/7877898.html" target="_blank" rel="noopener">《java队列——queue详细分析》</a></p><ul><li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li><li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li></ul></li><li><p><a href="https://www.cnblogs.com/mantu/p/5802393.html" target="_blank" rel="noopener">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></p></li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li><a href="https://blog.csdn.net/qq_33642117/article/details/52040345" target="_blank" rel="noopener">《Java Set集合的详解》</a></li></ul><h3 id="链表、数组"><a href="#链表、数组" class="headerlink" title="链表、数组"></a>链表、数组</h3><ul><li><a href="https://blog.csdn.net/wz249863091/article/details/52853360" target="_blank" rel="noopener">《Java集合详解–什么是List》</a></li></ul><h3 id="字典、关联数组"><a href="#字典、关联数组" class="headerlink" title="字典、关联数组"></a>字典、关联数组</h3><ul><li><a href="https://baike.xsoftlab.net/view/250.html" target="_blank" rel="noopener">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li><a href="https://blog.csdn.net/javazejian/article/details/53362993" target="_blank" rel="noopener">《java数据结构与算法之栈（Stack）设计与实现》</a></li><li><a href="http://www.runoob.com/java/java-stack-class.html" target="_blank" rel="noopener">《Java Stack 类》</a></li><li><a href="https://blog.csdn.net/f2006116/article/details/51375225" target="_blank" rel="noopener">《java stack的详细实现分析》</a><ul><li>Stack 是线程安全的。</li><li>内部使用数组保存数据，不够时翻倍。</li></ul></li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>每个节点最多有两个叶子节点。</p><ul><li><a href="https://blog.csdn.net/cai2016/article/details/52589952" target="_blank" rel="noopener">《二叉树》</a></li></ul><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><ul><li><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin" target="_blank" rel="noopener">《完全二叉树》</a><ul><li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li></ul></li></ul><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><ul><li><a href="http://www.cnblogs.com/polly333/p/4798944.html" target="_blank" rel="noopener">《浅谈数据结构-平衡二叉树》</a></li><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html" target="_blank" rel="noopener">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li></ul><h4 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h4><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p><ul><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html" target="_blank" rel="noopener">《浅谈算法和数据结构: 七 二叉查找树》</a></li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul><li><a href="https://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener">《最容易懂得红黑树》</a><ul><li>添加阶段后，左旋或者右旋从而再次达到平衡。 </li></ul></li><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" target="_blank" rel="noopener">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li></ul><h4 id="B-，B-，B-树"><a href="#B-，B-，B-树" class="headerlink" title="B-，B+，B*树"></a>B-，B+，B*树</h4><p>MySQL是基于B+树聚集索引组织表</p><ul><li><a href="https://blog.csdn.net/aqzwss/article/details/53074186" target="_blank" rel="noopener">《B-树，B+树，B*树详解》</a></li><li><a href="https://blog.csdn.net/bigtree_3721/article/details/73632405" target="_blank" rel="noopener">《B-树，B+树与B*树的优缺点比较》</a><ul><li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。<h4 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h4></li></ul></li></ul><p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。<br>Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p><ul><li><p><a href="https://blog.csdn.net/dbanote/article/details/8897599" target="_blank" rel="noopener">《LSM树 VS B+树》</a></p><ul><li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。</li><li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li></ul></li><li><p><a href="https://blog.csdn.net/u014774781/article/details/52105708" target="_blank" rel="noopener">《LSM树（Log-Structured Merge Tree）存储引擎》</a></p><ul><li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li><li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li><li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li></ul></li></ul><h3 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h3><p>经常用于大规模数据的排重检查。</p><ul><li><a href="http://www.runoob.com/java/java-bitset-class.html" target="_blank" rel="noopener">《Java Bitset类》</a></li><li><a href="https://blog.csdn.net/caiandyong/article/details/51581160" target="_blank" rel="noopener">《Java BitSet（位集）》</a></li></ul><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><ul><li><a href="https://blog.csdn.net/gane_cheng/article/details/52652705" target="_blank" rel="noopener">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h3 id="排序、查找算法"><a href="#排序、查找算法" class="headerlink" title="排序、查找算法"></a>排序、查找算法</h3><ul><li><a href="https://blog.csdn.net/gane_cheng/article/details/52652705" target="_blank" rel="noopener">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul><li><a href="https://www.cnblogs.com/shen-hua/p/5424059.html" target="_blank" rel="noopener">《Java中的经典算法之选择排序（SelectionSort）》</a><ul><li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li></ul></li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li><a href="https://blog.csdn.net/shuaizai88/article/details/73250615" target="_blank" rel="noopener">《冒泡排序的2种写法》</a><ul><li>相邻元素前后交换、把最大的排到最后。</li><li>时间复杂度 O(n²) </li></ul></li></ul><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul><li><a href="https://www.cnblogs.com/hapjin/p/5517667.html" target="_blank" rel="noopener">《排序算法总结之插入排序》</a></li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li><a href="http://developer.51cto.com/art/201403/430986.htm" target="_blank" rel="noopener">《坐在马桶上看算法：快速排序》</a><ul><li>一侧比另外一次都大或小。 <h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4></li></ul></li><li><a href="http://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">《图解排序算法(四)之归并排序》</a><ul><li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 </li></ul></li></ul><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>TODO</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">《图解排序算法(三)之堆排序》</a><ul><li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li></ul></li></ul><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul><li><a href="https://www.cnblogs.com/suvllian/p/5495780.html" target="_blank" rel="noopener">《计数排序和桶排序》</a><ul><li>和桶排序过程比较像，差别在于桶的数量。</li></ul></li></ul><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul><li><a href="http://blog.51cto.com/ahalei/1362789" target="_blank" rel="noopener">《【啊哈！算法】最快最简单的排序——桶排序》</a></li><li><a href="https://blog.csdn.net/sunjinshengli/article/details/70738527" target="_blank" rel="noopener">《排序算法（三）：计数排序与桶排序》</a><ul><li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li><li>每个桶单独进行排序，然后再遍历每个桶。</li></ul></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>按照个位、十位、百位、…依次来排。</p><ul><li><a href="https://blog.csdn.net/lemon_tree12138/article/details/51695211" target="_blank" rel="noopener">《排序算法系列：基数排序》</a></li><li><a href="https://www.cnblogs.com/skywang12345/p/3603669.html" target="_blank" rel="noopener">《基数排序》</a></li></ul><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><ul><li><p><a href="https://www.cnblogs.com/coderising/p/5708632.html" target="_blank" rel="noopener">《二分查找(java实现)》</a></p><ul><li>要求待查找的序列有序。</li><li>时间复杂度 O(logN)。</li></ul></li><li><p><a href="https://blog.csdn.net/maoyuanming0806/article/details/78176957" target="_blank" rel="noopener">《java实现二分查找-两种方式》</a></p><ul><li>while + 递归。<h4 id="Java-中的排序工具"><a href="#Java-中的排序工具" class="headerlink" title="Java 中的排序工具"></a>Java 中的排序工具</h4></li></ul></li><li><a href="https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&amp;fps=1" target="_blank" rel="noopener">《Arrays.sort和Collections.sort实现原理解析》</a><ul><li>Collections.sort算法调用的是合并排序。</li><li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li></ul></li></ul><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>常用于大数据的排重，比如email，url 等。<br>核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。<br>优点：空间和时间效率都很高。<br>缺点：随着存入的元素数量增加，误算率随之增加。</p><ul><li><a href="https://segmentfault.com/a/1190000002729689" target="_blank" rel="noopener">《布隆过滤器 – 空间效率很高的数据结构》</a></li><li><a href="https://blog.csdn.net/zdxiq000/article/details/57626464" target="_blank" rel="noopener">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li><li><a href="https://blog.csdn.net/qq_30242609/article/details/71024458" target="_blank" rel="noopener">《基于Redis的布隆过滤器的实现》</a><ul><li>基于 Redis 的 Bitmap 数据结构。</li></ul></li><li><a href="https://blog.csdn.net/lemon_tree12138/article/details/47973715" target="_blank" rel="noopener">《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》</a><ul><li>使用Java中的 BitSet 类 和 加权和hash算法。</li></ul></li></ul><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><h4 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h4><p>KMP：Knuth-Morris-Pratt算法（简称KMP）<br>核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">《字符串匹配的KMP算法》</a></li></ul><h3 id="深度优先、广度优先"><a href="#深度优先、广度优先" class="headerlink" title="深度优先、广度优先"></a>深度优先、广度优先</h3><ul><li><a href="https://www.cnblogs.com/0kk470/p/7555033.html" target="_blank" rel="noopener">《广度优先搜索BFS和深度优先搜索DFS》</a></li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li><a href="https://www.cnblogs.com/MrSaver/p/8641971.html" target="_blank" rel="noopener">《算法：贪婪算法基础》</a></li><li><a href="https://blog.csdn.net/a345017062/article/details/52443781" target="_blank" rel="noopener">《常见算法及问题场景——贪心算法》</a></li></ul><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><ul><li><a href="https://blog.csdn.net/qfikh/article/details/51960331" target="_blank" rel="noopener">《 五大常用算法之四：回溯法》</a></li></ul><h3 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h3><ul><li><a href="https://blog.csdn.net/luningcsdn/article/details/50930276" target="_blank" rel="noopener">《α-β剪枝算法》</a></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><a href="https://www.cnblogs.com/little-YTMM/p/5372680.html" target="_blank" rel="noopener">《详解动态规划——邹博讲动态规划》</a></li><li><a href="https://blog.csdn.net/yao_zi_jie/article/details/54580283" target="_blank" rel="noopener">《动态规划算法的个人理解》</a></li></ul><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><ul><li><p><a href="https://blog.csdn.net/amds123/article/details/70173402" target="_blank" rel="noopener">《带你搞懂朴素贝叶斯分类算法》</a></p><ul><li>P(B|A)=P(A|B)P(B)/P(A)</li></ul></li><li><p><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html" target="_blank" rel="noopener">《贝叶斯推断及其互联网应用1》</a></p></li><li><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html" target="_blank" rel="noopener">《贝叶斯推断及其互联网应用2》</a></li></ul><h3 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h3><ul><li><a href="http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01" target="_blank" rel="noopener">《推荐算法综述》</a></li><li><a href="https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems" target="_blank" rel="noopener">《TOP 10 开源的推荐系统简介》</a></li></ul><h3 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h3><ul><li><a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li></ul><h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><ul><li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">《Dijkstra算法详解》</a></li></ul><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h3><ul><li><a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">Java 并发知识合集</a></li><li><a href="https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png" target="_blank" rel="noopener">JAVA并发知识图谱</a></li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><a href="http://www.importnew.com/18459.html" target="_blank" rel="noopener">《40个Java多线程问题总结》</a></li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li><a href="https://www.cnblogs.com/zhanht/p/5450325.html" target="_blank" rel="noopener">《Java并发编程——线程安全及解决机制简介》</a></li></ul><h3 id="一致性、事务"><a href="#一致性、事务" class="headerlink" title="一致性、事务"></a>一致性、事务</h3><h4 id="事务-ACID-特性"><a href="#事务-ACID-特性" class="headerlink" title="事务 ACID 特性"></a>事务 ACID 特性</h4><ul><li><a href="https://blog.csdn.net/u012440687/article/details/52116108" target="_blank" rel="noopener">《数据库事务ACID特性》</a></li></ul><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul><li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li><li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li><li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li><li><p>序列化：所有事物串行处理（牺牲了效率）</p></li><li><p><a href="https://blog.csdn.net/qq_33290787/article/details/51924963" target="_blank" rel="noopener">《理解事务的4种隔离级别》</a></p></li><li><p><a href="https://www.cnblogs.com/z-sm/p/7245981.html" target="_blank" rel="noopener">数据库事务的四大特性及事务隔离级别</a></p></li><li><p><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">《MySQL的InnoDB的幻读问题 》</a></p><ul><li>幻读的例子非常清楚。</li><li>通过 SELECT … FOR UPDATE 解决。</li></ul></li><li><p><a href="http://database.51cto.com/art/201804/570101.htm" target="_blank" rel="noopener">《一篇文章带你读懂MySQL和InnoDB》</a></p><ul><li>图解脏读、不可重复读、幻读问题。</li></ul></li></ul><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><ul><li><p><a href="https://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">《【mysql】关于innodb中MVCC的一些理解》</a></p><ul><li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li><li>MVCC 会产生幻读问题（更新时异常。）</li></ul></li><li><p><a href="https://blog.csdn.net/whoamiyang/article/details/51901888" target="_blank" rel="noopener">《轻松理解MYSQL MVCC 实现机制》</a></p><ul><li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li><li>每次只操作比当前版本小（或等于）的 行。</li></ul></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="Java中的锁和同步类"><a href="#Java中的锁和同步类" class="headerlink" title="Java中的锁和同步类"></a>Java中的锁和同步类</h4><ul><li><p><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">《Java中的锁分类》</a></p><ul><li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 </li></ul></li><li><p><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">《Java并发之AQS详解》</a></p></li><li><p><a href="http://cuisuqiang.iteye.com/blog/2020146" target="_blank" rel="noopener">《Java中信号量 Semaphore》</a></p><ul><li>有数量控制</li><li>申请用 acquire，申请不要则阻塞；释放用 release。</li></ul></li><li><p><a href="https://www.cnblogs.com/davidwang456/p/6094947.html" target="_blank" rel="noopener">《java开发中的Mutex vs Semaphore》</a></p><ul><li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。     </li></ul></li></ul><h4 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h4><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p><ul><li><a href="https://blog.csdn.net/EthanWhite/article/details/55508357" target="_blank" rel="noopener">《公平锁与非公平锁》</a><ul><li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li></ul></li></ul><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p><ul><li><p><a href="https://www.cnblogs.com/zhiqian-ali/p/6200874.html" target="_blank" rel="noopener">《【MySQL】悲观锁&amp;乐观锁》</a></p><ul><li>乐观锁的方式：版本号+重试方式</li><li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li></ul></li><li><p><a href="https://www.cnblogs.com/Lawson/p/5008741.html" target="_blank" rel="noopener">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a></p><ul><li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li><li>锁相同数据的不同索引条件可能会引起死锁。</li></ul></li><li><p><a href="https://www.cnblogs.com/zejin2008/p/5262751.html" target="_blank" rel="noopener">《Mysql并发时经典常见的死锁原因及解决方法》</a></p></li></ul><h4 id="乐观锁-amp-CAS"><a href="#乐观锁-amp-CAS" class="headerlink" title="乐观锁 &amp; CAS"></a>乐观锁 &amp; CAS</h4><ul><li><a href="http://www.importnew.com/20472.html" target="_blank" rel="noopener">《乐观锁的一种实现方式——CAS》</a><ul><li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。     </li></ul></li></ul><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p><ul><li><a href="https://www.cnblogs.com/549294286/p/3766717.html" target="_blank" rel="noopener">《Java CAS 和ABA问题》</a></li><li><a href="https://blog.csdn.net/li954644351/article/details/50511879" target="_blank" rel="noopener">《Java 中 ABA问题及避免》</a><ul><li>AtomicStampedReference 和 AtomicStampedReference。 </li></ul></li></ul><h4 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h4><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p><ul><li><p><a href="https://www.cnblogs.com/hapjin/p/4840107.html" target="_blank" rel="noopener">《JAVA中写时复制(Copy-On-Write)Map实现》</a></p><ul><li>实现读写分离，读取发生在原始数据上，写入发生在副本上。  </li><li>不用加锁，通过最终一致实现一致性。</li></ul></li><li><p><a href="https://blog.csdn.net/a494303877/article/details/53404623" target="_blank" rel="noopener">《聊聊并发-Java中的Copy-On-Write容器》</a></p></li></ul><h4 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h4><ul><li><a href="http://www.cnblogs.com/l00l/p/4115001.html" target="_blank" rel="noopener">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li></ul><h4 id="可重入锁-amp-不可重入锁"><a href="#可重入锁-amp-不可重入锁" class="headerlink" title="可重入锁 &amp; 不可重入锁"></a>可重入锁 &amp; 不可重入锁</h4><ul><li><p><a href="https://www.cnblogs.com/dj3839/p/6580765.html" target="_blank" rel="noopener">《可重入锁和不可重入锁》</a></p><ul><li>通过简单代码举例说明可重入锁和不可重入锁。</li><li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li><li>可重入锁可以用户避免死锁。</li><li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li></ul></li><li><p><a href="https://www.cnblogs.com/baizhanshi/p/7211802.html" target="_blank" rel="noopener">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a></p><ul><li>synchronized 使用方便，编译器来加锁，是非公平锁。</li><li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li><li>相同加锁场景下，推荐使用 synchronized。</li></ul></li></ul><h4 id="互斥锁-amp-共享锁"><a href="#互斥锁-amp-共享锁" class="headerlink" title="互斥锁 &amp; 共享锁"></a>互斥锁 &amp; 共享锁</h4><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。<br>共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p><ul><li><a href="https://www.cnblogs.com/liang1101/p/6475555.html" target="_blank" rel="noopener">《ReadWriteLock场景应用》</a></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li><a href="https://blog.csdn.net/yunfenglw/article/details/45950305" target="_blank" rel="noopener">《“死锁”四个必要条件的合理解释》</a><ul><li>互斥、持有、不可剥夺、环形等待。</li></ul></li><li><p><a href="https://blog.csdn.net/u014039577/article/details/52351626" target="_blank" rel="noopener">Java如何查看死锁？</a></p><ul><li>JConsole 可以识别死锁。</li></ul></li><li><p><a href="https://blog.csdn.net/bohu83/article/details/51135061" target="_blank" rel="noopener">java多线程系列：死锁及检测</a></p><ul><li>jstack 可以显示死锁。</li></ul></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h3><ul><li><a href="https://segmentfault.com/a/1190000003692840" target="_blank" rel="noopener">《操作系统基础知识——操作系统的原理，类型和结构》</a></li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p><ul><li><a href="https://blog.csdn.net/zero__007/article/details/54089730" target="_blank" rel="noopener">《从Java视角理解CPU缓存和伪共享》</a></li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>TODO</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li><a href="https://blog.csdn.net/asdf_1024/article/details/78978437" target="_blank" rel="noopener">《线程的生命周期及状态转换详解》</a></li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li><a href="https://www.thinksaas.cn/group/topic/839375/" target="_blank" rel="noopener">《终结python协程—-从yield到actor模型的实现》</a><ul><li>线程的调度是由操作系统负责，协程调度是程序自行负责</li><li>与线程相比，协程减少了无谓的操作系统切换.</li><li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li></ul></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><a href="http://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">《Linux 命令大全》</a></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ul><li><a href="https://blog.csdn.net/q291611265/article/details/48465113" target="_blank" rel="noopener">《设计模式的六大原则》</a><ul><li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li><li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li><li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li><li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li><li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li><li>合成复用原则：尽量使用合成/聚合,而不是使用继承。</li></ul></li></ul><h3 id="23种常见设计模式"><a href="#23种常见设计模式" class="headerlink" title="23种常见设计模式"></a>23种常见设计模式</h3><ul><li><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">《设计模式》</a></li><li><a href="https://www.cnblogs.com/susanws/p/5510229.html" target="_blank" rel="noopener">《23种设计模式全解析》</a></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p><a href="http://blog.jobbole.com/62314/" target="_blank" rel="noopener">《细数JDK里的设计模式》</a></p><ul><li><p>结构型模式：</p><ul><li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li><li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li><li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li><li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li><li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li><li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li></ul></li><li><p>创建模式:</p><ul><li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li><li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li><li>工厂方法：就是 <strong>一个返*</strong> 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li><li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li><li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li></ul></li><li>行为模式：<ul><li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li><li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li><li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li><li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li><li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li><li>空对象模式：如 java.util.Collections#emptyList()。</li><li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li><li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li></ul></li></ul></li><li><p><a href="https://www.cnblogs.com/hwaggLee/p/4510687.html" target="_blank" rel="noopener">《Spring-涉及到的设计模式汇总》</a></p></li><li><a href="https://blog.csdn.net/u012387062/article/details/54719114" target="_blank" rel="noopener">《Mybatis使用的设计模式》</a></li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul><li><a href="https://blog.csdn.net/YECrazy/article/details/79481964" target="_blank" rel="noopener">《单例模式的三种实现 以及各自的优缺点》</a></li><li><a href="https://www.cnblogs.com/ttylinux/p/6498822.html" target="_blank" rel="noopener">《单例模式－－反射－－防止序列化破坏单例模式》</a><ul><li>使用枚举类型。</li></ul></li></ul><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>TODO</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul><li><a href="http://www.runoob.com/design-pattern/mvc-pattern.html" target="_blank" rel="noopener">《MVC 模式》</a><ul><li>模型(model)－视图(view)－控制器(controller) </li></ul></li></ul><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><ul><li><a href="https://www.zhihu.com/question/23277575" target="_blank" rel="noopener">《理解 IOC》</a></li><li><a href="https://www.cnblogs.com/NancyStartOnce/p/6813162.html" target="_blank" rel="noopener">《IOC 的理解与解释》</a><ul><li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li><li>作用：用于模块解耦。</li><li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li></ul></li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><ul><li><a href="https://my.oschina.net/yanquan345/blog/203415" target="_blank" rel="noopener">《轻松理解AOP(面向切面编程)》</a></li><li><a href="https://www.cnblogs.com/hongwz/p/5764917.html" target="_blank" rel="noopener">《Spring AOP详解》</a></li><li><a href="http://www.importnew.com/24305.html" target="_blank" rel="noopener">《Spring AOP的实现原理》</a><ul><li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li></ul></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="noopener">《Spring AOP 实现原理与 CGLIB 应用》</a><ul><li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 </li></ul></li></ul><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><ul><li><a href="https://www.w3cschool.cn/uml_tutorial/" target="_blank" rel="noopener">《UML教程》</a></li></ul><h3 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a>微服务思想</h3><ul><li><a href="https://www.cnblogs.com/wintersun/p/6219259.html" target="_blank" rel="noopener">《微服务架构设计》</a></li><li><a href="http://www.infoq.com/cn/articles/micro-service-technology-stack" target="_blank" rel="noopener">《微服务架构技术栈选型手册》</a></li></ul><h4 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h4><ul><li><p><a href="https://yq.aliyun.com/articles/8611" target="_blank" rel="noopener">《微服务架构的理论基础 - 康威定律》</a></p><ul><li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li><li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li><li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li><li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li></ul></li><li><p><a href="https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf" target="_blank" rel="noopener">《微服务架构核⼼20讲》</a></p></li></ul><h1 id="运维-amp-统计-amp-技术支持"><a href="#运维-amp-统计-amp-技术支持" class="headerlink" title="运维 &amp; 统计 &amp; 技术支持"></a>运维 &amp; 统计 &amp; 技术支持</h1><h3 id="常规监控"><a href="#常规监控" class="headerlink" title="常规监控"></a>常规监控</h3><ul><li><p><a href="https://blog.csdn.net/enweitech/article/details/77849205" target="_blank" rel="noopener">《腾讯业务系统监控的修炼之路》</a></p><ul><li>监控的方式：主动、被动、旁路(比如舆情监控)</li><li>监控类型： 基础监控、服务端监控、客户端监控、<br>监控、用户端监控</li><li>监控的目标：全、块、准</li><li>核心指标：请求量、成功率、耗时</li></ul></li><li><p><a href="https://www.oschina.net/news/67525/monitoring-tools" target="_blank" rel="noopener">《开源还是商用？十大云运维监控工具横评》</a></p><ul><li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li></ul></li><li><p><a href="http://developer.51cto.com/art/201612/525373.htm" target="_blank" rel="noopener">《监控报警系统搭建及二次开发经验》</a></p></li></ul><p><strong>命令行监控工具</strong></p><ul><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html" target="_blank" rel="noopener">《常用命令行监控工具》</a></p><ul><li>top、sar、tsar、nload</li></ul></li><li><p><a href="http://blog.jobbole.com/96846/" target="_blank" rel="noopener">《20个命令行工具监控 Linux 系统性能》</a></p></li><li><p><a href="https://my.oschina.net/feichexia/blog/196575" target="_blank" rel="noopener">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></p></li></ul><h3 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h3><p>APM —  Application Performance Management</p><ul><li><p><a href="http://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener">《Dapper，大规模分布式系统的跟踪系统》</a></p></li><li><p><a href="http://opentracing.io" target="_blank" rel="noopener">CNCF OpenTracing</a>，<a href="https://github.com/opentracing-contrib/opentracing-specification-zh" target="_blank" rel="noopener">中文版</a></p></li><li><p>主要开源软件，按字母排序</p><ul><li><a href="https://github.com/apache/incubator-skywalking" target="_blank" rel="noopener">Apache SkyWalking</a></li><li><a href="https://github.com/dianping/cat" target="_blank" rel="noopener">CAT</a></li><li><a href="https://github.com/jaegertracing/jaeger" target="_blank" rel="noopener">CNCF jaeger</a></li><li><a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">Pinpoint</a></li><li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">Zipkin</a></li></ul></li><li><p><a href="http://www.infoq.com/cn/articles/apm-Pinpoint-practice" target="_blank" rel="noopener">《开源APM技术选型与实战》</a></p><ul><li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li></ul></li></ul><h3 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/25195217" target="_blank" rel="noopener">《流量统计的基础：埋点》</a></p><ul><li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li></ul></li><li><p><a href="http://www.25xt.com/company/17066.html" target="_blank" rel="noopener">《APP埋点常用的统计工具、埋点目标和埋点内容》</a></p><ul><li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li></ul></li><li><p><a href="https://tech.meituan.com/mt-mobile-analytics-practice.html" target="_blank" rel="noopener">《美团点评前端无痕埋点实践》</a></p><ul><li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 </li></ul></li></ul><h3 id="持续集成-CI-CD"><a href="#持续集成-CI-CD" class="headerlink" title="持续集成(CI/CD)"></a>持续集成(CI/CD)</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">《持续集成是什么？》</a></li><li><a href="https://www.testwo.com/article/1170" target="_blank" rel="noopener">《8个流行的持续集成工具》</a></li></ul><h4 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h4><ul><li><a href="https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000" target="_blank" rel="noopener">《使用Jenkins进行持续集成》</a></li></ul><h4 id="环境分离"><a href="#环境分离" class="headerlink" title="环境分离"></a>环境分离</h4><p>开发、测试、生成环境分离。</p><ul><li><a href="https://my.oschina.net/sancuo/blog/214904" target="_blank" rel="noopener">《开发环境、生产环境、测试环境的基本理解和区》</a></li></ul><h3 id="自动化运维"><a href="#自动化运维" class="headerlink" title="自动化运维"></a>自动化运维</h3><h4 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h4><ul><li><a href="http://www.ansible.com.cn/" target="_blank" rel="noopener">《Ansible中文权威指南》</a></li><li><a href="https://www.cnblogs.com/heiye123/articles/7855890.html" target="_blank" rel="noopener">《Ansible基础配置和企业级项目实用案例》</a></li></ul><h4 id="puppet"><a href="#puppet" class="headerlink" title="puppet"></a>puppet</h4><ul><li><a href="https://www.cnblogs.com/keerya/p/8040071.html" target="_blank" rel="noopener">《自动化运维工具——puppet详解》</a></li></ul><h4 id="chef"><a href="#chef" class="headerlink" title="chef"></a>chef</h4><ul><li><a href="https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/" target="_blank" rel="noopener">《Chef 的安装与使用》</a></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="TDD-理论"><a href="#TDD-理论" class="headerlink" title="TDD 理论"></a>TDD 理论</h4><ul><li><a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">《深度解读 - TDD（测试驱动开发）》</a><ul><li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li><li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； </li></ul></li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li><a href="https://www.cnblogs.com/happyzm/p/6482886.html" target="_blank" rel="noopener">《Java单元测试之JUnit篇》</a></li><li><a href="https://blog.csdn.net/hotdust/article/details/53406086" target="_blank" rel="noopener">《JUnit 4 与 TestNG 对比》</a><ul><li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 </li></ul></li><li><a href="https://blog.csdn.net/wqetfg/article/details/50900512" target="_blank" rel="noopener">《单元测试主要的测试功能点》</a><ul><li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 </li></ul></li></ul><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><ul><li><a href="https://blog.csdn.net/blueheart20/article/details/52170790" target="_blank" rel="noopener">《Apache ab 测试使用指南》</a></li><li><a href="https://www.cnblogs.com/binyue/p/6141088.html" target="_blank" rel="noopener">《大型网站压力测试及优化方案》</a></li><li><a href="http://news.chinabyte.com/466/14126966.shtml" target="_blank" rel="noopener">《10大主流压力/负载/性能测试工具推荐》</a></li><li><a href="http://quentinxxz.iteye.com/blog/2249799" target="_blank" rel="noopener">《真实流量压测工具 tcpcopy应用浅析》</a></li><li><a href="https://www.cnblogs.com/jwentest/p/7136727.html" target="_blank" rel="noopener">《nGrinder 简易使用教程》</a></li></ul><h4 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h4><ul><li><a href="http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot" target="_blank" rel="noopener">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li><li><a href="https://zhuanlan.zhihu.com/p/30306892" target="_blank" rel="noopener">《饿了么全链路压测的探索与实践》</a></li><li><a href="https://zhuanlan.zhihu.com/p/28355759" target="_blank" rel="noopener">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li><li><a href="https://www.jianshu.com/p/27060fd61f72" target="_blank" rel="noopener">《全链路压测经验》</a></li></ul><h4 id="A-B-、灰度、蓝绿测试"><a href="#A-B-、灰度、蓝绿测试" class="headerlink" title="A/B 、灰度、蓝绿测试"></a>A/B 、灰度、蓝绿测试</h4><ul><li><a href="https://testerhome.com/topics/11165" target="_blank" rel="noopener">《技术干货 | AB 测试和灰度发布探索及实践》</a></li><li><p><a href="http://blog.51cto.com/purplegrape/1403123" target="_blank" rel="noopener">《nginx 根据IP 进行灰度发布》</a></p></li><li><p><a href="https://www.v2ex.com/t/344341" target="_blank" rel="noopener">《蓝绿部署、A/B 测试以及灰度发布》</a></p></li></ul><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><ul><li><a href="https://blog.csdn.net/enweitech/article/details/52910082" target="_blank" rel="noopener">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li></ul><h4 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h4><ul><li><a href="http://blog.chinaunix.net/uid-20201831-id-5775661.html" target="_blank" rel="noopener">《KVM详解，太详细太深入了，经典》</a></li><li><a href="https://www.coderxing.com/kvm-install.html" target="_blank" rel="noopener">《【图文】KVM 虚拟机安装详解》</a></li></ul><h4 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h4><ul><li><a href="https://www.cnblogs.com/sddai/p/5931201.html" target="_blank" rel="noopener">《Xen虚拟化基本原理详解》</a></li></ul><h4 id="OpenVZ"><a href="#OpenVZ" class="headerlink" title="OpenVZ"></a>OpenVZ</h4><ul><li><a href="https://blog.csdn.net/longerzone/article/details/44829255" target="_blank" rel="noopener">《开源Linux容器 OpenVZ 快速上手指南》</a></li></ul><h3 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h3><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><ul><li><a href="https://www.cnblogs.com/SzeCheng/p/6822905.html" target="_blank" rel="noopener">《几张图帮你理解 docker 基本原理及快速入门》</a></li><li><a href="https://draveness.me/docker" target="_blank" rel="noopener">《Docker 核心技术与实现原理》</a></li><li><a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">《Docker 教程》</a></li></ul><h3 id="云技术"><a href="#云技术" class="headerlink" title="云技术"></a>云技术</h3><h4 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h4><ul><li><a href="https://www.cnblogs.com/klb561/p/8660264.html" target="_blank" rel="noopener">《OpenStack构架知识梳理》</a></li></ul><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><ul><li><a href="https://www.cnblogs.com/jetzhang/p/6068773.html" target="_blank" rel="noopener">《一分钟告诉你究竟DevOps是什么鬼？》</a></li><li><a href="http://www.infoq.com/cn/articles/detail-analysis-of-devops" target="_blank" rel="noopener">《DevOps详解》</a></li></ul><h3 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h3><ul><li><a href="http://www.confluence.cn/" target="_blank" rel="noopener">Confluence-收费文档管理系统</a></li><li>GitLab?</li><li>Wiki</li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h3><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ul><li><p><a href="https://blog.csdn.net/qq_25797077/article/details/52200722" target="_blank" rel="noopener">《Ngnix的基本学习-多进程和Apache的比较》</a></p><ul><li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li><li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  </li></ul></li><li><p><a href="https://www.cnblogs.com/cunkouzh/p/5410154.html" target="_blank" rel="noopener">《nginx与Apache的对比以及优缺点》</a></p><ul><li>nginx只适合静态和反向代理，不适合处理动态请求。</li></ul></li></ul><h4 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h4><ul><li><a href="http://openresty.org/cn/" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1034" target="_blank" rel="noopener">《浅谈 OpenResty》</a><ul><li>通过 Lua 模块可以在Nginx上进行开发。 </li></ul></li></ul><h4 id="Apache-Httpd"><a href="#Apache-Httpd" class="headerlink" title="Apache Httpd"></a>Apache Httpd</h4><ul><li><a href="http://httpd.apache.org/" target="_blank" rel="noopener">官方网站</a></li></ul><h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><h5 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h5><ul><li><a href="https://www.cnblogs.com/hggen/p/6264475.html" target="_blank" rel="noopener">《TOMCAT原理详解及请求过程》</a></li><li><a href="https://www.cnblogs.com/crazylqy/p/4706223.html" target="_blank" rel="noopener">《Tomcat服务器原理详解》</a></li><li><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/" target="_blank" rel="noopener">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></p></li><li><p><a href="https://blog.csdn.net/xlgen157387/article/details/79006434" target="_blank" rel="noopener">《四张图带你了解Tomcat系统架构》</a></p></li><li><p><a href="https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/" target="_blank" rel="noopener">《JBoss vs. Tomcat: Choosing A Java Application Server》</a></p><ul><li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。</li><li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li></ul></li></ul><h5 id="调优方案"><a href="#调优方案" class="headerlink" title="调优方案"></a>调优方案</h5><ul><li><p><a href="https://www.cnblogs.com/sunfenqing/p/7339058.html" target="_blank" rel="noopener">《Tomcat 调优方案》</a></p><ul><li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； </li></ul></li><li><p><a href="http://blog.chinaunix.net/uid-20662363-id-3012760.html" target="_blank" rel="noopener">《tomcat http协议与ajp协议》</a></p></li><li><a href="http://dmouse.iteye.com/blog/1354527" target="_blank" rel="noopener">《AJP与HTTP比较和分析》</a><ul><li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li><li>并发高时，AJP协议优于HTTP协议。</li></ul></li></ul><h4 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h4><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jetty/" target="_blank" rel="noopener">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li><li><a href="https://blog.csdn.net/doutao6677/article/details/51957288" target="_blank" rel="noopener">《jetty和tomcat优势比较》</a><ul><li>架构比较:Jetty的架构比Tomcat的更为简单。</li><li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li><li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 </li></ul></li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><a href="https://blog.csdn.net/clementad/article/details/48229243" target="_blank" rel="noopener">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li></ul><h4 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h4><ul><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html" target="_blank" rel="noopener">《HashMap本地缓存》</a></p></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html" target="_blank" rel="noopener">《EhCache本地缓存》</a></p><ul><li>堆内、堆外、磁盘三级缓存。</li><li>可按照缓存空间容量进行设置。</li><li>按照时间、次数等过期策略。</li></ul></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html" target="_blank" rel="noopener">《Guava Cache》</a></p><ul><li>简单轻量、无堆外、磁盘缓存。</li></ul></li></ul><ul><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html" target="_blank" rel="noopener">《Nginx本地缓存》</a></p></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html" target="_blank" rel="noopener">《Pagespeed—懒人工具，服务器端加速》</a></p></li></ul><h3 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h3><ul><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html" target="_blank" rel="noopener">《浏览器端缓存》</a></p><ul><li>主要是利用 Cache-Control 参数。</li></ul></li><li><p><a href="https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w" target="_blank" rel="noopener">《H5 和移动端 WebView 缓存机制解析与实战》</a></p></li></ul><h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4><ul><li><a href="https://github.com/jiangwenyuan/nuster" target="_blank" rel="noopener">nuster</a> - nuster cache</li><li><a href="https://github.com/varnishcache/varnish-cache" target="_blank" rel="noopener">varnish</a> - varnish cache</li><li><a href="https://github.com/squid-cache/squid" target="_blank" rel="noopener">squid</a> - squid cache</li></ul><h4 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h4><ul><li><a href="http://www.runoob.com/Memcached/Memcached-tutorial.html" target="_blank" rel="noopener">《Memcached 教程》</a></li><li><a href="https://blog.csdn.net/chenleixing/article/details/47035453" target="_blank" rel="noopener">《深入理解Memcached原理》</a><ul><li>采用多路复用技术提高并发性。</li><li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li></ul></li><li><a href="https://www.jianshu.com/p/36e5cd400580" target="_blank" rel="noopener">《Memcached软件工作原理》</a></li><li><p><a href="http://zhihuzeye.com/archives/2361" target="_blank" rel="noopener">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></p></li><li><p><a href="https://blog.csdn.net/liu251890347/article/details/37690045" target="_blank" rel="noopener">《memcache 中 add 、 set 、replace 的区别》</a></p><ul><li>区别在于当key存在还是不存在时，返回值是true和false的。</li></ul></li><li><p><a href="https://pan.baidu.com/s/1qX00Lti?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=" target="_blank" rel="noopener"><strong>《memcached全面剖析》</strong></a></p></li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul><li><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">《Redis 教程》</a></li><li><a href="https://blog.csdn.net/wcf373722432/article/details/78678504" target="_blank" rel="noopener">《redis底层原理》</a><ul><li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li><li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li></ul></li><li><p><a href="http://doc.redisfans.com/topic/persistence.html" target="_blank" rel="noopener">《Redis持久化方式》</a></p><ul><li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li><li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li><li>也可以两者结合使用。</li></ul></li><li><p><a href="https://blog.csdn.net/chunlongyu/article/details/53346436" target="_blank" rel="noopener">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></p></li></ul><h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><ul><li><a href="https://blog.csdn.net/sunhuiliang85/article/details/73656830" target="_blank" rel="noopener">《Redis单线程架构》</a></li></ul><h5 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h5><ul><li><a href="https://blog.csdn.net/qq_29108585/article/details/63251491" target="_blank" rel="noopener">《redis的回收策略》</a></li></ul><h4 id="Tair"><a href="#Tair" class="headerlink" title="Tair"></a>Tair</h4><ul><li><a href="https://github.com/alibaba/tair" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://blog.csdn.net/farphone/article/details/53522383" target="_blank" rel="noopener">《Tair和Redis的对比》</a></li><li>特点：可以配置备份节点数目，通过异步同步到备份节点</li><li>一致性Hash算法。</li><li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li></ul><p>几种存储引擎:</p><ul><li>MDB，完全内存性，可以用来存储Session等数据。</li><li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li><li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li><li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li><p><a href="https://www.cnblogs.com/charlesblc/p/6045238.html" target="_blank" rel="noopener">《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》</a></p><ul><li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li><li>Kafka 默认是拉模式。</li><li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li><li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li></ul></li><li><p><a href="https://blog.csdn.net/yunfeng482/article/details/72856762" target="_blank" rel="noopener">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></p></li></ul><h4 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h4><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p><ul><li><a href="https://blog.csdn.net/yanghua_kobe/article/details/43877281" target="_blank" rel="noopener">《消息总线VS消息队列》</a></li></ul><h4 id="消息的顺序"><a href="#消息的顺序" class="headerlink" title="消息的顺序"></a>消息的顺序</h4><ul><li><a href="https://www.cnblogs.com/cjsblog/p/8267892.html" target="_blank" rel="noopener">《如何保证消费者接收消息的顺序》</a></li></ul><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p><ul><li><a href="https://blog.csdn.net/whoamiyang/article/details/54954780" target="_blank" rel="noopener">《RabbitMQ的应用场景以及基本原理介绍》</a></li><li><a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">《消息队列之 RabbitMQ》</a> </li><li><a href="https://blog.csdn.net/u013256816/article/details/55515234" target="_blank" rel="noopener">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li></ul><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p><ul><li><a href="https://www.jianshu.com/p/824066d70da8" target="_blank" rel="noopener">《RocketMQ 实战之快速入门》</a></li><li><a href="http://www.iocoder.cn/categories/RocketMQ/?vip&amp;architect-awesome" target="_blank" rel="noopener">《RocketMQ 源码解析》</a></li></ul><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p><ul><li><a href="https://www.cnblogs.com/wintersun/p/3962302.html" target="_blank" rel="noopener">《ActiveMQ消息队列介绍》</a></li></ul><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p><ul><li><a href="http://kafka.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://blog.csdn.net/allthesametome/article/details/47362451" target="_blank" rel="noopener">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li><li><a href="http://lxw1234.com/archives/2015/10/538.htm" target="_blank" rel="noopener">《Kafka分区机制介绍与示例》</a></li></ul><h4 id="Redis-消息推送"><a href="#Redis-消息推送" class="headerlink" title="Redis 消息推送"></a>Redis 消息推送</h4><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p><ul><li><a href="https://blog.csdn.net/qq_34212276/article/details/78455004" target="_blank" rel="noopener">《Redis学习笔记之十：Redis用作消息队列》</a></li></ul><h4 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h4><p> TODO</p><h3 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h3><h4 id="单机定时调度"><a href="#单机定时调度" class="headerlink" title="单机定时调度"></a>单机定时调度</h4><ul><li><p><a href="https://www.cnblogs.com/shuaiqing/p/7742382.html" target="_blank" rel="noopener">《linux定时任务cron配置》</a></p></li><li><p><a href="https://my.oschina.net/daquan/blog/483305" target="_blank" rel="noopener">《Linux cron运行原理》</a></p><ul><li>fork 进程 + sleep 轮询</li></ul></li><li><p><a href="https://www.cnblogs.com/drift-ice/p/3817269.html" target="_blank" rel="noopener">《Quartz使用总结》</a></p></li><li><a href="https://blog.csdn.net/wenniuwuren/article/details/42082981/" target="_blank" rel="noopener">《Quartz源码解析 —- 触发器按时启动原理》</a></li><li><a href="https://www.jianshu.com/p/bab8e4e32952" target="_blank" rel="noopener">《quartz原理揭秘和源码解读》</a><ul><li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li></ul></li></ul><h4 id="分布式定时调度"><a href="#分布式定时调度" class="headerlink" title="分布式定时调度"></a>分布式定时调度</h4><ul><li><p><a href="https://blog.csdn.net/qq_16216221/article/details/70314337" target="_blank" rel="noopener">《这些优秀的国产分布式任务调度系统，你用过几个？》</a></p><ul><li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li></ul></li><li><p><a href="https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html" target="_blank" rel="noopener">《Quartz任务调度的基本实现原理》</a></p><ul><li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 </li></ul></li><li><a href="http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&amp;architect-awesome" target="_blank" rel="noopener">《Elastic-Job-Lite 源码解析》</a></li><li><a href="http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&amp;architect-awesome" target="_blank" rel="noopener">《Elastic-Job-Cloud 源码解析》</a></li></ul><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ul><li><p><a href="https://blog.csdn.net/top_code/article/details/54615853" target="_blank" rel="noopener">《从零开始实现RPC框架 - RPC原理及实现》</a></p><ul><li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li></ul></li><li><p><a href="https://blog.csdn.net/testcs_dn/article/details/78050590" target="_blank" rel="noopener">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></p></li></ul><h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><ul><li><a href="http://dubbo.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://www.cnblogs.com/steven520213/p/7606598.html" target="_blank" rel="noopener">dubbo实现原理简单介绍</a></li></ul><p><strong>SPI</strong><br>TODO</p><h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><ul><li><a href="http://thrift.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://blog.csdn.net/kesonyk/article/details/50924489" target="_blank" rel="noopener">《Thrift RPC详解》</a><ul><li>支持多语言，通过中间语言定义接口。</li></ul></li></ul><h4 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h4><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p><ul><li><a href="https://grpc.io/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://www.cnblogs.com/LBSer/p/4853234.html" target="_blank" rel="noopener">《你应该知道的RPC原理》</a></li></ul><h3 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h3><h4 id="Sharding-Jdbc"><a href="#Sharding-Jdbc" class="headerlink" title="Sharding Jdbc"></a>Sharding Jdbc</h4><ul><li><a href="http://shardingjdbc.io/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h3><h4 id="日志搜集"><a href="#日志搜集" class="headerlink" title="日志搜集"></a>日志搜集</h4><ul><li><a href="http://cjting.me/misc/build-log-system-with-elkb/" target="_blank" rel="noopener">《从零开始搭建一个ELKB日志收集系统》</a></li><li><a href="https://blog.csdn.net/lzw_2006/article/details/51280058" target="_blank" rel="noopener">《用ELK搭建简单的日志收集分析系统》</a></li><li><a href="https://www.cnblogs.com/beginmind/p/6058194.html" target="_blank" rel="noopener">《日志收集系统-探究》</a></li></ul><h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><ul><li><p><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">Apollo - 携程开源的配置中心应用</a></p><ul><li>Spring Boot 和 Spring Cloud</li><li>支持推、拉模式更新配置</li><li>支持多种语言 </li></ul></li><li><p><a href="https://blog.csdn.net/u011320740/article/details/78742625" target="_blank" rel="noopener">《基于zookeeper实现统一配置管理》</a></p></li><li><p><a href="https://www.cnblogs.com/shamo89/p/8016908.html" target="_blank" rel="noopener">《 Spring Cloud Config 分布式配置中心使用教程》</a></p></li></ul><p>servlet 3.0 异步特性可用于配置中心的客户端</p><ul><li><a href="https://www.cnblogs.com/dogdogwang/p/7151866.html" target="_blank" rel="noopener">《servlet3.0 新特性——异步处理》</a></li></ul><h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h3><p>主要职责：请求转发、安全认证、协议转换、容灾。</p><ul><li><a href="http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/" target="_blank" rel="noopener">《API网关那些儿》</a></li><li><p><a href="http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo" target="_blank" rel="noopener">《谈API网关的背景、架构以及落地方案》</a></p></li><li><p><a href="https://blog.csdn.net/zhanglh046/article/details/78651993" target="_blank" rel="noopener">《使用Zuul构建API Gateway》</a></p></li><li><a href="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&amp;architect-awesome" target="_blank" rel="noopener">《Spring Cloud Gateway 源码解析》</a></li><li><a href="https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A" target="_blank" rel="noopener">《HTTP API网关选择之一Kong介绍》</a></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI 七层协议"></a>OSI 七层协议</h4><ul><li><a href="https://www.cnblogs.com/Robin-YB/p/6668762.html" target="_blank" rel="noopener">《OSI七层协议模型、TCP/IP四层模型学习笔记》</a></li></ul><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><ul><li><a href="https://www.cnblogs.com/onepixel/p/7092302.html" target="_blank" rel="noopener">《深入浅出 TCP/IP 协议》</a></li><li><a href="https://blog.csdn.net/whuslei/article/details/6667471/" target="_blank" rel="noopener">《TCP协议中的三次握手和四次挥手》</a></li></ul><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><ul><li><a href="https://www.cnblogs.com/wangning528/p/6388464.html" target="_blank" rel="noopener">《http协议详解(超详细)》</a></li></ul><h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4><ul><li><a href="https://blog.csdn.net/zhuyiquan/article/details/69257126" target="_blank" rel="noopener">《HTTP 2.0 原理详细分析》</a></li><li><a href="https://blog.csdn.net/u012657197/article/details/77877840" target="_blank" rel="noopener">《HTTP2.0的基本单位为二进制帧》</a><ul><li>利用二进制帧负责传输。</li><li>多路复用。</li></ul></li></ul><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><ul><li><p><a href="https://www.cnblogs.com/zhangshitong/p/6478721.html" target="_blank" rel="noopener">《https原理通俗了解》</a></p><ul><li>使用非对称加密协商加密算法</li><li>使用对称加密方式传输数据</li><li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li></ul></li><li><p><a href="https://blog.csdn.net/enweitech/article/details/53213862" target="_blank" rel="noopener">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></p></li></ul><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ul><li><p><a href="http://blog.51cto.com/litaotao/1289790" target="_blank" rel="noopener">《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》</a></p><ul><li>五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li><li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li></ul></li><li><p><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">《select、poll、epoll之间的区别总结》</a></p><ul><li>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li><li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li><li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li><li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li></ul></li><li><p><a href="http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/" target="_blank" rel="noopener">《select，poll，epoll比较  》</a></p><ul><li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li></ul></li><li><p><a href="https://www.cnblogs.com/geason/p/5774096.html" target="_blank" rel="noopener">《深入理解Java NIO》</a></p><ul><li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li></ul></li><li><p><a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">《BIO与NIO、AIO的区别》</a></p></li><li><p><a href="https://blog.csdn.net/u013074465/article/details/46276967" target="_blank" rel="noopener">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></p></li></ul><h4 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h4><ul><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html" target="_blank" rel="noopener">《epoll使用详解（精髓）》</a></li></ul><h4 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h4><ul><li><a href="https://www.cnblogs.com/geason/p/5774096.html" target="_blank" rel="noopener">《深入理解Java NIO》</a></li><li><a href="https://blog.csdn.net/xidianliuy/article/details/51612676" target="_blank" rel="noopener">《Java NIO编写Socket服务器的一个例子》</a></li></ul><h4 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h4><ul><li><a href="http://www.cnblogs.com/luminocean/p/5631336.html" target="_blank" rel="noopener">《kqueue用法简介》</a></li></ul><h3 id="连接和短连接"><a href="#连接和短连接" class="headerlink" title="连接和短连接"></a>连接和短连接</h3><ul><li><a href="https://www.cnblogs.com/pangguoping/p/5571422.html" target="_blank" rel="noopener">《TCP/IP系列——长连接与短连接的区别》</a></li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li><a href="https://blog.csdn.net/excellentyuxiao/article/details/53390408" target="_blank" rel="noopener">《Netty原理剖析》</a><ul><li>Reactor 模式介绍。</li><li>Netty 是 Reactor 模式的一种实现。</li></ul></li></ul><h3 id="零拷贝（Zero-copy）"><a href="#零拷贝（Zero-copy）" class="headerlink" title="零拷贝（Zero-copy）"></a>零拷贝（Zero-copy）</h3><ul><li><a href="https://www.cnblogs.com/xys1228/p/6088805.html" target="_blank" rel="noopener">《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》</a><ul><li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li></ul></li></ul><h3 id="序列化-二进制协议"><a href="#序列化-二进制协议" class="headerlink" title="序列化(二进制协议)"></a>序列化(二进制协议)</h3><h4 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h4><ul><li><a href="https://www.cnblogs.com/happyday56/p/4268249.html" target="_blank" rel="noopener">《Hessian原理分析》</a><br>Binary-RPC;不仅仅是序列化</li></ul><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><ul><li><a href="https://blog.csdn.net/antgan/article/details/52103966" target="_blank" rel="noopener">《Protobuf协议的Java应用例子》</a><br>Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。</li><li><p><a href="https://worktile.com/tech/share/prototol-buffers" target="_blank" rel="noopener">《Protocol Buffers序列化协议及应用》</a></p><pre><code>* 关于协议的解释；缺点：可读性差;</code></pre></li><li><p><a href="https://blog.csdn.net/eric520zenobia/article/details/53766571" target="_blank" rel="noopener">《简单的使用 protobuf 和 protostuff》</a></p><ul><li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li></ul></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h3><h4 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h4><ul><li><a href="https://www.cnblogs.com/waj6511988/p/7027127.html" target="_blank" rel="noopener">《数据库的三大范式以及五大约束》</a><ul><li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li><li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li><li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li></ul></li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><p><a href="http://www.admin10000.com/document/5372.html" target="_blank" rel="noopener">《MySQL的InnoDB索引原理详解》</a></p></li><li><p><a href="https://blog.csdn.net/xifeijian/article/details/20316775" target="_blank" rel="noopener">《MySQL存储引擎－－MyISAM与InnoDB区别》</a></p><ul><li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li></ul></li><li><p><a href="https://www.2cto.com/database/201211/172380.html" target="_blank" rel="noopener">《myisam和innodb索引实现的不同》</a></p></li></ul><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul><li><a href="https://my.oschina.net/kailuncen/blog/1504217" target="_blank" rel="noopener">《一篇文章带你读懂Mysql和InnoDB》</a></li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li><p><a href="http://vdisk.weibo.com/s/muWOT" target="_blank" rel="noopener">《MySQL36条军规》</a></p></li><li><p><a href="https://www.cnblogs.com/zhouyusheng/p/8038224.html" target="_blank" rel="noopener">《MYSQL性能优化的最佳20+条经验》</a></p></li><li><a href="https://blog.csdn.net/when_less_is_more/article/details/70187459" target="_blank" rel="noopener">《SQL优化之道》</a></li><li><a href="https://www.cnblogs.com/sivkun/p/7518540.html" target="_blank" rel="noopener">《mysql数据库死锁的产生原因及解决办法》</a></li><li><a href="https://blog.csdn.net/monkey_d_feilong/article/details/52291556" target="_blank" rel="noopener">《导致索引失效的可能情况》</a></li><li><a href="https://blog.csdn.net/zy_281870667/article/details/51604540" target="_blank" rel="noopener">《 MYSQL分页limit速度太慢优化方法》</a><ul><li>原则上就是缩小扫描范围。</li></ul></li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="聚集索引-非聚集索引"><a href="#聚集索引-非聚集索引" class="headerlink" title="聚集索引, 非聚集索引"></a>聚集索引, 非聚集索引</h5><ul><li><a href="https://blog.csdn.net/no_endless/article/details/77073549" target="_blank" rel="noopener">《MySQL 聚集索引/非聚集索引简述》</a></li><li><a href="https://www.cnblogs.com/zlcxbb/p/5757245.html" target="_blank" rel="noopener">《MyISAM和InnoDB的索引实现》</a></li></ul><p>MyISAM 是非聚集，InnoDB 是聚集</p><h5 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h5><ul><li><a href="https://www.cnblogs.com/summer0space/p/7247778.html" target="_blank" rel="noopener">《复合索引的优点和注意事项》</a></li></ul><h5 id="自适应哈希索引-AHI"><a href="#自适应哈希索引-AHI" class="headerlink" title="自适应哈希索引(AHI)"></a>自适应哈希索引(AHI)</h5><ul><li><a href="https://blog.csdn.net/Linux_ever/article/details/62043708" target="_blank" rel="noopener">《InnoDB存储引擎——自适应哈希索引》</a></li></ul><h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><ul><li><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">《MySQL 性能优化神器 Explain 使用分析》</a></li></ul><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><ul><li><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">MongoDB 教程</a></li><li><a href="http://mxdxm.iteye.com/blog/2093603" target="_blank" rel="noopener">《Mongodb相对于关系型数据库的优缺点》</a><ul><li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li><li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li></ul></li></ul><h4 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h4><ul><li><a href="http://www.thebigdata.cn/HBase/35831.html" target="_blank" rel="noopener">《简明 HBase 入门教程（开篇）》</a></li><li><a href="https://www.cnblogs.com/qiaoyihang/p/6246424.html" target="_blank" rel="noopener">《深入学习HBase架构原理》</a></li><li><a href="https://blog.csdn.net/youzhouliu/article/details/67632882" target="_blank" rel="noopener">《传统的行存储和（HBase）列存储的区别》</a></li></ul><ul><li><p><a href="https://blog.csdn.net/lifuxiangcaohui/article/details/39891099" target="_blank" rel="noopener">《Hbase与传统数据库的区别》</a></p><ul><li>空数据不存储，节省空间，且适用于并发。</li></ul></li><li><p><a href="https://blog.csdn.net/u014091123/article/details/73163088" target="_blank" rel="noopener">《HBase Rowkey设计》</a></p><ul><li>rowkey 按照字典顺序排列，便于批量扫描。</li><li>通过散列可以避免热点。</li></ul></li></ul><h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><h3 id="搜索引擎原理"><a href="#搜索引擎原理" class="headerlink" title="搜索引擎原理"></a>搜索引擎原理</h3><ul><li><a href="https://www.jianshu.com/p/0193dc44135b" target="_blank" rel="noopener">《倒排索引–搜索引擎入门》</a></li></ul><h3 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h3><ul><li><a href="https://www.cnblogs.com/rodge-run/p/6551152.html" target="_blank" rel="noopener">《Lucene入门简介》</a></li></ul><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><ul><li><a href="https://blog.csdn.net/laoyang360/article/details/52244917" target="_blank" rel="noopener">《Elasticsearch学习，请先看这一篇！》</a></li><li><a href="https://blog.csdn.net/cyony/article/details/65437708" target="_blank" rel="noopener">《Elasticsearch索引原理》</a></li></ul><h3 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h3><ul><li><a href="https://blog.csdn.net/u011936655/article/details/51960005" target="_blank" rel="noopener">《 Apache Solr入门教程》</a></li><li><a href="https://blog.csdn.net/convict_eva/article/details/53537837" target="_blank" rel="noopener">《elasticsearch与solr比较》</a></li></ul><h3 id="sphinx"><a href="#sphinx" class="headerlink" title="sphinx"></a>sphinx</h3><ul><li><a href="http://blog.jobbole.com/101672/" target="_blank" rel="noopener">《Sphinx 的介绍和原理探索》</a></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a>性能优化方法论</h3><ul><li><p><a href="https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread" target="_blank" rel="noopener">《15天的性能优化工作，5方面的调优经验》</a></p><ul><li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li></ul></li><li><p><a href="https://blog.csdn.net/tenglizhe/article/details/44563135" target="_blank" rel="noopener">《系统性能优化的几个方面》</a></p></li></ul><h3 id="容量评估"><a href="#容量评估" class="headerlink" title="容量评估"></a>容量评估</h3><ul><li><a href="https://blog.csdn.net/u012528360/article/details/70054156" target="_blank" rel="noopener">《联网性能与容量评估的方法论和典型案例》</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959542&amp;idx=1&amp;sn=2494bbea9a855e0e1c3ccd6d2562a600&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《互联网架构，如何进行容量设计？》</a><ul><li>评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS</li></ul></li></ul><h3 id="CDN-网络"><a href="#CDN-网络" class="headerlink" title="CDN 网络"></a>CDN 网络</h3><ul><li><a href="https://www.cnblogs.com/wxiaona/p/5867685.html" target="_blank" rel="noopener">《CDN加速原理》</a></li><li><a href="https://www.zhihu.com/question/20536932" target="_blank" rel="noopener">《国内有哪些比较好的 CDN？》</a></li></ul><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><ul><li><a href="https://blog.csdn.net/fysuccess/article/details/66972554" target="_blank" rel="noopener">《主流Java数据库连接池比较与开发配置实战》</a></li></ul><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><ul><li><a href="https://blog.csdn.net/yethyeth/article/details/73266455" target="_blank" rel="noopener">《九大Java性能调试工具，必备至少一款》</a></li></ul><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="流式计算"><a href="#流式计算" class="headerlink" title="流式计算"></a>流式计算</h3><h4 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h4><ul><li><a href="http://storm.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://blog.csdn.net/uisoul/article/details/77989927" target="_blank" rel="noopener">《最详细的Storm入门教程》</a></li></ul><h4 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h4><ul><li><a href="https://blog.csdn.net/lisi1129/article/details/54844919" target="_blank" rel="noopener">《Flink之一 Flink基本原理介绍》</a></li></ul><h4 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h4><ul><li><a href="https://yq.aliyun.com/articles/58382" target="_blank" rel="noopener">《Kafka Stream调研：一种轻量级流计算模式》</a></li></ul><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>例如：</p><ul><li>广告相关实时统计；</li><li>推荐系统用户画像标签实时更新；</li><li>线上服务健康状况实时监测；</li><li>实时榜单；</li><li>实时数据统计。</li></ul><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><ul><li><a href="https://blog.csdn.net/houbin0912/article/details/72967178" target="_blank" rel="noopener">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li><li><a href="http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html" target="_blank" rel="noopener">《史上最详细的Hadoop环境搭建》</a></li></ul><h4 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h4><ul><li><a href="https://segmentfault.com/a/1190000011575458" target="_blank" rel="noopener">《【Hadoop学习】HDFS基本原理》</a></li></ul><h4 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h4><ul><li><a href="https://blog.csdn.net/oppo62258801/article/details/72884633" target="_blank" rel="noopener">《用通俗易懂的大白话讲解Map/Reduce原理》</a></li><li><a href="https://blog.csdn.net/foye12/article/details/78358292" target="_blank" rel="noopener">《 简单的map-reduce的java例子》</a></li></ul><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h4><ul><li><a href="http://www.cnblogs.com/codeOfLife/p/5492740.html" target="_blank" rel="noopener">《初步掌握Yarn的架构及原理》</a></li></ul><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><ul><li><a href="http://www.cnblogs.com/tgzhu/p/5818374.html" target="_blank" rel="noopener">《Spark(一): 基本架构及原理》</a></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a>web 安全</h3><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><ul><li><a href="https://blog.csdn.net/qq_21956483/article/details/54377947" target="_blank" rel="noopener">《xss攻击原理与解决方法》</a><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html" target="_blank" rel="noopener">《CSRF原理及防范》</a></li></ul><h4 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h4><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html" target="_blank" rel="noopener">《SQL注入》</a></li></ul><h4 id="Hash-Dos"><a href="#Hash-Dos" class="headerlink" title="Hash Dos"></a>Hash Dos</h4><ul><li><a href="http://www.freebuf.com/articles/web/14199.html" target="_blank" rel="noopener">《邪恶的JAVA HASH DOS攻击》</a><ul><li>利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li></ul></li><li><a href="https://yq.aliyun.com/articles/92194?t=t1" target="_blank" rel="noopener">《一种高级的DoS攻击-Hash碰撞攻击》</a></li><li><a href="http://www.iteye.com/news/23939/" target="_blank" rel="noopener">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li></ul><h4 id="脚本注入"><a href="#脚本注入" class="headerlink" title="脚本注入"></a>脚本注入</h4><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html" target="_blank" rel="noopener">《上传文件漏洞原理及防范》</a></li></ul><h4 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a>漏洞扫描工具</h4><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html" target="_blank" rel="noopener">《DVWA》</a></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html" target="_blank" rel="noopener">W3af</a></li><li><a href="https://blog.csdn.net/xygg0801/article/details/53610640" target="_blank" rel="noopener">OpenVAS详解</a></li></ul><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><ul><li><p><a href="https://blog.csdn.net/niaonao/article/details/51112686" target="_blank" rel="noopener">《验证码原理分析及实现》</a></p></li><li><p><a href="https://my.oschina.net/jiangbianwanghai/blog/1031031" target="_blank" rel="noopener">《详解滑动验证码的实现原理》</a></p><ul><li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li></ul></li><li><p><a href="https://www.cnblogs.com/xcj26/p/5242758.html" target="_blank" rel="noopener">《淘宝滑动验证码研究》</a></p></li></ul><h3 id="DDoS-防范"><a href="#DDoS-防范" class="headerlink" title="DDoS 防范"></a>DDoS 防范</h3><ul><li><a href="http://netsecurity.51cto.com/art/201601/503799.htm" target="_blank" rel="noopener">《学习手册：DDoS的攻击方式及防御手段》</a></li><li><a href="http://netsecurity.51cto.com/art/201406/442756.htm" target="_blank" rel="noopener">《免费DDoS攻击测试工具大合集》</a></li></ul><h3 id="用户隐私信息保护"><a href="#用户隐私信息保护" class="headerlink" title="用户隐私信息保护"></a>用户隐私信息保护</h3><ol><li>用户密码非明文保存，加动态salt。</li><li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li><li>联系方式在的显示与否由用户自己控制。</li><li>TODO</li></ol><ul><li><a href="https://zhidao.baidu.com/question/1988017976673661587.html" target="_blank" rel="noopener">《个人隐私包括哪些》</a></li><li><p><a href="https://www.zhihu.com/question/20137108" target="_blank" rel="noopener">《在互联网上，隐私的范围包括哪些？》</a></p></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html" target="_blank" rel="noopener">《用户密码保存》</a></p></li></ul><h3 id="序列化漏洞"><a href="#序列化漏洞" class="headerlink" title="序列化漏洞"></a>序列化漏洞</h3><ul><li><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/" target="_blank" rel="noopener">《Lib之过？Java反序列化漏洞通用利用分析》</a></li></ul><h3 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html" target="_blank" rel="noopener">《常见对称加密算法》</a><ul><li>DES、3DES、Blowfish、AES</li><li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li><li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li></ul></li></ul><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><ul><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html" target="_blank" rel="noopener">《常用的哈希算法》</a></p><ul><li>MD5 和 SHA-1 已经不再安全，已被弃用。</li><li>目前 SHA-256 是比较安全的。</li></ul></li><li><p><a href="https://blog.csdn.net/zhangruhong168/article/details/78033202" target="_blank" rel="noopener">《基于Hash摘要签名的公网URL签名验证设计方案》</a></p></li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html" target="_blank" rel="noopener">《常见非对称加密算法》</a></p><ul><li>RSA、DSA、ECDSA(螺旋曲线加密算法)</li><li>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</li><li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p><p>  <a href="http://baijiahao.baidu.com/s?id=1578348858092033763&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">《区块链的加密技术》</a>    </p></li></ul></li></ul><h3 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a>服务器安全</h3><ul><li><a href="http://www.freebuf.com/articles/system/121540.html" target="_blank" rel="noopener">《Linux强化论：15步打造一个安全的Linux服务器》</a></li></ul><h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><p>TODO</p><h3 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h3><h4 id="内外网分离"><a href="#内外网分离" class="headerlink" title="内外网分离"></a>内外网分离</h4><p>TODO</p><h4 id="登录跳板机"><a href="#登录跳板机" class="headerlink" title="登录跳板机"></a>登录跳板机</h4><p>在内外环境中通过跳板机登录到线上主机。</p><ul><li><a href="http://blog.51cto.com/zero01/2062618" target="_blank" rel="noopener">《搭建简易堡垒机》</a></li></ul><h3 id="授权、认证"><a href="#授权、认证" class="headerlink" title="授权、认证"></a>授权、认证</h3><h4 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h4><ul><li><a href="https://www.cnblogs.com/zq8024/p/5003050.html" target="_blank" rel="noopener">《基于组织角色的权限设计》</a></li><li><a href="https://www.cnblogs.com/shijiaqi1066/p/3793894.html" target="_blank" rel="noopener">《权限系统与RBAC模型概述》</a></li><li><a href="https://blog.csdn.net/he90227/article/details/38663553" target="_blank" rel="noopener">《Spring整合Shiro做权限控制模块详细案例分析》</a></li></ul><h4 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h4><ul><li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">《理解OAuth 2.0》</a></li><li><a href="https://www.cnblogs.com/flashsun/p/7424071.html" target="_blank" rel="noopener">《一张图搞定OAuth2.0》</a></li></ul><h4 id="双因素认证（2FA）"><a href="#双因素认证（2FA）" class="headerlink" title="双因素认证（2FA）"></a>双因素认证（2FA）</h4><p>2FA - Two-factor authentication，用于加强登录验证</p><p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p><ul><li>【《双因素认证（2FA）教程》】(<a href="http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a>)</li></ul><h4 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录(SSO)"></a>单点登录(SSO)</h4><ul><li><p><a href="https://www.cnblogs.com/ywlaker/p/6113927.html" target="_blank" rel="noopener">《单点登录原理与简单实现》</a></p></li><li><p><a href="https://github.com/apereo/cas" target="_blank" rel="noopener">CAS单点登录框架</a></p></li></ul><h2 id="常用开源框架"><a href="#常用开源框架" class="headerlink" title="常用开源框架"></a>常用开源框架</h2><h3 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h3><ul><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html" target="_blank" rel="noopener">《开源协议的选择》</a></p></li><li><p><a href="http://choosealicense.online/" target="_blank" rel="noopener">如何选择一个开源软件协议</a></p></li></ul><h3 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h3><h4 id="Log4j、Log4j2"><a href="#Log4j、Log4j2" class="headerlink" title="Log4j、Log4j2"></a>Log4j、Log4j2</h4><ul><li><a href="https://blog.csdn.net/u012422446/article/details/51199724" target="_blank" rel="noopener">《log4j 详细讲解》</a></li><li><a href="https://blog.csdn.net/vbirdbest/article/details/71751835" target="_blank" rel="noopener">《log4j2 实际使用详解》</a></li><li><a href="https://my.oschina.net/OutOfMemory/blog/789267" target="_blank" rel="noopener">《Log4j1,Logback以及Log4j2性能测试对比》</a><ul><li>Log4J 异步日志性能优异。 </li></ul></li></ul><h4 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h4><ul><li><a href="https://blog.csdn.net/rulon147/article/details/52620541" target="_blank" rel="noopener">《最全LogBack 详解、含java案例和配置说明》</a></li></ul><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><ul><li><a href="https://blog.csdn.net/sinat_34093604/article/details/53082000" target="_blank" rel="noopener">《ORM框架使用优缺点》</a><ul><li>主要目的是为了提高开发效率。 </li></ul></li></ul><p><strong>MyBatis：</strong></p><ul><li><p><a href="https://www.cnblogs.com/winclpt/articles/7511672.html" target="_blank" rel="noopener">《mybatis缓存机制详解》</a></p><ul><li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li><li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  </li></ul></li><li><p><a href="https://blog.csdn.net/baidu_32877851/article/details/53959268" target="_blank" rel="noopener">《MyBatis学习之代码生成器Generator》</a></p></li></ul><h3 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h3><p>TODO</p><h3 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h3><h4 id="Spring-家族"><a href="#Spring-家族" class="headerlink" title="Spring 家族"></a>Spring 家族</h4><p><strong>Spring</strong></p><ul><li><a href="https://www.w3cschool.cn/wkspring/" target="_blank" rel="noopener">Spring 简明教程</a></li></ul><p><strong>Spring Boot</strong></p><ul><li><a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">《Spring Boot基础教程》</a></li></ul><p><strong>Spring Cloud</strong></p><ul><li><a href="http://springboot.fun/" target="_blank" rel="noopener">Spring Boot 中文索引站</a></li><li><a href="https://springcloud.cc/" target="_blank" rel="noopener">Spring Cloud 中文文档</a></li><li><a href="http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">《Spring Cloud基础教程》</a></li></ul><h3 id="工具框架"><a href="#工具框架" class="headerlink" title="工具框架"></a>工具框架</h3><ul><li><a href="https://www.cnblogs.com/crazylqy/p/4872236.html" target="_blank" rel="noopener">《Apache Commons 工具类介绍及简单使用》</a></li><li><a href="http://ifeve.com/google-guava/" target="_blank" rel="noopener">《Google guava 中文教程》</a></li></ul><h2 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h2><h3 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h3><ul><li><p><a href="https://blog.csdn.net/hemin1003/article/details/53633926" target="_blank" rel="noopener">《架构师不可不知的十大可扩展架构》</a></p><ul><li>总结下来，通用的套路就是分布、缓存及异步处理。 </li></ul></li><li><p><a href="https://yq.aliyun.com/articles/38119" target="_blank" rel="noopener">《可扩展性设计之数据切分》</a></p><ul><li>水平切分+垂直切分</li><li>利用中间件进行分片如，MySQL Proxy。</li><li>利用分片策略进行切分，如按照ID取模。 </li></ul></li><li><p><a href="https://blog.csdn.net/deniro_li/article/details/78458306" target="_blank" rel="noopener">《说说如何实现可扩展性的大型网站架构》</a></p><ul><li>分布式服务+消息队列。</li></ul></li><li><p><a href="https://blog.csdn.net/chaofanwei/article/details/29191073" target="_blank" rel="noopener">《大型网站技术架构（七）–网站的可扩展性架构》</a></p></li></ul><h3 id="稳定性-amp-高可用"><a href="#稳定性-amp-高可用" class="headerlink" title="稳定性 &amp; 高可用"></a>稳定性 &amp; 高可用</h3><ul><li><a href="https://blog.csdn.net/hustspy1990/article/details/78008324" target="_blank" rel="noopener">《系统设计：关于高可用系统的一些技术方案》</a><ul><li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li><li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li><li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li><li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li><li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li><li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li><li>自动化测试：通过完善的测试，减少发布引起的故障。</li><li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li></ul></li></ul><ul><li><a href="https://coolshell.cn/articles/17459.html" target="_blank" rel="noopener">《关于高可用的系统》</a><ul><li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。     </li></ul></li></ul><h4 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h4><ul><li><p><a href="https://www.cnblogs.com/wuyun-blog/p/6186198.html" target="_blank" rel="noopener">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a></p><ul><li>主要是和F5对比。</li></ul></li><li><p><a href="https://www.cnblogs.com/lcword/p/5773296.html" target="_blank" rel="noopener">《软/硬件负载均衡产品 你知多少？》</a></p></li></ul><h4 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h4><ul><li><a href="https://www.cnblogs.com/tianzhiliang/articles/2317808.html" target="_blank" rel="noopener">《几种负载均衡算法》</a><br>  轮寻、权重、负载、最少连接、QoS</li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html" target="_blank" rel="noopener">《DNS负载均衡》</a><ul><li>配置简单，更新速度慢。 </li></ul></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html" target="_blank" rel="noopener">《Nginx负载均衡》</a></p><ul><li>简单轻量、学习成本低；主要适用于web应用。</li></ul></li><li><p><a href="https://www.cnblogs.com/edisonchou/p/4281978.html" target="_blank" rel="noopener">《借助LVS+Keepalived实现负载均衡 》</a></p><ul><li>配置比较负载、只支持到4层，性能较高。</li></ul></li><li><p><a href="http://www.ttlsa.com/linux/haproxy-study-tutorial/" target="_blank" rel="noopener">《HAProxy用法详解 全网最详细中文文档》</a></p><ul><li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li></ul></li><li><p><a href="http://blog.itpub.net/25704976/viewspace-1319781/" target="_blank" rel="noopener">《Haproxy+Keepalived+MySQL实现读均衡负载》</a></p><ul><li>主要是用户读请求的负载均衡。</li></ul></li><li><p><a href="https://www.cnblogs.com/lylife/p/5584019.html" target="_blank" rel="noopener">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></p></li></ul><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><ul><li><a href="https://www.cnblogs.com/haoxinyue/p/6792309.html" target="_blank" rel="noopener">《谈谈高并发系统的限流》</a><ul><li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li><li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li><li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li><li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li></ul></li></ul><h4 id="应用层容灾"><a href="#应用层容灾" class="headerlink" title="应用层容灾"></a>应用层容灾</h4><ul><li><p><a href="https://segmentfault.com/a/1190000005988895" target="_blank" rel="noopener">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a></p><ul><li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 </li><li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li><li>Hystrix设计原则：<ul><li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li><li>熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。</li><li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 </li></ul></li></ul></li><li><p><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></p></li><li><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">《缓存击穿、失效以及热点key问题》</a> <ul><li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li><li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li></ul></li></ul><h4 id="跨机房容灾"><a href="#跨机房容灾" class="headerlink" title="跨机房容灾"></a>跨机房容灾</h4><ul><li><p><a href="http://dc.idcquan.com/ywgl/71559.shtml" target="_blank" rel="noopener">《“异地多活”多机房部署经验谈》</a></p><ul><li>通过自研中间件进行数据同步。 </li></ul></li><li><p><a href="https://blog.csdn.net/jeffreynicole/article/details/48135093" target="_blank" rel="noopener">《异地多活（异地双活）实践经验》</a></p><ul><li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li><li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li><li>不能依赖于程序端数据双写，要有自动同步方案。 </li><li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li><li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li><li>异地多活监控部署、测试也要跟上。</li><li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li><li>控制跨机房消息体大小，越小越好。</li><li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li></ul></li><li><p><a href="https://blog.csdn.net/yoara/article/details/38013751" target="_blank" rel="noopener">容灾技术及建设经验介绍</a></p></li></ul><h4 id="容灾演练流程"><a href="#容灾演练流程" class="headerlink" title="容灾演练流程"></a>容灾演练流程</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650996320&amp;idx=1&amp;sn=0ed3be190bbee4a9277886ef88cbb2e5" target="_blank" rel="noopener">《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》</a><ul><li>常见故障画像</li><li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li></ul></li></ul><h4 id="平滑启动"><a href="#平滑启动" class="headerlink" title="平滑启动"></a>平滑启动</h4><ul><li><p>平滑重启应用思路<br>1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</p></li><li><p><a href="https://blog.csdn.net/u011001084/article/details/73480432" target="_blank" rel="noopener">《JVM安全退出（如何优雅的关闭java服务）》</a><br>推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</p></li><li><a href="http://ju.outofmemory.cn/entry/337235" target="_blank" rel="noopener">《常见Java应用如何优雅关闭》</a><br>Java、Srping、Dubbo 优雅关闭方式。</li></ul><h3 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h3><h4 id="读写分离模式"><a href="#读写分离模式" class="headerlink" title="读写分离模式"></a>读写分离模式</h4><ul><li><a href="https://www.cnblogs.com/houdj/p/6563771.html" target="_blank" rel="noopener">《Mysql主从方案的实现》</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/4133148.html" target="_blank" rel="noopener">《搭建MySQL主从复制经典架构》</a></li><li><p><a href="https://blog.csdn.net/nimasike/article/details/48048341" target="_blank" rel="noopener">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></p></li><li><p><a href="https://www.cnblogs.com/zhangsubai/p/6801764.html" target="_blank" rel="noopener">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a></p><ul><li>DRDB 进行磁盘复制，避免单点问题。</li></ul></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html" target="_blank" rel="noopener">《MySQL Cluster 方式》</a></p></li></ul><h4 id="分片模式"><a href="#分片模式" class="headerlink" title="分片模式"></a>分片模式</h4><ul><li><p><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">《分库分表需要考虑的问题及方案》</a></p><ul><li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li><li>问题：事务、Join、迁移、扩容、ID、分页等。</li><li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li><li>分库策略：数值范围；取模；日期等。</li><li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 </li></ul></li><li><p><a href="https://www.2cto.com/database/201503/380348.html" target="_blank" rel="noopener">《MySql分表和表分区详解》</a></p><ul><li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li><li>分表：物理上创建不同的表、客户端需要管理分表路由。</li></ul></li></ul><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><h4 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h4><ul><li><a href="https://blog.csdn.net/jiaolongdy/article/details/51188798" target="_blank" rel="noopener">《永不失联！如何实现微服务架构中的服务发现？》</a><ul><li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li><li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li></ul></li><li><p><a href="https://blog.csdn.net/u010963948/article/details/71730165" target="_blank" rel="noopener">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a></p><ul><li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li><li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li></ul></li><li><p><a href="http://mobile.51cto.com/news-502394.htm" target="_blank" rel="noopener">《基于Zookeeper的服务注册与发现》</a></p><ul><li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 </li></ul></li></ul><h4 id="服务路由控制"><a href="#服务路由控制" class="headerlink" title="服务路由控制"></a>服务路由控制</h4><ul><li><a href="https://blog.csdn.net/xundh/article/details/59492750" target="_blank" rel="noopener">《分布式服务框架学习笔记4 服务路由》</a><ul><li>原则：透明化路由</li><li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li><li>本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li><li>配置方式：统一注册表；本地配置；动态下发。</li></ul></li></ul><h3 id="分布式一致"><a href="#分布式一致" class="headerlink" title="分布式一致"></a>分布式一致</h3><h4 id="CAP-与-BASE-理论"><a href="#CAP-与-BASE-理论" class="headerlink" title="CAP 与 BASE 理论"></a>CAP 与 BASE 理论</h4><ul><li><a href="http://www.cnblogs.com/szlbm/p/5588543.html" target="_blank" rel="noopener">《从分布式一致性谈到CAP理论、BASE理论》</a><ul><li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li><li>CAP：一致性、可用性、分区容错性(网络故障引起)</li><li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li><li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li></ul></li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li><a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">《分布式锁的几种实现方式》</a><ul><li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li><li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li><li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li></ul></li><li><p><a href="https://www.tuicool.com/articles/VZJr6fY" target="_blank" rel="noopener">《基于Zookeeper的分布式锁》</a></p><ul><li>清楚的原理描述 + Java 代码示例。 </li></ul></li><li><p><a href="https://www.cnblogs.com/0201zcr/p/5942748.html" target="_blank" rel="noopener">《jedisLock—redis分布式锁实现》</a></p><ul><li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li></ul></li><li><p><a href="https://blog.csdn.net/albertfly/article/details/77412333" target="_blank" rel="noopener">《Memcached 和 Redis 分布式锁方案》</a></p><ul><li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li></ul></li></ul><h4 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h4><h5 id="PAXOS"><a href="#PAXOS" class="headerlink" title="PAXOS"></a>PAXOS</h5><ul><li><a href="https://www.cnblogs.com/linbingdong/p/6253479.html" target="_blank" rel="noopener">《分布式系列文章——Paxos算法原理与推导》</a></li><li><a href="https://blog.csdn.net/u010039929/article/details/70171672" target="_blank" rel="noopener">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li><li><a href="https://www.cnblogs.com/leesf456/p/6012777.html" target="_blank" rel="noopener">《【分布式】Zookeeper与Paxos》</a></li></ul><h5 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h5><ul><li><a href="https://www.jianshu.com/p/fb527a64deee" target="_blank" rel="noopener">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li></ul><h5 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h5><ul><li><a href="http://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">《Raft 为什么是更易理解的分布式一致性算法》</a><ul><li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li><li>通过随机等待的方式发出投票，得票多的获胜。</li></ul></li></ul><h5 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h5><ul><li><a href="http://blog.51cto.com/tianya23/530743" target="_blank" rel="noopener">《Gossip算法》</a></li></ul><h5 id="两阶段提交、多阶段提交"><a href="#两阶段提交、多阶段提交" class="headerlink" title="两阶段提交、多阶段提交"></a>两阶段提交、多阶段提交</h5><ul><li><a href="http://blog.jobbole.com/95632/" target="_blank" rel="noopener">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li></ul><h4 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h4><ul><li><a href="https://www.cnblogs.com/wxgblogs/p/6639272.html" target="_blank" rel="noopener">《分布式系统—幂等性设计》</a><ul><li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li><li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 </li></ul></li></ul><h4 id="分布式一致方案"><a href="#分布式一致方案" class="headerlink" title="分布式一致方案"></a>分布式一致方案</h4><ul><li><a href="http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency" target="_blank" rel="noopener">《分布式系统事务一致性解决方案》</a></li><li><a href="https://weibo.com/ttarticle/p/show?id=2309403965965003062676" target="_blank" rel="noopener">《保证分布式系统数据一致性的6种方案》</a></li></ul><h4 id="分布式-Leader-节点选举"><a href="#分布式-Leader-节点选举" class="headerlink" title="分布式 Leader 节点选举"></a>分布式 Leader 节点选举</h4><ul><li><a href="https://blog.csdn.net/johnson_moon/article/details/78809995" target="_blank" rel="noopener">《利用zookeeper实现分布式leader节点选举》</a></li></ul><h4 id="TCC-Try-Confirm-Cancel-柔性事务"><a href="#TCC-Try-Confirm-Cancel-柔性事务" class="headerlink" title="TCC(Try/Confirm/Cancel) 柔性事务"></a>TCC(Try/Confirm/Cancel) 柔性事务</h4><ul><li><a href="https://www.jianshu.com/p/ab1a1c6b08a1" target="_blank" rel="noopener">《传统事务与柔性事务》</a><ul><li>基于BASE理论：基本可用、柔性状态、最终一致。</li><li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li></ul></li></ul><h3 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/27666295" target="_blank" rel="noopener">说说分布式文件存储系统-基本架构</a> ？</li><li><a href="https://blog.csdn.net/gatieme/article/details/44982961" target="_blank" rel="noopener">《各种分布式文件系统的比较》</a> ？<ul><li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li><li>FastDFS：轻量级、适合小文件。</li></ul></li></ul><h3 id="唯一ID-生成"><a href="#唯一ID-生成" class="headerlink" title="唯一ID 生成"></a>唯一ID 生成</h3><h4 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h4><ul><li><p><a href="https://www.cnblogs.com/baiwa/p/5318432.html" target="_blank" rel="noopener">《高并发分布式系统中生成全局唯一Id汇总》</a></p><ul><li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li><li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” </li><li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li><li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li></ul></li><li><p><a href="https://blog.csdn.net/hdu09075340/article/details/79103851" target="_blank" rel="noopener">《TDDL 在分布式下的SEQUENCE原理》</a></p><ul><li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li><li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li><li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li></ul></li></ul><h3 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html" target="_blank" rel="noopener">《一致性哈希算法》</a></li></ul><h2 id="设计思想-amp-开发模式"><a href="#设计思想-amp-开发模式" class="headerlink" title="设计思想 &amp; 开发模式"></a>设计思想 &amp; 开发模式</h2><h3 id="DDD-Domain-driven-Design-领域驱动设计"><a href="#DDD-Domain-driven-Design-领域驱动设计" class="headerlink" title="DDD(Domain-driven Design - 领域驱动设计)"></a>DDD(Domain-driven Design - 领域驱动设计)</h3><ul><li><p><a href="https://www.cnblogs.com/netfocus/p/5548025.html" target="_blank" rel="noopener">《浅谈我对DDD领域驱动设计的理解》</a></p><ul><li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li><li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li><li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li></ul></li><li><p><a href="https://www.cnblogs.com/butterfly100/p/7827870.html" target="_blank" rel="noopener">《领域驱动设计的基础知识总结》</a></p><ul><li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li><li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li><li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li><li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li><li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li><li>使用的模式：<ul><li>关联尽量少，尽量单项，尽量降低整体复杂度。</li><li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li><li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li><li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li><li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li><li>工厂（Factory）：类似于设计模式中的工厂模式。</li><li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li></ul></li></ul></li><li><p><a href="http://www.cnblogs.com/Leo_wl/p/3866629.html" target="_blank" rel="noopener">《领域驱动设计(DDD)实现之路》</a></p><ul><li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li></ul></li><li><p><a href="http://www.hollischuang.com/archives/553" target="_blank" rel="noopener">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></p></li></ul><h4 id="命令查询职责分离-CQRS"><a href="#命令查询职责分离-CQRS" class="headerlink" title="命令查询职责分离(CQRS)"></a>命令查询职责分离(CQRS)</h4><p>CQRS — Command Query Responsibility Seperation</p><ul><li><p><a href="https://www.cnblogs.com/cnblogsfans/p/4551990.html" target="_blank" rel="noopener">《领域驱动设计系列 (六)：CQRS》</a></p><ul><li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li></ul></li><li><p><a href="http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml" target="_blank" rel="noopener">《DDD CQRS架构和传统架构的优缺点比较》</a></p><ul><li>最终一致的设计理念；依赖于高可用消息中间件。</li></ul></li><li><p><a href="http://www.cnblogs.com/netfocus/p/4055346.html" target="_blank" rel="noopener">《CQRS架构简介》</a></p><ul><li>一个实现 CQRS 的抽象案例。</li></ul></li><li><p><a href="http://www.uml.org.cn/zjjs/201609221.asp" target="_blank" rel="noopener">《深度长文：我对CQRS/EventSourcing架构的思考》</a></p><ul><li>CQRS 模式分析 + 12306 抢票案例</li></ul></li></ul><h4 id="贫血，充血模型"><a href="#贫血，充血模型" class="headerlink" title="贫血，充血模型"></a>贫血，充血模型</h4><ul><li><a href="https://kb.cnblogs.com/page/520743/" target="_blank" rel="noopener">《贫血，充血模型的解释以及一些经验》</a><ul><li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li><li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li><li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li><li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li><li>作者主张使用贫血模式。</li></ul></li></ul><h3 id="Actor-模式"><a href="#Actor-模式" class="headerlink" title="Actor 模式"></a>Actor 模式</h3><p>TODO</p><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><h4 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h4><p>TODO</p><h4 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h4><p>TODO</p><h4 id="Vert-x"><a href="#Vert-x" class="headerlink" title="Vert.x"></a>Vert.x</h4><p>TODO</p><h3 id="DODAF2-0"><a href="#DODAF2-0" class="headerlink" title="DODAF2.0"></a>DODAF2.0</h3><ul><li><a href="http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml" target="_blank" rel="noopener">《DODAF2.0方法论》</a></li><li><a href="http://blog.51cto.com/xiaoyong/1553164" target="_blank" rel="noopener">《DODAF2.0之能力视角如何落地》</a></li></ul><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><p>无需过多关系服务器的服务架构理念。</p><ul><li><p><a href="http://www.jdon.com/soa/serverless.html" target="_blank" rel="noopener">《什么是Serverless无服务器架构？》</a></p><ul><li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li><li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li><li>Serverless 不代表某个具体的框架。</li></ul></li><li><p><a href="http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless" target="_blank" rel="noopener">《如何理解Serverless？》</a></p><ul><li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li></ul></li></ul><h3 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h3><ul><li><a href="https://time.geekbang.org/article/2355" target="_blank" rel="noopener">《什么是Service Mesh？》</a></li><li><p><a href="https://www.jianshu.com/p/e23e3e74538e" target="_blank" rel="noopener">《初识 Service Mesh》</a></p></li><li><p><a href="https://time.geekbang.org/article/2355" target="_blank" rel="noopener">《什么是Service Mesh？》</a></p></li></ul><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><h3 id="架构评审"><a href="#架构评审" class="headerlink" title="架构评审"></a>架构评审</h3><ul><li><a href="http://developer.51cto.com/art/201506/478486.htm" target="_blank" rel="noopener">《架构设计之如何评审架构设计说明书》</a></li><li><a href="https://blog.csdn.net/wireless_com/article/details/45935591" target="_blank" rel="noopener">《人人都是架构师：非功能性需求》</a></li></ul><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><ul><li><a href="http://www.infoq.com/cn/articles/architect-12-rules-complete/" target="_blank" rel="noopener">《架构之重构的12条军规》</a></li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ul><li><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">《阿里巴巴Java开发手册》</a></li></ul><h3 id="代码-Review"><a href="#代码-Review" class="headerlink" title="代码 Review"></a>代码 Review</h3><p>制度还是制度!<br>另外，每个公司需要根据自己的需求和目标制定自己的 check list</p><ul><li><p><a href="http://www.sohu.com/a/229745352_181657" target="_blank" rel="noopener">《为什么你做不好 Code Review？》</a></p><ul><li>代码 review 做的好，在于制度建设。</li></ul></li><li><p><a href="https://blog.csdn.net/uxyheaven/article/details/49773619" target="_blank" rel="noopener">《从零开始Code Review》</a></p></li><li><p><a href="https://www.cnblogs.com/zuoping/p/5477047.html" target="_blank" rel="noopener">《Code Review Checklist》</a></p></li><li><p><a href="https://dzone.com/articles/java-code-review-checklist" target="_blank" rel="noopener">《Java Code Review Checklist》</a></p></li><li><p><a href="https://blog.csdn.net/legend0011/article/details/45585575" target="_blank" rel="noopener">《如何用 gitlab 做 code review》</a></p></li></ul><h3 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a>RUP</h3><ul><li><a href="https://blog.csdn.net/apanious/article/details/51011946" target="_blank" rel="noopener">《运用RUP 4+1视图方法进行软件架构设计》</a></li></ul><h3 id="看板管理"><a href="#看板管理" class="headerlink" title="看板管理"></a>看板管理</h3><ul><li><a href="https://blog.csdn.net/tkchen/article/details/51637643" target="_blank" rel="noopener">《说说看板在项目中的应用》</a></li></ul><h3 id="SCRUM"><a href="#SCRUM" class="headerlink" title="SCRUM"></a>SCRUM</h3><p>SCRUM - 争球</p><ul><li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li><li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li><li>五个价值观：专注、勇气、公开、承诺、尊重。</li></ul><ul><li><p><a href="https://blog.csdn.net/inny100_100/article/details/54633757" target="_blank" rel="noopener">《敏捷项目管理流程-Scrum框架最全总结！》</a></p></li><li><p><a href="https://blog.csdn.net/superkunkun/article/details/52951142" target="_blank" rel="noopener">《敏捷其实很简单3—敏捷方法之scrum》</a></p></li></ul><h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><p>TODO</p><h2 id="极限编程（XP）"><a href="#极限编程（XP）" class="headerlink" title="极限编程（XP）"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p><ul><li><p><a href="http://www.woshipm.com/pmd/406917.html" target="_blank" rel="noopener">《主流敏捷开发方法：极限编程XP》</a></p><ul><li>是一种指导开发人员的方法论。</li><li><p>4大价值：</p><ul><li>沟通：鼓励口头沟通，提高效率。</li><li>简单：够用就好。</li><li>反馈：及时反馈、通知相关人。</li><li>勇气：提倡拥抱变化，敢于重构。</li></ul></li><li><p>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</p></li><li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li></ul></li></ul><h3 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h3><p>边写码，边review。能够增强代码质量、减少bug。</p><ul><li><a href="http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">《结对编程》</a></li></ul><h3 id="PDCA-循环质量管理"><a href="#PDCA-循环质量管理" class="headerlink" title="PDCA 循环质量管理"></a>PDCA 循环质量管理</h3><p>P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进</p><ul><li><a href="http://www.baike.com/wiki/PDCA" target="_blank" rel="noopener">《PDCA》</a></li></ul><h3 id="FMEA管理模式"><a href="#FMEA管理模式" class="headerlink" title="FMEA管理模式"></a>FMEA管理模式</h3><p>TODO</p><h2 id="通用业务术语"><a href="#通用业务术语" class="headerlink" title="通用业务术语"></a>通用业务术语</h2><p>TODO</p><h2 id="技术趋势"><a href="#技术趋势" class="headerlink" title="技术趋势"></a>技术趋势</h2><p>TODO</p><h2 id="政策、法规"><a href="#政策、法规" class="headerlink" title="政策、法规"></a>政策、法规</h2><p>TODO</p><h3 id="法律"><a href="#法律" class="headerlink" title="法律"></a>法律</h3><h4 id="严格遵守刑法253法条"><a href="#严格遵守刑法253法条" class="headerlink" title="严格遵守刑法253法条"></a>严格遵守刑法253法条</h4><p>我国刑法第253条之一规定：</p><blockquote><ul><li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li><li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 </li><li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li></ul></blockquote><p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p><ul><li><a href="https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA" target="_blank" rel="noopener">《非法获取公民个人信息罪》</a></li></ul><h2 id="架构师素质"><a href="#架构师素质" class="headerlink" title="架构师素质"></a>架构师素质</h2><ul><li><p><a href="http://hellojava.info/?p=430" target="_blank" rel="noopener">《架构师画像》</a></p><ul><li>业务理解和抽象能力</li><li>NB的代码能力</li><li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； </li><li>全局：是否考虑到了对上下游的系统的影响。</li><li>权衡：权衡投入产出比；优先级和节奏控制；</li></ul></li><li><p><a href="http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know" target="_blank" rel="noopener">《关于架构优化和设计，架构师必须知道的事情》</a></p><ul><li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。</li><li>基础设施、配置、测试、开发、运维综合考虑。</li><li>考虑人、团队、和组织的影响。 </li></ul></li><li><p><a href="https://www.zhihu.com/question/19841397" target="_blank" rel="noopener">《如何才能真正的提高自己，成为一名出色的架构师？》</a> </p></li><li><p><a href="https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129" target="_blank" rel="noopener">《架构师的必备素质和成长途径》</a></p><ul><li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li><li>成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 </li></ul></li><li><p><a href="http://blog.51cto.com/frankfan/1248401" target="_blank" rel="noopener">《架构设计师—你在哪层楼？》</a></p><ul><li>第一层的架构师看到的只是产品本身</li><li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li><li>第三层的架构师看到的是商业价值 </li></ul></li></ul><h2 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h2><p>TODO</p><h3 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h3><h2 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h2><h3 id="行业资讯"><a href="#行业资讯" class="headerlink" title="行业资讯"></a>行业资讯</h3><ul><li><a href="http://36kr.com/" target="_blank" rel="noopener">36kr</a></li><li><a href="http://www.techweb.com.cn/" target="_blank" rel="noopener">Techweb</a></li></ul><h3 id="公众号列表"><a href="#公众号列表" class="headerlink" title="公众号列表"></a>公众号列表</h3><p>TODO</p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><h4 id="团队博客"><a href="#团队博客" class="headerlink" title="团队博客"></a>团队博客</h4><ul><li><a href="http://jm.taobao.org/" target="_blank" rel="noopener">阿里中间件博客</a></li><li><a href="https://tech.meituan.com" target="_blank" rel="noopener">美团点评技术团队博客</a></li></ul><h4 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h4><ul><li><a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰的网络日志</a></li><li><a href="https://coolshell.cn/" target="_blank" rel="noopener">酷壳 - COOLSHELL-陈皓</a></li><li><a href="http://hellojava.info/" target="_blank" rel="noopener">hellojava-阿里毕玄</a></li><li><a href="http://cmsblogs.com/" target="_blank" rel="noopener">Cm’s Blog</a></li><li><a href="http://blog.didispace.com/" target="_blank" rel="noopener">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li></ul><h3 id="综合门户、社区"><a href="#综合门户、社区" class="headerlink" title="综合门户、社区"></a>综合门户、社区</h3><p><strong>国内：</strong></p><ul><li><a href="http://csdn.net" target="_blank" rel="noopener">CSDN</a><br>   老牌技术社区、不必解释。</li><li><a href="http://www.51cto.com/" target="_blank" rel="noopener">51cto.com</a></li><li><a href="http://www.iteye.com/" target="_blank" rel="noopener">ITeye</a><ul><li>偏 Java 方向 </li></ul></li><li><a href="https://www.cnblogs.com" target="_blank" rel="noopener">博客园</a></li><li><a href="http://www.tom.net/" target="_blank" rel="noopener">ChinaUnix</a><ul><li>偏 Linux 方向 </li></ul></li><li><a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国社区</a></li><li><a href="http://www.open-open.com/" target="_blank" rel="noopener">深度开源</a></li><li><p><a href="http://www.jobbole.com/" target="_blank" rel="noopener">伯乐在线</a></p><ul><li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li></ul></li><li><p><a href="http://www.itpub.net/" target="_blank" rel="noopener">ITPUB</a></p></li><li><a href="https://cloud.tencent.com/developer/column" target="_blank" rel="noopener">腾讯云— 云+社区</a></li><li><a href="https://yq.aliyun.com/" target="_blank" rel="noopener">阿里云— 云栖社区</a></li><li><a href="https://www.ibm.com/developerworks/cn/" target="_blank" rel="noopener">IBM DeveloperWorks</a></li><li><a href="https://toutiao.io/" target="_blank" rel="noopener">开发者头条</a></li><li><a href="http://www.linkedkeeper.com" target="_blank" rel="noopener">LinkedKeeper</a></li></ul><p><strong>国外：</strong></p><ul><li><a href="https://dzone.com" target="_blank" rel="noopener">DZone</a></li><li><a href="https://www.reddit.com" target="_blank" rel="noopener">Reddit</a></li></ul><h3 id="问答、讨论类社区"><a href="#问答、讨论类社区" class="headerlink" title="问答、讨论类社区"></a>问答、讨论类社区</h3><ul><li><a href="https://segmentfault.com" target="_blank" rel="noopener">segmentfault</a><ul><li>问答+专栏 </li></ul></li><li><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></li><li><a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a></li></ul><h3 id="行业数据分析"><a href="#行业数据分析" class="headerlink" title="行业数据分析"></a>行业数据分析</h3><ul><li><a href="http://report.iresearch.cn/" target="_blank" rel="noopener">艾瑞网</a></li><li><p><a href="https://www.questmobile.com.cn" target="_blank" rel="noopener">QUEST MOBILE</a></p></li><li><p><a href="http://data.stats.gov.cn/" target="_blank" rel="noopener">国家数据</a></p></li><li><p><a href="http://www.talkingdata.com/" target="_blank" rel="noopener">TalkingData</a></p></li></ul><h3 id="专项网站"><a href="#专项网站" class="headerlink" title="专项网站"></a>专项网站</h3><ul><li><p>测试:</p><ul><li><a href="http://www.ltesting.net/" target="_blank" rel="noopener">领测国际</a> </li><li><a href="https://www.testwo.com/" target="_blank" rel="noopener">测试窝</a></li><li><a href="https://testerhome.com" target="_blank" rel="noopener">TesterHome</a></li></ul></li><li><p>运维:</p><pre><code>* [运维派](http://www.yunweipai.com/) * [Abcdocker](https://www.abcdocker.com/)</code></pre></li><li><p>Java:</p><ul><li><a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew</a><ul><li>专注于 Java 技术分享</li></ul></li><li><a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a><ul><li>英文博客</li></ul></li></ul></li><li><p>安全</p><ul><li><a href="https://www.2cto.com/" target="_blank" rel="noopener">红黑联盟</a> </li><li><a href="http://www.freebuf.com/" target="_blank" rel="noopener">FreeBuf</a></li></ul></li><li><p>大数据</p><ul><li><a href="http://www.thebigdata.cn/" target="_blank" rel="noopener">中国大数据</a> </li></ul></li><li><p>其他专题网站：</p><ul><li><a href="http://www.dockerinfo.net/" target="_blank" rel="noopener">DockerInfo</a><ul><li>专注于 Docker 应用及咨询、教程的网站。</li></ul></li><li><a href="https://www.linuxidc.com/" target="_blank" rel="noopener">Linux公社</a><ul><li>Linux 主题社区</li></ul></li></ul></li></ul><h3 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h3><ul><li><a href="https://github.com/TeamStuQ/skill-map" target="_blank" rel="noopener">程序员技能图谱</a></li></ul><h3 id="推荐参考书"><a href="#推荐参考书" class="headerlink" title="推荐参考书"></a>推荐参考书</h3><h4 id="在线电子书"><a href="#在线电子书" class="headerlink" title="在线电子书"></a>在线电子书</h4><ul><li><a href="https://github.com/forezp/SpringCloudLearning" target="_blank" rel="noopener">《深入理解Spring Cloud与微服务构建》</a></li></ul><ul><li><a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf" target="_blank" rel="noopener">《阿里技术参考图册-研发篇》</a></li><li><p><a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf" target="_blank" rel="noopener">《阿里技术参考图册-算法篇》</a></p></li><li><p><a href="http://dpurl.cn/n/1lqcX" target="_blank" rel="noopener">《2018美团点评技术年货（合辑）》70M</a></p></li><li><p><a href="http://www.infoq.com/cn/architect/" target="_blank" rel="noopener">InfoQ《架构师》月刊</a></p></li><li><p><a href="https://www.w3cschool.cn/architectroad/" target="_blank" rel="noopener">《架构师之路》</a></p></li></ul><h4 id="纸质书"><a href="#纸质书" class="headerlink" title="纸质书"></a>纸质书</h4><h5 id="开发方面"><a href="#开发方面" class="headerlink" title="开发方面"></a>开发方面</h5><ul><li>《阿里巴巴Java开发手册》<a href="https://union-click.jd.com/jdc?d=bVKwZQ" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=阿里巴巴Java开发手册" target="_blank" rel="noopener">淘宝</a></li></ul><h5 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a>架构方面</h5><ul><li>《软件架构师的12项修炼：技术技能篇》<a href="https://union-click.jd.com/jdc?d=gXvRd8" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇" target="_blank" rel="noopener">淘宝</a></li><li>《架构之美》<a href="https://union-click.jd.com/jdc?d=xJit5I" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=架构之美" target="_blank" rel="noopener">淘宝</a></li><li>《分布式服务架构》<a href="https://union-click.jd.com/jdc?d=JS5Od9" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=分布式服务架构" target="_blank" rel="noopener">淘宝</a></li><li>《聊聊架构》 <a href="https://union-click.jd.com/jdc?d=FHooH4" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=聊聊架构" target="_blank" rel="noopener">淘宝</a></li><li>《云原生应用架构实践》<a href="https://union-click.jd.com/jdc?d=orkJSj" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=云原生应用架构实践" target="_blank" rel="noopener">淘宝</a></li><li>《亿级流量网站架构核心技术》<a href="https://union-click.jd.com/jdc?d=RnOSP5" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=亿级流量网站架构核心技术" target="_blank" rel="noopener">淘宝</a></li><li>《淘宝技术这十年》<a href="https://union-click.jd.com/jdc?d=LwrDfD" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=淘宝技术这十年" target="_blank" rel="noopener">淘宝</a></li><li><p>《企业IT架构转型之道-中台战略思想与架构实战》 <a href="https://union-click.jd.com/jdc?d=89pAEm" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=企业IT架构转型之道" target="_blank" rel="noopener">淘宝</a></p></li><li><p>《高可用架构（第1卷）》<a href="https://item.jd.com/12195481.html" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=高可用架构" target="_blank" rel="noopener">淘宝</a></p></li></ul><h5 id="技术管理方面"><a href="#技术管理方面" class="headerlink" title="技术管理方面"></a>技术管理方面</h5><ul><li>《CTO说》<a href="https://union-click.jd.com/jdc?d=zhTZyr" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=CTO说" target="_blank" rel="noopener">淘宝</a></li><li>《技术管理之巅》<a href="https://union-click.jd.com/jdc?d=LgRBUW" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=技术管理之巅" target="_blank" rel="noopener">淘宝</a></li><li>《网易一千零一夜：互联网产品项目管理实战》<a href="https://union-click.jd.com/jdc?d=jcRz2r" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战" target="_blank" rel="noopener">淘宝</a></li></ul><h5 id="基础理论-1"><a href="#基础理论-1" class="headerlink" title="基础理论"></a>基础理论</h5><ul><li>《数学之美》<a href="https://union-click.jd.com/jdc?d=ghIES2" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=数学之美" target="_blank" rel="noopener">淘宝</a></li><li>《编程珠玑》<a href="https://union-click.jd.com/jdc?d=YmhdEu" target="_blank" rel="noopener">京东</a> <a href="https://s.taobao.com/search?q=编程珠玑" target="_blank" rel="noopener">淘宝</a></li></ul><h5 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a>工具方面</h5><p>TODO</p><h5 id="大数据方面"><a href="#大数据方面" class="headerlink" title="大数据方面"></a>大数据方面</h5><h1 id="技术资源"><a href="#技术资源" class="headerlink" title="技术资源"></a>技术资源</h1><h3 id="开源资源"><a href="#开源资源" class="headerlink" title="开源资源"></a>开源资源</h3><ul><li><p><a href="https://github.com" target="_blank" rel="noopener">github</a></p></li><li><p><a href="https://www.apache.org/index.html" target="_blank" rel="noopener">Apache 软件基金会</a></p></li></ul><h3 id="手册、文档、教程"><a href="#手册、文档、教程" class="headerlink" title="手册、文档、教程"></a>手册、文档、教程</h3><p><strong>国内：</strong></p><ul><li><a href="http://w3cschool.cn" target="_blank" rel="noopener">W3Cschool</a> </li><li><p><a href="http://www.runoob.com/" target="_blank" rel="noopener">Runoob.com</a></p><ul><li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li></ul></li><li><p><a href="https://love2.io/" target="_blank" rel="noopener">Love2.io</a></p><ul><li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li></ul></li><li><a href="http://gitbook.cn/" target="_blank" rel="noopener">gitbook.cn</a><ul><li>付费电子书。 </li></ul></li><li><a href="http://www.apachecn.org/" target="_blank" rel="noopener">ApacheCN</a><ul><li>AI、大数据方面系列中文文档。</li></ul></li></ul><p><strong>国外：</strong></p><ul><li><a href="http://www.quickcode.co/" target="_blank" rel="noopener">Quick Code</a><ul><li>免费在线技术教程。</li></ul></li><li><a href="http://gitbook.com" target="_blank" rel="noopener">gitbook.com</a><ul><li>有部分中文电子书。</li></ul></li><li><a href="https://www.cheatography.com/" target="_blank" rel="noopener">Cheatography</a><ul><li>Cheat Sheets 大全，单页文档网站。</li></ul></li><li><a href="https://www.tutorialspoint.com/index.htm" target="_blank" rel="noopener">Tutorialspoint</a><ul><li>知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。</li></ul></li></ul><h3 id="在线课堂"><a href="#在线课堂" class="headerlink" title="在线课堂"></a>在线课堂</h3><ul><li><a href="http://www.xuetuwuyou.com/" target="_blank" rel="noopener">学徒无忧</a></li><li><a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a></li><li><a href="https://segmentfault.com/lives" target="_blank" rel="noopener">segmentfault</a></li><li><a href="https://new.stuq.org/course/explore" target="_blank" rel="noopener">斯达克学院</a></li><li><a href="http://nowcoder.com" target="_blank" rel="noopener">牛客网</a></li><li><a href="https://www.jikexueyuan.com/" target="_blank" rel="noopener">极客学院</a></li><li><a href="http://edu.51cto.com/" target="_blank" rel="noopener">51CTO学院</a></li></ul><h3 id="会议、活动"><a href="#会议、活动" class="headerlink" title="会议、活动"></a>会议、活动</h3><ul><li><a href="http://www.infoq.com/cn/qcon/" target="_blank" rel="noopener">QCon</a></li><li><a href="https://archsummit.com" target="_blank" rel="noopener">ArchSummit</a></li><li><a href="http://www.thegitc.com/" target="_blank" rel="noopener">GITC全球互联网技术大会</a></li></ul><p><strong>活动发布平台:</strong> </p><ul><li><a href="http://www.huodongxing.com/" target="_blank" rel="noopener">活动行</a></li></ul><h3 id="常用APP"><a href="#常用APP" class="headerlink" title="常用APP"></a>常用APP</h3><ul><li><a href="https://time.geekbang.org" target="_blank" rel="noopener">极客时间</a></li><li><a href="https://www.igetget.com" target="_blank" rel="noopener">得到</a></li></ul><h3 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h3><ul><li><a href="https://www.zhipin.com" target="_blank" rel="noopener">Boss直聘</a></li><li><a href="https://www.lagou.com" target="_blank" rel="noopener">拉勾网</a></li><li><a href="https://www.liepin.com" target="_blank" rel="noopener">猎聘</a></li><li><a href="https://cn.100offer.com/" target="_blank" rel="noopener">100Offer</a></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><a href="https://s.geekbang.org/" target="_blank" rel="noopener">极客搜索</a><ul><li>技术文章搜索引擎。</li></ul></li></ul><h3 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a>代码托管</h3><ul><li><a href="https://coding.net" target="_blank" rel="noopener">Coding</a></li><li><a href="https://gitee.com/" target="_blank" rel="noopener">码云</a></li></ul><h3 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h3><ul><li>七牛</li><li>又拍云</li></ul><h3 id="综合云服务商"><a href="#综合云服务商" class="headerlink" title="综合云服务商"></a>综合云服务商</h3><ul><li>阿里云</li><li><a href="https://cloud.tencent.com/redirect.php?redirect=1012&amp;cps_key=c2665015d90871c0cb20fef91b7afc3c" target="_blank" rel="noopener">腾讯云</a></li><li>百度云</li><li>新浪云</li><li>金山云</li><li><a href="https://amazonaws-china.com/cn/" target="_blank" rel="noopener">亚马逊云(AWS)</a></li><li><a href="https://cloud.google.com/?hl=zh-cn" target="_blank" rel="noopener">谷歌云</a></li><li><a href="https://azure.microsoft.com/zh-cn/" target="_blank" rel="noopener">微软云</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;本文摘自 &lt;code&gt;github&lt;/code&gt; 上的一篇长约 &lt;code&gt;10&lt;/code&gt; 万字服务端架构师技术总结归纳文档，覆盖广度包括数据结构、算法、并发、操作系统、设计模式、运维、中间件、网络、数据库、搜索引擎、性能、大数据、安全、常见开源框架、分布式、设计思想、项目管理和技术资源等。&lt;/p&gt;
    
    </summary>
    
      <category term="技术知识图谱" scheme="https://ostenant.coding.me/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0 Reactive编程系列(一) - WebFlux初体验</title>
    <link href="https://ostenant.coding.me/2018/05/27/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%20Reactive%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97(%E4%B8%80)%20-%20WebFlux%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://ostenant.coding.me/2018/05/27/实战Spring Boot 2.0 Reactive编程系列(一) - WebFlux初体验/</id>
    <published>2018-05-27T07:25:00.000Z</published>
    <updated>2018-06-18T01:57:04.779Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文引入了 <strong>反应式编程模型</strong> 相关概念，对 <code>Spring Reactor</code> 的核心 <code>API</code> 进行了简单归纳。本文会对 <code>Spring 5 WebFlux</code> 进行相关介绍，包括引入 <code>Servlet 3.1 +</code>，各个功能组件 <code>Router Functions</code>、<code>WebFlux</code> 和 <code>Reactive Streams</code> 等，以及如何在 <code>Spring Boot 2.0</code> 中分别以 <strong>全局功能路由</strong> 和 <code>MVC</code> <strong>控制器</strong> 的方式配置 <code>HTTP</code> 请求处理。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/Sprng_Boot_2.0_Log.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Spring-5-WebFlux介绍"><a href="#Spring-5-WebFlux介绍" class="headerlink" title="Spring 5 WebFlux介绍"></a>Spring 5 WebFlux介绍</h2><p>关于 <code>Spring 5</code> 的 <code>WebFlux</code> 响应式编程，下图是传统 <code>Spring Web MVC</code> 结构以及<code>Spring 5</code> 中新增加的基于 <code>Reactive Streams</code> 的 <code>Spring WebFlux</code> 框架。可以使用 <code>webFlux</code> 模块来构建 <strong>异步的</strong>、<strong>非堵塞的</strong>、<strong>事件驱动</strong> 的服务，其在 <strong>伸缩性方面</strong> 表现非常好。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/WebFlux_01_00.png" alt=""></p><p>如图所示，<code>WebFlux</code> 模块从上到下依次是 <code>Router Functions</code>、<code>WebFlux</code>、<code>Reactive Streams</code> 三个新组件。</p><h3 id="Servlet-3-1-API介绍"><a href="#Servlet-3-1-API介绍" class="headerlink" title="Servlet 3.1+ API介绍"></a>Servlet 3.1+ API介绍</h3><p><code>WebFlux</code> 模块需要运行在实现了 <code>Servlet 3.1+</code> <strong>规范</strong> 的容器之上。<code>Servlet 3.1</code> 规范中新增了对 <strong>异步处理</strong> 的支持，在新的 <code>Servlet</code> 规范中，<code>Servlet</code> 线程不需要一直 <strong>阻塞等待</strong> 到业务处理完成。</p><p>在 <code>Servlet 3.1</code> 中，其请求处理的线程模型大致如下：</p><ol><li><p><code>Servlet</code> 线程接收到新的请求后，不需要等待业务处理完成再进行结果输出，而是将这个请求委托给另外一个线程（业务线程）来完成。</p></li><li><p><code>Servlet</code> 线程将委托完成之后变返回到容器中去接收新的请求。</p></li></ol><p><code>Servlet 3.1</code> 规范特别适用于那种 <strong>业务处理非常耗时</strong> 的场景之下，可以减少 <strong>服务器资源</strong> 的占用，并且提高 <strong>并发处理速度</strong> ，而对于那些能 <strong>快速响应</strong> 的场景收益并不大。</p><p>所以 <code>WebFlux</code> 支持的容器有 <code>Tomcat</code>、<code>Jetty</code> 等 <strong>同步容器</strong> ，也可以是 <code>Netty</code> 和 <code>Undertow</code> 这类 <strong>异步容器</strong>。在容器中 <code>Spring WebFlux</code> 会将 <strong>输入流</strong> 适配成 <code>Mono</code> 或 <code>Flux</code> 格式进行统一处理。</p><h3 id="Spring-WebFlux的功能模块"><a href="#Spring-WebFlux的功能模块" class="headerlink" title="Spring WebFlux的功能模块"></a>Spring WebFlux的功能模块</h3><p>下面介绍上图中 <code>WebFlux</code> 各个模块：</p><h4 id="1-Router-Functions"><a href="#1-Router-Functions" class="headerlink" title="1. Router Functions"></a>1. Router Functions</h4><p>对标准的 <code>@Controller</code>，<code>@RequestMapping</code>等的 <code>Spring MVC</code> 注解，提供一套 <strong>函数式风格</strong> 的 <code>API</code>，用于创建 <code>Router</code>、<code>Handler</code> 和<code>Filter</code>。</p><h4 id="2-WebFlux"><a href="#2-WebFlux" class="headerlink" title="2. WebFlux"></a>2. WebFlux</h4><p>核心组件，协调上下游各个组件提供 <strong>响应式编程</strong> 支持。</p><h4 id="3-Reactive-Streams"><a href="#3-Reactive-Streams" class="headerlink" title="3. Reactive Streams"></a>3. Reactive Streams</h4><p>一种支持 <strong>背压</strong> <code>(Backpressure)</code> 的 <strong>异步数据流处理标准</strong>，主流实现有 <code>RxJava</code> 和 <code>Reactor</code>，<code>Spring WebFlux</code> 集成的是<code>Reactor</code>。</p><h4 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h4><p><code>Flux</code> 和 <code>Mono</code> 属于 <strong>事件发布者</strong>，类似于 <strong>生产者</strong>，对消费者 <strong>提供订阅接口</strong>。当有事件发生的时候，<code>Flux</code> 或 <code>Mono</code> 会回调 <strong>消费者</strong>相应的方法来通知 <strong>消费者</strong> 相应的事件。</p><p>下面这张图是 <code>Flux</code> 的工作流程图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Flux_Workflow.png" alt=""></p><p>关于 <code>Flux</code> 的工作模式，可以看出 <code>Flux</code> 可以 触发 <code>(emit)</code> 很多 <code>item</code>，而这些 <code>item</code> 可以经过若干 <code>Operators</code> 然后才被 <code>subscribe</code>，下面是使用 <code>Flux</code> 的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flux.fromIterable(getSomeLongList())</span><br><span class="line">    .mergeWith(Flux.interval(<span class="number">100</span>))</span><br><span class="line">    .doOnNext(serviceA::someObserver)</span><br><span class="line">    .map(d -&gt; d * <span class="number">2</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .onErrorResumeWith(errorHandler::fallback)</span><br><span class="line">    .doAfterTerminate(serviceM::incrementTerminate)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h4><p>下面的图片是 <code>Mono</code> 的处理流程，可以很直观的看出来 <code>Mono</code> 和 <code>Flux</code> 的区别：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Mono_Workflow.png" alt=""></p><p><code>Mono</code> 只能触发 <code>(emit)</code> 一个 <code>item</code>，下面是使用 <code>Mono</code> 的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mono.fromCallable(System::currentTimeMillis)</span><br><span class="line">    .flatMap(time -&gt; Mono.first(serviceA.findRecent(time), serviceB.findRecent(time)))</span><br><span class="line">    .timeout(Duration.ofSeconds(<span class="number">3</span>), errorHandler::fallback)</span><br><span class="line">    .doOnSuccess(r -&gt; serviceM.incrementSuccess())</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-2-0-Reactive-Stack"><a href="#Spring-Boot-2-0-Reactive-Stack" class="headerlink" title="Spring Boot 2.0 Reactive Stack"></a>Spring Boot 2.0 Reactive Stack</h2><p><code>Spring Boot Webflux</code> 就是基于 <code>Reactor</code> 实现的。<code>Spring Boot 2.0</code> 包括一个新的 <code>spring-webflux</code> 模块。该模块包含对 <strong>响应式</strong> <code>HTTP</code> 和 <code>WebSocket</code> 客户端的支持，以及对 <code>REST</code> 、<code>HTML</code> 和 <code>WebSocket</code> <strong>交互等程序</strong> 的支持。一般来说，<code>Spring MVC</code> 用于 <strong>同步处理</strong>，<code>Spring Webflux</code> 用于 <strong>异步处理</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBoot2.0_Reactor.png" alt=""></p><p>如上图所示，从 <code>Web</code> 表现层到数据访问，再到容器，<code>Spring Boot 2.0</code> 同时提供了 <strong>同步阻塞式</strong> 和 <strong>异步非阻塞式</strong> 两套完整的 <code>API Stack</code>。</p><p>从上而下对比以下两者的区别:</p><table><thead><tr><th style="text-align:left">API Stack</th><th style="text-align:left">Sevlet Stack</th><th style="text-align:left">Reactive Stack</th></tr></thead><tbody><tr><td style="text-align:left">Web控制层</td><td style="text-align:left">Spring MVC</td><td style="text-align:left">Spring WebFlux</td></tr><tr><td style="text-align:left">安全认证层</td><td style="text-align:left">Spring Security</td><td style="text-align:left">Spring Security</td></tr><tr><td style="text-align:left">数据访问层</td><td style="text-align:left">Spring Data Repositories</td><td style="text-align:left">Spring Data Reactive Repositories</td></tr><tr><td style="text-align:left">容器API</td><td style="text-align:left">Servlet API</td><td style="text-align:left">Reactive Streams Adapters</td></tr><tr><td style="text-align:left">内嵌容器</td><td style="text-align:left">Servlet Containers</td><td style="text-align:left">Netty, Servlet 3.1+ Containers</td></tr></tbody></table><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>控制层一旦使用 <code>Spring WebFlux</code>，它下面的安全认证层、数据访问层都必须使用 <code>Reactive API</code>。其次，<code>Spring Data Reactive Repositories</code> 目前只支持 <code>MongoDB</code>、<code>Redis</code> 和 <code>Couchbase</code> 等几种不支持事务管理的 <code>NOSQL</code>。技术选型时一定要权衡这些弊端和风险，比如：</p><ol><li><p><code>Spring MVC</code> 能满足场景的，就不需要更改为  <code>Spring WebFlux</code>。</p></li><li><p>要注意容器的支持，可以看看底层 <strong>内嵌容器</strong> 的支持。</p></li><li><p><strong>微服务</strong> 体系结构，<code>Spring WebFlux</code> 和 <code>Spring MVC</code> 可以混合使用。尤其开发 <code>IO</code> <strong>密集型</strong> 服务的时候，可以选择 <code>Spring WebFlux</code> 去实现。</p></li></ol><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p><code>Spring 5 Web</code> 模块包含了 <code>Spring WebFlux</code> 的 <code>HTTP</code> 抽象。类似 <code>Servlet API</code>， <code>WebFlux</code> 提供了 <code>WebHandler API</code> 去定义 <strong>非阻塞</strong> <code>API</code> 抽象接口。可以选择以下两种编程模型实现：</p><ol><li><p><strong>注解控制层:</strong> 和 <code>MVC</code> 保持一致，<code>WebFlux</code> 也支持 <strong>响应性</strong> <code>@RequestBody</code> 注解。</p></li><li><p><strong>功能性端点:</strong> 基于 <code>lambda</code> 轻量级编程模型，用来 <strong>建立路由</strong> 和 <strong>处理请求</strong> 的工具。和上面最大的区别就是，这种模型，<strong>全程</strong> 控制了 <strong>请求 - 响应</strong> 的生命流程</p></li></ol><h3 id="内嵌容器"><a href="#内嵌容器" class="headerlink" title="内嵌容器"></a>内嵌容器</h3><p>跟 <code>Spring Boot</code> 大框架一样启动应用，但 <code>Spring WebFlux</code> 默认是通过 <code>Netty</code> 启动，并且自动设置了 <strong>默认端口</strong> 为 <code>8080</code>。另外还提供了对 <code>Jetty</code>、<code>Undertow</code> 等容器的支持。开发者自行在添加对应的容器 <code>Starter</code> 组件依赖，即可配置并使用对应 <strong>内嵌容器实例</strong>。</p><blockquote><p>注意: 必须是 Servlet 3.1+ 容器，如 Tomcat、Jetty；或者非 Servlet 容器，如 Netty 和 Undertow。</p></blockquote><h3 id="Starter-组件"><a href="#Starter-组件" class="headerlink" title="Starter 组件"></a>Starter 组件</h3><p>跟 <code>Spring Boot</code> 大框架一样，<code>Spring Boot Webflux</code> 提供了很多 <strong>开箱即用</strong> 的 <code>Starter</code> 组件。添加 <code>spring-boot-starter-webflux</code> 依赖，就可用于构建 <strong>响应式</strong> <code>API</code> 服务，其包含了 <code>WebFlux</code> 和 <code>Tomcat</code> <strong>内嵌容器</strong> 等。</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="Spring-Initializr构建项目骨架"><a href="#Spring-Initializr构建项目骨架" class="headerlink" title="Spring Initializr构建项目骨架"></a>Spring Initializr构建项目骨架</h4><p>利用 <code>Spring Initializer</code> 快速生成 <code>Spring Boot</code> 应用，配置项目信息并设置依赖。</p><h4 id="配置Maven依赖"><a href="#配置Maven依赖" class="headerlink" title="配置Maven依赖"></a>配置Maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Boot启动类"><a href="#Spring-Boot启动类" class="headerlink" title="Spring Boot启动类"></a>Spring Boot启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置实体类"><a href="#配置实体类" class="headerlink" title="配置实体类"></a>配置实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    String body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-MVC控制器方式"><a href="#1-MVC控制器方式" class="headerlink" title="1. MVC控制器方式"></a>1. MVC控制器方式</h3><h4 id="1-1-编写控制器"><a href="#1-1-编写控制器" class="headerlink" title="1.1. 编写控制器"></a>1.1. 编写控制器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;Message&gt; <span class="title">allMessages</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Flux.just(</span><br><span class="line">            Message.builder().body(<span class="string">"hello Spring 5"</span>).build(),</span><br><span class="line">            Message.builder().body(<span class="string">"hello Spring Boot 2"</span>).build()</span><br><span class="line">        );</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-编写测试类"><a href="#1-2-编写测试类" class="headerlink" title="1.2. 编写测试类"></a>1.2. 编写测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebFluxTest</span>(controllers = MessageController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WebTestClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllMessagesShouldBeOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.get().uri(<span class="string">"/"</span>).exchange().expectStatus().isOk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-查看启动日志"><a href="#1-3-查看启动日志" class="headerlink" title="1.3. 查看启动日志"></a>1.3. 查看启动日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-05-27 17:37:23.550  INFO 67749 --- [           main] s.w.r.r.m.a.RequestMappingHandlerMapping : Mapped <span class="string">"&#123;[],methods=[GET]&#125;"</span> onto reactor.core.publisher.Flux&lt;com.example.demo.Message&gt; com.example.demo.MessageController.allMessages()</span><br><span class="line">2018-05-27 17:37:23.998  INFO 67749 --- [ctor-http-nio-1] r.ipc.netty.tcp.BlockingNettyContext     : Started HttpServer on /0:0:0:0:0:0:0:0:8080</span><br><span class="line">2018-05-27 17:37:23.999  INFO 67749 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080</span><br><span class="line">2018-05-27 17:37:24.003  INFO 67749 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication <span class="keyword">in</span> 1.6 seconds (JVM running <span class="keyword">for</span> 2.274)</span><br></pre></td></tr></table></figure><p>从日志里可以看出：</p><ol><li>启动时 <code>WebFlux</code> 利用 <code>MVC</code> 原生的 <code>RequestMappingHandlerMapping</code> 将控制器里的 <strong>请求路径</strong> 和 <code>MVC</code> 中的 <strong>处理器</strong> 进行绑定。</li><li><code>Spring WebFlux</code> 默认采用 <code>Netty</code> 作为 <strong>内嵌容器</strong>，且启动端口默认为 <code>8080</code>。</li></ol><p>访问 <a href="localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>，返回结果如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Controller_Result_001.png" alt=""></p><h3 id="2-全局Router-API方式"><a href="#2-全局Router-API方式" class="headerlink" title="2. 全局Router API方式"></a>2. 全局Router API方式</h3><h4 id="2-1-配置全局Router-Bean"><a href="#2-1-配置全局Router-Bean" class="headerlink" title="2.1. 配置全局Router Bean"></a>2.1. 配置全局Router Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRouterConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">routes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">"/"</span>), (ServerRequest req)-&gt; ok()</span><br><span class="line">                .body(</span><br><span class="line">                    BodyInserters.fromObject(</span><br><span class="line">                        Arrays.asList(</span><br><span class="line">                            Message.builder().body(<span class="string">"hello Spring 5"</span>).build(),</span><br><span class="line">                            Message.builder().body(<span class="string">"hello Spring Boot 2"</span>).build()</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-编写测试类"><a href="#2-2-编写测试类" class="headerlink" title="2.2. 编写测试类"></a>2.2. 编写测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebFluxTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WebTestClient client;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllMessagesShouldBeOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.get().uri(<span class="string">"/"</span>).exchange().expectStatus().isOk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-查看启动日志"><a href="#2-3-查看启动日志" class="headerlink" title="2.3. 查看启动日志"></a>2.3. 查看启动日志</h4><p>运行 <code>Spring Boot</code> 启动入口类，启动日志如下(不重要的省略)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-05-27 17:20:28.870  INFO 67696 --- [           main] o.s.w.r.f.s.s.RouterFunctionMapping      : Mapped (GET &amp;&amp; /) -&gt; com.example.demo.DemoRouterConfig$<span class="variable">$Lambda</span><span class="variable">$213</span>/1561745898@3381b4fc</span><br><span class="line">2018-05-27 17:20:28.931  INFO 67696 --- [           main] o.s.w.r.r.m.a.ControllerMethodResolver   : Looking <span class="keyword">for</span> @ControllerAdvice: org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@1460a8c0: startup date [Sun May 27 17:20:27 CST 2018]; root of context hierarchy</span><br><span class="line">2018-05-27 17:20:29.311  INFO 67696 --- [ctor-http-nio-1] r.ipc.netty.tcp.BlockingNettyContext     : Started HttpServer on /0:0:0:0:0:0:0:0:8080</span><br><span class="line">2018-05-27 17:20:29.312  INFO 67696 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080</span><br><span class="line">2018-05-27 17:20:29.316  INFO 67696 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication <span class="keyword">in</span> 2.137 seconds (JVM running <span class="keyword">for</span> 3.169)</span><br></pre></td></tr></table></figure><p>从日志里可以看出：启动时 <code>WebFlux</code> 利用 <code>RouterFunctionMapping</code> 将 <code>RouterFunction</code> 里的 <strong>全局路径</strong> 和 <strong>请求处理</strong> 进行了映射和绑定。</p><p>访问 <a href="localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>，返回结果如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Router_Result_000.png" alt=""></p><p>可以看出，无论是使用 <code>Fucntional Router</code> 还是 <code>MVC Controller</code>，都可以产生相同的效果！</p><h2 id="开发运行环境"><a href="#开发运行环境" class="headerlink" title="开发运行环境"></a>开发运行环境</h2><ul><li><p><strong>JDK 1.8 +</strong> : <code>Spring Boot 2.x</code> 要求 <code>JDK 1.8</code> 环境及以上版本。另外，<code>Spring Boot 2.x</code> 只兼容 <code>Spring Framework 5.0</code> 及以上版本。</p></li><li><p><strong>Maven 3.2 +</strong> : 为 <code>Spring Boot 2.x</code> 提供了相关依赖构建工具是 <code>Maven</code>，版本需要 <code>3.2</code> 及以上版本。使用 <code>Gradle</code> 则需要 <code>1.12</code> 及以上版本。<code>Maven</code> 和 <code>Gradle</code> 大家各自挑选下喜欢的就好。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文首先对 <code>Spring 5 WebFlux</code> 进行了单独介绍，包括引入 <code>Servlet 3.1 +</code>，各个功能组件 <code>Router Functions</code>、<code>WebFlux</code> 和 <code>Reactive Streams</code> 等。然后在 <code>Spring Boot 2.0</code> 详细地介绍了 <code>Reactive Stack</code> 和 <code>Servlet Stack</code> 的组成区别，并分别给出了 <code>WebFlux</code> 基于 <strong>全局功能路由</strong> 和 <strong>控制器</strong> 的配置和使用案例。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上文引入了 &lt;strong&gt;反应式编程模型&lt;/strong&gt; 相关概念，对 &lt;code&gt;Spring Reactor&lt;/code&gt; 的核心 &lt;code&gt;API&lt;/code&gt; 进行了简单归纳。本文会对 &lt;code&gt;Spring 5 WebFlux&lt;/code&gt; 进行相关介绍，包括引入 &lt;code&gt;Servlet 3.1 +&lt;/code&gt;，各个功能组件 &lt;code&gt;Router Functions&lt;/code&gt;、&lt;code&gt;WebFlux&lt;/code&gt; 和 &lt;code&gt;Reactive Streams&lt;/code&gt; 等，以及如何在 &lt;code&gt;Spring Boot 2.0&lt;/code&gt; 中分别以 &lt;strong&gt;全局功能路由&lt;/strong&gt; 和 &lt;code&gt;MVC&lt;/code&gt; &lt;strong&gt;控制器&lt;/strong&gt; 的方式配置 &lt;code&gt;HTTP&lt;/code&gt; 请求处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Reactive编程系列" scheme="https://ostenant.coding.me/categories/Spring-Reactive%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Reactive Streams" scheme="https://ostenant.coding.me/tags/Reactive-Streams/"/>
    
      <category term="Spring WebFlux" scheme="https://ostenant.coding.me/tags/Spring-WebFlux/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Spring Reactor反应式编程</title>
    <link href="https://ostenant.coding.me/2018/05/26/%E8%81%8A%E8%81%8ASpring%20Reactor%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://ostenant.coding.me/2018/05/26/聊聊Spring Reactor反应式编程/</id>
    <published>2018-05-26T08:41:00.000Z</published>
    <updated>2018-06-18T01:59:19.114Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了应对 <strong>高并发环境下</strong> 的服务端编程，微软提出了一个实现 <strong>异步编程</strong> 的方案 -  <code>Reactive Programming</code>，中文名称 <strong>反应式编程</strong>。随后，其它技术也迅速地跟上了脚步，像 <code>ES6</code> 通过 <code>Promise</code> 引入了类似的异步编程方式。<code>Java</code> 社区也没有落后很多，<code>Netflix</code> 和 <code>TypeSafe</code> 公司提供了 <code>RxJava</code> 和 <code>Akka Stream</code> 技术，让 <code>Java</code> 平台也有了能够实现反应式编程的框架。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/Reactor.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程是种编程方式，它将计算机的运算视为函数的计算。函数编程语言最重要的基础是 <strong>λ演算</strong> <code>(lambda calculus)</code>，而λ演算的函数可以接受函数当作 <strong>输入(参数)</strong> 和 <strong>输出(返回值)</strong>。<code>lambda</code> 表达式对与大多数程序员已经很熟悉了，<code>jdk8</code> 以及 <code>es6</code>都是引入的 <code>lambda</code>。</p><h3 id="函数式编程的特点"><a href="#函数式编程的特点" class="headerlink" title="函数式编程的特点"></a>函数式编程的特点</h3><ul><li>惰性计算 </li><li>函数是“第一等公民” </li><li>只使用表达式而不使用语句 </li><li>没有副作用</li></ul><h2 id="反应式编程"><a href="#反应式编程" class="headerlink" title="反应式编程"></a>反应式编程</h2><p>反应式编程 <code>(reactive programming)</code> 是一种基于 <strong>数据流</strong> <code>(data stream)</code> 和 <strong>变化传递</strong> <code>(propagation of change)</code> 的 <strong>声明式</strong> <code>(declarative)</code> 的编程范式。</p><h3 id="反应式编程的特点"><a href="#反应式编程的特点" class="headerlink" title="反应式编程的特点"></a>反应式编程的特点</h3><h4 id="1-事件驱动"><a href="#1-事件驱动" class="headerlink" title="1. 事件驱动"></a>1. 事件驱动</h4><p>在一个 <strong>事件驱动</strong> 的应用程序中，组件之间的交互是通过松耦合的 <strong>生产者</strong> <code>(production)</code>和 <strong>消费者</strong> <code>(consumption)</code> 来实现的。这些事件是以 <strong>异步</strong> 和 <strong>非阻塞</strong> 的方式发送和接收的。</p><p><strong>事件驱动</strong> 的系统依靠 <strong>推模式</strong> 而不是 <strong>拉模式</strong> 或 <strong>投票表决</strong>，即 <strong>生产者</strong> 是在有消息时才推送数据给 <strong>消费者</strong>，而不是通过一种浪费资源方式：让 <strong>消费者</strong> 不断地 <strong>轮询</strong> 或 <strong>等待数据</strong>。</p><h4 id="2-实时响应"><a href="#2-实时响应" class="headerlink" title="2. 实时响应"></a>2. 实时响应</h4><p>程序发起执行以后，应该 <strong>快速</strong> 返回存储 <strong>结果的上下文</strong>，把具体执行交给 <strong>后台线程</strong>。待处理完成以后，异步地将 <strong>真实返回值</strong> 封装在此 <strong>上下文</strong> 中，而不是 <strong>阻塞</strong> 程序的执行。实时响应是通过 <strong>异步</strong> 编程实现的，例如：发起调用后，快速返回类似 <code>java8</code> 中 <code>CompletableFuture</code> 对象。</p><h4 id="3-弹性机制"><a href="#3-弹性机制" class="headerlink" title="3. 弹性机制"></a>3. 弹性机制</h4><p>事件驱动的 <strong>松散耦合</strong> 提供了组件在失败下，可以抓获 <strong>完全隔离</strong> 的上下文场景，作为 <strong>消息封装</strong>，发送到下游组件。在具体编程时可以 <strong>检查错误</strong> ，比如：是否接收到，接收的命令是否可执行等，并决定如何应对。</p><h2 id="Reactor简介"><a href="#Reactor简介" class="headerlink" title="Reactor简介"></a>Reactor简介</h2><p><code>Reactor</code> 框架是 <code>Pivotal</code> 基于 <code>Reactive Programming</code> 思想实现的。它符合 <code>Reactive Streams</code> 规范 (<code>Reactive Streams</code> 是由 <code>Netflix</code>、<code>TypeSafe</code>、<code>Pivotal</code> 等公司发起的) 的一项技术。其名字有 <strong>反应堆</strong> 之意，反映了其背后的强大的 <strong>性能</strong>。</p><h3 id="1-Reactive-Programming"><a href="#1-Reactive-Programming" class="headerlink" title="1. Reactive Programming"></a>1. Reactive Programming</h3><p><code>Reactive Programming</code>，中文称 <strong>反应式编程</strong>。<code>Reactive Programming</code> 是一种 <strong>非阻塞</strong>、<strong>事件驱动数据流</strong> 的开发方案，使用 <strong>函数式编程</strong> 的概念来操作数据流，系统中某部分的数据变动后会自动更新其他部分，而且成本极低。</p><blockquote><p>其最早是由微软提出并引入到 .NET 平台中，随后 ES6 也引入了类似的技术。在 Java 平台上，较早采用反应式编程技术的是 Netflix 公司开源的 RxJava 框架。Hystrix 就是以 RxJava 为基础开发的。</p></blockquote><p>反应式编程其实并不神秘，通过与我们熟悉的 <strong>迭代器模式</strong> 对比，便可了解其基本思想：</p><table><thead><tr><th style="text-align:left">事件</th><th style="text-align:left">Iterable (pull)</th><th style="text-align:left">Observable (push)</th></tr></thead><tbody><tr><td style="text-align:left">获取数据</td><td style="text-align:left">T next()</td><td style="text-align:left">onNext(T)</td></tr><tr><td style="text-align:left">发现异常</td><td style="text-align:left">throws Exception</td><td style="text-align:left">onError(Exception)</td></tr><tr><td style="text-align:left">处理完成</td><td style="text-align:left">hasNext()</td><td style="text-align:left">onCompleted()</td></tr></tbody></table><p>上面表格的中的 <code>Observable</code> 那一列便代表 <strong>反应式编程</strong> 的 <code>API</code> 的使用方式。它其实是 <strong>观察者模式</strong> 的一种延伸。</p><p>如果将 <strong>迭代器模式</strong> 看作是 <strong>拉模式</strong>，那 <strong>观察者模式</strong> 便是 <strong>推模式</strong>。</p><ol><li><p><strong>被订阅者</strong> <code>(Publisher)</code> 主动推送数据给 <strong>订阅者</strong> <code>(Subscriber)</code>，触发 <code>onNext()</code> 方法。异常和完成时触发另外两个方法。</p></li><li><p><strong>被订阅者</strong> <code>(Publisher)</code> 发生异常，则触发 <strong>订阅者</strong> <code>(Subscriber)</code> 的 <code>onError()</code> 方法进行异常捕获处理。</p></li><li><p><strong>被订阅者</strong> <code>(Publisher)</code> 每次推送都会触发一次 <code>onNext()</code> 方法。所有的推送完成且无异常时，<code>onCompleted()</code> 方法将 <strong>在最后</strong> 触发一次。</p></li></ol><p> 如果 <code>Publisher</code> 发布消息太快了，超过了 <code>Subscriber</code> 的处理速度，那怎么办？这就是 <code>Backpressure</code> 的由来。<code>Reactive Programming</code> 框架需要提供 <strong>背压机制</strong>，使得 <code>Subscriber</code> 能够控制 <strong>消费消息</strong> 的速度。</p><h3 id="2-Reactive-Streams"><a href="#2-Reactive-Streams" class="headerlink" title="2. Reactive Streams"></a>2. Reactive Streams</h3><p>在 <code>Java</code> 平台上，<code>Netflix</code>（开发了 <code>RxJava</code>）、<code>TypeSafe</code>（开发了 <code>Scala</code>、<code>Akka</code>）、<code>Pivatol</code>（开发了 <code>Spring</code>、<code>Reactor</code>）共同制定了一个被称为 <code>Reactive Streams</code> 项目（规范），用于制定反应式编程相关的规范以及接口。</p><p><code>Reactive Streams</code> 由以下几个组件组成：</p><ul><li><strong>发布者</strong>：发布元素到订阅者</li><li><strong>订阅者</strong>：消费元素</li><li><strong>订阅</strong>：在发布者中，订阅被创建时，将与订阅者共享</li><li><strong>处理器</strong>：发布者与订阅者之间处理数据</li></ul><p>其主要的接口有这三个：</p><ul><li>Publisher</li><li>Subscriber</li><li>Subcription</li></ul><p>其中，<code>Subcriber</code> 中便包含了上面表格提到的 <code>onNext</code>、<code>onError</code>、<code>onCompleted</code> 这三个方法。对于 <code>Reactive Streams</code>，只需要理解其思想就可以，包括基本思想以及 <code>Backpressure</code> 等思想即可。</p><h3 id="3-Reactor的主要模块"><a href="#3-Reactor的主要模块" class="headerlink" title="3. Reactor的主要模块"></a>3. Reactor的主要模块</h3><p><code>Reactor</code> 框架主要有两个主要的模块：</p><ul><li>reactor-core</li><li>reactor-ipc</li></ul><p>前者主要负责 <code>Reactive Programming</code> 相关的 <strong>核心</strong> <code>API</code> 的实现，后者负责 <strong>高性能网络通信</strong> 的实现，目前是基于 <code>Netty</code> 实现的。</p><h3 id="4-Reactor的核心类"><a href="#4-Reactor的核心类" class="headerlink" title="4. Reactor的核心类"></a>4. Reactor的核心类</h3><p>在 <code>Reactor</code> 中，经常使用的类并不是很多，主要有以下两个：</p><ul><li><strong>Mono</strong></li></ul><p><code>Mono</code> 实现了 <code>org.reactivestreams.Publisher</code> 接口，代表 <code>0</code> 到 <code>1</code> 个元素的 <strong>发布者</strong>。</p><ul><li><strong>Flux</strong></li></ul><p><code>Flux</code> 同样实现了 <code>org.reactivestreams.Publisher</code> 接口，代表 <code>0</code> 到 <code>N</code> 个元素的发表者。</p><ul><li><strong>Scheduler</strong></li></ul><p>代表背后驱动反应式流的调度器，通常由各种线程池实现。</p><h3 id="5-WebFlux"><a href="#5-WebFlux" class="headerlink" title="5. WebFlux"></a>5. WebFlux</h3><p><code>Spring 5</code> 引入的一个基于 <code>Netty</code> 而不是 <code>Servlet</code> 的高性能的 <code>Web</code> 框架 - <code>Spring WebFlux</code> ，但是使用方式并没有同传统的基于 <code>Servlet</code> 的 <code>Spring MVC</code> 有什么大的不同。</p><p><code>WebFlux</code> 中 <code>MVC</code> 接口的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/webflux"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebFluxTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/mono"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Foobar&gt; <span class="title">foobar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> Foobar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大的变化就是返回值从 <code>Foobar</code> 所表示的一个对象变为 <code>Mono&lt;Foobar&gt;</code> 或 <code>Flux&lt;Foobar&gt;</code>。</p><h3 id="6-Reactive-Streams、Reactor和WebFlux"><a href="#6-Reactive-Streams、Reactor和WebFlux" class="headerlink" title="6. Reactive Streams、Reactor和WebFlux"></a>6. Reactive Streams、Reactor和WebFlux</h3><p>上面介绍了 <strong>反应式编程</strong> 的一些概念。可能读者看到这里有些乱，梳理一下三者的关系：</p><ol><li><code>Reactive Streams</code> 是一套反应式编程 <strong>标准</strong> 和 <strong>规范</strong>；</li><li><code>Reactor</code> 是基于 <code>Reactive Streams</code> 一套 <strong>反应式编程框架</strong>；</li><li><code>WebFlux</code> 以 <code>Reactor</code> 为基础，实现 <code>Web</code> 领域的 <strong>反应式编程框架</strong>。</li></ol><p>其实，对于业务开发人员来说，当编写反应式代码时，通常只会接触到 <code>Publisher</code> 这个接口，对应到 <code>Reactor</code> 便是 <code>Mono</code> 和 <code>Flux</code>。</p><p>对于 <code>Subscriber</code> 和 <code>Subcription</code> 这两个接口，<code>Reactor</code> 也有相应的实现。这些都是 <code>Spring WebFlux</code> 和 <code>Spring Data Reactive</code> 这样的框架用到的。如果 <strong>不开发中间件</strong>，开发人员是不会接触到的。</p><h2 id="Reactor入门"><a href="#Reactor入门" class="headerlink" title="Reactor入门"></a>Reactor入门</h2><p>接下来介绍一下 <code>Reactor</code> 中 <code>Mono</code> 和 <code>Flux</code> 这两个类中的主要方法的使用。</p><p>如同 <code>Java 8</code> 所引入的 <code>Stream</code> 一样，<code>Reactor</code> 的使用方式基本上也是分三步：</p><ul><li>开始阶段的创建</li><li>中间阶段的处理</li><li>最终阶段的消费</li></ul><p>只不过创建和消费可能是通过像 <code>Spring 5</code> 这样框架完成的（比如通过 <code>WebFlux</code> 中的 <code>WebClient</code> 调用  <code>HTTP</code> 接口，返回值便是一个 <code>Mono</code>）。但我们还是需要基本了解这些阶段的开发方式。</p><h3 id="1-创建-Mono-和-Flux（开始阶段）"><a href="#1-创建-Mono-和-Flux（开始阶段）" class="headerlink" title="1. 创建 Mono 和 Flux（开始阶段）"></a>1. 创建 Mono 和 Flux（开始阶段）</h3><p>使用 <code>Reactor</code> 编程的开始必然是先创建出 <code>Mono</code> 或 <code>Flux</code>。有些时候不需要我们自己创建，而是实现例如 <code>WebFlux</code> 中的 <code>WebClient</code> 或 <code>Spring Data Reactive</code> 得到一个 <code>Mono</code> 或 <code>Flux</code>。</p><ul><li>使用 WebFlux WebClient 调用 HTTP 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WebClient webClient = WebClient.create(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">findById</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> webClient</span><br><span class="line">            .get()</span><br><span class="line">            .uri(<span class="string">"/users/"</span> + userId)</span><br><span class="line">            .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">            .exchange()</span><br><span class="line">            .flatMap(cr -&gt; cr.bodyToMono(User.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 ReactiveMongoRepository 查询 User</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">ReactiveMongoRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Mono&lt;User&gt; <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有些时候，我们也需要主动地创建一个 <code>Mono</code> 或  <code>Flux</code>。</p><h4 id="普通的创建方式"><a href="#普通的创建方式" class="headerlink" title="普通的创建方式"></a>普通的创建方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; helloWorld = Mono.just(<span class="string">"Hello World"</span>);</span><br><span class="line">Flux&lt;String&gt; fewWords = Flux.just(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br><span class="line">Flux&lt;String&gt; manyWords = Flux.fromIterable(words);</span><br></pre></td></tr></table></figure><p>这样的创建方式在什么时候用呢？一般是用在经过一系列 <strong>非IO型</strong> 操作之后，得到了一个对象。接下来要基于这个对象运用 <code>Reactor</code> 进行 <strong>高性能</strong> 的 <code>IO</code> 操作时，可以用这种方式将之前得到的对象转换为 <code>Mono</code> 或 <code>Flux</code>。</p><h4 id="文艺的创建方式"><a href="#文艺的创建方式" class="headerlink" title="文艺的创建方式"></a>文艺的创建方式</h4><p>上面是通过一个 <strong>同步调用</strong> 得到的结果创建出 <code>Mono</code> 或 <code>Flux</code>，但有时需要从一个 <strong>非</strong> <code>Reactive</code> 的 <strong>异步调用</strong> 的结果创建出 <code>Mono</code> 或 <code>Flux</code>。</p><p>如果这个 <strong>异步方法</strong> 返回一个 <code>CompletableFuture</code>，那可以基于这个  <code>CompletableFuture</code> 创建一个 <code>Mono</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.fromFuture(completableFuture);</span><br></pre></td></tr></table></figure><p>如果这个 <strong>异步调用</strong> 不会返回   <code>CompletableFuture</code>，是有自己的 <strong>回调方法</strong>，那怎么创建 <code>Mono</code> 呢？可以使用 <code>static &lt;T&gt; Mono&lt;T&gt; create(Consumer&lt;MonoSink&lt;T&gt;&gt; callback)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Mono.create(sink -&gt; &#123;</span><br><span class="line">    ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; entity = asyncRestTemplate.getForEntity(url, String.class);</span><br><span class="line">    entity.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;ResponseEntity&lt;String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ResponseEntity&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">            sink.success(result.getBody());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">            sink.error(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在使用 <code>WebFlux</code> 之后，<code>AsyncRestTemplate</code> 已经不推荐使用，这里只是做演示。</p><h3 id="2-处理-Mono-和-Flux（中间阶段）"><a href="#2-处理-Mono-和-Flux（中间阶段）" class="headerlink" title="2. 处理 Mono 和 Flux（中间阶段）"></a>2. 处理 Mono 和 Flux（中间阶段）</h3><p>中间阶段的 <code>Mono</code> 和 <code>Flux</code> 的方法主要有 <code>filter</code>、<code>map</code>、<code>flatMap</code>、<code>then</code>、<code>zip</code>、<code>reduce</code> 等。这些方法使用方法和 <code>Stream</code> 中的方法类似。</p><p>下面举几个 <code>Reactor</code> 开发实际项目的问题，帮大家理解这些方法的使用场景：</p><h4 id="问题一-map、flatMap-和-then-在什么时候使用"><a href="#问题一-map、flatMap-和-then-在什么时候使用" class="headerlink" title="问题一: map、flatMap 和 then 在什么时候使用"></a>问题一: map、flatMap 和 then 在什么时候使用</h4><p>本段内容将涉及到如下类和方法：</p><ul><li><strong>方法</strong>：<code>Mono.map()</code></li><li><strong>方法</strong>：<code>Mono.flatMap()</code></li><li><strong>方法</strong>：<code>Mono.then()</code></li><li><strong>类</strong>：<code>Function</code></li></ul><p>在 <code>Mono</code> 和 <code>Flux</code> <strong>中间环节</strong>的处理过程中，有三个有些类似的方法：<code>map()</code>、<code>flatMap()</code> 和 <code>then()</code>。这三个方法的使用频率很高。</p><ul><li><strong>传统的命令式编程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object result1 = doStep1(params);</span><br><span class="line">Object result2 = doStep2(result1);</span><br><span class="line">Object result3 = doStep3(result2);</span><br></pre></td></tr></table></figure><ul><li><strong>对应的反应式编程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(params)</span><br><span class="line">    .flatMap(v -&gt; doStep1(v))</span><br><span class="line">    .flatMap(v -&gt; doStep2(v))</span><br><span class="line">    .flatMap(v -&gt; doStep3(v));</span><br></pre></td></tr></table></figure><p>从上面两段代码的对比就可以看出来 <code>flatMap()</code> 方法在其中起到的作用，<code>map()</code> 和 <code>then()</code> 方法也有类似的作用。但这些方法之间的区别是什么呢？我们先来看看这三个方法的签名（以 <code>Mono</code> 为例）：</p><ul><li>flatMap(Function&lt;? super T, ? extends Mono&lt;? extends R&gt;&gt; transformer)</li><li>map(Function&lt;? super T, ? extends R&gt; mapper)</li><li>then(Mono<v> other)</v></li></ul><h5 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h5><p><code>then()</code> 看上去是下一步的意思，但它只表示执行顺序的下一步，不表示下一步依赖于上一步。<code>then()</code> 方法的参数只是一个 <code>Mono</code>，无从接受上一步的执行结果。而 <code>flatMap()</code> 和 <code>map()</code> 的参数都是一个 <code>Function</code>，入参是上一步的执行结果。</p><h5 id="flatMap-和-map"><a href="#flatMap-和-map" class="headerlink" title="flatMap() 和 map()"></a>flatMap() 和 map()</h5><p><code>flatMap()</code> 和 <code>map()</code> 的区别在于，<code>flatMap()</code> 中的入参 <code>Function</code> 的返回值要求是一个 <code>Mono</code> 对象，而 <code>map</code> 的入参 <code>Function</code> 只要求返回一个 <strong>普通对象</strong>。在业务处理中常需要调用 <code>WebClient</code> 或 <code>ReactiveXxxRepository</code> 中的方法，这些方法的 <strong>返回值</strong> 都是 <code>Mono</code>（或 <code>Flux</code>）。所以要将这些调用串联为一个整体 <strong>链式调用</strong>，就必须使用 <code>flatMap()</code>，而不是 <code>map()</code>。</p><h4 id="问题二：如何实现并发执行"><a href="#问题二：如何实现并发执行" class="headerlink" title="问题二：如何实现并发执行"></a>问题二：如何实现并发执行</h4><p>本段内容将涉及到如下类和方法：</p><ul><li><strong>方法</strong>：<code>Mono.zip()</code></li><li><strong>类</strong>：<code>Tuple2</code></li><li><strong>类</strong>：<code>BiFunction</code></li></ul><p><strong>并发执行</strong> 是常见的一个需求。<code>Reactive Programming</code> 虽然是一种 <strong>异步编程</strong> 方式，但是 <strong>异步</strong> 不代表就是 <strong>并发并行</strong> 的。</p><p>在 <strong>传统的命令式编程</strong> 中，<strong>并发执行</strong> 是通过 <strong>线程池</strong> 加 <code>Future</code> 的方式实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Result1&gt; result1Future = threadPoolExecutor.submit(() -&gt; doStep1(params));</span><br><span class="line">Future&lt;Result2&gt; result2Future = threadPoolExecutor.submit(() -&gt; doStep2(params));</span><br><span class="line"><span class="comment">// Retrive result</span></span><br><span class="line">Result1 result1 = result1Future.get();</span><br><span class="line">Result2 result2 = result2Future.get();</span><br><span class="line"><span class="comment">// Do merge;</span></span><br><span class="line"><span class="keyword">return</span> mergeResult;</span><br></pre></td></tr></table></figure><p>上面的代码虽然实现了 <strong>异步调用</strong>，但 <code>Future.get()</code> 方法是 <strong>阻塞</strong> 的。在使用 <code>Reactor</code> 开发有 <strong>并发</strong> 执行场景的 <strong>反应式代码</strong> 时，不能用上面的方式。</p><p>这时应该使用 <code>Mono</code> 和 <code>Flux</code> 中的 <code>zip()</code> 方法，以 <code>Mono</code> 为例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;CustomType1&gt; item1Mono = ...;</span><br><span class="line">Mono&lt;CustomType2&gt; item2Mono = ...;</span><br><span class="line">Mono.zip(items -&gt; &#123;</span><br><span class="line">    CustomType1 item1 = CustomType1.class.cast(items[<span class="number">0</span>]);</span><br><span class="line">    CustomType2 item2 = CustomType2.class.cast(items[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// Do merge</span></span><br><span class="line">    <span class="keyword">return</span> mergeResult;</span><br><span class="line">&#125;, item1Mono, item2Mono);</span><br></pre></td></tr></table></figure><p>上述代码中，产生 <code>item1Mono</code> 和 <code>item2Mono</code> 的过程是 <strong>并行</strong> 的。比如，调用一个 <code>HTTP</code> 接口的同时，执行一个 <strong>数据库查询</strong> 操作。这样就可以加快程序的执行。</p><p>但上述代码存在一个问题，就是 <code>zip()</code> 方法需要做 <strong>强制类型转换</strong>。而强制类型转换是 <strong>不安全</strong>的。好在 <code>zip()</code> 方法存在 <strong>多种重载</strong> 形式。除了最基本的形式以外，还有多种 <strong>类型安全</strong> 的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T1, T2&gt; Mono&lt;Tuple2&lt;T1, T2&gt;&gt; zip(Mono&lt;? extends T1&gt; p1, Mono&lt;? extends T2&gt; p2);</span><br><span class="line"><span class="keyword">static</span> &lt;T1, T2, O&gt; <span class="function">Mono&lt;O&gt; <span class="title">zip</span><span class="params">(Mono&lt;? extends T1&gt; p1, Mono&lt;? extends T2&gt; p2, BiFunction&lt;? <span class="keyword">super</span> T1, ? <span class="keyword">super</span> T2, ? extends O&gt; combinator)</span></span>; </span><br><span class="line"><span class="keyword">static</span> &lt;T1, T2, T3&gt; Mono&lt;Tuple3&lt;T1, T2, T3&gt;&gt; zip(Mono&lt;? extends T1&gt; p1, Mono&lt;? extends T2&gt; p2, Mono&lt;? extends T3&gt; p3);</span><br></pre></td></tr></table></figure><p>对于不超过 <code>7</code> 个元素的合并操作，都有 <strong>类型安全</strong> 的 <code>zip()</code> 方法可选。以两个元素的合并为例，介绍一下使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mono.zip(item1Mono, item2Mono).map(tuple -&gt; &#123;</span><br><span class="line">    CustomType1 item1 = tuple.getT1();</span><br><span class="line">    CustomType2 item2 = tuple.getT2();</span><br><span class="line">    <span class="comment">// Do merge</span></span><br><span class="line">    <span class="keyword">return</span> mergeResult;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码中，<code>map()</code> 方法的参数是一个 <code>Tuple2</code>，表示一个 <strong>二元数组</strong>，相应的还有 <code>Tuple3</code>、<code>Tuple4</code> 等。</p><p>对于两个元素的并发执行，也可以通过 <code>zip(Mono&lt;? extends T1&gt; p1, Mono&lt;? extends T2&gt; p2, BiFunction&lt;? super T1, ? super T2, ? extends O&gt; combinator)</code> 方法直接将结果合并。方法是传递 <code>BiFunction</code> 实现 <strong>合并算法</strong>。</p><h4 id="问题三：集合循环之后的汇聚"><a href="#问题三：集合循环之后的汇聚" class="headerlink" title="问题三：集合循环之后的汇聚"></a>问题三：集合循环之后的汇聚</h4><p>本段内容将涉及到如下类和方法：</p><ul><li><strong>方法</strong>：<code>Flux.fromIterable()</code></li><li><strong>方法</strong>：<code>Flux.reduce()</code></li><li><strong>类</strong>：<code>BiFunction</code></li></ul><p>另外一个稍微复杂的场景，对一个对象中的一个类型为集合类的（<code>List</code> 、<code>Set</code>）进行处理之后，再对原本的对象进行处理。使用 <strong>迭代器模式</strong> 的代码很容易编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubData&gt; subDataList = data.getSubDataList();</span><br><span class="line"><span class="keyword">for</span> (SubData item : subDataList) &#123;</span><br><span class="line">    <span class="comment">// Do something on data and item</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do something on data</span></span><br></pre></td></tr></table></figure><p>当我们要用 <code>Reactive</code> 风格的代码实现上述逻辑时，就不是那么简单了。这里会用到 <code>Flux</code> 的 <code>reduce()</code> 方法。<code>reduce()</code> 方法的签名如下：</p><ul><li><code>&lt;A&gt; Mono&lt;A&gt; reduce(A initial, BiFunction&lt;A, ? super T, A&gt; accumulator);</code></li></ul><p>可以看出，<code>reduce()</code> 方法的功能是将一个 <code>Flux</code> <strong>聚合</strong> 成一个 <code>Mono</code>。</p><ul><li><p><strong>第一个参数</strong>: 返回值 <code>Mono</code> 中元素的 <strong>初始值</strong>。</p></li><li><p><strong>第二个参数</strong>: 是一个 <code>BiFunction</code>，用来实现 <strong>聚合操作</strong> 的逻辑。对于泛型参数 <code>&lt;A, ? super T, A&gt;</code> 中：</p><ul><li>第一个 <code>A</code>: 表示每次 <strong>聚合操作</strong> 之后的 <strong>结果的类型</strong>，它作为 <code>BiFunction.apply()</code> 方法的 <strong>第一个入参</strong>；</li><li>第二个 <code>? super T</code>: 表示集合中的每个元素的类型，它作为 <code>BiFunction.apply()</code> 方法的 <strong>第二个入参</strong>；</li><li>第三个 <code>A</code>: 表示聚合操作的 <strong>结果</strong>，它作为 <code>BiFunction.apply()</code> 方法的 <strong>返回值</strong>。</li></ul></li></ul><p>接下来看一下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Data initData = ...;</span><br><span class="line">List&lt;SubData&gt; list = ...;</span><br><span class="line">Flux.fromIterable(list)</span><br><span class="line">    .reduce(initData, (data, itemInList) -&gt; &#123;</span><br><span class="line">        <span class="comment">// Do something on data and itemInList</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面的示例代码中，<code>initData</code> 和 <code>data</code> 的类型相同。执行完上述代码之后，<code>reduce()</code> 方法会返回  <code>Mono&lt;Data&gt;</code>。</p><h3 id="3-消费-Mono-和-Flux（结束阶段）"><a href="#3-消费-Mono-和-Flux（结束阶段）" class="headerlink" title="3. 消费 Mono 和 Flux（结束阶段）"></a>3. 消费 Mono 和 Flux（结束阶段）</h3><p>直接消费的 <code>Mono</code> 或 <code>Flux</code> 的方式就是调用 <code>subscribe()</code> 方法。如果在 <code>WebFlux</code> 接口中开发，直接返回 <code>Mono</code> 或 Flux 即可。<code>WebFlux</code> 框架会完成最后的 <code>Response</code> 输出工作。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了反应式编程的一些概念和 <code>Spring Reactor</code> 框架的基本用法，还介绍了如何用 <code>Reactor</code> 解决一些稍微复杂一点的问题。<code>Reactor</code> 在 <code>Spring 5</code> 中有大量的应用，后面会给大家分享一些 <code>Spring Reactor</code> 实战系列的博客。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为了应对 &lt;strong&gt;高并发环境下&lt;/strong&gt; 的服务端编程，微软提出了一个实现 &lt;strong&gt;异步编程&lt;/strong&gt; 的方案 -  &lt;code&gt;Reactive Programming&lt;/code&gt;，中文名称 &lt;strong&gt;反应式编程&lt;/strong&gt;。随后，其它技术也迅速地跟上了脚步，像 &lt;code&gt;ES6&lt;/code&gt; 通过 &lt;code&gt;Promise&lt;/code&gt; 引入了类似的异步编程方式。&lt;code&gt;Java&lt;/code&gt; 社区也没有落后很多，&lt;code&gt;Netflix&lt;/code&gt; 和 &lt;code&gt;TypeSafe&lt;/code&gt; 公司提供了 &lt;code&gt;RxJava&lt;/code&gt; 和 &lt;code&gt;Akka Stream&lt;/code&gt; 技术，让 &lt;code&gt;Java&lt;/code&gt; 平台也有了能够实现反应式编程的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Reactive编程系列" scheme="https://ostenant.coding.me/categories/Spring-Reactive%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Reactive Streams" scheme="https://ostenant.coding.me/tags/Reactive-Streams/"/>
    
      <category term="Spring WebFlux" scheme="https://ostenant.coding.me/tags/Spring-WebFlux/"/>
    
      <category term="Reactor" scheme="https://ostenant.coding.me/tags/Reactor/"/>
    
  </entry>
  
</feed>
