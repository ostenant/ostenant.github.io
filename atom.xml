<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding | Harrison&#39;s Blog</title>
  
  <subtitle>上善若水任方猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ostenant.coding.me/"/>
  <updated>2018-05-28T08:20:00.333Z</updated>
  <id>https://ostenant.coding.me/</id>
  
  <author>
    <name>Chen Harrison</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实战Spring Boot 2.0 Reactive编程系列(一) - WebFlux初体验</title>
    <link href="https://ostenant.coding.me/2018/05/27/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%20Reactive%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97(%E4%B8%80)%20-%20WebFlux%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://ostenant.coding.me/2018/05/27/实战Spring Boot 2.0 Reactive编程系列(一) - WebFlux初体验/</id>
    <published>2018-05-27T07:25:00.000Z</published>
    <updated>2018-05-28T08:20:00.333Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文引入了 <strong>反应式编程模型</strong> 相关概念，对 <code>Spring Reactor</code> 的核心 <code>API</code> 进行了简单归纳。本文会对 <code>Spring 5 WebFlux</code> 进行相关介绍，包括引入 <code>Servlet 3.1 +</code>，各个功能组件 <code>Router Functions</code>、<code>WebFlux</code> 和 <code>Reactive Streams</code> 等，以及如何在 <code>Spring Boot 2.0</code> 中分别以 <strong>全局功能路由</strong> 和 <code>MVC</code> <strong>控制器</strong> 的方式配置 <code>HTTP</code> 请求处理。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/Sprng_Boot_2.0_Log.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Spring-5-WebFlux介绍"><a href="#Spring-5-WebFlux介绍" class="headerlink" title="Spring 5 WebFlux介绍"></a>Spring 5 WebFlux介绍</h2><p>关于 <code>Spring 5</code> 的 <code>WebFlux</code> 响应式编程，下图是传统 <code>Spring Web MVC</code> 结构以及<code>Spring 5</code> 中新增加的基于 <code>Reactive Streams</code> 的 <code>Spring WebFlux</code> 框架。可以使用 <code>webFlux</code> 模块来构建 <strong>异步的</strong>、<strong>非堵塞的</strong>、<strong>事件驱动</strong> 的服务，其在 <strong>伸缩性方面</strong> 表现非常好。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/WebFlux_01_00.png" alt=""></p><p>如图所示，<code>WebFlux</code> 模块从上到下依次是 <code>Router Functions</code>、<code>WebFlux</code>、<code>Reactive Streams</code> 三个新组件。</p><h3 id="Servlet-3-1-API介绍"><a href="#Servlet-3-1-API介绍" class="headerlink" title="Servlet 3.1+ API介绍"></a>Servlet 3.1+ API介绍</h3><p><code>WebFlux</code> 模块需要运行在实现了 <code>Servlet 3.1+</code> <strong>规范</strong> 的容器之上。<code>Servlet 3.1</code> 规范中新增了对 <strong>异步处理</strong> 的支持，在新的 <code>Servlet</code> 规范中，<code>Servlet</code> 线程不需要一直 <strong>阻塞等待</strong> 到业务处理完成。</p><p>在 <code>Servlet 3.1</code> 中，其请求处理的线程模型大致如下：</p><ol><li><p><code>Servlet</code> 线程接收到新的请求后，不需要等待业务处理完成再进行结果输出，而是将这个请求委托给另外一个线程（业务线程）来完成。</p></li><li><p><code>Servlet</code> 线程将委托完成之后变返回到容器中去接收新的请求。</p></li></ol><p><code>Servlet 3.1</code> 规范特别适用于那种 <strong>业务处理非常耗时</strong> 的场景之下，可以减少 <strong>服务器资源</strong> 的占用，并且提高 <strong>并发处理速度</strong> ，而对于那些能 <strong>快速响应</strong> 的场景收益并不大。</p><p>所以 <code>WebFlux</code> 支持的容器有 <code>Tomcat</code>、<code>Jetty</code> 等 <strong>同步容器</strong> ，也可以是 <code>Netty</code> 和 <code>Undertow</code> 这类 <strong>异步容器</strong>。在容器中 <code>Spring WebFlux</code> 会将 <strong>输入流</strong> 适配成 <code>Mono</code> 或 <code>Flux</code> 格式进行统一处理。</p><h3 id="Spring-WebFlux的功能模块"><a href="#Spring-WebFlux的功能模块" class="headerlink" title="Spring WebFlux的功能模块"></a>Spring WebFlux的功能模块</h3><p>下面介绍上图中 <code>WebFlux</code> 各个模块：</p><h4 id="1-Router-Functions"><a href="#1-Router-Functions" class="headerlink" title="1. Router Functions"></a>1. Router Functions</h4><p>对标准的 <code>@Controller</code>，<code>@RequestMapping</code>等的 <code>Spring MVC</code> 注解，提供一套 <strong>函数式风格</strong> 的 <code>API</code>，用于创建 <code>Router</code>、<code>Handler</code> 和<code>Filter</code>。</p><h4 id="2-WebFlux"><a href="#2-WebFlux" class="headerlink" title="2. WebFlux"></a>2. WebFlux</h4><p>核心组件，协调上下游各个组件提供 <strong>响应式编程</strong> 支持。</p><h4 id="3-Reactive-Streams"><a href="#3-Reactive-Streams" class="headerlink" title="3. Reactive Streams"></a>3. Reactive Streams</h4><p>一种支持 <strong>背压</strong> <code>(Backpressure)</code> 的 <strong>异步数据流处理标准</strong>，主流实现有 <code>RxJava</code> 和 <code>Reactor</code>，<code>Spring WebFlux</code> 集成的是<code>Reactor</code>。</p><h4 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h4><p><code>Flux</code> 和 <code>Mono</code> 属于 <strong>事件发布者</strong>，类似于 <strong>生产者</strong>，对消费者 <strong>提供订阅接口</strong>。当有事件发生的时候，<code>Flux</code> 或 <code>Mono</code> 会回调 <strong>消费者</strong>相应的方法来通知 <strong>消费者</strong> 相应的事件。</p><p>下面这张图是 <code>Flux</code> 的工作流程图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Flux_Workflow.png" alt=""></p><p>关于 <code>Flux</code> 的工作模式，可以看出 <code>Flux</code> 可以 触发 <code>(emit)</code> 很多 <code>item</code>，而这些 <code>item</code> 可以经过若干 <code>Operators</code> 然后才被 <code>subscribe</code>，下面是使用 <code>Flux</code> 的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flux.fromIterable(getSomeLongList())</span><br><span class="line">    .mergeWith(Flux.interval(<span class="number">100</span>))</span><br><span class="line">    .doOnNext(serviceA::someObserver)</span><br><span class="line">    .map(d -&gt; d * <span class="number">2</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .onErrorResumeWith(errorHandler::fallback)</span><br><span class="line">    .doAfterTerminate(serviceM::incrementTerminate)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h4><p>下面的图片是 <code>Mono</code> 的处理流程，可以很直观的看出来 <code>Mono</code> 和 <code>Flux</code> 的区别：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Mono_Workflow.png" alt=""></p><p><code>Mono</code> 只能触发 <code>(emit)</code> 一个 <code>item</code>，下面是使用 <code>Mono</code> 的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mono.fromCallable(System::currentTimeMillis)</span><br><span class="line">    .flatMap(time -&gt; Mono.first(serviceA.findRecent(time), serviceB.findRecent(time)))</span><br><span class="line">    .timeout(Duration.ofSeconds(<span class="number">3</span>), errorHandler::fallback)</span><br><span class="line">    .doOnSuccess(r -&gt; serviceM.incrementSuccess())</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-2-0-Reactive-Stack"><a href="#Spring-Boot-2-0-Reactive-Stack" class="headerlink" title="Spring Boot 2.0 Reactive Stack"></a>Spring Boot 2.0 Reactive Stack</h2><p><code>Spring Boot Webflux</code> 就是基于 <code>Reactor</code> 实现的。<code>Spring Boot 2.0</code> 包括一个新的 <code>spring-webflux</code> 模块。该模块包含对 <strong>响应式</strong> <code>HTTP</code> 和 <code>WebSocket</code> 客户端的支持，以及对 <code>REST</code> 、<code>HTML</code> 和 <code>WebSocket</code> <strong>交互等程序</strong> 的支持。一般来说，<code>Spring MVC</code> 用于 <strong>同步处理</strong>，<code>Spring Webflux</code> 用于 <strong>异步处理</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBoot2.0_Reactor.png" alt=""></p><p>如上图所示，从 <code>Web</code> 表现层到数据访问，再到容器，<code>Spring Boot 2.0</code> 同时提供了 <strong>同步阻塞式</strong> 和 <strong>异步非阻塞式</strong> 两套完整的 <code>API Stack</code>。</p><p>从上而下对比以下两者的区别:</p><table><thead><tr><th style="text-align:left">API Stack</th><th style="text-align:left">Sevlet Stack</th><th style="text-align:left">Reactive Stack</th></tr></thead><tbody><tr><td style="text-align:left">Web控制层</td><td style="text-align:left">Spring MVC</td><td style="text-align:left">Spring WebFlux</td></tr><tr><td style="text-align:left">安全认证层</td><td style="text-align:left">Spring Security</td><td style="text-align:left">Spring Security</td></tr><tr><td style="text-align:left">数据访问层</td><td style="text-align:left">Spring Data Repositories</td><td style="text-align:left">Spring Data Reactive Repositories</td></tr><tr><td style="text-align:left">容器API</td><td style="text-align:left">Servlet API</td><td style="text-align:left">Reactive Streams Adapters</td></tr><tr><td style="text-align:left">内嵌容器</td><td style="text-align:left">Servlet Containers</td><td style="text-align:left">Netty, Servlet 3.1+ Containers</td></tr></tbody></table><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>控制层一旦使用 <code>Spring WebFlux</code>，它下面的安全认证层、数据访问层都必须使用 <code>Reactive API</code>。其次，<code>Spring Data Reactive Repositories</code> 目前只支持 <code>MongoDB</code>、<code>Redis</code> 和 <code>Couchbase</code> 等几种不支持事务管理的 <code>NOSQL</code>。技术选型时一定要权衡这些弊端和风险，比如：</p><ol><li><p><code>Spring MVC</code> 能满足场景的，就不需要更改为  <code>Spring WebFlux</code>。</p></li><li><p>要注意容器的支持，可以看看底层 <strong>内嵌容器</strong> 的支持。</p></li><li><p><strong>微服务</strong> 体系结构，<code>Spring WebFlux</code> 和 <code>Spring MVC</code> 可以混合使用。尤其开发 <code>IO</code> <strong>密集型</strong> 服务的时候，可以选择 <code>Spring WebFlux</code> 去实现。</p></li></ol><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p><code>Spring 5 Web</code> 模块包含了 <code>Spring WebFlux</code> 的 <code>HTTP</code> 抽象。类似 <code>Servlet API</code>， <code>WebFlux</code> 提供了 <code>WebHandler API</code> 去定义 <strong>非阻塞</strong> <code>API</code> 抽象接口。可以选择以下两种编程模型实现：</p><ol><li><p><strong>注解控制层:</strong> 和 <code>MVC</code> 保持一致，<code>WebFlux</code> 也支持 <strong>响应性</strong> <code>@RequestBody</code> 注解。</p></li><li><p><strong>功能性端点:</strong> 基于 <code>lambda</code> 轻量级编程模型，用来 <strong>建立路由</strong> 和 <strong>处理请求</strong> 的工具。和上面最大的区别就是，这种模型，<strong>全程</strong> 控制了 <strong>请求 - 响应</strong> 的生命流程</p></li></ol><h3 id="内嵌容器"><a href="#内嵌容器" class="headerlink" title="内嵌容器"></a>内嵌容器</h3><p>跟 <code>Spring Boot</code> 大框架一样启动应用，但 <code>Spring WebFlux</code> 默认是通过 <code>Netty</code> 启动，并且自动设置了 <strong>默认端口</strong> 为 <code>8080</code>。另外还提供了对 <code>Jetty</code>、<code>Undertow</code> 等容器的支持。开发者自行在添加对应的容器 <code>Starter</code> 组件依赖，即可配置并使用对应 <strong>内嵌容器实例</strong>。</p><blockquote><p>注意: 必须是 Servlet 3.1+ 容器，如 Tomcat、Jetty；或者非 Servlet 容器，如 Netty 和 Undertow。</p></blockquote><h3 id="Starter-组件"><a href="#Starter-组件" class="headerlink" title="Starter 组件"></a>Starter 组件</h3><p>跟 <code>Spring Boot</code> 大框架一样，<code>Spring Boot Webflux</code> 提供了很多 <strong>开箱即用</strong> 的 <code>Starter</code> 组件。添加 <code>spring-boot-starter-webflux</code> 依赖，就可用于构建 <strong>响应式</strong> <code>API</code> 服务，其包含了 <code>WebFlux</code> 和 <code>Tomcat</code> <strong>内嵌容器</strong> 等。</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="Spring-Initializr构建项目骨架"><a href="#Spring-Initializr构建项目骨架" class="headerlink" title="Spring Initializr构建项目骨架"></a>Spring Initializr构建项目骨架</h4><p>利用 <code>Spring Initializer</code> 快速生成 <code>Spring Boot</code> 应用，配置项目信息并设置依赖。</p><h4 id="配置Maven依赖"><a href="#配置Maven依赖" class="headerlink" title="配置Maven依赖"></a>配置Maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Boot启动类"><a href="#Spring-Boot启动类" class="headerlink" title="Spring Boot启动类"></a>Spring Boot启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置实体类"><a href="#配置实体类" class="headerlink" title="配置实体类"></a>配置实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    String body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-MVC控制器方式"><a href="#1-MVC控制器方式" class="headerlink" title="1. MVC控制器方式"></a>1. MVC控制器方式</h3><h4 id="1-1-编写控制器"><a href="#1-1-编写控制器" class="headerlink" title="1.1. 编写控制器"></a>1.1. 编写控制器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;Message&gt; <span class="title">allMessages</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Flux.just(</span><br><span class="line">            Message.builder().body(<span class="string">"hello Spring 5"</span>).build(),</span><br><span class="line">            Message.builder().body(<span class="string">"hello Spring Boot 2"</span>).build()</span><br><span class="line">        );</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-编写测试类"><a href="#1-2-编写测试类" class="headerlink" title="1.2. 编写测试类"></a>1.2. 编写测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebFluxTest</span>(controllers = MessageController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WebTestClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllMessagesShouldBeOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.get().uri(<span class="string">"/"</span>).exchange().expectStatus().isOk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-查看启动日志"><a href="#1-3-查看启动日志" class="headerlink" title="1.3. 查看启动日志"></a>1.3. 查看启动日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-05-27 17:37:23.550  INFO 67749 --- [           main] s.w.r.r.m.a.RequestMappingHandlerMapping : Mapped <span class="string">"&#123;[],methods=[GET]&#125;"</span> onto reactor.core.publisher.Flux&lt;com.example.demo.Message&gt; com.example.demo.MessageController.allMessages()</span><br><span class="line">2018-05-27 17:37:23.998  INFO 67749 --- [ctor-http-nio-1] r.ipc.netty.tcp.BlockingNettyContext     : Started HttpServer on /0:0:0:0:0:0:0:0:8080</span><br><span class="line">2018-05-27 17:37:23.999  INFO 67749 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080</span><br><span class="line">2018-05-27 17:37:24.003  INFO 67749 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication <span class="keyword">in</span> 1.6 seconds (JVM running <span class="keyword">for</span> 2.274)</span><br></pre></td></tr></table></figure><p>从日志里可以看出：</p><ol><li>启动时 <code>WebFlux</code> 利用 <code>MVC</code> 原生的 <code>RequestMappingHandlerMapping</code> 将控制器里的 <strong>请求路径</strong> 和 <code>MVC</code> 中的 <strong>处理器</strong> 进行绑定。</li><li><code>Spring WebFlux</code> 默认采用 <code>Netty</code> 作为 <strong>内嵌容器</strong>，且启动端口默认为 <code>8080</code>。</li></ol><p>访问 <a href="localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>，返回结果如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Controller_Result_001.png" alt=""></p><h3 id="2-全局Router-API方式"><a href="#2-全局Router-API方式" class="headerlink" title="2. 全局Router API方式"></a>2. 全局Router API方式</h3><h4 id="2-1-配置全局Router-Bean"><a href="#2-1-配置全局Router-Bean" class="headerlink" title="2.1. 配置全局Router Bean"></a>2.1. 配置全局Router Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRouterConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">routes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">"/"</span>), (ServerRequest req)-&gt; ok()</span><br><span class="line">                .body(</span><br><span class="line">                    BodyInserters.fromObject(</span><br><span class="line">                        Arrays.asList(</span><br><span class="line">                            Message.builder().body(<span class="string">"hello Spring 5"</span>).build(),</span><br><span class="line">                            Message.builder().body(<span class="string">"hello Spring Boot 2"</span>).build()</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-编写测试类"><a href="#2-2-编写测试类" class="headerlink" title="2.2. 编写测试类"></a>2.2. 编写测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebFluxTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WebTestClient client;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllMessagesShouldBeOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.get().uri(<span class="string">"/"</span>).exchange().expectStatus().isOk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-查看启动日志"><a href="#2-3-查看启动日志" class="headerlink" title="2.3. 查看启动日志"></a>2.3. 查看启动日志</h4><p>运行 <code>Spring Boot</code> 启动入口类，启动日志如下(不重要的省略)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-05-27 17:20:28.870  INFO 67696 --- [           main] o.s.w.r.f.s.s.RouterFunctionMapping      : Mapped (GET &amp;&amp; /) -&gt; com.example.demo.DemoRouterConfig$<span class="variable">$Lambda</span><span class="variable">$213</span>/1561745898@3381b4fc</span><br><span class="line">2018-05-27 17:20:28.931  INFO 67696 --- [           main] o.s.w.r.r.m.a.ControllerMethodResolver   : Looking <span class="keyword">for</span> @ControllerAdvice: org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@1460a8c0: startup date [Sun May 27 17:20:27 CST 2018]; root of context hierarchy</span><br><span class="line">2018-05-27 17:20:29.311  INFO 67696 --- [ctor-http-nio-1] r.ipc.netty.tcp.BlockingNettyContext     : Started HttpServer on /0:0:0:0:0:0:0:0:8080</span><br><span class="line">2018-05-27 17:20:29.312  INFO 67696 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080</span><br><span class="line">2018-05-27 17:20:29.316  INFO 67696 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication <span class="keyword">in</span> 2.137 seconds (JVM running <span class="keyword">for</span> 3.169)</span><br></pre></td></tr></table></figure><p>从日志里可以看出：启动时 <code>WebFlux</code> 利用 <code>RouterFunctionMapping</code> 将 <code>RouterFunction</code> 里的 <strong>全局路径</strong> 和 <strong>请求处理</strong> 进行了映射和绑定。</p><p>访问 <a href="localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>，返回结果如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Router_Result_000.png" alt=""></p><p>可以看出，无论是使用 <code>Fucntional Router</code> 还是 <code>MVC Controller</code>，都可以产生相同的效果！</p><h2 id="开发运行环境"><a href="#开发运行环境" class="headerlink" title="开发运行环境"></a>开发运行环境</h2><ul><li><p><strong>JDK 1.8 +</strong> : <code>Spring Boot 2.x</code> 要求 <code>JDK 1.8</code> 环境及以上版本。另外，<code>Spring Boot 2.x</code> 只兼容 <code>Spring Framework 5.0</code> 及以上版本。</p></li><li><p><strong>Maven 3.2 +</strong> : 为 <code>Spring Boot 2.x</code> 提供了相关依赖构建工具是 <code>Maven</code>，版本需要 <code>3.2</code> 及以上版本。使用 <code>Gradle</code> 则需要 <code>1.12</code> 及以上版本。<code>Maven</code> 和 <code>Gradle</code> 大家各自挑选下喜欢的就好。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文首先对 <code>Spring 5 WebFlux</code> 进行了单独介绍，包括引入 <code>Servlet 3.1 +</code>，各个功能组件 <code>Router Functions</code>、<code>WebFlux</code> 和 <code>Reactive Streams</code> 等。然后在 <code>Spring Boot 2.0</code> 详细地介绍了 <code>Reactive Stack</code> 和 <code>Servlet Stack</code> 的组成区别，并分别给出了 <code>WebFlux</code> 基于 <strong>全局功能路由</strong> 和 <strong>控制器</strong> 的配置和使用案例。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上文引入了 &lt;strong&gt;反应式编程模型&lt;/strong&gt; 相关概念，对 &lt;code&gt;Spring Reactor&lt;/code&gt; 的核心 &lt;code&gt;API&lt;/code&gt; 进行了简单归纳。本文会对 &lt;code&gt;Spring 5 WebFlux&lt;/code&gt; 进行相关介绍，包括引入 &lt;code&gt;Servlet 3.1 +&lt;/code&gt;，各个功能组件 &lt;code&gt;Router Functions&lt;/code&gt;、&lt;code&gt;WebFlux&lt;/code&gt; 和 &lt;code&gt;Reactive Streams&lt;/code&gt; 等，以及如何在 &lt;code&gt;Spring Boot 2.0&lt;/code&gt; 中分别以 &lt;strong&gt;全局功能路由&lt;/strong&gt; 和 &lt;code&gt;MVC&lt;/code&gt; &lt;strong&gt;控制器&lt;/strong&gt; 的方式配置 &lt;code&gt;HTTP&lt;/code&gt; 请求处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
      <category term="Spring Reactive编程系列" scheme="https://ostenant.coding.me/categories/Spring-Boot-2-0%E7%B3%BB%E5%88%97/Spring-Reactive%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Reactive Streams" scheme="https://ostenant.coding.me/tags/Reactive-Streams/"/>
    
      <category term="Spring WebFlux" scheme="https://ostenant.coding.me/tags/Spring-WebFlux/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Spring Reactor反应式编程</title>
    <link href="https://ostenant.coding.me/2018/05/26/%E8%81%8A%E8%81%8ASpring%20Reactor%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://ostenant.coding.me/2018/05/26/聊聊Spring Reactor反应式编程/</id>
    <published>2018-05-26T08:41:00.000Z</published>
    <updated>2018-05-27T10:03:31.352Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了应对 <strong>高并发环境下</strong> 的服务端编程，微软提出了一个实现 <strong>异步编程</strong> 的方案 -  <code>Reactive Programming</code>，中文名称 <strong>反应式编程</strong>。随后，其它技术也迅速地跟上了脚步，像 <code>ES6</code> 通过 <code>Promise</code> 引入了类似的异步编程方式。<code>Java</code> 社区也没有落后很多，<code>Netflix</code> 和 <code>TypeSafe</code> 公司提供了 <code>RxJava</code> 和 <code>Akka Stream</code> 技术，让 <code>Java</code> 平台也有了能够实现反应式编程的框架。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/Reactor.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程是种编程方式，它将计算机的运算视为函数的计算。函数编程语言最重要的基础是 <strong>λ演算</strong> <code>(lambda calculus)</code>，而λ演算的函数可以接受函数当作 <strong>输入(参数)</strong> 和 <strong>输出(返回值)</strong>。<code>lambda</code> 表达式对与大多数程序员已经很熟悉了，<code>jdk8</code> 以及 <code>es6</code>都是引入的 <code>lambda</code>。</p><h3 id="函数式编程的特点"><a href="#函数式编程的特点" class="headerlink" title="函数式编程的特点"></a>函数式编程的特点</h3><ul><li>惰性计算 </li><li>函数是“第一等公民” </li><li>只使用表达式而不使用语句 </li><li>没有副作用</li></ul><h2 id="反应式编程"><a href="#反应式编程" class="headerlink" title="反应式编程"></a>反应式编程</h2><p>反应式编程 <code>(reactive programming)</code> 是一种基于 <strong>数据流</strong> <code>(data stream)</code> 和 <strong>变化传递</strong> <code>(propagation of change)</code> 的 <strong>声明式</strong> <code>(declarative)</code> 的编程范式。</p><h3 id="反应式编程的特点"><a href="#反应式编程的特点" class="headerlink" title="反应式编程的特点"></a>反应式编程的特点</h3><h4 id="1-事件驱动"><a href="#1-事件驱动" class="headerlink" title="1. 事件驱动"></a>1. 事件驱动</h4><p>在一个 <strong>事件驱动</strong> 的应用程序中，组件之间的交互是通过松耦合的 <strong>生产者</strong> <code>(production)</code>和 <strong>消费者</strong> <code>(consumption)</code> 来实现的。这些事件是以 <strong>异步</strong> 和 <strong>非阻塞</strong> 的方式发送和接收的。</p><p><strong>事件驱动</strong> 的系统依靠 <strong>推模式</strong> 而不是 <strong>拉模式</strong> 或 <strong>投票表决</strong>，即 <strong>生产者</strong> 是在有消息时才推送数据给 <strong>消费者</strong>，而不是通过一种浪费资源方式：让 <strong>消费者</strong> 不断地 <strong>轮询</strong> 或 <strong>等待数据</strong>。</p><h4 id="2-实时响应"><a href="#2-实时响应" class="headerlink" title="2. 实时响应"></a>2. 实时响应</h4><p>程序发起执行以后，应该 <strong>快速</strong> 返回存储 <strong>结果的上下文</strong>，把具体执行交给 <strong>后台线程</strong>。待处理完成以后，异步地将 <strong>真实返回值</strong> 封装在此 <strong>上下文</strong> 中，而不是 <strong>阻塞</strong> 程序的执行。实时响应是通过 <strong>异步</strong> 编程实现的，例如：发起调用后，快速返回类似 <code>java8</code> 中 <code>CompletableFuture</code> 对象。</p><h4 id="3-弹性机制"><a href="#3-弹性机制" class="headerlink" title="3. 弹性机制"></a>3. 弹性机制</h4><p>事件驱动的 <strong>松散耦合</strong> 提供了组件在失败下，可以抓获 <strong>完全隔离</strong> 的上下文场景，作为 <strong>消息封装</strong>，发送到下游组件。在具体编程时可以 <strong>检查错误</strong> ，比如：是否接收到，接收的命令是否可执行等，并决定如何应对。</p><h2 id="Reactor简介"><a href="#Reactor简介" class="headerlink" title="Reactor简介"></a>Reactor简介</h2><p><code>Reactor</code> 框架是 <code>Pivotal</code> 基于 <code>Reactive Programming</code> 思想实现的。它符合 <code>Reactive Streams</code> 规范 (<code>Reactive Streams</code> 是由 <code>Netflix</code>、<code>TypeSafe</code>、<code>Pivotal</code> 等公司发起的) 的一项技术。其名字有 <strong>反应堆</strong> 之意，反映了其背后的强大的 <strong>性能</strong>。</p><h3 id="1-Reactive-Programming"><a href="#1-Reactive-Programming" class="headerlink" title="1. Reactive Programming"></a>1. Reactive Programming</h3><p><code>Reactive Programming</code>，中文称 <strong>反应式编程</strong>。<code>Reactive Programming</code> 是一种 <strong>非阻塞</strong>、<strong>事件驱动数据流</strong> 的开发方案，使用 <strong>函数式编程</strong> 的概念来操作数据流，系统中某部分的数据变动后会自动更新其他部分，而且成本极低。</p><blockquote><p>其最早是由微软提出并引入到 .NET 平台中，随后 ES6 也引入了类似的技术。在 Java 平台上，较早采用反应式编程技术的是 Netflix 公司开源的 RxJava 框架。Hystrix 就是以 RxJava 为基础开发的。</p></blockquote><p>反应式编程其实并不神秘，通过与我们熟悉的 <strong>迭代器模式</strong> 对比，便可了解其基本思想：</p><table><thead><tr><th style="text-align:left">事件</th><th style="text-align:left">Iterable (pull)</th><th style="text-align:left">Observable (push)</th></tr></thead><tbody><tr><td style="text-align:left">获取数据</td><td style="text-align:left">T next()</td><td style="text-align:left">onNext(T)</td></tr><tr><td style="text-align:left">发现异常</td><td style="text-align:left">throws Exception</td><td style="text-align:left">onError(Exception)</td></tr><tr><td style="text-align:left">处理完成</td><td style="text-align:left">hasNext()</td><td style="text-align:left">onCompleted()</td></tr></tbody></table><p>上面表格的中的 <code>Observable</code> 那一列便代表 <strong>反应式编程</strong> 的 <code>API</code> 的使用方式。它其实是 <strong>观察者模式</strong> 的一种延伸。</p><p>如果将 <strong>迭代器模式</strong> 看作是 <strong>拉模式</strong>，那 <strong>观察者模式</strong> 便是 <strong>推模式</strong>。</p><ol><li><p><strong>被订阅者</strong> <code>(Publisher)</code> 主动推送数据给 <strong>订阅者</strong> <code>(Subscriber)</code>，触发 <code>onNext()</code> 方法。异常和完成时触发另外两个方法。</p></li><li><p><strong>被订阅者</strong> <code>(Publisher)</code> 发生异常，则触发 <strong>订阅者</strong> <code>(Subscriber)</code> 的 <code>onError()</code> 方法进行异常捕获处理。</p></li><li><p><strong>被订阅者</strong> <code>(Publisher)</code> 每次推送都会触发一次 <code>onNext()</code> 方法。所有的推送完成且无异常时，<code>onCompleted()</code> 方法将 <strong>在最后</strong> 触发一次。</p></li></ol><p> 如果 <code>Publisher</code> 发布消息太快了，超过了 <code>Subscriber</code> 的处理速度，那怎么办？这就是 <code>Backpressure</code> 的由来。<code>Reactive Programming</code> 框架需要提供 <strong>背压机制</strong>，使得 <code>Subscriber</code> 能够控制 <strong>消费消息</strong> 的速度。</p><h3 id="2-Reactive-Streams"><a href="#2-Reactive-Streams" class="headerlink" title="2. Reactive Streams"></a>2. Reactive Streams</h3><p>在 <code>Java</code> 平台上，<code>Netflix</code>（开发了 <code>RxJava</code>）、<code>TypeSafe</code>（开发了 <code>Scala</code>、<code>Akka</code>）、<code>Pivatol</code>（开发了 <code>Spring</code>、<code>Reactor</code>）共同制定了一个被称为 <code>Reactive Streams</code> 项目（规范），用于制定反应式编程相关的规范以及接口。</p><p><code>Reactive Streams</code> 由以下几个组件组成：</p><ul><li><strong>发布者</strong>：发布元素到订阅者</li><li><strong>订阅者</strong>：消费元素</li><li><strong>订阅</strong>：在发布者中，订阅被创建时，将与订阅者共享</li><li><strong>处理器</strong>：发布者与订阅者之间处理数据</li></ul><p>其主要的接口有这三个：</p><ul><li>Publisher</li><li>Subscriber</li><li>Subcription</li></ul><p>其中，<code>Subcriber</code> 中便包含了上面表格提到的 <code>onNext</code>、<code>onError</code>、<code>onCompleted</code> 这三个方法。对于 <code>Reactive Streams</code>，只需要理解其思想就可以，包括基本思想以及 <code>Backpressure</code> 等思想即可。</p><h3 id="3-Reactor的主要模块"><a href="#3-Reactor的主要模块" class="headerlink" title="3. Reactor的主要模块"></a>3. Reactor的主要模块</h3><p><code>Reactor</code> 框架主要有两个主要的模块：</p><ul><li>reactor-core</li><li>reactor-ipc</li></ul><p>前者主要负责 <code>Reactive Programming</code> 相关的 <strong>核心</strong> <code>API</code> 的实现，后者负责 <strong>高性能网络通信</strong> 的实现，目前是基于 <code>Netty</code> 实现的。</p><h3 id="4-Reactor的核心类"><a href="#4-Reactor的核心类" class="headerlink" title="4. Reactor的核心类"></a>4. Reactor的核心类</h3><p>在 <code>Reactor</code> 中，经常使用的类并不是很多，主要有以下两个：</p><ul><li><strong>Mono</strong></li></ul><p><code>Mono</code> 实现了 <code>org.reactivestreams.Publisher</code> 接口，代表 <code>0</code> 到 <code>1</code> 个元素的 <strong>发布者</strong>。</p><ul><li><strong>Flux</strong></li></ul><p><code>Flux</code> 同样实现了 <code>org.reactivestreams.Publisher</code> 接口，代表 <code>0</code> 到 <code>N</code> 个元素的发表者。</p><ul><li><strong>Scheduler</strong></li></ul><p>代表背后驱动反应式流的调度器，通常由各种线程池实现。</p><h3 id="5-WebFlux"><a href="#5-WebFlux" class="headerlink" title="5. WebFlux"></a>5. WebFlux</h3><p><code>Spring 5</code> 引入的一个基于 <code>Netty</code> 而不是 <code>Servlet</code> 的高性能的 <code>Web</code> 框架 - <code>Spring WebFlux</code> ，但是使用方式并没有同传统的基于 <code>Servlet</code> 的 <code>Spring MVC</code> 有什么大的不同。</p><p><code>WebFlux</code> 中 <code>MVC</code> 接口的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/webflux"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebFluxTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/mono"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Foobar&gt; <span class="title">foobar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> Foobar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大的变化就是返回值从 <code>Foobar</code> 所表示的一个对象变为 <code>Mono&lt;Foobar&gt;</code> 或 <code>Flux&lt;Foobar&gt;</code>。</p><h3 id="6-Reactive-Streams、Reactor和WebFlux"><a href="#6-Reactive-Streams、Reactor和WebFlux" class="headerlink" title="6. Reactive Streams、Reactor和WebFlux"></a>6. Reactive Streams、Reactor和WebFlux</h3><p>上面介绍了 <strong>反应式编程</strong> 的一些概念。可能读者看到这里有些乱，梳理一下三者的关系：</p><ol><li><code>Reactive Streams</code> 是一套反应式编程 <strong>标准</strong> 和 <strong>规范</strong>；</li><li><code>Reactor</code> 是基于 <code>Reactive Streams</code> 一套 <strong>反应式编程框架</strong>；</li><li><code>WebFlux</code> 以 <code>Reactor</code> 为基础，实现 <code>Web</code> 领域的 <strong>反应式编程框架</strong>。</li></ol><p>其实，对于业务开发人员来说，当编写反应式代码时，通常只会接触到 <code>Publisher</code> 这个接口，对应到 <code>Reactor</code> 便是 <code>Mono</code> 和 <code>Flux</code>。</p><p>对于 <code>Subscriber</code> 和 <code>Subcription</code> 这两个接口，<code>Reactor</code> 也有相应的实现。这些都是 <code>Spring WebFlux</code> 和 <code>Spring Data Reactive</code> 这样的框架用到的。如果 <strong>不开发中间件</strong>，开发人员是不会接触到的。</p><h2 id="Reactor入门"><a href="#Reactor入门" class="headerlink" title="Reactor入门"></a>Reactor入门</h2><p>接下来介绍一下 <code>Reactor</code> 中 <code>Mono</code> 和 <code>Flux</code> 这两个类中的主要方法的使用。</p><p>如同 <code>Java 8</code> 所引入的 <code>Stream</code> 一样，<code>Reactor</code> 的使用方式基本上也是分三步：</p><ul><li>开始阶段的创建</li><li>中间阶段的处理</li><li>最终阶段的消费</li></ul><p>只不过创建和消费可能是通过像 <code>Spring 5</code> 这样框架完成的（比如通过 <code>WebFlux</code> 中的 <code>WebClient</code> 调用  <code>HTTP</code> 接口，返回值便是一个 <code>Mono</code>）。但我们还是需要基本了解这些阶段的开发方式。</p><h3 id="1-创建-Mono-和-Flux（开始阶段）"><a href="#1-创建-Mono-和-Flux（开始阶段）" class="headerlink" title="1. 创建 Mono 和 Flux（开始阶段）"></a>1. 创建 Mono 和 Flux（开始阶段）</h3><p>使用 <code>Reactor</code> 编程的开始必然是先创建出 <code>Mono</code> 或 <code>Flux</code>。有些时候不需要我们自己创建，而是实现例如 <code>WebFlux</code> 中的 <code>WebClient</code> 或 <code>Spring Data Reactive</code> 得到一个 <code>Mono</code> 或 <code>Flux</code>。</p><ul><li>使用 WebFlux WebClient 调用 HTTP 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WebClient webClient = WebClient.create(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">findById</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> webClient</span><br><span class="line">            .get()</span><br><span class="line">            .uri(<span class="string">"/users/"</span> + userId)</span><br><span class="line">            .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">            .exchange()</span><br><span class="line">            .flatMap(cr -&gt; cr.bodyToMono(User.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 ReactiveMongoRepository 查询 User</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">ReactiveMongoRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Mono&lt;User&gt; <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有些时候，我们也需要主动地创建一个 <code>Mono</code> 或  <code>Flux</code>。</p><h4 id="普通的创建方式"><a href="#普通的创建方式" class="headerlink" title="普通的创建方式"></a>普通的创建方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; helloWorld = Mono.just(<span class="string">"Hello World"</span>);</span><br><span class="line">Flux&lt;String&gt; fewWords = Flux.just(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br><span class="line">Flux&lt;String&gt; manyWords = Flux.fromIterable(words);</span><br></pre></td></tr></table></figure><p>这样的创建方式在什么时候用呢？一般是用在经过一系列 <strong>非IO型</strong> 操作之后，得到了一个对象。接下来要基于这个对象运用 <code>Reactor</code> 进行 <strong>高性能</strong> 的 <code>IO</code> 操作时，可以用这种方式将之前得到的对象转换为 <code>Mono</code> 或 <code>Flux</code>。</p><h4 id="文艺的创建方式"><a href="#文艺的创建方式" class="headerlink" title="文艺的创建方式"></a>文艺的创建方式</h4><p>上面是通过一个 <strong>同步调用</strong> 得到的结果创建出 <code>Mono</code> 或 <code>Flux</code>，但有时需要从一个 <strong>非</strong> <code>Reactive</code> 的 <strong>异步调用</strong> 的结果创建出 <code>Mono</code> 或 <code>Flux</code>。</p><p>如果这个 <strong>异步方法</strong> 返回一个 <code>CompletableFuture</code>，那可以基于这个  <code>CompletableFuture</code> 创建一个 <code>Mono</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.fromFuture(completableFuture);</span><br></pre></td></tr></table></figure><p>如果这个 <strong>异步调用</strong> 不会返回   <code>CompletableFuture</code>，是有自己的 <strong>回调方法</strong>，那怎么创建 <code>Mono</code> 呢？可以使用 <code>static &lt;T&gt; Mono&lt;T&gt; create(Consumer&lt;MonoSink&lt;T&gt;&gt; callback)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Mono.create(sink -&gt; &#123;</span><br><span class="line">    ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; entity = asyncRestTemplate.getForEntity(url, String.class);</span><br><span class="line">    entity.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;ResponseEntity&lt;String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ResponseEntity&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">            sink.success(result.getBody());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">            sink.error(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在使用 <code>WebFlux</code> 之后，<code>AsyncRestTemplate</code> 已经不推荐使用，这里只是做演示。</p><h3 id="2-处理-Mono-和-Flux（中间阶段）"><a href="#2-处理-Mono-和-Flux（中间阶段）" class="headerlink" title="2. 处理 Mono 和 Flux（中间阶段）"></a>2. 处理 Mono 和 Flux（中间阶段）</h3><p>中间阶段的 <code>Mono</code> 和 <code>Flux</code> 的方法主要有 <code>filter</code>、<code>map</code>、<code>flatMap</code>、<code>then</code>、<code>zip</code>、<code>reduce</code> 等。这些方法使用方法和 <code>Stream</code> 中的方法类似。</p><p>下面举几个 <code>Reactor</code> 开发实际项目的问题，帮大家理解这些方法的使用场景：</p><h4 id="问题一-map、flatMap-和-then-在什么时候使用"><a href="#问题一-map、flatMap-和-then-在什么时候使用" class="headerlink" title="问题一: map、flatMap 和 then 在什么时候使用"></a>问题一: map、flatMap 和 then 在什么时候使用</h4><p>本段内容将涉及到如下类和方法：</p><ul><li><strong>方法</strong>：<code>Mono.map()</code></li><li><strong>方法</strong>：<code>Mono.flatMap()</code></li><li><strong>方法</strong>：<code>Mono.then()</code></li><li><strong>类</strong>：<code>Function</code></li></ul><p>在 <code>Mono</code> 和 <code>Flux</code> <strong>中间环节</strong>的处理过程中，有三个有些类似的方法：<code>map()</code>、<code>flatMap()</code> 和 <code>then()</code>。这三个方法的使用频率很高。</p><ul><li><strong>传统的命令式编程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object result1 = doStep1(params);</span><br><span class="line">Object result2 = doStep2(result1);</span><br><span class="line">Object result3 = doStep3(result2);</span><br></pre></td></tr></table></figure><ul><li><strong>对应的反应式编程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(params)</span><br><span class="line">    .flatMap(v -&gt; doStep1(v))</span><br><span class="line">    .flatMap(v -&gt; doStep2(v))</span><br><span class="line">    .flatMap(v -&gt; doStep3(v));</span><br></pre></td></tr></table></figure><p>从上面两段代码的对比就可以看出来 <code>flatMap()</code> 方法在其中起到的作用，<code>map()</code> 和 <code>then()</code> 方法也有类似的作用。但这些方法之间的区别是什么呢？我们先来看看这三个方法的签名（以 <code>Mono</code> 为例）：</p><ul><li>flatMap(Function&lt;? super T, ? extends Mono&lt;? extends R&gt;&gt; transformer)</li><li>map(Function&lt;? super T, ? extends R&gt; mapper)</li><li>then(Mono<v> other)</v></li></ul><h5 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h5><p><code>then()</code> 看上去是下一步的意思，但它只表示执行顺序的下一步，不表示下一步依赖于上一步。<code>then()</code> 方法的参数只是一个 <code>Mono</code>，无从接受上一步的执行结果。而 <code>flatMap()</code> 和 <code>map()</code> 的参数都是一个 <code>Function</code>，入参是上一步的执行结果。</p><h5 id="flatMap-和-map"><a href="#flatMap-和-map" class="headerlink" title="flatMap() 和 map()"></a>flatMap() 和 map()</h5><p><code>flatMap()</code> 和 <code>map()</code> 的区别在于，<code>flatMap()</code> 中的入参 <code>Function</code> 的返回值要求是一个 <code>Mono</code> 对象，而 <code>map</code> 的入参 <code>Function</code> 只要求返回一个 <strong>普通对象</strong>。在业务处理中常需要调用 <code>WebClient</code> 或 <code>ReactiveXxxRepository</code> 中的方法，这些方法的 <strong>返回值</strong> 都是 <code>Mono</code>（或 <code>Flux</code>）。所以要将这些调用串联为一个整体 <strong>链式调用</strong>，就必须使用 <code>flatMap()</code>，而不是 <code>map()</code>。</p><h4 id="问题二：如何实现并发执行"><a href="#问题二：如何实现并发执行" class="headerlink" title="问题二：如何实现并发执行"></a>问题二：如何实现并发执行</h4><p>本段内容将涉及到如下类和方法：</p><ul><li><strong>方法</strong>：<code>Mono.zip()</code></li><li><strong>类</strong>：<code>Tuple2</code></li><li><strong>类</strong>：<code>BiFunction</code></li></ul><p><strong>并发执行</strong> 是常见的一个需求。<code>Reactive Programming</code> 虽然是一种 <strong>异步编程</strong> 方式，但是 <strong>异步</strong> 不代表就是 <strong>并发并行</strong> 的。</p><p>在 <strong>传统的命令式编程</strong> 中，<strong>并发执行</strong> 是通过 <strong>线程池</strong> 加 <code>Future</code> 的方式实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Result1&gt; result1Future = threadPoolExecutor.submit(() -&gt; doStep1(params));</span><br><span class="line">Future&lt;Result2&gt; result2Future = threadPoolExecutor.submit(() -&gt; doStep2(params));</span><br><span class="line"><span class="comment">// Retrive result</span></span><br><span class="line">Result1 result1 = result1Future.get();</span><br><span class="line">Result2 result2 = result2Future.get();</span><br><span class="line"><span class="comment">// Do merge;</span></span><br><span class="line"><span class="keyword">return</span> mergeResult;</span><br></pre></td></tr></table></figure><p>上面的代码虽然实现了 <strong>异步调用</strong>，但 <code>Future.get()</code> 方法是 <strong>阻塞</strong> 的。在使用 <code>Reactor</code> 开发有 <strong>并发</strong> 执行场景的 <strong>反应式代码</strong> 时，不能用上面的方式。</p><p>这时应该使用 <code>Mono</code> 和 <code>Flux</code> 中的 <code>zip()</code> 方法，以 <code>Mono</code> 为例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;CustomType1&gt; item1Mono = ...;</span><br><span class="line">Mono&lt;CustomType2&gt; item2Mono = ...;</span><br><span class="line">Mono.zip(items -&gt; &#123;</span><br><span class="line">    CustomType1 item1 = CustomType1.class.cast(items[<span class="number">0</span>]);</span><br><span class="line">    CustomType2 item2 = CustomType2.class.cast(items[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// Do merge</span></span><br><span class="line">    <span class="keyword">return</span> mergeResult;</span><br><span class="line">&#125;, item1Mono, item2Mono);</span><br></pre></td></tr></table></figure><p>上述代码中，产生 <code>item1Mono</code> 和 <code>item2Mono</code> 的过程是 <strong>并行</strong> 的。比如，调用一个 <code>HTTP</code> 接口的同时，执行一个 <strong>数据库查询</strong> 操作。这样就可以加快程序的执行。</p><p>但上述代码存在一个问题，就是 <code>zip()</code> 方法需要做 <strong>强制类型转换</strong>。而强制类型转换是 <strong>不安全</strong>的。好在 <code>zip()</code> 方法存在 <strong>多种重载</strong> 形式。除了最基本的形式以外，还有多种 <strong>类型安全</strong> 的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T1, T2&gt; Mono&lt;Tuple2&lt;T1, T2&gt;&gt; zip(Mono&lt;? extends T1&gt; p1, Mono&lt;? extends T2&gt; p2);</span><br><span class="line"><span class="keyword">static</span> &lt;T1, T2, O&gt; <span class="function">Mono&lt;O&gt; <span class="title">zip</span><span class="params">(Mono&lt;? extends T1&gt; p1, Mono&lt;? extends T2&gt; p2, BiFunction&lt;? <span class="keyword">super</span> T1, ? <span class="keyword">super</span> T2, ? extends O&gt; combinator)</span></span>; </span><br><span class="line"><span class="keyword">static</span> &lt;T1, T2, T3&gt; Mono&lt;Tuple3&lt;T1, T2, T3&gt;&gt; zip(Mono&lt;? extends T1&gt; p1, Mono&lt;? extends T2&gt; p2, Mono&lt;? extends T3&gt; p3);</span><br></pre></td></tr></table></figure><p>对于不超过 <code>7</code> 个元素的合并操作，都有 <strong>类型安全</strong> 的 <code>zip()</code> 方法可选。以两个元素的合并为例，介绍一下使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mono.zip(item1Mono, item2Mono).map(tuple -&gt; &#123;</span><br><span class="line">    CustomType1 item1 = tuple.getT1();</span><br><span class="line">    CustomType2 item2 = tuple.getT2();</span><br><span class="line">    <span class="comment">// Do merge</span></span><br><span class="line">    <span class="keyword">return</span> mergeResult;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码中，<code>map()</code> 方法的参数是一个 <code>Tuple2</code>，表示一个 <strong>二元数组</strong>，相应的还有 <code>Tuple3</code>、<code>Tuple4</code> 等。</p><p>对于两个元素的并发执行，也可以通过 <code>zip(Mono&lt;? extends T1&gt; p1, Mono&lt;? extends T2&gt; p2, BiFunction&lt;? super T1, ? super T2, ? extends O&gt; combinator)</code> 方法直接将结果合并。方法是传递 <code>BiFunction</code> 实现 <strong>合并算法</strong>。</p><h4 id="问题三：集合循环之后的汇聚"><a href="#问题三：集合循环之后的汇聚" class="headerlink" title="问题三：集合循环之后的汇聚"></a>问题三：集合循环之后的汇聚</h4><p>本段内容将涉及到如下类和方法：</p><ul><li><strong>方法</strong>：<code>Flux.fromIterable()</code></li><li><strong>方法</strong>：<code>Flux.reduce()</code></li><li><strong>类</strong>：<code>BiFunction</code></li></ul><p>另外一个稍微复杂的场景，对一个对象中的一个类型为集合类的（<code>List</code> 、<code>Set</code>）进行处理之后，再对原本的对象进行处理。使用 <strong>迭代器模式</strong> 的代码很容易编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubData&gt; subDataList = data.getSubDataList();</span><br><span class="line"><span class="keyword">for</span> (SubData item : subDataList) &#123;</span><br><span class="line">    <span class="comment">// Do something on data and item</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do something on data</span></span><br></pre></td></tr></table></figure><p>当我们要用 <code>Reactive</code> 风格的代码实现上述逻辑时，就不是那么简单了。这里会用到 <code>Flux</code> 的 <code>reduce()</code> 方法。<code>reduce()</code> 方法的签名如下：</p><ul><li><code>&lt;A&gt; Mono&lt;A&gt; reduce(A initial, BiFunction&lt;A, ? super T, A&gt; accumulator);</code></li></ul><p>可以看出，<code>reduce()</code> 方法的功能是将一个 <code>Flux</code> <strong>聚合</strong> 成一个 <code>Mono</code>。</p><ul><li><p><strong>第一个参数</strong>: 返回值 <code>Mono</code> 中元素的 <strong>初始值</strong>。</p></li><li><p><strong>第二个参数</strong>: 是一个 <code>BiFunction</code>，用来实现 <strong>聚合操作</strong> 的逻辑。对于泛型参数 <code>&lt;A, ? super T, A&gt;</code> 中：</p><ul><li>第一个 <code>A</code>: 表示每次 <strong>聚合操作</strong> 之后的 <strong>结果的类型</strong>，它作为 <code>BiFunction.apply()</code> 方法的 <strong>第一个入参</strong>；</li><li>第二个 <code>? super T</code>: 表示集合中的每个元素的类型，它作为 <code>BiFunction.apply()</code> 方法的 <strong>第二个入参</strong>；</li><li>第三个 <code>A</code>: 表示聚合操作的 <strong>结果</strong>，它作为 <code>BiFunction.apply()</code> 方法的 <strong>返回值</strong>。</li></ul></li></ul><p>接下来看一下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Data initData = ...;</span><br><span class="line">List&lt;SubData&gt; list = ...;</span><br><span class="line">Flux.fromIterable(list)</span><br><span class="line">    .reduce(initData, (data, itemInList) -&gt; &#123;</span><br><span class="line">        <span class="comment">// Do something on data and itemInList</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面的示例代码中，<code>initData</code> 和 <code>data</code> 的类型相同。执行完上述代码之后，<code>reduce()</code> 方法会返回  <code>Mono&lt;Data&gt;</code>。</p><h3 id="3-消费-Mono-和-Flux（结束阶段）"><a href="#3-消费-Mono-和-Flux（结束阶段）" class="headerlink" title="3. 消费 Mono 和 Flux（结束阶段）"></a>3. 消费 Mono 和 Flux（结束阶段）</h3><p>直接消费的 <code>Mono</code> 或 <code>Flux</code> 的方式就是调用 <code>subscribe()</code> 方法。如果在 <code>WebFlux</code> 接口中开发，直接返回 <code>Mono</code> 或 Flux 即可。<code>WebFlux</code> 框架会完成最后的 <code>Response</code> 输出工作。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了反应式编程的一些概念和 <code>Spring Reactor</code> 框架的基本用法，还介绍了如何用 <code>Reactor</code> 解决一些稍微复杂一点的问题。<code>Reactor</code> 在 <code>Spring 5</code> 中有大量的应用，后面会给大家分享一些 <code>Spring Reactor</code> 实战系列的博客。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为了应对 &lt;strong&gt;高并发环境下&lt;/strong&gt; 的服务端编程，微软提出了一个实现 &lt;strong&gt;异步编程&lt;/strong&gt; 的方案 -  &lt;code&gt;Reactive Programming&lt;/code&gt;，中文名称 &lt;strong&gt;反应式编程&lt;/strong&gt;。随后，其它技术也迅速地跟上了脚步，像 &lt;code&gt;ES6&lt;/code&gt; 通过 &lt;code&gt;Promise&lt;/code&gt; 引入了类似的异步编程方式。&lt;code&gt;Java&lt;/code&gt; 社区也没有落后很多，&lt;code&gt;Netflix&lt;/code&gt; 和 &lt;code&gt;TypeSafe&lt;/code&gt; 公司提供了 &lt;code&gt;RxJava&lt;/code&gt; 和 &lt;code&gt;Akka Stream&lt;/code&gt; 技术，让 &lt;code&gt;Java&lt;/code&gt; 平台也有了能够实现反应式编程的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Reactive编程系列" scheme="https://ostenant.coding.me/categories/Spring-Reactive%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Reactive Streams" scheme="https://ostenant.coding.me/tags/Reactive-Streams/"/>
    
      <category term="Spring WebFlux" scheme="https://ostenant.coding.me/tags/Spring-WebFlux/"/>
    
      <category term="Reactor" scheme="https://ostenant.coding.me/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>Android异步框架RxJava 1.x系列(三) - 线程调度器Scheduler</title>
    <link href="https://ostenant.coding.me/2018/05/23/Android%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6RxJava%201.x%E7%B3%BB%E5%88%97(%E4%B8%89)%20-%20%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%08Scheduler/"/>
    <id>https://ostenant.coding.me/2018/05/23/Android异步框架RxJava 1.x系列(三) - 线程调度器Scheduler/</id>
    <published>2018-05-23T12:22:00.000Z</published>
    <updated>2018-05-23T15:41:32.662Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>RxJava</code> 事件的发出和消费都在同一个线程，基于同步的观察者模式。观察者模式的核心是后台处理，前台回调的异步机制。要实现异步，需要引入 <code>RxJava</code> 的另一个概念 - 线程调度器 <code>Scheduler</code>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/RXjava_logo.jpeg" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在不指定线程的情况下，<code>RxJava</code> 遵循的是线程不变的原则。即在哪个线程调用 <code>subscribe()</code> 方法，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到线程调度器 <code>Scheduler</code>。</p><h3 id="1-几种Scheduler介绍"><a href="#1-几种Scheduler介绍" class="headerlink" title="1. 几种Scheduler介绍"></a>1. 几种Scheduler介绍</h3><p>在 <code>RxJava</code> 中，<code>Scheduler</code> - 调度器，相当于线程控制器，<code>RxJava</code> 通过它来指定每一段代码应该运行在什么样的线程。<code>RxJava</code> 已经内置了几个 <code>Scheduler</code> ，它们已经适合大多数的使用场景：</p><ul><li><strong>Schedulers.immediate()</strong></li></ul><p>直接在当前线程运行，相当于不指定线程。这是默认的 <code>Scheduler</code>。</p><ul><li><strong>Schedulers.newThread()</strong></li></ul><p>总是启用新线程，并在新线程执行操作。</p><ul><li><strong>Schedulers.io()</strong></li></ul><p><code>I/O</code> 操作（读写文件、读写数据库、网络信息交互等）所使用的 <code>Scheduler</code>。行为模式和 <code>newThread()</code> 差不多，区别在于 <code>io()</code> 内部采用的是一个无数量上限的线程池，可以重用空闲的线程。因此多数情况下 <code>io()</code> 比 <code>newThread()</code> 更有效率。</p><blockquote><p>注意：不要把计算任务放在 <code>io()</code> 中，可以避免创建不必要的线程。</p></blockquote><ul><li><strong>Schedulers.computation()</strong> </li></ul><p>计算任务所使用的 <code>Scheduler</code>。这个计算指的是 <code>CPU</code> 密集型计算，即不会被 <code>I/O</code> 等操作限制性能的操作，例如图形的计算。这个 <code>Scheduler</code> 使用的固定的线程池，大小为 <code>CPU</code> 核数。</p><blockquote><p>注意：不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p></blockquote><ul><li><strong>AndroidSchedulers.mainThread()</strong></li></ul><p><code>Android</code> 还有一个专用的 <code>AndroidSchedulers.mainThread()</code>，它指定的操作将在 <code>Android</code> 主线程运行。</p><h3 id="2-Scheduler的线程切换"><a href="#2-Scheduler的线程切换" class="headerlink" title="2. Scheduler的线程切换"></a>2. Scheduler的线程切换</h3><h4 id="2-1-单次线程切换"><a href="#2-1-单次线程切换" class="headerlink" title="2.1. 单次线程切换"></a>2.1. 单次线程切换</h4><p>有了这几个 <code>Scheduler</code>，就可以使用 <code>subscribeOn()</code> 和 <code>observeOn()</code> 两个方法来对线程进行控制了。 </p><ul><li><p><code>subscribeOn()</code>: 指定 <code>subscribe()</code> 所发生的线程，即 <code>Observable.OnSubscribe</code> 被激活时所处的线程，或者叫做<strong>事件产生</strong>的线程。 </p></li><li><p><code>observeOn()</code>: 指定 <code>Subscriber</code> 所运行在的线程，或者叫做<strong>事件消费</strong>的线程。</p></li></ul><p>直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    .subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, <span class="string">"number:"</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面这段代码中，由于 <code>subscribeOn(Schedulers.io())</code> 的指定，被创建的事件的内容 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 将会在 <code>IO</code> <strong>线程</strong>发出；由于 <code>observeOn(AndroidScheculers.mainThread())</code> 的指定，因此 <code>subscriber</code> 数字的打印将发生在<strong>主线程</strong>。</p><p>事实上，这种使用方式非常常见，它适用于多数的 『<strong>后台线程取数据，主线程显示</strong>』的程序策略。</p><p>以下是一个完整的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 指定事件发出，即图片读取发生在 IO 线程</span></span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line"><span class="comment">// 指定事件消费 - 回调，即页面图片渲染发生在主线程</span></span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样的好处是，加载图片的过程发生在 <code>IO</code> <strong>线程</strong>，而设置图片则发生在了<strong>主线程</strong>。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成界面上的丝毫卡顿。</p><h4 id="2-2-多次线程切换"><a href="#2-2-多次线程切换" class="headerlink" title="2.2. 多次线程切换"></a>2.2. 多次线程切换</h4><p>上面介绍到可以利用 <code>subscribeOn()</code> 结合 <code>observeOn()</code> 来实现线程控制，让事件的产生和消费发生在不同的线程。在了解了 <code>map()</code> 和 <code>flatMap()</code> 等变换方法后，一个问题就产生了 - 能不能多切换几次线程？</p><p>因为 <code>observeOn()</code> 指定的是 <code>Subscriber</code> 的线程，而这个 <code>Subscriber</code> 并不是 <code>subscribe()</code> 参数中的 <code>Subscriber</code> ，而是 <code>observeOn()</code> 执行时，当前 <code>Observable</code> 所对应的 <code>Subscriber</code>，即它的直接下级 <code>Subscriber</code>。</p><blockquote><p>也就是说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。</p></blockquote><p>直接查看示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) </span><br><span class="line">    <span class="comment">// 事件发出的 IO 线程，由 subscribeOn() 指定</span></span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    <span class="comment">// 新线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(Schedulers.newThread())</span><br><span class="line">    .map(mapOperator) </span><br><span class="line">    <span class="comment">// IO 线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(mapOperator2) </span><br><span class="line">    <span class="comment">// Android 主线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>上面的代码，通过 <code>observeOn()</code> 的多次调用，程序实现了线程的多次切换。不过，不同于 <code>observeOn()</code>的是，<code>subscribeOn()</code> 的位置放在哪里都可以，但它是只能调用一次的。</p><h2 id="3-Scheduler的实现原理"><a href="#3-Scheduler的实现原理" class="headerlink" title="3. Scheduler的实现原理"></a>3. Scheduler的实现原理</h2><p>其实，<code>subscribeOn()</code> 和 <code>observeOn()</code> 的内部实现，也是用的 <code>lift()</code> (见上文)，具体看图（不同颜色的箭头表示不同的线程）：</p><ul><li><strong>subscribeOn()的原理图</strong></li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/RxJava1_200.jpg" alt=""></p><p>从图中可以看出，<code>subscribeOn()</code> 进行了线程切换的工作（图中的 <code>schedule...</code> 的位置）。</p><p><code>subscribeOn()</code> 的线程切换发生在 <code>OnSubscribe</code> 中，即在它<strong>通知上一级</strong> <code>OnSubscribe</code> 时，这时事件还没有开始发送，因此 <code>subscribeOn()</code> 的线程控制只能在<strong>事件发出的开端</strong>造成影响，即只允许一次线程切换。</p><ul><li><strong>observeOn()的原理图</strong></li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/RxJava1_210.jpg" alt=""></p><p>从图中可以看出，和 <code>observeOn()</code> 进行了线程切换的工作（图中的 <code>schedule...</code> 的位置）。</p><p><code>observeOn()</code> 的线程切换则发生在它内建的 <code>Subscriber</code> 中，即发生在它即将给<strong>下一级</strong> <code>Subscriber</code> 发送事件时，因此 <code>observeOn()</code> 控制的是它<strong>后面</strong>的线程，允许多次线程切换。</p><ul><li><strong>混合切换原理图</strong></li></ul><p>最后用一张图来解释当多个 <code>subscribeOn()</code> 和 <code>observeOn()</code> 混合使用时，线程调度是怎么发生的：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/RxJava1_211.jpg" alt=""></p><p>图中共有 <code>5</code> 处对事件的操作，由图中可以看出: </p><ol><li><p>① 和 ② 两处受第一个 <code>subscribeOn()</code> 影响，运行在<strong>红色线程</strong>；</p></li><li><p>③ 和 ④ 处受第一个 <code>observeOn()</code> 的影响，运行在<strong>绿色线程</strong>；</p></li><li><p>⑤ 处受第二个 <code>onserveOn()</code> 影响，运行在<strong>紫色线程</strong>；</p></li><li><p>而第二个 <code>subscribeOn()</code> ，由于在<strong>通知过程</strong>中线程就被第一个 <code>subscribeOn()</code> 截断，因此对整个流程并没有任何影响。</p></li></ol><blockquote><p>注意：当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。</p></blockquote><h2 id="4-延伸拓展"><a href="#4-延伸拓展" class="headerlink" title="4. 延伸拓展"></a>4. 延伸拓展</h2><p>虽然超过一个的 <code>subscribeOn()</code> 对事件处理的流程没有影响，但在<strong>流程之前</strong>却是有用的。在前面的文章介绍 <code>Subscriber</code> 的时候，提到过 <code>Subscriber</code> 的 <code>onStart()</code> 可以用作流程开始前的<strong>初始化处理</strong>。</p><blockquote><p>由于 onStart() 在 subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如：在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为无法预测 subscribe() 会在什么线程执行。</p></blockquote><p>与 <code>Subscriber.onStart()</code> 相对应的，有一个方法 <code>Observable.doOnSubscribe()</code>。它和 <code>Subscriber.onStart()</code> 同样是在 <code>subscribe()</code> <strong>调用后</strong>而且<strong>在事件发送前</strong>执行，但区别在于它可以指定线程。默认情况下，<code>doOnSubscribe()</code> 执行在 <code>subscribe()</code> 发生的线程；而如果在 <code>doOnSubscribe()</code> 之后有 <code>subscribeOn()</code> 的话，它将执行在离它最近的 <code>subscribeOn()</code> 所指定的线程。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(onSubscribe)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 需要在主线程执行</span></span><br><span class="line">            progressBar.setVisibility(View.VISIBLE); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(AndroidSchedulers.mainThread()) </span><br><span class="line">    <span class="comment">// 指定主线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>上面的代码，在 <code>doOnSubscribe()</code> 的后面跟一个 <code>subscribeOn()</code> ，就能指定特定工作的线程了！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>RxJava</code> 的提供的各种事件及事件转换模型，以及基于转换的线程调度器，结合观察者模式，使得 <code>RxJava</code> 在异步编程体验、灵活性和运行效率上领先于其他的开源框架！</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;RxJava&lt;/code&gt; 事件的发出和消费都在同一个线程，基于同步的观察者模式。观察者模式的核心是后台处理，前台回调的异步机制。要实现异步，需要引入 &lt;code&gt;RxJava&lt;/code&gt; 的另一个概念 - 线程调度器 &lt;code&gt;Scheduler&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava异步框架系列" scheme="https://ostenant.coding.me/categories/RxJava%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Android" scheme="https://ostenant.coding.me/tags/Android/"/>
    
      <category term="RxJava" scheme="https://ostenant.coding.me/tags/RxJava/"/>
    
      <category term="异步" scheme="https://ostenant.coding.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Android异步框架RxJava 1.x系列(二) - 事件及事件序列转换原理</title>
    <link href="https://ostenant.coding.me/2018/05/21/Android%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6RxJava%201.x%E7%B3%BB%E5%88%97(%E4%BA%8C)%20-%20%E4%BA%8B%E4%BB%B6%E5%8F%8A%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    <id>https://ostenant.coding.me/2018/05/21/Android异步框架RxJava 1.x系列(二) - 事件及事件序列转换原理/</id>
    <published>2018-05-21T11:14:00.000Z</published>
    <updated>2018-05-21T15:30:10.905Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在介绍 <code>RxJava 1.x</code> 线程调度器之前，首先引入一个重要的概念 - 事件序列转换。<code>RxJava</code> 提供了对事件序列进行转换的支持，这是它的核心功能之一。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/RXjava_logo.jpeg" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-事件序列转换定义"><a href="#1-事件序列转换定义" class="headerlink" title="1. 事件序列转换定义"></a>1. 事件序列转换定义</h2><p>所谓转换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列，有点类似 <code>Java 1.8</code> 中的流处理。</p><h2 id="2-事件序列转换API"><a href="#2-事件序列转换API" class="headerlink" title="2. 事件序列转换API"></a>2. 事件序列转换API</h2><p>首先看一个 <code>map()</code> 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"images/logo.png"</span>) <span class="comment">// 输入类型 String</span></span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(String filePath)</span> </span>&#123; <span class="comment">// 参数类型 String</span></span><br><span class="line">            <span class="keyword">return</span> getBitmapFromPath(filePath); <span class="comment">// 返回类型 Bitmap</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123; <span class="comment">// 参数类型 Bitmap</span></span><br><span class="line">            showBitmap(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这里出现了一个叫 <code>Func1</code> 的类。它和 <code>Action1</code> 非常相似，也是 <code>RxJava</code> 的一个接口，用于包装含有<strong>一个参数</strong>的方法。 <code>Func1</code> 和 <code>Action</code> 的区别在于: <code>Func1</code> 包装的是<strong>有返回值</strong>的方法。另外，和 <code>ActionX</code> 一样，<code>FuncX</code> 也有多个，用于不同参数个数的方法。同理，<code>FuncX</code> 和 <code>ActionX</code> 的区别在 <code>FuncX</code> 包装的是有返回值的方法。</p><blockquote><p>可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。</p></blockquote><p>这种直接转换对象并返回的，是最常见的也最容易理解的变换。不过 <code>RxJava</code> 的转换远不止这样，它不仅可以针对<strong>事件对象</strong>，还可以针对整个<strong>事件队列</strong>，这使得 <code>RxJava</code> 变得非常灵活。</p><p>下面给出几个示例：</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><strong>事件对象</strong>的直接变换，具体功能上面已经介绍过。它是 <code>RxJava</code> 最常用的变换。 <code>map()</code> 的示意图如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_010.jpg" alt=""></p><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><p>这是一个很有用但非常难理解的变换。首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.from(students)</span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;Student, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> student.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>如果要打印出每个学生所需要修的所有课程的名称呢？需求的区别在于，每个学生只有一个名字，但却有多个课程，首先可以这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Student&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        List&lt;Course&gt; courses = student.getCourses();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; courses.size(); i++) &#123;</span><br><span class="line">            Course course = courses.get(i);</span><br><span class="line">            Log.d(tag, course.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.from(students)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>如果我不想在 <code>Subscriber</code> 中使用 <code>for</code> 循环，而是希望 <code>Subscriber</code> 中直接传入单个的 <code>Course</code> 对象呢（这对于代码复用很重要）？用 <code>map()</code> 显然是不行的，因为 <code>map()</code> 是<strong>一对一</strong>的转化，而现在需要<strong>一对多</strong>的转化。问题出现了：怎样把一个 <code>Student</code> 转化成多个 <code>Course</code> ？</p><p>这个时候，<code>flatMap()</code> 就派上了用场：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Course&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Course&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Course course)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, course.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.from(students)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;Course&gt; <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(student.getCourses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，<code>flatMap()</code> 和 <code>map()</code> 有一个相同点：它也是把传入的参数转化之后返回另一个对象。</p><p><code>flatMap()</code> 和 <code>map()</code> 不同的是，<code>flatMap()</code> 返回的是个 <code>Observable</code> 对象，并且这个 <code>Observable</code> 对象并不是被直接发送到 <code>Subscriber</code> 的回调方法中。</p><p><code>flatMap()</code> 示意图如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_011.jpg" alt=""></p><p><code>flatMap()</code> 的原理是这样的：</p><ol><li>使用传入的事件对象创建一个 <code>Observable</code> 对象；</li><li>并不立即发送这个 <code>Observable</code>, 而是将它激活，然后开始发送事件；</li><li>将每一个创建出来的 <code>Observable</code> 发送的事件，都被汇入同一个 <code>Observable</code>。</li></ol><p>而这个 <code>Observable</code> 负责将这些事件统一交给 <code>Subscriber</code> 的回调方法。这三个步骤，把事件拆成了<strong>两级</strong>，通过一组新创建的 <code>Observable</code> 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 <code>flatMap()</code> 所谓的 <code>flat</code>。</p><h2 id="3-事件序列转换原理"><a href="#3-事件序列转换原理" class="headerlink" title="3. 事件序列转换原理"></a>3. 事件序列转换原理</h2><p>这些转换虽然功能各有不同，但实质上都是针对<strong>事件序列的处理和再发送</strong>。而在 <code>RxJava</code> 的内部，它们是基于同一个基础的转换方法：<code>lift(Operator)</code>。</p><h3 id="lift"><a href="#lift" class="headerlink" title="lift()"></a>lift()</h3><p>首先看一下 <code>lift()</code> 的内部实现（核心代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;R&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">            Subscriber newSubscriber = operator.call(subscriber);</span><br><span class="line">            newSubscriber.onStart();</span><br><span class="line">            onSubscribe.call(newSubscriber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现的功能，简单来说就是创建了一个新的 <code>Observable</code> 并返回。如果看过上篇博客会发现有些蹊跷。重温一下 <code>Observable.subscribe(Subscriber)</code> 的实现(核心代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    onSubscribe.call(subscriber);</span><br><span class="line">    <span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下以上两段代码的方法体(忽略返回值)，会发现一行突兀的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subscriber newSubscriber = operator.call(subscriber);</span><br></pre></td></tr></table></figure><p>解释一下 <code>lift()</code> 方法完成的操作：</p><ol><li><p>利用 <code>Observable.create()</code> 方法创建一个新的 <code>Observable</code> 对象，加上之前的原始 <code>Observable</code>，已经有两个 <code>Observable</code>。</p></li><li><p>创建 <code>Observable</code> 的同时创建一个新的 <code>OnSubscribe</code> 用于发出事件。</p></li><li><p>通过 <code>lift()</code> 传入的 <code>Operator</code> 函数的 <code>call()</code> 方法构造一个新的 <code>Subscriber</code> 对象，并将新 <code>Subscriber</code> 和原始 <code>Subscriber</code> 进行关联。</p></li><li><p>利用这个新 <code>Subscriber</code> 向原始 <code>Observable</code> 进行订阅，实现事件序列的转换。</p></li></ol><blockquote><p>这种实现基于代理模式，通过事件拦截和处理实现事件序列的变换。</p></blockquote><p>在 <code>Observable</code> 执行了 <code>lift(Operator)</code> 方法之后，会返回一个新的 <code>Observable</code>，这个新的 <code>Observable</code> 会像一个代理一样，负责接收原始的 <code>Observable</code> 发出的事件，并在处理后发送给 <code>Subscriber</code>。</p><p>整个过程的思维导图如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_013.jpg" alt=""></p><p>或者可以看动图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_014.gif" alt=""></p><p>两次和多次的 <code>lift()</code> 同理，如下图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_015.jpg" alt=""></p><p>举一个具体的 <code>Operator</code> 的实现。下面是一个将事件的 <code>Integer</code> 对象转换成 <code>String</code> 的例子，仅供参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">observable.lift(<span class="keyword">new</span> Observable.Operator&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 将事件序列中的 Integer 对象转换为 String 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                subscriber.onNext(<span class="string">""</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                subscriber.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>学习 lift() 的原理只是为了更好地理解 RxJava ，从而可以更好地使用它。然而RxJava 不建议开发者自定义 Operator 来直接使用 lift()，而是尽量使用已有的 lift() 包装方法（如 map() flatMap() 等）进行组合。</p></blockquote><h3 id="compose"><a href="#compose" class="headerlink" title="compose()"></a>compose()</h3><p>除了 <code>lift()</code> 之外，<code>Observable</code> 还有一个转方法叫做 <code>compose()</code>。它和 <code>lift()</code> 的区别在于，<code>lift()</code> 是针对<strong>事件项</strong>和<strong>事件序列</strong>的，而 <code>compose()</code> 是针对 <code>Observable</code> 自身进行转换。</p><p>举个例子，假设在程序中有多个 <code>Observable</code> 都需要应用一组相同的 <code>lift()</code> 进行转换，通常会这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">observable1.lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber1);</span><br><span class="line"></span><br><span class="line">observable2.lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber2);</span><br><span class="line"></span><br><span class="line">observable3.lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber3);</span><br><span class="line"></span><br><span class="line">observable4.lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber1);</span><br></pre></td></tr></table></figure><p>可以发现有太多重复代码，代码重构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable <span class="title">liftAll</span><span class="params">(Observable observable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observable.lift1()</span><br><span class="line">        .lift2()</span><br><span class="line">        .lift3()</span><br><span class="line">        .lift4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">liftAll(observable1).subscribe(subscriber1);</span><br><span class="line">liftAll(observable2).subscribe(subscriber2);</span><br><span class="line">liftAll(observable3).subscribe(subscriber3);</span><br><span class="line">liftAll(observable4).subscribe(subscriber4);</span><br></pre></td></tr></table></figure><p>可读性、可维护性都提高了。可是 <code>Observable</code> 被一个方法包起来，这种方式对于 <code>Observale</code> 的灵活性进行了限制。怎么办？这个时候，就应该用 <code>compose()</code> 来解决了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Observable&lt;Integer&gt; observable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observable.lift1()</span><br><span class="line">            .lift2()</span><br><span class="line">            .lift3()</span><br><span class="line">            .lift4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Transformer liftAll = <span class="keyword">new</span> LiftAllTransformer();</span><br><span class="line">observable1.compose(liftAll).subscribe(subscriber1);</span><br><span class="line">observable2.compose(liftAll).subscribe(subscriber2);</span><br><span class="line">observable3.compose(liftAll).subscribe(subscriber3);</span><br><span class="line">observable4.compose(liftAll).subscribe(subscriber4);</span><br></pre></td></tr></table></figure><p>如上，使用 <code>compose()</code> 方法，<code>Observable</code> 可以利用传入的 <code>Transformer</code> 对象的 <code>call</code> 方法直接对自身进行处理，而不是被包在方法的里面。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文主要介绍了 <code>RxJava</code> 事件及事件序列转换原理，其中 <code>lift()</code> 方法的使用方法和实现原理是重点、难点。后续将会介绍的 <code>RxJava</code> 线程调度器底层也是基于它实现的。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在介绍 &lt;code&gt;RxJava 1.x&lt;/code&gt; 线程调度器之前，首先引入一个重要的概念 - 事件序列转换。&lt;code&gt;RxJava&lt;/code&gt; 提供了对事件序列进行转换的支持，这是它的核心功能之一。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava异步框架系列" scheme="https://ostenant.coding.me/categories/RxJava%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Android" scheme="https://ostenant.coding.me/tags/Android/"/>
    
      <category term="RxJava" scheme="https://ostenant.coding.me/tags/RxJava/"/>
    
      <category term="异步" scheme="https://ostenant.coding.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Android异步框架RxJava 1.x系列(一) - 观察者模式及实现</title>
    <link href="https://ostenant.coding.me/2018/05/20/Android%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6RxJava%201.x%E7%B3%BB%E5%88%97(%E4%B8%80)%20-%20%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ostenant.coding.me/2018/05/20/Android异步框架RxJava 1.x系列(一) - 观察者模式及实现/</id>
    <published>2018-05-20T10:14:00.000Z</published>
    <updated>2018-05-21T15:28:22.014Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>RxJava</code> 是一款基于 <code>Java VM</code> 实现的响应式编程扩展库 - 基于观察者模式的异步和事件处理框架。<code>RxJava</code> 官方目前同时维护了两个版本，分别是 <code>1.x</code> 和 <code>2.x</code>，区别是它们使用不同的 <code>group id</code> 和 <code>namespaces</code>。</p><a id="more"></a><p> <img src="http://ols3fdyll.bkt.clouddn.com/RXjava_logo.jpeg" alt=""></p><table><thead><tr><th>版本</th><th style="text-align:left">group id</th><th style="text-align:left">namespaces</th></tr></thead><tbody><tr><td>v1.x</td><td style="text-align:left">io.reactivex</td><td style="text-align:left">io.reactivex</td></tr><tr><td>v2.x</td><td style="text-align:left">io.reactivex.rxjava2</td><td style="text-align:left">rx</td></tr></tbody></table><p>本系列的文章将针对 <code>RxJava 1.x</code> 进行介绍，先给出 <code>Github</code> 的地址：</p><ul><li>RxJava：<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">https://github.com/ReactiveX/RxJava</a></li><li>RxAndroid：<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">https://github.com/ReactiveX/RxAndroid</a></li></ul><p>通过 Gradle 引入相关依赖：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'io.reactivex:rxjava:1.0.14'</span> </span><br><span class="line"><span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:1.0.1'</span></span><br></pre></td></tr></table></figure><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-RxJava的定义"><a href="#1-RxJava的定义" class="headerlink" title="1. RxJava的定义"></a>1. RxJava的定义</h2><p>一个精准的解释如下：<code>RxJava</code> 是一个运行于 <code>Java VM</code> ，由可观测序列组成的，异步、基于事件的函数库。</p><h2 id="2-RxJava的优点"><a href="#2-RxJava的优点" class="headerlink" title="2. RxJava的优点"></a>2. RxJava的优点</h2><p>换句话说，『同样是做异步，为什么人们用它，而不用现成的 <code>AsyncTask</code> / <code>Handler</code> / <code>XXX</code> / … ？』</p><p>一个词：<strong>简洁</strong>。</p><p>异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 <code>Android</code> 创造的 <code>AsyncTask 和Handler</code>，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/rxjava1_001.jpg" alt=""></p><p>在 <code>Android</code> 开发中，假设有这样一个需求：界面上有一个自定义的视图 <code>imageCollectorView</code> ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 <code>File[] folders</code> 中每个目录下的 <code>png</code> 图片都加载出来并显示在 <code>imageCollectorView</code> 中。</p><blockquote><p>注意: 由于读取图片的过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。</p></blockquote><p>常用的实现方式有多种，这里给出其中一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (File folder : folders) &#123;</span><br><span class="line">            File[] files = folder.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">".png"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Bitmap bitmap = getBitmapFromFile(file);</span><br><span class="line">                    getActivity().runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            imageCollectorView.addImage(bitmap);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><p>而如果使用 <code>RxJava</code>，实现方式是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(folders)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;File, Observable&lt;File&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;File&gt; <span class="title">call</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(file.listFiles());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="keyword">new</span> Func1&lt;File, Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> file.getName().endsWith(<span class="string">".png"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;File, Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getBitmapFromFile(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">            imageCollectorView.addImage(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>可以发现，使用 RxJava 方式代码量明显大大增加，所谓简洁从何而来？</p><p>这里说的简洁是指的<strong>逻辑</strong>上的。观察一下你会发现，<code>RxJava</code> 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显（试想如果还要求只选取前 10 张图片，常规方式要怎么办？如果有更多这样那样的要求呢？再试想，在这一大堆需求实现完两个月之后需要改功能，当你翻回这里看到自己当初写下的那一片迷之缩进，你能保证自己将迅速看懂，而不是对着代码重新捋一遍思路？）。</p><p>另外，如果你的 <code>IDE</code> 是 <code>Android Studio</code>，其实每次打开某个 <code>Java</code> 文件的时候，你会看到被自动 <code>Lambda</code> 化的预览，这将让你更加清晰地看到程序逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(folders)</span><br><span class="line">    .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;)</span><br><span class="line">    .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(<span class="string">".png"</span>) &#125;)</span><br><span class="line">    .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe((Action1) (bitmap) -&gt; &#123; imageCollectorView.addImage(bitmap) &#125;);</span><br></pre></td></tr></table></figure><p>所以，<code>RxJava</code> 有啥优点？就好在简洁，优点就是把复杂逻辑，通过函数式编程模型穿成一条线。</p><h2 id="3-观察者模式的扩展"><a href="#3-观察者模式的扩展" class="headerlink" title="3. 观察者模式的扩展"></a>3. 观察者模式的扩展</h2><p><code>RxJava</code> 的异步实现，是通过一种扩展的观察者模式来实现的。</p><h3 id="3-1-通用的观察者模式"><a href="#3-1-通用的观察者模式" class="headerlink" title="3.1. 通用的观察者模式"></a>3.1. 通用的观察者模式</h3><p>观察者模式面向的需求是：<code>A</code> 对象（观察者）对 <code>B</code> 对象（被观察者）的某种变化高度敏感，需要在 <code>B</code> 变化的一瞬间做出反应。</p><p>举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。</p><p>程序的观察者模式略有不同，观察者不需要时刻盯着被观察者（例如 <code>A</code> 不需要每过 <code>2ms</code> 就检查一次 <code>B</code> 的状态），而是采用<strong>注册</strong>( <code>Register</code> )或者称为<strong>订阅</strong>(<code>Subscribe</code>)的方式，告诉被观察者：<strong>我需要你的某种状态，你要在它变化的时候通知我</strong>。 </p><blockquote><p>采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。</p></blockquote><p><code>Android</code> 开发中一个典型的例子是点击监听器 <code>OnClickListener</code> 。对设置 <code>OnClickListener</code> 来说，<code>View</code> 是<strong>被观察者</strong>，<code>OnClickListener</code> 是<strong>观察者</strong>，二者通过 <code>setOnClickListener()</code> 方法达成<strong>订阅关系</strong>。订阅之后用户点击按钮的瞬间，<code>Android Framework</code> 就会将点击事件发送给<strong>已注册</strong>的 <strong>OnClickListener</strong> 。</p><p><code>OnClickListener</code> 的观察者模式大致如下图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_002.jpg" alt=""></p><p>如图所示，通过 <code>setOnClickListener()</code> 方法，<code>Button</code> 持有 <code>OnClickListener</code> 的引用（这一过程没有在图上画出）。当用户点击时，<code>Button</code> 自动调用 <code>OnClickListener</code> 的 <code>onClick()</code> 方法。</p><p>按照观察者模式抽象出来的各个概念：</p><ul><li>Button: 被观察者</li><li>OnClickListener: 观察者</li><li>setOnClickListener(): 订阅</li><li>onClick(): 事件处理</li></ul><p>就由专用的观察者模式转变成了通用的观察者模式，如下图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_003.jpg" alt=""></p><h3 id="3-2-RxJava的观察者模式"><a href="#3-2-RxJava的观察者模式" class="headerlink" title="3.2. RxJava的观察者模式"></a>3.2. RxJava的观察者模式</h3><p><code>RxJava</code> 有四个基本概念：</p><ul><li>Observable: 可观察者，即被观察者</li><li>Observer: 观察者</li><li>Subscribe: 订阅</li><li>Event: 事件处理</li></ul><p><code>Observable</code> 和 <code>Observer</code> 通过 <code>subscribe()</code> 方法实现订阅关系，使得<code>Observable</code> 可以在需要的时候发出事件来通知 <code>Observer</code>。</p><p>与传统观察者模式不同，<code>RxJava</code> 的事件回调方法除了普通事件 <code>onNext()</code> （相当于 <code>onClick()</code>) 之外，还定义了两个特殊的事件：<code>onCompleted()</code> 和 <code>onError()</code>。</p><ul><li><strong>onCompleted(): 事件队列完结</strong></li></ul><p><code>RxJava</code> 不仅把每个事件单独处理，还会把它们看做一个队列。<code>RxJava</code>规定，当不会再有新的 <code>onNext()</code> 发出时，需要触发 <code>onCompleted()</code> 方法作为事件完成标志。</p><ul><li><strong>onError(): 事件队列异常</strong></li></ul><p>在事件处理过程中出异常时，<code>onError()</code> 会被触发，同时队列自动终止，不允许再有事件发出。</p><blockquote><p>在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个被调用，并且是事件序列中的最后一个执行。</p></blockquote><p><code>RxJava</code> 的观察者模式大致如下图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_004.jpg" alt=""></p><h2 id="4-RxJava的基本使用"><a href="#4-RxJava的基本使用" class="headerlink" title="4. RxJava的基本使用"></a>4. RxJava的基本使用</h2><p>基于以上的概念，<code>RxJava</code> 的基本使用有 3 个步骤：</p><h3 id="4-1-创建Obsever"><a href="#4-1-创建Obsever" class="headerlink" title="4.1. 创建Obsever"></a>4.1. 创建Obsever</h3><p><code>Observer</code> 即观察者，它决定事件触发的时候将有怎样的行为。 <code>RxJava</code> 中的 <code>Observer</code> 接口的声明方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Item: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Error: "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了 <code>Observer</code> 接口之外，<code>RxJava</code> 还内置了一个实现了 <code>Observer</code> 的抽象类：<code>Subscriber</code>。 <code>Subscriber</code> 对 <code>Observer</code> 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Item: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Error: "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实质上，在 <code>RxJava</code> 的 <code>subscribe</code> 过程中，<code>Observer</code> 也总是会先被转换成一个 <code>Subscriber</code> 再使用。所以如果你只想使用基本功能，选择 <code>Observer</code> 和 <code>Subscriber</code> 是完全一样的。它们的区别对于使用者来说主要有两点：</p><ul><li><strong>onStart()</strong></li></ul><p>这是 <code>Subscriber</code> 增加的方法。它会在 <code>subscribe</code> 刚开始，而事件还未发送之前被调用。可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。</p><p>需要注意的是，如果对准备工作的线程有要求（例如: 弹出一个显示进度的对话框，这必须在主线程执行），<code>onStart()</code> 就不适用了。因为它总是在 <code>subscribe</code> 所发生的<strong>线程</strong>被调用，而不能<strong>指定线程</strong>。要在指定的线程来做准备工作，可以使用 <code>doOnSubscribe()</code> 方法，具体可以在后面的章节中看到。</p><ul><li><strong>unsubscribe()</strong></li></ul><p>这是 <code>Subscriber</code> 所实现的另一个接口 <code>Subscription</code> 的方法，用于<strong>取消订阅</strong>。在这个方法被调用后，<code>Subscriber</code> 将不再接收事件。一般在这个方法调用前，可以使用 <code>isUnsubscribed()</code> 先判断一下状态。 </p><p><code>unsubscribe()</code> 这个方法很重要，因为在 <code>subscribe()</code> 之后， <code>Observable</code> 会持有 Subscriber 的引用。这个引用如果不能及时被释放，将有<strong>内存泄露</strong>的风险。</p><p>注意：在不再使用的时候尽快在合适的地方（例如: <code>onPause()</code> 和 <code>onStop()</code> 等方法中）调用 <code>unsubscribe()</code> 来解除<strong>引用关系</strong>，以避免内存泄露的发生。</p><h3 id="4-2-创建Obsevable"><a href="#4-2-创建Obsevable" class="headerlink" title="4.2. 创建Obsevable"></a>4.2. 创建Obsevable</h3><h4 id="4-2-1-Obsevable-create"><a href="#4-2-1-Obsevable-create" class="headerlink" title="4.2.1. Obsevable.create()"></a>4.2.1. Obsevable.create()</h4><p><code>Observable</code> 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 <code>RxJava</code> 使用 <code>create()</code> 方法来创建一个 <code>Observable</code> ，并为它定义事件触发规则。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Hi"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Aloha"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，这里传入了一个 <code>OnSubscribe</code> 对象作为参数。<code>OnSubscribe</code> 会被存储在返回的 <code>Observable</code> 对象中。</p><p>它的作用相当于一个计划表，当 <code>Observable</code> 被订阅的时候，<code>OnSubscribe</code> 的 <code>call()</code> 方法会自动被调用，<strong>事件序列</strong>就会依照设定依次触发（对于上面的代码，就是观察者<code>Subscriber</code> 将会被调用三次 <code>onNext()</code> 和一次 <code>onCompleted()</code>）。</p><p>这样，由<strong>被观察者</strong>调用了<strong>观察者</strong>的回调方法，就实现了由被观察者向观察者的<strong>事件传递</strong>，即观察者模式。</p><h4 id="4-2-2-Obsevable-just-T…"><a href="#4-2-2-Obsevable-just-T…" class="headerlink" title="4.2.2. Obsevable.just(T…)"></a>4.2.2. Obsevable.just(T…)</h4><p><code>create()</code> 方法是 <code>RxJava</code> 最基本的创建<strong>事件序列</strong>的方法。基于这个方法，<code>RxJava</code> 还提供了一些方法用于快捷创建事件队列，例如 <code>just()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>);</span><br><span class="line"><span class="comment">// 将会依次调用方法序列：onNext("Hello") -&gt; onNext("Hi") -&gt; onCompleted()</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-Obsevable-from-T-和from-Iterable-lt-extends-T-gt"><a href="#4-2-3-Obsevable-from-T-和from-Iterable-lt-extends-T-gt" class="headerlink" title="4.2.3. Obsevable.from(T[])和from(Iterable&lt;? extends T&gt;)"></a>4.2.3. Obsevable.from(T[])和from(Iterable&lt;? extends T&gt;)</h4><p>将传入的数组或 <code>Iterable</code> 拆分成具体对象后，依次发送给观察者，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>&#125;;</span><br><span class="line">Observable observable = Observable.from(words);</span><br><span class="line"><span class="comment">// 将会依次调用方法序列：onNext("Hello") -&gt; onNext("Hi") -&gt; onCompleted()</span></span><br></pre></td></tr></table></figure><h3 id="4-3-Subscribe关联"><a href="#4-3-Subscribe关联" class="headerlink" title="4.3. Subscribe关联"></a>4.3. Subscribe关联</h3><p>创建了 <code>Observable</code> 和 <code>Observer</code> 之后，再用 <code>subscribe()</code> 方法将它们关联起来，整条链子就可以工作了。代码很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>可能会注意到，subscribe() 这个方法有点怪：它看起来是『observable 订阅了 observer / subscriber』，而不是『observer / subscriber 订阅了 observable』。这看起来就像『杂志订阅了读者』一样颠倒了对象关系。</p><p>这让人读起来有点别扭，不过如果把 API 设计成 『observer.subscribe(observable) / subscriber.subscribe(observable)』，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。</p><p><code>Observable.subscribe(Subscriber)</code> 的内部实现是这样的(核心代码): </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    onSubscribe.call(subscriber);</span><br><span class="line">    <span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>subscriber()</code> 做了3件事：</p><p>(a). 调用Subscriber.onStart()</p><blockquote><p>这个方法在前面已经介绍过，是一个可选的准备方法。</p></blockquote><p>(b). 调用Observable中的OnSubscribe.call(Subscriber)</p><blockquote><p>事件发送的逻辑开始运行。从这也可以看出，在RxJava中，Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当subscribe()方法执行的时候。</p></blockquote><p>(c). 返回Subscription</p><blockquote><p>将传入的Subscriber作为Subscription返回。这是为了方便后面的unsubscribe()。</p></blockquote><p>整个过程中对象间的关系如下图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_005.jpg" alt=""></p><p>或者可以看动图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_006.gif" alt=""></p><p>除了 <code>subscribe(Observer)</code> 和 <code>subscribe(Subscriber)</code> ，<code>subscribe()</code> 还支持不完整定义的回调，<code>RxJava</code> 会自动根据定义创建出 <code>Subscriber</code>。形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">// onNext()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">    <span class="comment">// onError()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error handling</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action0 onCompletedAction = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">    <span class="comment">// onCompleted()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</span><br></pre></td></tr></table></figure><p>简单解释一下这段代码中出现的 <code>Action1</code> 和 <code>Action0</code>。 </p><ul><li><strong>Action0</strong></li></ul><p><code>Action0</code> 是 <code>RxJava</code> 的一个接口，它只有一个方法 <code>call()</code>，这个方法是<strong>无参无返回值的</strong>。由于 <code>onCompleted()</code> 方法也是<strong>无参无返回值的</strong>，因此 <code>Action0</code> 可以被当成一个<strong>包装对象</strong>，将 <code>onCompleted()</code> 的内容打包起来将自己作为一个参数传入 <code>subscribe()</code> 以实现不完整定义的回调。</p><ul><li><strong>Action1</strong></li></ul><p><code>Action1</code> 也是一个接口，它同样只有一个方法 <code>call(T param)</code>，这个方法也无返回值，但有一个参数。与 <code>Action0</code> 同理，由于 <code>onNext(T obj)</code> 和 <code>onError(Throwable error)</code> 也是<strong>单参数无返回值的</strong>，因此 <code>Action1</code> 可以将 <code>onNext(obj)</code> 和 <code>onError(error)</code> 打包起来传入 <code>subscribe()</code> 以实现不完整定义的回调。</p><blockquote><p>事实上，虽然 <code>Action0</code> 和 <code>Action1</code> 在 <code>API</code> 中使用最广泛，但 <code>RxJava</code> 提供了多个 <code>ActionX</code> 形式的接口 (例如: <code>Action2</code>, <code>Action3</code>)，它们可以被用以包装不同的无返回值的方法。</p></blockquote><h3 id="4-4-场景示例"><a href="#4-4-场景示例" class="headerlink" title="4.4. 场景示例"></a>4.4. 场景示例</h3><h4 id="4-4-1-打印字符串数组"><a href="#4-4-1-打印字符串数组" class="headerlink" title="4.4.1. 打印字符串数组"></a>4.4.1. 打印字符串数组</h4><p>将字符串数组 names 中的所有字符串依次打印出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] names = ...;</span><br><span class="line">Observable.from(names)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="4-4-2-由ID取得图片显示"><a href="#4-4-2-由ID取得图片显示" class="headerlink" title="4.4.2. 由ID取得图片显示"></a>4.4.2. 由ID取得图片显示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line"></span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>正如上面两个例子这样，创建出 <code>Observable</code> 和 <code>Subscriber</code>，再用 <code>subscribe()</code> 将它们串起来，一次 <code>RxJava</code> 的基本使用就完成了，非常简单！</p><p>然而。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Rxjava1_007.jpg" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在 <code>RxJava</code> 的默认规则中，事件的发出和消费都是在<strong>同一个线程</strong>的。也就是说，如果只用上面的方法，实现出来的只是一个<strong>同步的观察者模式</strong>。观察者模式本身的目的就是『后台处理，前台回调』的<strong>异步机制</strong>，因此异步对于 <code>RxJava</code> 是至关重要的。而要实现异步，则需要用到 <code>RxJava</code> 的另一个核心的概念 <code>Scheduler</code>，后续将给出详细介绍。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;RxJava&lt;/code&gt; 是一款基于 &lt;code&gt;Java VM&lt;/code&gt; 实现的响应式编程扩展库 - 基于观察者模式的异步和事件处理框架。&lt;code&gt;RxJava&lt;/code&gt; 官方目前同时维护了两个版本，分别是 &lt;code&gt;1.x&lt;/code&gt; 和 &lt;code&gt;2.x&lt;/code&gt;，区别是它们使用不同的 &lt;code&gt;group id&lt;/code&gt; 和 &lt;code&gt;namespaces&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava异步框架系列" scheme="https://ostenant.coding.me/categories/RxJava%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Android" scheme="https://ostenant.coding.me/tags/Android/"/>
    
      <category term="RxJava" scheme="https://ostenant.coding.me/tags/RxJava/"/>
    
      <category term="异步" scheme="https://ostenant.coding.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>分布式唯一ID的几种生成方案</title>
    <link href="https://ostenant.coding.me/2018/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"/>
    <id>https://ostenant.coding.me/2018/05/14/分布式唯一ID的几种生成方案/</id>
    <published>2018-05-13T23:46:00.000Z</published>
    <updated>2018-05-14T06:04:56.491Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在互联网的业务系统中，涉及到各种各样的ID，如在支付系统中就会有支付ID、退款ID等。那一般生成ID都有哪些解决方案呢？特别是在复杂的分布式系统业务场景中，我们应该采用哪种适合自己的解决方案是十分重要的。下面我们一一来列举一下，不一定全部适合，这些解决方案仅供你参考，或许对你有用。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/640.webp" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="分布式ID的特性"><a href="#分布式ID的特性" class="headerlink" title="分布式ID的特性"></a>分布式ID的特性</h2><ul><li>唯一性：确保生成的ID是全网唯一的。</li><li>有序递增性：确保生成的ID是对于某个用户或者业务是按一定的数字有序递增的。</li><li>高可用性：确保任何时候都能正确的生成ID。</li><li>带时间：ID里面包含时间，一眼扫过去就知道哪天的交易。</li></ul><h2 id="分布式ID的生成方案"><a href="#分布式ID的生成方案" class="headerlink" title="分布式ID的生成方案"></a>分布式ID的生成方案</h2><h3 id="1-UUID"><a href="#1-UUID" class="headerlink" title="1. UUID"></a>1. UUID</h3><p>算法的核心思想是结合机器的网卡、当地时间、一个随记数来生成UUID。</p><ul><li>优点：本地生成，生成简单，性能好，没有高可用风险</li><li>缺点：长度过长，存储冗余，且无序不可读，查询效率低</li></ul><h3 id="2-数据库自增ID"><a href="#2-数据库自增ID" class="headerlink" title="2. 数据库自增ID"></a>2. 数据库自增ID</h3><p>使用数据库的id自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。</p><ul><li>优点：数据库生成的ID绝对有序，高可用实现方式简单</li><li>缺点：需要独立部署数据库实例，成本高，有性能瓶颈</li></ul><h3 id="3-批量生成ID"><a href="#3-批量生成ID" class="headerlink" title="3. 批量生成ID"></a>3. 批量生成ID</h3><p>一次按需批量生成多个ID，每次生成都需要访问数据库，将数据库修改为最大的ID值，并在内存中记录当前值及最大值。</p><ul><li>优点：避免了每次生成ID都要访问数据库并带来压力，提高性能</li><li>缺点：属于本地生成策略，存在单点故障，服务重启造成ID不连续</li></ul><h3 id="4-Redis生成ID"><a href="#4-Redis生成ID" class="headerlink" title="4. Redis生成ID"></a>4. Redis生成ID</h3><p>Redis的所有命令操作都是单线程的，本身提供像 incr 和 increby 这样的自增原子命令，所以能保证生成的 ID 肯定是唯一有序的。</p><ul><li><p>优点：不依赖于数据库，灵活方便，且性能优于数据库；数字ID天然排序，对分页或者需要排序的结果很有帮助。</p></li><li><p>缺点：如果系统中没有Redis，还需要引入新的组件，增加系统复杂度；需要编码和配置的工作量比较大。</p></li></ul><p>考虑到单节点的性能瓶颈，可以使用 Redis 集群来获取更高的吞吐量。假如一个集群中有5台 Redis。可以初始化每台 Redis 的值分别是1, 2, 3, 4, 5，然后步长都是 5。各个 Redis 生成的 ID 为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A：1, 6, 11, 16, 21</span><br><span class="line">B：2, 7, 12, 17, 22</span><br><span class="line">C：3, 8, 13, 18, 23</span><br><span class="line">D：4, 9, 14, 19, 24</span><br><span class="line">E：5, 10, 15, 20, 25</span><br></pre></td></tr></table></figure><p>随便负载到哪个机确定好，未来很难做修改。步长和初始值一定需要事先确定。使用 Redis 集群也可以方式单点故障的问题。</p><p>另外，比较适合使用 Redis 来生成每天从0开始的流水号。比如订单号 = 日期 + 当日自增长号。可以每天在 Redis 中生成一个 Key ，使用 INCR 进行累加。</p><h3 id="5-Twitter的snowflake算法"><a href="#5-Twitter的snowflake算法" class="headerlink" title="5. Twitter的snowflake算法"></a>5. Twitter的snowflake算法</h3><p>Twitter 利用 zookeeper 实现了一个全局ID生成的服务 Snowflake：<a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">https://github.com/twitter/snowflake</a></p><p><img src="http://ols3fdyll.bkt.clouddn.com/5954965-eb19f67333187500.jpg" alt=""></p><p>如上图的所示，Twitter 的 Snowflake 算法由下面几部分组成：</p><ul><li><strong>1位符号位：</strong></li></ul><p>由于 long 类型在 java 中带符号的，最高位为符号位，正数为 0，负数为 1，且实际系统中所使用的ID一般都是正数，所以最高位为 0。</p><ul><li><strong>41位时间戳（毫秒级）：</strong></li></ul><p>需要注意的是此处的 41 位时间戳并非存储当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 起始时间戳），这里的起始时间戳一般是ID生成器开始使用的时间戳，由程序来指定，所以41位毫秒时间戳最多可以使用 <code>(1 &lt;&lt; 41) / (1000x60x60x24x365) = 69年</code>。</p><ul><li><strong>10位数据机器位：</strong> </li></ul><p>包括5位数据标识位和5位机器标识位，这10位决定了分布式系统中最多可以部署 <code>1 &lt;&lt; 10 = 1024</code> s个节点。超过这个数量，生成的ID就有可能会冲突。</p><ul><li><strong>12位毫秒内的序列：</strong></li></ul><p>这 12 位计数支持每个节点每毫秒（同一台机器，同一时刻）最多生成 <code>1 &lt;&lt; 12 = 4096个ID</code> </p><p>加起来刚好64位，为一个Long型。</p><ul><li>优点：高性能，低延迟，按时间有序，一般不会造成ID碰撞</li><li>缺点：需要独立的开发和部署，依赖于机器的时钟</li></ul><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始时间戳 2017-04-01</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> epoch = <span class="number">1491004800000L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识ID所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的最大机器ID,结果是31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的最大数据标识ID,结果是31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDataCenterId = ~(-<span class="number">1</span> &lt;&lt; dataCenterIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 毫秒内序列在id中所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID向左移12位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识ID向左移17(12+5)位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> dataCenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳向左移22(12+5+5)位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampShift = sequenceBits + workerIdBits + dataCenterIdBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识ID（0～31）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> dataCenterId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID（0～31）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 毫秒内序列（0～4095）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上次生成ID的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">(<span class="keyword">long</span> dataCenterId, <span class="keyword">long</span> workerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"dataCenterId can't be greater than %d or less than 0"</span>, maxDataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> snowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳,说明系统时钟回退过,这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp == lastTimestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = nextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="comment">//移位并通过按位或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - epoch) &lt;&lt; timestampShift) |</span><br><span class="line">                (dataCenterId &lt;&lt; dataCenterIdShift) |</span><br><span class="line">                (workerId &lt;&lt; workerIdShift) |</span><br><span class="line">                sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">nextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = lastTimestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-百度UidGenerator"><a href="#6-百度UidGenerator" class="headerlink" title="6. 百度UidGenerator"></a>6. 百度UidGenerator</h3><p>UidGenerator是百度开源的分布式ID生成器，基于于snowflake算法的实现，看起来感觉还行。不过，国内开源的项目维护性真是担忧。</p><p>具体可以参考官网说明：<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md</a></p><h3 id="7-美团Leaf"><a href="#7-美团Leaf" class="headerlink" title="7. 美团Leaf"></a>7. 美团Leaf</h3><p>Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。</p><p>具体可以参考官网说明：<a href="https://tech.meituan.com/MT_Leaf.html" target="_blank" rel="noopener">https://tech.meituan.com/MT_Leaf.html</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇文章和大家分享了全局id生成服务的几种常用方案，同时对比了各自的优缺点和适用场景。在实际工作中，大家可以结合自身业务和系统架构体系进行合理选型。</p><p>欢迎扫码关注公众号：零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在互联网的业务系统中，涉及到各种各样的ID，如在支付系统中就会有支付ID、退款ID等。那一般生成ID都有哪些解决方案呢？特别是在复杂的分布式系统业务场景中，我们应该采用哪种适合自己的解决方案是十分重要的。下面我们一一来列举一下，不一定全部适合，这些解决方案仅供你参考，或许对你有用。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Unique ID" scheme="https://ostenant.coding.me/tags/Unique-ID/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁金服SOFA-Boot整合SOFA-RPC(下篇)</title>
    <link href="https://ostenant.coding.me/2018/05/12/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8DSOFA-Boot%E6%95%B4%E5%90%88SOFA-RPC(%E4%B8%8B%E7%AF%87)/"/>
    <id>https://ostenant.coding.me/2018/05/12/蚂蚁金服SOFA-Boot整合SOFA-RPC(下篇)/</id>
    <published>2018-05-12T12:12:00.000Z</published>
    <updated>2018-05-12T15:18:18.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文介绍了SOFA-RPC 的几种调用方式，包括单向调用、同步调用、Future调用、回调，引入了泛化调用和过滤器。本文将对 SOFA-RPC 的高级功能，包括参数配置、自定义线程池、预热权重和自动故障剔除等。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SOFA.JPG" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-参数配置"><a href="#1-参数配置" class="headerlink" title="1. 参数配置"></a>1. 参数配置</h2><p><code>SOFABoot RPC Starter</code> 提供了方便的参数设置方式。这些参数目前可以分为两个部分。一部分是如端口，注册中心地址等配置，这类配置在 <code>application.properties</code> 中。另一部分是如超时时间等配置，这类配置在 <code>XML</code> 中。</p><h3 id="XML-配置"><a href="#XML-配置" class="headerlink" title="XML 配置"></a>XML 配置</h3><ul><li><strong>调用超时时间</strong></li></ul><p>如下是设置超时时间的方式，单位为 ms ，如果调用超过了这个时间则会抛出异常。服务端和客户端都可以设置，以客户端的超时时间设置优先。默认客户端为 3000 ，目前对 bolt，rest，dubbo 生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">timeout</span>=<span class="string">"5000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取地址等待时间</strong></li></ul><p>如下是设置获取地址等待时间，单位为ms。在启动时如果服务引用方等待超过了这个时间则不会再等待地址，会继续启动。客户端设置，默认为-1，表示会一直等待到地址为止。目前对 bolt，rest 生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">address-wait-time</span>=<span class="string">"30000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>建立连接超时时间</strong></li></ul><p>如下是设置建立连接超时时间，单位为 ms 。在建立连接时如果耗时超过了这个时间则会抛出异常。客户端设，默认为 5000。目前对 bolt，rest 生效。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">connect.timeout</span>=<span class="string">"30000"</span></span></span><br><span class="line">&lt;/sofa:binding.bolt&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>权重</strong></li></ul><p>如下是设置权重。客户端在发起调用时，如果采用的算法是随机调用，则会根据该权重来进行随机。服务端设置，默认为 100。目前对 bolt 生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">weight</span>=<span class="string">"200"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>lazy 连接</strong></li></ul><p>默认情况下客户端在注册中心推送地址到客户端时，就立即建立好连接，这个过程通常是在第一次调用之前进行的。如果设置服务引用的属性 lazy 为 true，客户端在第一次调用时才和所要调用的远程地址建立连接。默认为 false。</p><p>如下设置 lazy 连接方式，将 lazy 属性设为 true。目前支持 bolt 和 dubbo 协议。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"lazyServiceReferenceBolt"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.lazy.LazyService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">lazy</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>check 属性</strong></li></ul><p>默认情况下客户端在启动时，服务引用不要求存在可用的地址和连接。如果设置服务引用的属性 check 为 true，客户端在启动时，服务引用会检查是否存在对应的地址和连接，如果不存在会抛出异常。默认为 false。</p><p>如下设置 check 连接方式，将 check 属性设为 true。目前支持 bolt 和 dubbo 协议。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"checkServiceReferenceBolt"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.check.CheckService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">check</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>重试次数</strong></li></ul><p>重试次数，即在第一次调用失败后重试的最大次数，如果重试成功则不再继续重试。默认为 0。如下设置调用次数，利用 retries 属性指定重试次数。目前支持 bolt 和 dubbo 协议。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"retriesServiceReferenceBolt"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.retries.RetriesService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">retries</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>负载均衡</strong></li></ul><p>如下选择负载均衡的方式，利用 loadBalancer 属性指定调用时候使用的负载均衡策略，默认为 random。</p><p>目前支持 random，localPref，roundRobin，consistentHash，weightRoundRobin 五种负载均衡策略，具体可见 SOFARPC 负载均衡相关介绍。目前支持bolt协议。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"loadBalancerServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.loadBalancer.LoadBalancerService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">loadBalancer</span>=<span class="string">"random"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>方法级别配置</strong></li></ul><p>如下，sofa:method 元素是方法级别的配置。方法级别的配置优先级比服务级别的更高。name 属性指定了方法的名字。支持调用超时时间，调用方式，回调类的设置。方法级别的配置与服务级别的配置所生效的协议一样。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:method</span> <span class="attr">name</span>=<span class="string">"sayMethod"</span> <span class="attr">timeout</span>=<span class="string">"3000"</span> <span class="attr">type</span>=<span class="string">"sync"</span> <span class="attr">callback-ref</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Properties-配置"><a href="#Properties-配置" class="headerlink" title="Properties 配置"></a>Properties 配置</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">spring.application.name</td><td style="text-align:left">应用名</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">logging.path</td><td style="text-align:left">日志路径</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">logging.level.com.alipay.sofa.rpc.boot</td><td style="text-align:left">sofa-rpc-boot-start的日志级别(starter自身的日志)</td><td style="text-align:left">info</td></tr><tr><td style="text-align:left">logging.level.com.alipay.sofa.rpc</td><td style="text-align:left">sofa-rpc的日志级别(sofa-rpc核心日志基本在这里)</td><td style="text-align:left">info</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.bolt.port</td><td style="text-align:left">bolt 端口</td><td style="text-align:left">22000</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.bolt.io.thread.count</td><td style="text-align:left">bolt 的 io 线程数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.bolt.executor.thread.count</td><td style="text-align:left">bolt 的业务线程最大值</td><td style="text-align:left">200</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.bolt.accepts.count</td><td style="text-align:left">bolt 能够支持的最大长连接数</td><td style="text-align:left">100000</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.rest.hostname</td><td style="text-align:left">rest 的 hostname</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.rest.port</td><td style="text-align:left">rest 端口</td><td style="text-align:left">8341</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.rest.io.thread.count</td><td style="text-align:left">rest 的 io 线程数</td><td style="text-align:left">cpu 核数 * 2</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.rest.executor.thread.count</td><td style="text-align:left">rest 的业务线程数</td><td style="text-align:left">200</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.rest.max.request.size</td><td style="text-align:left">rest 的最大 byte 请求长度</td><td style="text-align:left">1024 <em> 1024 </em> 10</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.rest.telnet</td><td style="text-align:left">rest 是否支持 telnet</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.rest.daemon</td><td style="text-align:left">rest 是否支持 daemon</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.dubbo.port</td><td style="text-align:left">dubbo 的端口</td><td style="text-align:left">20880</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.dubbo.io.thread.count</td><td style="text-align:left">dubbo 的 io 线程数</td><td style="text-align:left">cpu 核数 + 1</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.dubbo.executor.thread.count</td><td style="text-align:left">dubbo 的业务线程数</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.dubbo.accepts.count</td><td style="text-align:left">dubbo能够支持的最大长连接数</td><td style="text-align:left">0，表示不限制</td></tr></tbody></table><h2 id="2-自定义线程池"><a href="#2-自定义线程池" class="headerlink" title="2. 自定义线程池"></a>2. 自定义线程池</h2><p>SOFA-RPC 支持自定义业务线程池。可以为指定服务设置一个独立的业务线程池，和 SOFA-RPC 自身的业务线程池是隔离的，多个服务可以共用一个独立的线程池。目前支持 bolt 协议。</p><p>在 SOFA-Boot 环境中可以为一个服务设置一个自定义线程池，配置如下：</p><ul><li><strong>声明自定义线程池</strong></li></ul><p>如下声明一个自定义线程池，<code>class</code> 必须为 <code>com.alipay.sofa.rpc.server.UserThreadPool</code>，这是 <code>SOFA-RPC</code> 提供的类，<code>init-method=&quot;init&quot;</code> 也必须声明以进行初始化。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customerThreadPool"</span> <span class="attr">class</span>=<span class="string">"com.alipay.sofa.rpc.server.UserThreadPool"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corePoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maximumPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queueSize"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"threadPoolName"</span> <span class="attr">value</span>=<span class="string">"customerThreadPool_name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>为服务设置自定义线程池</strong></li></ul><p>如下通过 <code>sofa:global-attrs</code> 元素的 <code>thread-pool-ref</code> 属性为该服务设置自定义线程池。<code>customerThreadPool</code> 是上面自定义线程池的 <code>bean id</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"threadPoolServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.ostenant.sofa.rpc.example.threadpool.ThreadPoolServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sofa:service</span> <span class="attr">ref</span>=<span class="string">"threadPoolServiceImpl"</span> <span class="attr">interface</span>=<span class="string">"com.alipay.sofa.rpc.samples.threadpool.ThreadPoolService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">thread-pool-ref</span>=<span class="string">"customerThreadPool"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-预热权重"><a href="#3-预热权重" class="headerlink" title="3. 预热权重"></a>3. 预热权重</h3><p>SOFA-RPC 提供了预热权重功能让客户端机器能够根据服务端的相应权重进行流量的分发。目前支持 bolt 协议。</p><p>SOFA-Boot 中提供了一系列参数属性，对指定服务进行预热配置。客户端机器能够自动解析这些参数，并按权重进行流量分发。</p><ul><li>warm-up-time: 服务的预热时间</li><li>warm-up-weight: 服务设置预热期间权重</li><li>weight: 服务设置预热完后的权重</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"sampleRestFacadeReferenceBolt"</span> <span class="attr">interface</span>=<span class="string">"com.alipay.sofa.endpoint.facade.SampleFacade"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">warm-up-time</span>=<span class="string">"10000"</span> <span class="attr">warm-up-weight</span>=<span class="string">"10"</span> <span class="attr">weight</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述配置中，该服务的预热期为10s，在预热期内权重为10，预热期结束后的正常权重为100。</p><p>如果该服务一共发布到A，B两个机器上。A机器正处于预热期内，使用上述配置；B已经完成预热，正常权重为200。那么客户端在调用的时候，此时流量分发的比重为10：200；A机器预热结束后，流量分发比重为100：200。</p><h2 id="4-自动故障剔除"><a href="#4-自动故障剔除" class="headerlink" title="4. 自动故障剔除"></a>4. 自动故障剔除</h2><p>自动故障剔除会自动监控 RPC 调用的情况，对故障节点进行权重降级，并在节点恢复健康时进行权重恢复。目前支持 bolt 协议。</p><p>在 SOFA-Boot 中，只需要将自动故障剔除的参数配置到 <code>application.properties</code> 即可。只配置自己关心的参数，其余参数会取默认值。需要注意的是，<code>rpc.aft.regulation.effective</code> 是该功能的全局开关，如果关闭则该功能不会运行，其他参数也都不生效。</p><ul><li><strong>自动故障剔除的配置参数意义</strong></li></ul><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">com.alipay.sofa.rpc.aft.time.window</td><td style="text-align:left">时间窗口大小：对统计信息计算的周期。</td><td style="text-align:left">10s</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.aft.least.window.count</td><td style="text-align:left">时间窗口内最少调用数：只有在时间窗口内达到了该最低值的数据才会被加入到计算和调控中。</td><td style="text-align:left">10次</td><td></td><td></td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.aft.least.window.exception.rate.multiple</td><td style="text-align:left">时间窗口内异常率与服务平均异常率的降级比值：在对统计信息进行计算的时候，会计算出该服务所有有效调用ip的平均异常率，如果某个ip的异常率大于等于了这个最低比值，则会被降级。</td><td style="text-align:left">6倍</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.aft.weight.degrade.rate</td><td style="text-align:left">降级比率：地址在进行权重降级时的降级比率。</td><td style="text-align:left">1/20</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.aft.weight.recover.rate</td><td style="text-align:left">恢复比率：地址在进行权重恢复时的恢复比率。</td><td style="text-align:left">2倍</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.aft.degrade.effective</td><td style="text-align:left">降级开关：如果应用打开了这个开关，则会对符合降级的地址进行降级，否则只会进行日志打印。</td><td style="text-align:left">false(关闭)</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.aft.degrade.least.weight</td><td style="text-align:left">降级最小权重：地址权重被降级后的值如果小于这个最小权重，则会以该最小权重作为降级后的值。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.aft.degrade.max.ip.count</td><td style="text-align:left">降级的最大ip数：同一个服务被降级的ip数不能超过该值。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">com.alipay.sofa.rpc.aft.regulation.effective</td><td style="text-align:left">全局开关：如果应用打开了这个开关，则会开启整个单点故障自动剔除摘除功能，否则完全不进入该功能的逻辑。</td><td style="text-align:left">false(关闭)</td></tr></tbody></table><ul><li><strong>配置示例</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">com.alipay.sofa.rpc.aft.time.window=20</span><br><span class="line">com.alipay.sofa.rpc.aft.least.window.count=30</span><br><span class="line">com.alipay.sofa.rpc.aft.least.window.exception.rate.multiple=6</span><br><span class="line">com.alipay.sofa.rpc.aft.weight.degrade.rate=0.5</span><br><span class="line">com.alipay.sofa.rpc.aft.weight.recover.rate=1.2</span><br><span class="line">com.alipay.sofa.rpc.aft.degrade.effective=ture</span><br><span class="line">com.alipay.sofa.rpc.aft.degrade.least.weight=1</span><br><span class="line">com.alipay.sofa.rpc.aft.degrade.max.ip.count=2</span><br><span class="line">com.alipay.sofa.rpc.aft.regulation.effective=true</span><br></pre></td></tr></table></figure><p>上述配置中，默认打开了自动故障剔除功能和降级开关。当节点出现故障时会被进行权重降级，在恢复时会被进行权重恢复。</p><p>每隔 20s 进行一次节点健康状态的度量，20s 内调用次数超过 30 次的节点才被作为计算数据。</p><p>如果单个节点的异常率超过了所有节点的平均异常率的 6 倍，则对该节点进行权重降级，降级的比率为 0.5。权重最小降级到 1。如果单个节点的异常率低于了平均异常率的 6 倍，则对该节点进行权重恢复，恢复的比率为1.2。单个服务最多降级 2 个 IP。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了 <code>SOFA-RPC</code> 的高级功能，包括参数配置，自定义线程池，服务预热和自动降级与权重恢复等用法。对于 <code>SOFA-RPC</code> 提供的基本功能，以及整合 <code>SOFA-Boot</code> 的配置和用法就介绍完了。对此有了初步的认识后，有利于后续深入实现原理和剖析源码。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上文介绍了SOFA-RPC 的几种调用方式，包括单向调用、同步调用、Future调用、回调，引入了泛化调用和过滤器。本文将对 SOFA-RPC 的高级功能，包括参数配置、自定义线程池、预热权重和自动故障剔除等。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
      <category term="SOFA-Boot" scheme="https://ostenant.coding.me/tags/SOFA-Boot/"/>
    
      <category term="SOFA_RPC" scheme="https://ostenant.coding.me/tags/SOFA-RPC/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁金服SOFA-Boot整合SOFA-RPC(中篇)</title>
    <link href="https://ostenant.coding.me/2018/05/09/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8DSOFA-Boot%E6%95%B4%E5%90%88SOFA-RPC(%E4%B8%AD%E7%AF%87)/"/>
    <id>https://ostenant.coding.me/2018/05/09/蚂蚁金服SOFA-Boot整合SOFA-RPC(中篇)/</id>
    <published>2018-05-09T07:08:00.000Z</published>
    <updated>2018-05-10T07:36:51.543Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章简单地介绍了 SOFA-Boot 的功能特性，对 Readiness 健康检查的配置举例说明。重点介绍了如何在 SOFA-Boot 中引入 SOFA-RPC 中间件，给出了基于 bolt、rest 和 dubbo 等不同协议通道的服务发布与消费的全流程。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SOFA.JPG" alt=""></p><p>本文将进一步介绍 SOFA-RPC 中间件提供的丰富而强大的功能，包括单向调用、同步调用、Future调用、回调，泛化调用，过滤器配置等。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-调用方式"><a href="#1-调用方式" class="headerlink" title="1. 调用方式"></a>1. 调用方式</h2><p>SOFA-RPC 提供单向调用、同步调用、异步调用和回调四种调用机制。为了区分四者的不同之处，这里给出 SOFA 官方提供的原理图。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/sofa-bolt-invoke-way.png" alt=""></p><p>下面给出详细阐述和配置说明：</p><h3 id="1-1-单向方式"><a href="#1-1-单向方式" class="headerlink" title="1.1. 单向方式"></a>1.1. 单向方式</h3><p>当前线程发起调用后，不关心调用结果，不做超时控制，只要请求已经发出，就完成本次调用。目前支持 bolt 协议。</p><h4 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h4><p>使用单向方式需要在<strong>服务引用</strong>的时候通过 <code>sofa:global-attrs</code> 元素的 <code>type</code> 属性声明调用方式为 <code>oneway</code> ，这样使用该服务引用发起调用时就是使用的单向方式了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"helloOneWayServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloOneWayService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">type</span>=<span class="string">"oneway"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>单向调用不保证成功，而且发起方无法知道调用结果。因此通常用于可以重试，或者定时通知类的场景，调用过程是有可能因为网络问题，机器故障等原因，导致请求失败。业务场景需要能接受这样的异常场景，才可以使用。</p><h3 id="1-2-同步方式"><a href="#1-2-同步方式" class="headerlink" title="1.2. 同步方式"></a>1.2. 同步方式</h3><p>当前线程发起调用后，需要在指定的超时时间内，等到响应结果，才能完成本次调用。如果超时时间内没有得到结果，那么会抛出超时异常。</p><h4 id="配置说明-1"><a href="#配置说明-1" class="headerlink" title="配置说明"></a>配置说明</h4><p><strong>服务接口与实现类</strong></p><p>SOFA-RPC 缺省采用的就是同步调用，可以省略 <code>sofa:global-attrs</code> 配置项。</p><p><strong>服务端发布配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloSyncServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloSyncServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sofa:service</span> <span class="attr">ref</span>=<span class="string">"helloSyncServiceImpl"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloSyncService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:service</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>客户端引用配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"helloSyncServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloSyncService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务端启动入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(SyncServerApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p><strong>客户端启动入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(SyncClientApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p><strong>客户端调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HelloSyncService helloSyncServiceReference = (HelloSyncService) applicationContext.getBean(<span class="string">"helloSyncServiceReference"</span>);</span><br><span class="line">System.out.println(helloSyncServiceReference.saySync(<span class="string">"sync"</span>));</span><br></pre></td></tr></table></figure><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><p>同步调用是最常用的方式。注意要根据对端的处理能力，合理设置超时时间。</p><h3 id="1-3-Future方式"><a href="#1-3-Future方式" class="headerlink" title="1.3. Future方式"></a>1.3. Future方式</h3><p>Future 方式下，客户端发起调用后不会等待服务端的结果，继续执行后面的业务逻辑。服务端返回的结果会被 SOFA-RPC 缓存，当客户端需要结果的时候，需要主动获取。目前支持 bolt 协议。</p><h4 id="配置说明-2"><a href="#配置说明-2" class="headerlink" title="配置说明"></a>配置说明</h4><p><strong>服务接口和实现类</strong></p><p>HelloFutureService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloFutureService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayFuture</span><span class="params">(String future)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloFutureServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFutureServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloFutureService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayFuture</span><span class="params">(String future)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端发布配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloFutureServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloFutureServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sofa:service</span> <span class="attr">ref</span>=<span class="string">"helloFutureServiceImpl"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloFutureService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:service</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>客户端引用配置</strong></p><p>使用 Future 方式需要在服务引用的时候通过 <code>sofa:global-attrs</code> 元素的 <code>type</code> 属性声明调用方式为 <code>future</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"helloFutureServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloFutureService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">type</span>=<span class="string">"future"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样使用该服务引用发起调用时就是使用的 <code>Future</code> 方式了。</p><p><strong>服务端启动入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(FutureServerApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p><strong>客户端启动入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(FutureClientApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p>客户端获取返回结果有两种方式：</p><ul><li>其一，通过 <code>SofaResponseFuture</code> 直接获取结果。第一个参数是获取结果的超时时间，第二个参数表示是否清除线程上下文中的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HelloFutureService helloFutureServiceReference = (HelloFutureService) applicationContext</span><br><span class="line">    .getBean(<span class="string">"helloFutureServiceReference"</span>);</span><br><span class="line">helloFutureServiceReference.sayFuture(<span class="string">"future"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String result = (String)SofaResponseFuture.getResponse(<span class="number">1000</span>, <span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">"Future result: "</span> + result)</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其二，获取原生 Future。该种方式会获取 JDK 原生的 Future ，参数表示是否清除线程上下文中的结果。获取结果的方式就是 JDK Future 的获取方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HelloFutureService helloFutureServiceReference = (HelloFutureService) applicationContext</span><br><span class="line">    .getBean(<span class="string">"helloFutureServiceReference"</span>);</span><br><span class="line">helloFutureServiceReference.sayFuture(<span class="string">"future"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Future future = SofaResponseFuture.getFuture(<span class="keyword">true</span>);</span><br><span class="line">    String result = (String)future.get(<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    System.out.println(<span class="string">"Future result: "</span> + result)</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><p>Future 方式适用于非阻塞编程模式。对于客户端程序处理后，不需要立即获取返回结果，可以先完成后续程序代码执行，在后续业务中，主动从当前线程上下文获取调用返回结果。减少了网络 IO 等待造成的代码运行阻塞和延迟。</p><h3 id="1-4-回调方式"><a href="#1-4-回调方式" class="headerlink" title="1.4. 回调方式"></a>1.4. 回调方式</h3><p>当前线程发起调用，则本次调用马上结束，可以马上执行下一次调用。发起调用时需要注册一个回调，该回调需要分配一个异步线程池。待响应返回后，会在回调的异步线程池，来执行回调逻辑。</p><h4 id="配置说明-3"><a href="#配置说明-3" class="headerlink" title="配置说明"></a>配置说明</h4><p><strong>服务接口和实现类</strong></p><p>HelloCallbackService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloCallbackService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayCallback</span><span class="params">(String callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloCallbackServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCallbackServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloCallbackService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayCallback</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>业务回调类</strong></p><p>客户端回调类需要实现 <code>com.alipay.sofa.rpc.core.invoke.SofaResponseCallback</code> 接口。</p><p>CallbackImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackImpl</span> <span class="keyword">implements</span> <span class="title">SofaResponseCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppResponse</span><span class="params">(Object appResponse, String methodName, RequestBase request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callback client process:"</span> + appResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppException</span><span class="params">(Throwable throwable, String methodName, RequestBase request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSofaException</span><span class="params">(SofaRpcException sofaException, String methodName, RequestBase request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SofaResponseCallback 接口提供了 3 个方法：</p><ul><li>onAppResponse: 程序正常运行，则进入该回调方法。</li><li>onAppException: 服务端程序抛出异常，则进入该回调方法。</li><li>onSofaException: 框架内部出现错误，则进入该回调方法。</li></ul><p><strong>服务端发布配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloCallbackServiceImpl"</span> <span class="attr">class</span>=<span class="string">"helloFutureServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloCallbackServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sofa:service</span> <span class="attr">ref</span>=<span class="string">"helloCallbackServiceImpl"</span> <span class="attr">interface</span>=<span class="string">"helloFutureServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloCallbackService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:service</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>客户端引用配置</strong></p><p>在服务引用的时候通过 <code>sofa:global-attrs</code> 元素的 <code>type</code> 属性声明调用方式为 <code>callback</code> ，再通过 <code>callback-ref</code> 声明回调的实现类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"callbackImpl"</span> <span class="attr">class</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.CallbackImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"helloCallbackServiceReference"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.invoke.HelloCallbackService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">type</span>=<span class="string">"callback"</span> <span class="attr">callback-ref</span>=<span class="string">"callbackImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样使用该服务引用发起调用时，就是使用的回调方式了。在结果返回时，由 SOFA-RPC 自动调用该回调类的相应方法。</p><p><strong>服务端启动入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(CallbackServerApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p><strong>客户端启动入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(CallbackClientApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p><strong>客户端发起调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HelloCallbackService helloCallbackServiceReference = (HelloCallbackService) applicationContext</span><br><span class="line">            .getBean(<span class="string">"helloCallbackServiceReference"</span>);</span><br><span class="line">helloCallbackServiceReference.sayCallback(<span class="string">"callback"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sayCallback() 的返回值不应该直接获取。在客户端注册的回调类中，返回值会以参数的形式传入正确的方法，以回调的形式完成后续逻辑处理。</p><h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h4><p>Callback 方式适用于异步非阻塞编程模式。客户端程序所在线程发起调用后，继续执行后续操作，不需要主动去获取返回值。服务端程序处理完成，将返回值传回一个异步线程池，由子线程通过回调函数进行返回值处理。很大情况的减少了网络 IO 阻塞，解决了单线程的瓶颈，实现了异步编程。</p><h2 id="2-泛化调用"><a href="#2-泛化调用" class="headerlink" title="2. 泛化调用"></a>2. 泛化调用</h2><p>泛化调用方式能够在客户端不依赖服务端的接口情况下发起调用，目前支持 bolt 协议。由于不知道服务端的接口，因此需要通过字符串的方式将服务端的接口，调用的方法，参数及结果类进行描述。</p><h4 id="配置说明-4"><a href="#配置说明-4" class="headerlink" title="配置说明"></a>配置说明</h4><p><strong>泛化参数类</strong></p><p>SampleGenericParamModel.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleGenericParamModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛化返回类</strong></p><p>SampleGenericResultModel.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleGenericResultModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务接口和实现类</strong></p><p>SampleGenericService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleGenericService</span> </span>&#123;</span><br><span class="line">    <span class="function">SampleGenericResultModel <span class="title">sayGeneric</span><span class="params">(SampleGenericParamModel sampleGenericParamModel)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>SampleGenericParamModel：作为 sayGeneric() 的输入参数类型，有一个 <code>name</code> 成员变量，作为真正的方法入参。</p></li><li><p>SampleGenericResultModel：作为 sayGeneric() 的返回结果类型，声明了 <code>name</code> 和 <code>value</code> 两个成员变量，作为真实的返回值。 </p></li></ul><p>SampleGenericServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleGenericServiceImpl</span> <span class="keyword">implements</span> <span class="title">SampleGenericService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SampleGenericResultModel <span class="title">sayGeneric</span><span class="params">(SampleGenericParamModel sampleGenericParamModel)</span> </span>&#123;</span><br><span class="line">        String name = sampleGenericParamModel.getName();</span><br><span class="line">        SampleGenericResultModel resultModel = <span class="keyword">new</span> SampleGenericResultModel();</span><br><span class="line">        resultModel.setName(name);</span><br><span class="line">        resultModel.setValue(<span class="string">"sample generic value"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端发布配置</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"sampleGenericServiceImpl"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.ostenant.sofa.rpc.example.generic.SampleGenericServiceImpl"</span>/&gt;</span><br><span class="line">&lt;sofa:service ref=<span class="string">"sampleGenericServiceImpl"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.ostenant.sofa.rpc.example.generic.SampleGenericService"</span>&gt;</span><br><span class="line">    &lt;sofa:binding.bolt/&gt;</span><br><span class="line">&lt;/sofa:service&gt;</span><br></pre></td></tr></table></figure><p><strong>客户端引用配置</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;sofa:reference id=<span class="string">"sampleGenericServiceReference"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alipay.sofa.rpc.api.GenericService"</span>&gt;</span><br><span class="line">    &lt;sofa:binding.bolt&gt;</span><br><span class="line">        &lt;sofa:global-attrs generic-<span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.ostenant.sofa.rpc.example.generic.SampleGenericService"</span>/&gt;</span><br><span class="line">    &lt;/sofa:binding.bolt&gt;</span><br><span class="line">&lt;/sofa:reference&gt;</span><br></pre></td></tr></table></figure><p>在泛化调用过程中，客户端配置有两点需要注意：</p><ul><li><code>sofa:reference</code> 指向的服务接口需要声明为 SOFA-RPC 提供的泛化接口 <code>com.alipay.sofa.rpc.api.GenericService</code>。</li><li><code>sofa:global-attrs</code> 需要声明属性 <code>generic-interface</code>，value 为真实的服务接口名称。</li></ul><p><strong>服务端启动入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(SampleGenericServerApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p><strong>客户端启动入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(SampleGenericClientApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p><strong>客户端发起调用</strong></p><ul><li>获取服务的泛化引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenericService sampleGenericServiceReference = (GenericService) applicationContext</span><br><span class="line">    .getBean(<span class="string">"sampleGenericServiceReference"</span>);</span><br></pre></td></tr></table></figure><ul><li>准备方法参数 </li></ul><p>由于客户端没有调用服务的参数类，因此通过 <code>com.alipay.hessian.generic.model.GenericObjectGenericObject</code> 进行描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备方法参数</span></span><br><span class="line">GenericObject genericParam = <span class="keyword">new</span> GenericObject(</span><br><span class="line">    <span class="string">"com.ostenant.sofa.rpc.example.generic.SampleGenericParamModel"</span>);</span><br><span class="line">genericParam.putField(<span class="string">"name"</span>, <span class="string">"Harrison"</span>);</span><br></pre></td></tr></table></figure><p><code>GenericObject</code> 持有一个 <code>Map&lt;String, Object&gt;</code> 类型的变量，你能够通过 <code>GenericObject</code> 提供的 <code>putField()</code> 方法，将参数类的属性和值放到这个 <code>Map</code> 中，以此来描述参数类。</p><ul><li>发起泛化调用</li></ul><p>通过 <code>GenericService</code> 的 <code>$genericInvoke(arg1, agr2, arg3)</code> 方法可以发起服务的泛化调用，各个参数含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">含义</th><th style="text-align:left">参数可选</th></tr></thead><tbody><tr><td style="text-align:left">arg1</td><td style="text-align:left">目标方法名称</td><td style="text-align:left">必填</td></tr><tr><td style="text-align:left">arg2</td><td style="text-align:left">参数类型的数组，要求严格遵循先后次序</td><td style="text-align:left">必填</td></tr><tr><td style="text-align:left">arg3</td><td style="text-align:left">参数值的数组，要求与参数类型数组保持一致</td><td style="text-align:left">必填</td></tr><tr><td style="text-align:left">arg4</td><td style="text-align:left">返回值的Class类型</td><td style="text-align:left">可选</td></tr></tbody></table><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GenericObject genericResult = (GenericObject) sampleGenericServiceReference.$genericInvoke(</span><br><span class="line">    <span class="comment">// 目标方法名称</span></span><br><span class="line">    <span class="string">"sayGeneric"</span>,</span><br><span class="line">    <span class="comment">// 参数类型名称</span></span><br><span class="line">    <span class="keyword">new</span> String[] &#123; <span class="string">"com.ostenant.sofa.rpc.example.generic.SampleGenericParamModel"</span> &#125;,</span><br><span class="line">    <span class="comment">// 参数的值</span></span><br><span class="line">    <span class="keyword">new</span> Object[] &#123; genericParam &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证返回结果</span></span><br><span class="line">System.out.println(<span class="string">"Type: "</span> + genericResult.getType());</span><br><span class="line">System.out.println(<span class="string">"Name: "</span> + genericResult.getField(<span class="string">"name"</span>));</span><br><span class="line">System.out.println(<span class="string">"Value: "</span> + genericResult.getField(<span class="string">"value"</span>));</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SampleGenericResultModel sampleGenericResult = sampleGenericServiceReference.$genericInvoke(</span><br><span class="line">    <span class="comment">// 目标方法名称</span></span><br><span class="line">    <span class="string">"sayGeneric"</span>,</span><br><span class="line">    <span class="comment">// 参数类型名称</span></span><br><span class="line">    <span class="keyword">new</span> String[] &#123; <span class="string">"com.ostenant.sofa.rpc.example.generic.SampleGenericParamModel"</span> &#125;,</span><br><span class="line">    <span class="comment">// 参数的值</span></span><br><span class="line">    <span class="keyword">new</span> Object[] &#123; genericParam &#125;,</span><br><span class="line">    <span class="comment">// 返回值的Class类型</span></span><br><span class="line">    SampleGenericResultModel.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证返回结果</span></span><br><span class="line">System.out.println(<span class="string">"Type: "</span> + sampleGenericResult.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"Name: "</span> + sampleGenericResult.getName());</span><br><span class="line">System.out.println(<span class="string">"Value: "</span> + sampleGenericResult.getValue());</span><br></pre></td></tr></table></figure><p><strong>查看控制台输出</strong></p><p>两种方式输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type: com.ostenant.sofa.rpc.example.generic.SampleGenericResultModel</span><br><span class="line">Name: Harrison</span><br><span class="line">Value: sample generic value</span><br></pre></td></tr></table></figure><h2 id="3-过滤器配置"><a href="#3-过滤器配置" class="headerlink" title="3. 过滤器配置"></a>3. 过滤器配置</h2><p>SOFA-RPC 通过过滤器 Filter 来实现对请求和响应的拦截处理。用户可以自定义 Filter 实现拦截扩展，目前支持 bolt 协议。开发人员通过继承 <code>com.alipay.sofa.rpc.filter.Filter</code> 实现过滤器的自定义。</p><h4 id="配置说明-5"><a href="#配置说明-5" class="headerlink" title="配置说明"></a>配置说明</h4><p><strong>服务接口与实现类</strong></p><p>FilterService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilterService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayFilter</span><span class="params">(String filter)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FilterServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterServiceImpl</span> <span class="keyword">implements</span> <span class="title">FilterService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayFilter</span><span class="params">(String filter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端过滤器</strong></p><p>在 Filter 实现类中，<code>invoke()</code> 方法实现具体的拦截逻辑，通过 <code>FilterInvoker.invoke(SofaRequest)</code> 触发服务的调用，在该方法前后可以实现具体的拦截处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleServerFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaResponse <span class="title">invoke</span><span class="params">(FilterInvoker invoker, SofaRequest request)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SampleFilter before server process"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(request);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"SampleFilter after server process"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端发布配置</strong></p><p>服务端需要配置服务实现类、过滤器，然后在 <code>sofa:service</code> 的 <code>sofa:global-attrs</code> 标签配置 <code>filter</code> 属性，实现两者的绑定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sampleFilter"</span> <span class="attr">class</span>=<span class="string">"com.ostenant.sofa.rpc.example.filter.SampleServerFilter"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"filterService"</span> <span class="attr">class</span>=<span class="string">"com.ostenant.sofa.rpc.example.filter.FilterServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sofa:service</span> <span class="attr">ref</span>=<span class="string">"filterService"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.filter.FilterService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">filter</span>=<span class="string">"sampleFilter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:service</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>客户端过滤器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClientFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaResponse <span class="title">invoke</span><span class="params">(FilterInvoker invoker, SofaRequest request)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SampleFilter before client invoke"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(request);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"SampleFilter after client invoke"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端引用配置</strong></p><p>同样的，客户端过滤器需要在 <code>sofa:reference</code> 的 <code>sofa:global-attrs</code> 标签中配置 <code>filter</code> 属性，实现客户端引用类的调用拦截。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sampleFilter"</span> <span class="attr">class</span>=<span class="string">"com.alipay.sofa.rpc.samples.filter.SampleClientFilter"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"filterServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.filter.FilterService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">filter</span>=<span class="string">"sampleFilter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务端启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(FilterServerApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p><strong>客户端启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(FilterClientApplication.class);</span><br><span class="line">ApplicationContext applicationContext = springApplication.run(args);</span><br></pre></td></tr></table></figure><p><strong>客户端调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FilterService filterServiceReference = (FilterService) applicationContext.getBean(<span class="string">"filterServiceReference"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// sleep 5s, 便于观察过滤器效果</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String result = filterServiceReference.sayFilter(<span class="string">"filter"</span>);</span><br><span class="line">System.out.println(<span class="string">"Invoke result: "</span> + result);</span><br></pre></td></tr></table></figure><p><strong>查看拦截输出</strong></p><ul><li>服务端打印输出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SampleFilter before server process</span><br><span class="line">SampleFilter after server process</span><br></pre></td></tr></table></figure><ul><li>客户端打印输出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SampleFilter before client invoke</span><br><span class="line">SampleFilter after client invoke</span><br><span class="line">Invoke result: filter</span><br></pre></td></tr></table></figure><p>过滤器配置生效，总结过滤器拦截先后次序如下：</p><ol><li>客户端发起调用 -&gt; 客户端前置拦截 -&gt; 服务端前置拦截          </li><li>服务端方法执行</li><li>服务端后置拦截 -&gt; 客户端后置拦截 -&gt; 客户端接收返回值</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了 SOFA-RPC 的集中调用方式，包括单向调用、同步调用、Future调用、回调，引入了 SOFA-RPC 独有的泛化调用机制，同时对过滤器的配置进行了简单介绍。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇文章简单地介绍了 SOFA-Boot 的功能特性，对 Readiness 健康检查的配置举例说明。重点介绍了如何在 SOFA-Boot 中引入 SOFA-RPC 中间件，给出了基于 bolt、rest 和 dubbo 等不同协议通道的服务发布与消费的全流程。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
      <category term="SOFA-Boot" scheme="https://ostenant.coding.me/tags/SOFA-Boot/"/>
    
      <category term="SOFA_RPC" scheme="https://ostenant.coding.me/tags/SOFA-RPC/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁金服SOFA-Boot整合SOFA-RPC(上篇)</title>
    <link href="https://ostenant.coding.me/2018/05/08/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8DSOFA-Boot%E6%95%B4%E5%90%88SOFA-RPC(%E4%B8%8A%E7%AF%87)/"/>
    <id>https://ostenant.coding.me/2018/05/08/蚂蚁金服SOFA-Boot整合SOFA-RPC(上篇)/</id>
    <published>2018-05-08T13:23:00.000Z</published>
    <updated>2018-05-09T06:28:50.824Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文介绍了 SOFARPC 的简单使用。在生产环境中，通常会将 SOFARPC 整合到 SpringBoot 中。蚂蚁金服提供了 SOFABoot 框架，SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等等能力。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SOFA.JPG" alt=""></p><p>在增强了 Spring Boot 的同时，SOFABoot 提供了让用户可以在 Spring Boot 中非常方便地使用 SOFA 中间件的能力。当前 SOFABoot 的 2.3.1 版本是基于 Spring Boot 1.4.2.RELEASE 来构建的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-功能描述"><a href="#1-功能描述" class="headerlink" title="1. 功能描述"></a>1. 功能描述</h2><p>SOFABoot 在 Spring Boot 的基础上，提供了以下能力：</p><h4 id="1-1-扩展-Spring-Boot-的健康检查"><a href="#1-1-扩展-Spring-Boot-的健康检查" class="headerlink" title="1.1. 扩展 Spring Boot 的健康检查"></a>1.1. 扩展 Spring Boot 的健康检查</h4><p>在 Spring Boot 健康检查能力的基础上，提供了 Readiness Check 的能力，保证应用实例安全上线。</p><h4 id="1-2-日志空间隔离能力"><a href="#1-2-日志空间隔离能力" class="headerlink" title="1.2. 日志空间隔离能力"></a>1.2. 日志空间隔离能力</h4><p>中间件框架自动发现应用的日志实现依赖并独立打印日志，避免中间件和应用日志实现绑定，通过 sofa-common-tools 实现。</p><h4 id="1-3-提供类隔离的能力"><a href="#1-3-提供类隔离的能力" class="headerlink" title="1.3. 提供类隔离的能力"></a>1.3. 提供类隔离的能力</h4><p>基于 SOFAArk 框架提供类隔离能力，方便使用者解决各种类冲突问题。</p><h4 id="1-4-中间件的集成管理"><a href="#1-4-中间件的集成管理" class="headerlink" title="1.4. 中间件的集成管理"></a>1.4. 中间件的集成管理</h4><p>统一管控、提供中间件统一易用的编程接口、每一个 SOFA 中间件都是独立可插拔的组件。</p><h4 id="1-5-完全兼容-Spring-Boot"><a href="#1-5-完全兼容-Spring-Boot" class="headerlink" title="1.5. 完全兼容 Spring Boot"></a>1.5. 完全兼容 Spring Boot</h4><p>SOFABoot 基于 Spring Boot 的基础上进行构建，并且完全兼容 Spring Boot。</p><h2 id="2-快速开始"><a href="#2-快速开始" class="headerlink" title="2. 快速开始"></a>2. 快速开始</h2><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1. 环境准备"></a>2.1. 环境准备</h3><p>要使用 SOFABoot，需要先准备好基础环境，SOFABoot 依赖以下环境：</p><ul><li>JDK7 或 JDK8</li><li>需要采用 Apache Maven 3.2.5 或者以上的版本来编译</li></ul><h3 id="2-2-创建工程"><a href="#2-2-创建工程" class="headerlink" title="2.2. 创建工程"></a>2.2. 创建工程</h3><p>SOFABoot 是直接构建在 Spring Boot 之上，因此可以使用 Spring Boot 的工程生成工具来生成。添加一个 Web 的依赖，以便最后在浏览器中查看效果。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/sofa-boot-examples.png" alt=""></p><h3 id="2-3-引入-SOFABoot"><a href="#2-3-引入-SOFABoot" class="headerlink" title="2.3. 引入 SOFABoot"></a>2.3. 引入 SOFABoot</h3><p>在创建好一个 Spring Boot 的工程之后，接下来就需要引入 SOFABoot 的依赖。首先，需要将上文中生成的 Spring Boot 工程的 zip 包解压后，修改 maven 项目的配置文件 pom.xml。</p><p>替换 spring-boot-starter-parent 为相应版本的 sofaboot-dependencies，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofaboot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-SOFABoot-健康检查"><a href="#2-4-SOFABoot-健康检查" class="headerlink" title="2.4. SOFABoot 健康检查"></a>2.4. SOFABoot 健康检查</h3><h4 id="引入相关依赖"><a href="#引入相关依赖" class="headerlink" title="引入相关依赖"></a>引入相关依赖</h4><p>添加 SOFABoot 健康检查扩展能力的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>healthcheck-sofa-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，在工程的 application.properties 文件下添加一个 SOFABoot 必须要使用的参数。</p><ul><li>spring.application.name：用于标示当前应用的名称</li><li>logging path：用于指定日志的输出目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Application Name</span><br><span class="line">spring.application.name=SOFABoot Example</span><br><span class="line"># logging path</span><br><span class="line">logging.path=./logs</span><br></pre></td></tr></table></figure><p>运行 main() 方法，项目启动以后，控制台的日志输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-05-09 09:56:48.305  INFO 15097 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)</span><br><span class="line">2018-05-09 09:56:48.309  INFO 15097 --- [           main] c.o.s.r.e.SofaBootExampleApplication     : Started SofaBootExampleApplication <span class="keyword">in</span> 2.551 seconds (JVM running <span class="keyword">for</span> 3.046)</span><br><span class="line">2018-05-09 09:57:46.005  INFO 15097 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet <span class="string">'dispatcherServlet'</span></span><br><span class="line">2018-05-09 09:57:46.005  INFO 15097 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet <span class="string">'dispatcherServlet'</span>: initialization started</span><br><span class="line">2018-05-09 09:57:46.021  INFO 15097 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet <span class="string">'dispatcherServlet'</span>: initialization completed <span class="keyword">in</span> 16 ms</span><br></pre></td></tr></table></figure><h4 id="查看健康状态"><a href="#查看健康状态" class="headerlink" title="查看健康状态"></a>查看健康状态</h4><ul><li>在浏览器中输入 <a href="http://localhost:8080/sofaboot/versions" target="_blank" rel="noopener">http://localhost:8080/sofaboot/versions</a> 来查看当前 SOFABoot 中使用 Maven 插件生成的版本信息汇总，结果类似如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"GroupId"</span>: <span class="string">"com.alipay.sofa"</span>,</span><br><span class="line">    <span class="attr">"Doc-Url"</span>: <span class="string">"https://github.com/alipay/sofa-boot"</span>,</span><br><span class="line">    <span class="attr">"ArtifactId"</span>: <span class="string">"infra-sofa-boot-starter"</span>,</span><br><span class="line">    <span class="attr">"Bulit-Time"</span>: <span class="string">"2018-04-18T22:19:09+0800"</span>,</span><br><span class="line">    <span class="attr">"Commit-Time"</span>: <span class="string">"2018-04-18T22:07:52+0800"</span>,</span><br><span class="line">    <span class="attr">"Commit-Id"</span>: <span class="string">"466f0e039b250ff7b201dc693eec7fa07eb21ad7"</span>,</span><br><span class="line">    <span class="attr">"Version"</span>: <span class="string">"2.3.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>在浏览器中输入 <a href="http://localhost:8080/health/readiness" target="_blank" rel="noopener">http://localhost:8080/health/readiness</a> 查看应用 Readiness Check 的状况，类似如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"UP"</span>,</span><br><span class="line">  <span class="attr">"sofaBootComponentHealthCheckInfo"</span>: &#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"UP"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"springContextHealthCheckInfo"</span>: &#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"UP"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"DiskSpaceHealthIndicator"</span>: &#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"UP"</span>,</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">250790436864</span>,</span><br><span class="line">    <span class="attr">"free"</span>: <span class="number">208612020224</span>,</span><br><span class="line">    <span class="attr">"threshold"</span>: <span class="number">10485760</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>status: &quot;UP&quot;</code> 表示应用 <code>Readiness Check</code> 的就绪状态是健康的。</p><ul><li>在浏览器中输入 <a href="http://localhost:8080/health" target="_blank" rel="noopener">http://localhost:8080/health</a> 来查看应用的运行时健康状态（可能会随着时间发生变化,Spring Boot原生自带功能）。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"UP"</span>,</span><br><span class="line">  <span class="attr">"sofaBootComponentHealthCheckInfo"</span>: &#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"UP"</span>,</span><br><span class="line">    <span class="attr">"Middleware"</span>: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"springContextHealthCheckInfo"</span>: &#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"UP"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"diskSpace"</span>: &#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"UP"</span>,</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">250790436864</span>,</span><br><span class="line">    <span class="attr">"free"</span>: <span class="number">208612528128</span>,</span><br><span class="line">    <span class="attr">"threshold"</span>: <span class="number">10485760</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>在上面的 application.properties 里面，我们配置的日志打印目录是 ./logs 即当前应用的根目录（我们可以根据自己的实践需要配置），在当前工程的根目录下可以看到类似如下结构的日志文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./logs</span><br><span class="line">├── health-check</span><br><span class="line">│   ├── sofaboot-common-default.log</span><br><span class="line">│   └── sofaboot-common-error.log</span><br><span class="line">├── infra</span><br><span class="line">│   ├── common-default.log</span><br><span class="line">│   └── common-error.log</span><br><span class="line">└── spring.log</span><br></pre></td></tr></table></figure><p>如果应用启动失败或者健康检查返回失败，可以通过相应的日志文件找到错误的原因，有些需要关注 common-error.log 日志。</p><h3 id="2-5-SOFA-RPC-环境准备"><a href="#2-5-SOFA-RPC-环境准备" class="headerlink" title="2.5. SOFA-RPC 环境准备"></a>2.5. SOFA-RPC 环境准备</h3><h4 id="引入相关依赖-1"><a href="#引入相关依赖-1" class="headerlink" title="引入相关依赖"></a>引入相关依赖</h4><p>SOFABoot 使用一系列后缀为 -sofa-boot-starter 来标示一个中间件服务，如果想要使用某个中间件，直接添加对应的依赖即可。进一步引入 SOFA-RPC 的 starter 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-sofa-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>选择 Zookeeper 作为服务注册列表，在 pom.xml 文件中引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意将 zkclient 重复的依赖排除在外，以免引起冲突。</p><h4 id="配置-zookeeper-集群"><a href="#配置-zookeeper-集群" class="headerlink" title="配置 zookeeper 集群"></a>配置 zookeeper 集群</h4><p>在 application.properties 中进一步配置 zookeeper 的地址信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># zookeeper address list</span><br><span class="line">com.alipay.sofa.rpc.registry.address=zookeeper://127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183?file=/home/admin/registry</span><br></pre></td></tr></table></figure><p>为了方便起见，本地使用 docker 环境对 zookeeper 集群进行容器编排。多个 zookeeper 节点通过逗号分隔，file 参数指定当 zookeeper 不可用时，可以利用本地缓存文件进行服务发现。</p><p>编写 docker-compose.yml 文件如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  zoo1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">zookeeper:latest</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">zoo1</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      ZOO_SERVERS:</span> <span class="string">server.1=0.0.0.0:2888:3888</span> <span class="string">server.2=zoo2:2888:3888</span> <span class="string">server.3=zoo3:2888:3888</span></span><br><span class="line"><span class="attr">  zoo2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">zookeeper:latest</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">zoo2</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888</span> <span class="string">server.2=0.0.0.0:2888:3888</span> <span class="string">server.3=zoo3:2888:3888</span></span><br><span class="line"><span class="attr">  zoo3:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">zookeeper:latest</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">zoo3</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888</span> <span class="string">server.2=zoo2:2888:3888</span> <span class="string">server.3=0.0.0.0:2888:3888</span></span><br></pre></td></tr></table></figure><p>进入 docker-compose.yml 所在文件目录， 运行 <code>docker-compose up -d</code> 启动3台 zookeeper 容器。启动完成后，运行 <code>docker-compose ps</code> 查看进程状态如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose ps</span><br><span class="line">      Name                    Command               State                     Ports                   </span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line">zookeeper_zoo1_1   /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2181-&gt;2181/tcp, 2888/tcp, 3888/tcp</span><br><span class="line">zookeeper_zoo2_1   /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2182-&gt;2181/tcp, 2888/tcp, 3888/tcp</span><br><span class="line">zookeeper_zoo3_1   /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2183-&gt;2181/tcp, 2888/tcp, 3888/tcp</span><br></pre></td></tr></table></figure><p>zookeeper 容器集群启动完成，如果想要查看集群 leader，可以运行 <code>docker exec -it [container-id] /bin/bash</code> 进入容器运行 <code>zkServer.sh status</code> 逐一查看。这里加以不累述！</p><h4 id="XSD管理"><a href="#XSD管理" class="headerlink" title="XSD管理"></a>XSD管理</h4><p>在要使用的 XML 配置文件中将头部 xsd 文件的声明设置为如下，这样就能够使用 SOFABoot 定义的 XML 元素进行开发。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:sofa</span>=<span class="string">"http://sofastack.io/schema/sofaboot"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://sofastack.io/schema/sofaboot   http://sofastack.io/schema/sofaboot.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-6-SOFA-Boot-整合-SOFA-RPC"><a href="#2-6-SOFA-Boot-整合-SOFA-RPC" class="headerlink" title="2.6. SOFA-Boot 整合 SOFA-RPC"></a>2.6. SOFA-Boot 整合 SOFA-RPC</h3><h4 id="编写服务接口和实现类"><a href="#编写服务接口和实现类" class="headerlink" title="编写服务接口和实现类"></a>编写服务接口和实现类</h4><p>HelloSyncService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloSyncService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">saySync</span><span class="params">(String string)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloSyncServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSyncServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloSyncService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saySync</span><span class="params">(String sync)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写服务提供方配置文件"><a href="#编写服务提供方配置文件" class="headerlink" title="编写服务提供方配置文件"></a>编写服务提供方配置文件</h4><p>simple-server-example.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:sofa</span>=<span class="string">"http://sofastack.io/schema/sofaboot"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://sofastack.io/schema/sofaboot http://sofastack.io/schema/sofaboot.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloSyncServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.ostenant.sofa.rpc.example.simple.HelloSyncServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以多种通信协议发布服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:service</span> <span class="attr">ref</span>=<span class="string">"helloSyncServiceImpl"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.simple.HelloSyncService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.rest</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.dubbo</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>sofa:service</code> 元素将该服务发布，其中 <code>ref</code> 属性表示发布的服务实例，interface 属性表示该服务的接口。</p><ul><li>sofa:binding.bolt: 服务通过 bolt 协协议通道发布，底层基于 Netty 实现。</li><li>sofa:binding.rest: 服务通过 http 协议发布。</li><li>sofa:binding.dubbo: 服务基于 dubbo 的协议通道发布。</li></ul><h4 id="编写服务提供方启动程序"><a href="#编写服务提供方启动程序" class="headerlink" title="编写服务提供方启动程序"></a>编写服务提供方启动程序</h4><p>SimpleServerApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(&#123; <span class="string">"classpath:simple-server-example.xml"</span> &#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(SimpleServerApplication.class);</span><br><span class="line">        ApplicationContext applicationContext = springApplication.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写服务消费方配置文件"><a href="#编写服务消费方配置文件" class="headerlink" title="编写服务消费方配置文件"></a>编写服务消费方配置文件</h4><p>simple-client-example.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:sofa</span>=<span class="string">"http://sofastack.io/schema/sofaboot"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://sofastack.io/schema/sofaboot http://sofastack.io/schema/sofaboot.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- bolt引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"boltHelloSyncServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.simple.HelloSyncService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- rest引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"restHelloSyncServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.simple.HelloSyncService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.rest</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- dubbo引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"dubboHelloSyncServiceReference"</span> <span class="attr">interface</span>=<span class="string">"com.ostenant.sofa.rpc.example.simple.HelloSyncService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.dubbo</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写服务提供方启动程序-1"><a href="#编写服务提供方启动程序-1" class="headerlink" title="编写服务提供方启动程序"></a>编写服务提供方启动程序</h4><p>SimpleClientApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(&#123; <span class="string">"classpath:simple-client-example.xml"</span> &#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"server.port"</span>, <span class="string">"8081"</span>);</span><br><span class="line">        SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(SimpleClientApplication.class);</span><br><span class="line">        ApplicationContext applicationContext = springApplication.run(args);</span><br><span class="line"></span><br><span class="line">        HelloSyncService boltHelloSyncService = (HelloSyncService) applicationContext.getBean(<span class="string">"boltHelloSyncServiceReference"</span>);</span><br><span class="line">        HelloSyncService restHelloSyncService = (HelloSyncService) applicationContext.getBean(<span class="string">"restHelloSyncServiceReference"</span>);</span><br><span class="line">        HelloSyncService dubboHelloSyncService = (HelloSyncService) applicationContext.getBean(<span class="string">"dubboHelloSyncServiceReference"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Bolt result:"</span> + boltHelloSyncService.saySync(<span class="string">"bolt"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Rest result:"</span> + restHelloSyncService.saySync(<span class="string">"rest"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Dubbo result:"</span> + dubboHelloSyncService.saySync(<span class="string">"dubbo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分别启动服务端和客户端"><a href="#分别启动服务端和客户端" class="headerlink" title="分别启动服务端和客户端"></a>分别启动服务端和客户端</h4><p>客户端控制台输出日志如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bolt result: bolt</span><br><span class="line">Rest result: rest</span><br><span class="line">Dubbo result: dubbo</span><br></pre></td></tr></table></figure><p>对于同一个服务，在服务发布方配置时，可在以 <code>sofa:service</code> 中通过 <code>sofa:binding.xxx</code> 提供多种协议通道配置；在服务消费方配置时，可以在 <code>sofa:reference</code> 中通过 <code>sofa:binding.xxx</code> 提供对不同通道服务的引用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文引入了 SOFA-Boot 框架，对 SOFA-Boot 的将康检查功能和日志管理的使用进行了简单说明，然后在 SOFA-Boot 环境中引入了 SOFA-RPC 框架，并提供了一个完整的服务发布和注册的示例程序。</p><p>关于 SOFA-RPC 更丰富、强大的功能介绍，下篇敬请期待！</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上文介绍了 SOFARPC 的简单使用。在生产环境中，通常会将 SOFARPC 整合到 SpringBoot 中。蚂蚁金服提供了 SOFABoot 框架，SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等等能力。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
      <category term="SOFA-RPC" scheme="https://ostenant.coding.me/tags/SOFA-RPC/"/>
    
      <category term="SOFA-Boot" scheme="https://ostenant.coding.me/tags/SOFA-Boot/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁金服RPC框架SOFA-RPC - 初体验</title>
    <link href="https://ostenant.coding.me/2018/04/29/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8DRPC%E6%A1%86%E6%9E%B6SOFA-RPC%20-%20%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://ostenant.coding.me/2018/04/29/蚂蚁金服RPC框架SOFA-RPC - 初体验/</id>
    <published>2018-04-29T09:59:00.000Z</published>
    <updated>2018-05-09T06:21:43.934Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SOFARPC 最早源于阿里内部的 HSF，是近期蚂蚁金服开源的一个高可扩展性、高性能、生产级的 Java RPC 框架。SOFA-RPC 在蚂蚁金服已经历了十多年的发展，致力于简化应用之间的 RPC 调用。为应用提供方便透明、稳定高效的点对点远程服务调用方案。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SOFA.JPG" alt=""></p><p>为了用户和开发者方便的进行功能扩展，SOFA-RPC 提供了丰富的模型抽象和可扩展接口，包括过滤器、路由、负载均衡等。同时围绕 SOFA-RPC 框架及其周边组件提供丰富的微服务治理方案。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-功能特性"><a href="#1-功能特性" class="headerlink" title="1. 功能特性"></a>1. 功能特性</h2><ul><li>透明化、高性能的远程服务调用</li><li>支持多种服务路由及负载均衡策略</li><li>支持多种注册中心的集成</li><li>支持 bolt、rest、dubbo 等多种通信协议  </li><li>支持同步、单向、回调、泛化等多种调用方式</li><li>支持集群容错、服务预热、自动故障隔离</li><li>强大的扩展功能，可以按需扩展各个功能组件</li></ul><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/sofa-rpc-quckstart.png" alt=""></p><p>a. 服务发布</p><blockquote><p>当一个 SOFARPC 的应用启动的时候，如果发现当前应用需要发布 RPC 服务的话，那么 SOFARPC 会将这些服务注册到服务注册中心上。如图中 Service 指向 Registry。</p></blockquote><p>b. 服务订阅</p><blockquote><p>当引用这个服务的 SOFARPC 应用启动时，会从服务注册中心订阅到相应服务的元数据信息。服务注册中心收到订阅请求后，会将发布方的元数据列表实时推送给服务引用方。如图中 Registry 指向 Reference。</p></blockquote><p>c. 服务调用</p><blockquote><p>当服务引用方拿到地址以后，就可以从中选取地址发起调用了。如图中 Reference 指向 Service。</p></blockquote><h2 id="3-快速开始"><a href="#3-快速开始" class="headerlink" title="3. 快速开始"></a>3. 快速开始</h2><h3 id="3-1-引入sofa-rpc依赖"><a href="#3-1-引入sofa-rpc依赖" class="headerlink" title="3.1. 引入sofa-rpc依赖"></a>3.1. 引入sofa-rpc依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-rpc-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-编写服务接口和服务实现类"><a href="#3-2-编写服务接口和服务实现类" class="headerlink" title="3.2. 编写服务接口和服务实现类"></a>3.2. 编写服务接口和服务实现类</h3><p>HelloService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String string)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Server receive: "</span> + string);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + string + <span class="string">" ！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-编写服务提供者启动类"><a href="#3-3-编写服务提供者启动类" class="headerlink" title="3.3. 编写服务提供者启动类"></a>3.3. 编写服务提供者启动类</h3><p>QuickStartServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerConfig serverConfig = <span class="keyword">new</span> ServerConfig()</span><br><span class="line">                .setProtocol(<span class="string">"bolt"</span>) <span class="comment">// 设置一个协议，默认bolt</span></span><br><span class="line">                .setPort(<span class="number">9696</span>) <span class="comment">// 设置一个端口，默认12200</span></span><br><span class="line">                .setDaemon(<span class="keyword">false</span>); <span class="comment">// 非守护线程</span></span><br><span class="line"></span><br><span class="line">        ProviderConfig&lt;HelloService&gt; providerConfig = <span class="keyword">new</span> ProviderConfig&lt;HelloService&gt;()</span><br><span class="line">                .setInterfaceId(HelloService.class.getName()) <span class="comment">// 指定接口</span></span><br><span class="line">                .setRef(<span class="keyword">new</span> HelloServiceImpl()) <span class="comment">// 指定实现</span></span><br><span class="line">                .setServer(serverConfig); <span class="comment">// 指定服务端</span></span><br><span class="line"></span><br><span class="line">        providerConfig.export(); <span class="comment">// 发布服务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行服务端提供方，日志输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sofa-Middleware-Log SLF4J Warn : No <span class="built_in">log</span> util is usable, Default app logger will be used.</span><br><span class="line">SLF4J: Failed to load class <span class="string">"org.slf4j.impl.StaticLoggerBinder"</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html<span class="comment">#StaticLoggerBinder for further details.</span></span><br><span class="line">Sofa-Middleware-Log SLF4J Warn : No <span class="built_in">log</span> util is usable, Default app logger will be used.</span><br></pre></td></tr></table></figure><h3 id="3-4-编写服务消费者启动类"><a href="#3-4-编写服务消费者启动类" class="headerlink" title="3.4. 编写服务消费者启动类"></a>3.4. 编写服务消费者启动类</h3><p>QuickStartClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConsumerConfig&lt;HelloService&gt; consumerConfig = <span class="keyword">new</span> ConsumerConfig&lt;HelloService&gt;()</span><br><span class="line">                .setInterfaceId(HelloService.class.getName()) <span class="comment">// 指定接口</span></span><br><span class="line">                .setProtocol(<span class="string">"bolt"</span>) <span class="comment">// 指定协议</span></span><br><span class="line">                .setDirectUrl(<span class="string">"bolt://127.0.0.1:9696"</span>); <span class="comment">// 指定直连地址</span></span><br><span class="line"></span><br><span class="line">        HelloService helloService = consumerConfig.refer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(helloService.sayHello(<span class="string">"world"</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行服务端消费方，调用服务提供方：</p><ul><li>服务提供方日志输出如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server receive: world</span><br><span class="line">Server receive: world</span><br><span class="line">Server receive: world</span><br><span class="line">Server receive: world</span><br></pre></td></tr></table></figure><ul><li>服务消费方日志输出如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">"org.slf4j.impl.StaticLoggerBinder"</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html<span class="comment">#StaticLoggerBinder for further details.</span></span><br><span class="line">Sofa-Middleware-Log SLF4J Warn : No <span class="built_in">log</span> util is usable, Default app logger will be used.</span><br><span class="line">Sofa-Middleware-Log SLF4J Warn : No <span class="built_in">log</span> util is usable, Default app logger will be used.</span><br><span class="line">hello world ！</span><br><span class="line">hello world ！</span><br><span class="line">hello world ！</span><br><span class="line">hello world ！</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这是一个快速入门的例子！</p><p>可以发现，在使用上，SOFA-RPC 与淘宝的 Dubbo，微博的 Motan 并无太大的区别。Dubbo 作为整套服务治理而存在，而 SOFA-RPC 只是一款轻量级的 RPC 框架，基于 HSF 框架改造，提供更加完善、强大的、多样化 RPC 编程 API。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SOFARPC 最早源于阿里内部的 HSF，是近期蚂蚁金服开源的一个高可扩展性、高性能、生产级的 Java RPC 框架。SOFA-RPC 在蚂蚁金服已经历了十多年的发展，致力于简化应用之间的 RPC 调用。为应用提供方便透明、稳定高效的点对点远程服务调用方案。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
      <category term="SOFA-RPC" scheme="https://ostenant.coding.me/tags/SOFA-RPC/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(四) - 3PC协议</title>
    <link href="https://ostenant.coding.me/2018/04/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E5%9B%9B)%20-%203PC%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ostenant.coding.me/2018/04/28/分布式理论(四) - 3PC协议/</id>
    <published>2018-04-28T13:26:00.000Z</published>
    <updated>2018-05-08T02:49:46.095Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷。所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/3PC.png" alt=""></p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><ol><li>引入超时机制 - 同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-三阶段提交的定义"><a href="#1-三阶段提交的定义" class="headerlink" title="1. 三阶段提交的定义"></a>1. 三阶段提交的定义</h2><p>三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p><p>所谓的三个阶段分别是：询问，然后再锁资源，最后真正提交。</p><ul><li>第一阶段：CanCommit</li><li>第二阶段：PreCommit</li><li>第三阶段：Do Commit</li></ul><h2 id="2-三阶段提交的过程"><a href="#2-三阶段提交的过程" class="headerlink" title="2. 三阶段提交的过程"></a>2. 三阶段提交的过程</h2><h3 id="2-1-阶段一：CanCommit"><a href="#2-1-阶段一：CanCommit" class="headerlink" title="2.1. 阶段一：CanCommit"></a>2.1. 阶段一：CanCommit</h3><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><p>a. 事务询问</p><blockquote><p>协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p></blockquote><p>b. 响应反馈</p><blockquote><p>参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态；否则反馈No。</p></blockquote><h3 id="2-2-阶段二：PreCommit"><a href="#2-2-阶段二：PreCommit" class="headerlink" title="2.2. 阶段二：PreCommit"></a>2.2. 阶段二：PreCommit</h3><p>协调者在得到所有参与者的响应之后，会根据结果执行2种操作：执行事务预提交，或者中断事务。</p><h4 id="2-2-1-执行事务预提交"><a href="#2-2-1-执行事务预提交" class="headerlink" title="2.2.1. 执行事务预提交"></a>2.2.1. 执行事务预提交</h4><p>a. 发送预提交请求</p><blockquote><p>协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态。</p></blockquote><p>b. 事务预提交</p><blockquote><p>参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 准备阶段中的 “执行事务”，也会 Undo 和 Redo 信息记录到事务日志中。</p></blockquote><p>c. 各参与者响应反馈</p><blockquote><p>如果参与者成功执行了事务，就反馈 ACK 响应，同时等待指令：提交（commit） 或终止（abort）。</p></blockquote><h4 id="2-2-2-中断事务"><a href="#2-2-2-中断事务" class="headerlink" title="2.2.2. 中断事务"></a>2.2.2. 中断事务</h4><p>a. 发送中断请求</p><blockquote><p>协调者向所有参与者节点发出 abort 请求 。</p></blockquote><p>b. 中断事务</p><blockquote><p>参与者如果收到 abort 请求或者超时了，都会中断事务。</p></blockquote><h3 id="2-3-阶段三：Do-Commit"><a href="#2-3-阶段三：Do-Commit" class="headerlink" title="2.3. 阶段三：Do Commit"></a>2.3. 阶段三：Do Commit</h3><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p><h4 id="2-3-1-执行提交"><a href="#2-3-1-执行提交" class="headerlink" title="2.3.1. 执行提交"></a>2.3.1. 执行提交</h4><p>a. 发送提交请求</p><blockquote><p>协调者接收到各参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。</p></blockquote><p>b. 事务提交</p><blockquote><p>参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p></blockquote><p>c. 响应反馈</p><blockquote><p>事务提交完之后，向协调者发送 ACK 响应。</p></blockquote><p>d. 完成事务</p><blockquote><p>协调者接收到所有参与者的 ACK 响应之后，完成事务。</p></blockquote><h4 id="2-3-2-中断事务"><a href="#2-3-2-中断事务" class="headerlink" title="2.3.2. 中断事务"></a>2.3.2. 中断事务</h4><p>协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><p>a. 发送中断请求</p><blockquote><p>协调者向所有参与者发送 abort 请求。</p></blockquote><p>b. 事务回滚</p><blockquote><p>参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></blockquote><p>c. 反馈结果</p><blockquote><p>参与者完成事务回滚之后，向协调者发送 ACK 消息。</p></blockquote><p>d. 中断事务</p><blockquote><p>协调者接收到参与者反馈的 ACK 消息之后，完成事务的中断。</p></blockquote><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h1><h2 id="3-1-三阶段提交的优点"><a href="#3-1-三阶段提交的优点" class="headerlink" title="3.1. 三阶段提交的优点"></a>3.1. 三阶段提交的优点</h2><p>相对于二阶段提交，三阶段提交主要解决的单点故障问题，并减少了阻塞的时间。</p><p>因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。</p><h3 id="3-2-三阶段提交的缺点"><a href="#3-2-三阶段提交的缺点" class="headerlink" title="3.2. 三阶段提交的缺点"></a>3.2. 三阶段提交的缺点</h3><p>三阶段提交也会导致数据一致性问题。由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。</p><p>这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。</p><hr><p>欢迎扫码关注公众号：零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷。所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="3PC" scheme="https://ostenant.coding.me/tags/3PC/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(三) - 2PC协议</title>
    <link href="https://ostenant.coding.me/2018/04/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%B8%89)%20-%202PC%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ostenant.coding.me/2018/04/25/分布式理论(三) - 2PC协议/</id>
    <published>2018-04-25T14:22:00.000Z</published>
    <updated>2018-05-08T02:49:46.095Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于BASE理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法和协议。其中比较著名的有二阶提交协议（2 Phase Commitment Protocol），三阶提交协议（3 Phase Commitment Protocol）和Paxos算法。</p><a id="more"></a><p>本文要介绍的2PC协议，分为两个阶段提交一个事务。并通过协调者和各个参与者的配合，实现分布式一致性。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/2PC.png" alt=""></p><p>两个阶段事务提交协议，由协调者和参与者共同完成。</p><table><thead><tr><th style="text-align:left">角色</th><th style="text-align:left">XA概念</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">协调者</td><td style="text-align:left">事务管理器</td><td style="text-align:left">协调各个参与者，对分布式事务进行提交或回滚</td></tr><tr><td style="text-align:left">参与者</td><td style="text-align:left">资源管理器</td><td style="text-align:left">分布式集群中的节点</td></tr></tbody></table><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1. 分布式事务"></a>1. 分布式事务</h2><p>分布式事务是指会涉及到操作多个数据库的事务，其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。</p><p>分布式事务处理的关键是：</p><ol><li>需要记录事务在任何节点所做的所有动作；</li><li>事务进行的所有操作要么全部提交，要么全部回滚。</li></ol><h2 id="2-XA规范"><a href="#2-XA规范" class="headerlink" title="2. XA规范"></a>2. XA规范</h2><h3 id="2-1-XA规范的组成"><a href="#2-1-XA规范的组成" class="headerlink" title="2.1. XA规范的组成"></a>2.1. XA规范的组成</h3><p>XA规范是由 X/Open组织（即现在的 Open Group ）定义的分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括：</p><ul><li>应用程序（ AP ）</li><li>事务管理器（ TM ）：交易中间件等</li><li>资源管理器（ RM ）：关系型数据库等</li><li>通信资源管理器（ CRM ）：消息中间件等</li></ul><h3 id="2-2-XA规范的定义"><a href="#2-2-XA规范的定义" class="headerlink" title="2.2. XA规范的定义"></a>2.2. XA规范的定义</h3><p>XA规范定义了交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。而XA接口函数由数据库厂商提供。</p><blockquote><p>二阶提交协议和三阶提交协议就是基于XA规范提出的其中，二阶段提交就是实现XA分布式事务的关键。</p></blockquote><h3 id="2-3-XA规范编程规范"><a href="#2-3-XA规范编程规范" class="headerlink" title="2.3. XA规范编程规范"></a>2.3. XA规范编程规范</h3><ol><li><p>配置TM，给TM注册RM作为数据源。其中，一个TM可以注册多个RM。</p></li><li><p>AP向TM发起一个全局事务。这时，TM会发送一个XID（全局事务ID）通知各个RM。</p></li><li><p>AP从TM获取资源管理器的代理（例如：使用JTA接口，从TM管理的上下文中，获取出这个TM所管理的RM的JDBC连接或JMS连接）。</p></li><li><p>AP通过从TM中获取的连接，间接操作RM进行业务操作。TM在每次AP操作时把XID传递给RM，RM正是通过这个XID关联来操作和事务的关系的。</p></li><li><p>AP结束全局事务时，TM会通知RM全局事务结束。开始二段提交，也就是prepare - commit的过程。</p></li></ol><p>XA规范的流程，大致如图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/XA_SEQ.png" alt=""></p><h2 id="3-二阶段提交（2PC）"><a href="#3-二阶段提交（2PC）" class="headerlink" title="3. 二阶段提交（2PC）"></a>3. 二阶段提交（2PC）</h2><h3 id="3-1-二阶段提交的定义"><a href="#3-1-二阶段提交的定义" class="headerlink" title="3.1. 二阶段提交的定义"></a>3.1. 二阶段提交的定义</h3><p>二阶段提交的算法思路可以概括为：每个参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报，决定各参与者是否要提交操作还是中止操作。</p><p>所谓的两个阶段分别是：</p><ul><li>第一阶段：准备阶段（投票阶段）</li><li>第二阶段：提交阶段（执行阶段）</li></ul><h4 id="3-1-1-准备阶段"><a href="#3-1-1-准备阶段" class="headerlink" title="3.1.1. 准备阶段"></a>3.1.1. 准备阶段</h4><p>准备阶段分为三个步骤：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/2PC_1.png" alt=""></p><p>a. 事务询问</p><blockquote><p>协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。</p></blockquote><p>b. 执行事务</p><blockquote><p>各参与者节点执行事务操作。如果本地事务成功，将Undo和Redo信息记入事务日志中，但不提交；否则，直接返回失败，退出执行。</p></blockquote><p>c. 各参与者向协调者反馈事务询问的响应</p><blockquote><p>如果参与者成功执行了事务操作，那么就反馈给协调者 Yes响应，表示事务可以执行提交；如果参与者没有成功执行事务，就返回No给协调者，表示事务不可以执行提交。</p></blockquote><h4 id="3-1-2-提交阶段"><a href="#3-1-2-提交阶段" class="headerlink" title="3.1.2. 提交阶段"></a>3.1.2. 提交阶段</h4><p>在提交阶段中，会根据准备阶段的投票结果执行2种操作：执行事务提交，中断事务。</p><p><strong>提交事务过程如下：</strong></p><p><img src="http://ols3fdyll.bkt.clouddn.com/2PC_21.png" alt=""></p><p>a. 发送提交请求</p><blockquote><p>协调者向所有参与者发出commit请求。</p></blockquote><p>b. 事务提交</p><blockquote><p>参与者收到commit请求后，会正式执行事务提交操作，并在完成提交之后，释放整个事务执行期间占用的事务资源。</p></blockquote><p>c. 反馈事务提交结果</p><blockquote><p>参与者在完成事务提交之后，向协调者发送Ack信息。</p></blockquote><p>d. 事务提交确认</p><blockquote><p>协调者接收到所有参与者反馈的Ack信息后，完成事务。</p></blockquote><p><strong>中断事务过程如下：</strong></p><p><img src="http://ols3fdyll.bkt.clouddn.com/2PC_22.png" alt=""></p><p>a. 发送回滚请求</p><blockquote><p>协调者向所有参与者发出Rollback请求。</p></blockquote><p>b. 事务回滚</p><blockquote><p>参与者接收到Rollback请求后，会利用其在提交阶段种记录的Undo信息，来执行事务回滚操作。在完成回滚之后，释放在整个事务执行期间占用的资源。</p></blockquote><p>c. 反馈事务回滚结果</p><blockquote><p>参与者在完成事务回滚之后，想协调者发送Ack信息。</p></blockquote><p>d. 事务中断确认</p><blockquote><p>协调者接收到所有参与者反馈的Ack信息后，完成事务中断。</p></blockquote><h3 id="3-1-二阶段提交的优缺点"><a href="#3-1-二阶段提交的优缺点" class="headerlink" title="3.1. 二阶段提交的优缺点"></a>3.1. 二阶段提交的优缺点</h3><ul><li>优点：原理简单，实现方便。</li><li>缺点：同步阻塞，单点问题，数据不一致，容错性不好。</li></ul><h4 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h4><p>在二阶段提交的过程中，所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。</p><h4 id="单点问题"><a href="#单点问题" class="headerlink" title="单点问题"></a>单点问题</h4><p>协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转。更重要的是，其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。</p><h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><p>假设当协调者向所有的参与者发送commit请求之后，发生了局部网络异常，或者是协调者在尚未发送完所有 commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了commit请求。这将导致严重的数据不一致问题。</p><h4 id="容错性不好"><a href="#容错性不好" class="headerlink" title="容错性不好"></a>容错性不好</h4><p>如果在二阶段提交的提交询问阶段中，参与者出现故障，导致协调者始终无法获取到所有参与者的确认信息，这时协调者只能依靠其自身的超时机制，判断是否需要中断事务。显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>对于2PC协议存在的同步阻塞、单点问题，将在下一篇文章的3PC协议中引入解决方案。</p><hr><p>欢迎扫码关注公众号：零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于BASE理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法和协议。其中比较著名的有二阶提交协议（2 Phase Commitment Protocol），三阶提交协议（3 Phase Commitment Protocol）和Paxos算法。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="2PC" scheme="https://ostenant.coding.me/tags/2PC/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(二) - BASE理论</title>
    <link href="https://ostenant.coding.me/2018/04/24/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%BA%8C)%20-%20BASE%E7%90%86%E8%AE%BA/"/>
    <id>https://ostenant.coding.me/2018/04/24/分布式理论(二) - BASE理论/</id>
    <published>2018-04-24T12:41:00.000Z</published>
    <updated>2018-05-08T02:49:46.095Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，才用适当的方式来使系统打到最终一致性。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-CAP的3选2伪命题"><a href="#1-CAP的3选2伪命题" class="headerlink" title="1. CAP的3选2伪命题"></a>1. CAP的3选2伪命题</h2><p>实际上，不是为了P（分区容错性），必须在C（一致性）和A（可用性）之间任选其一。分区的情况很少出现，CAP在大多时间能够同时满足C和A。</p><p>对于分区存在或者探知其影响的情况下，需要提供一种预备策略做出处理：</p><ul><li>探知分区的发生；</li><li>进入显示的分区模式，限制某些操作；</li><li>启动恢复过程，恢复数据一致性，补偿分区发生期间的错误。</li></ul><h2 id="2-BASE理论简介"><a href="#2-BASE理论简介" class="headerlink" title="2. BASE理论简介"></a>2. BASE理论简介</h2><p>BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p><p>其核心思想是：</p><blockquote><p>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p></blockquote><h2 id="3-BASE理论的内容"><a href="#3-BASE理论的内容" class="headerlink" title="3. BASE理论的内容"></a>3. BASE理论的内容</h2><ul><li>基本可用（Basically Available）</li><li>软状态（Soft State）</li><li>最终一致性（Eventually Consistent）</li></ul><p>下面展开讨论：</p><h3 id="3-1-基本可用"><a href="#3-1-基本可用" class="headerlink" title="3.1. 基本可用"></a>3.1. 基本可用</h3><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p><ol><li><p><strong>响应时间上的损失</strong>：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。</p></li><li><p><strong>功能上的损失</strong>：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p></li></ol><h3 id="3-2-软状态"><a href="#3-2-软状态" class="headerlink" title="3.2. 软状态"></a>3.2. 软状态</h3><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p><p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><h3 id="3-3-最终一致性"><a href="#3-3-最终一致性" class="headerlink" title="3.3. 最终一致性"></a>3.3. 最终一致性</h3><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p><p>而在实际工程实践中，最终一致性分为5种：</p><h4 id="3-3-1-因果一致性（Causal-consistency）"><a href="#3-3-1-因果一致性（Causal-consistency）" class="headerlink" title="3.3.1. 因果一致性（Causal consistency）"></a>3.3.1. 因果一致性（Causal consistency）</h4><p>因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。</p><h4 id="3-3-2-读己之所写（Read-your-writes）"><a href="#3-3-2-读己之所写（Read-your-writes）" class="headerlink" title="3.3.2. 读己之所写（Read your writes）"></a>3.3.2. 读己之所写（Read your writes）</h4><p>读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p><h4 id="3-3-3-会话一致性（Session-consistency）"><a href="#3-3-3-会话一致性（Session-consistency）" class="headerlink" title="3.3.3. 会话一致性（Session consistency）"></a>3.3.3. 会话一致性（Session consistency）</h4><p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p><h4 id="3-3-4-单调读一致性（Monotonic-read-consistency）"><a href="#3-3-4-单调读一致性（Monotonic-read-consistency）" class="headerlink" title="3.3.4. 单调读一致性（Monotonic read consistency）"></a>3.3.4. 单调读一致性（Monotonic read consistency）</h4><p>单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p><h4 id="3-3-5-单调写一致性（Monotonic-write-consistency）"><a href="#3-3-5-单调写一致性（Monotonic-write-consistency）" class="headerlink" title="3.3.5. 单调写一致性（Monotonic write consistency）"></a>3.3.5. 单调写一致性（Monotonic write consistency）</h4><p>单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p><blockquote><p>在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。</p></blockquote><p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p><hr><p>欢迎扫码关注公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，才用适当的方式来使系统打到最终一致性。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="BASE" scheme="https://ostenant.coding.me/tags/BASE/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论(一) - CAP定理</title>
    <link href="https://ostenant.coding.me/2018/04/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%B8%80)%20-%20CAP%E5%AE%9A%E7%90%86/"/>
    <id>https://ostenant.coding.me/2018/04/23/分布式理论(一) - CAP定理/</id>
    <published>2018-04-23T12:33:00.000Z</published>
    <updated>2018-05-08T02:49:46.094Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这三个基本需求，最多只能同时满足其中的2个。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/CAP.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-CAP原则简介"><a href="#1-CAP原则简介" class="headerlink" title="1. CAP原则简介"></a>1. CAP原则简介</h2><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Consistency（一致性）</td><td style="text-align:left">指数据在多个副本之间能够保持一致的特性（严格的一致性）</td></tr><tr><td style="text-align:left">Availability（可用性）</td><td style="text-align:left">指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）</td></tr><tr><td style="text-align:left">Partition tolerance（分区容错性）</td><td style="text-align:left">分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障</td></tr></tbody></table><p><strong>什么是分区？</strong></p><blockquote><p>在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域，这就是分区。</p></blockquote><h2 id="2-CAP原则论证"><a href="#2-CAP原则论证" class="headerlink" title="2. CAP原则论证"></a>2. CAP原则论证</h2><p>如图所示，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/CAP_prove.png" alt=""></p><ul><li>在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。</li><li>在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。</li><li>在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</li></ul><p>如图所示，这是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库V0为V1。分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/CAP_prove2.png" alt=""></p><p>根据CAP原则定义，系统的一致性、可用性和分区容错性细分如下：</p><ul><li>一致性：N1和N2的数据库V之间的数据是否完全一样。</li><li>可用性：N1和N2的对外部的请求能否做出正常的响应。</li><li>分区容错性：N1和N2之间的网络是否互通。</li></ul><p>这是正常运作的场景，也是理想的场景。作为一个分布式系统，它和单机系统的最大区别，就在于网络。现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常。相当于要满足分区容错性，能不能同时满足一致性和可用性呢？还是说要对他们进行取舍？</p><p><img src="http://ols3fdyll.bkt.clouddn.com/CAP_prove3.png" alt=""></p><p>假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1。由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0。这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？</p><p>这里有两种选择：</p><ul><li>第一：牺牲数据一致性，保证可用性。响应旧的数据V0给用户。</li><li>第二：牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。</li></ul><p>这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p><h2 id="3-CAP原则权衡"><a href="#3-CAP原则权衡" class="headerlink" title="3. CAP原则权衡"></a>3. CAP原则权衡</h2><p>通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p><h3 id="3-1-CA-without-P"><a href="#3-1-CA-without-P" class="headerlink" title="3.1. CA without P"></a>3.1. CA without P</h3><p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。</p><h3 id="3-2-CP-without-A"><a href="#3-2-CP-without-A" class="headerlink" title="3.2. CP without A"></a>3.2. CP without A</h3><p>如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p><h3 id="3-3-AP-wihtout-C"><a href="#3-3-AP-wihtout-C" class="headerlink" title="3.3. AP wihtout C"></a>3.3. AP wihtout C</h3><p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>对于多数大型互联网应用的场景，主机众多、部署分散。而且现在的集群规模越来越大，所以节点故障、网络故障是常态。这种应用一般要保证服务可用性达到N个9，即保证P和A，只有舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p><p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证CP，舍弃A，例如网络故障时只读不写。</p><p>孰优孰劣，没有定论，只能根据场景定夺，适合的才是最好的。</p><hr><p>欢迎扫码关注公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这三个基本需求，最多只能同时满足其中的2个。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="CAP" scheme="https://ostenant.coding.me/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker + Consul + Nginx + Consul-template的服务负载均衡实现</title>
    <link href="https://ostenant.coding.me/2018/02/08/%E5%9F%BA%E4%BA%8EDocker%20+%20Consul%20+%20Nginx%20+%20Consul-template%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ostenant.coding.me/2018/02/08/基于Docker + Consul + Nginx + Consul-template的服务负载均衡实现/</id>
    <published>2018-02-08T03:03:00.000Z</published>
    <updated>2018-05-08T02:49:46.095Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章使用 <code>Consul</code> 和 <code>Registrator</code> 在 <code>docker</code> 的容器环境中搭建了<strong>服务注册和发现</strong>集群。在服务发现和注册的基础上，本文将引入 <code>Nginx</code>反向代理服务器和 <code>Consul-template</code> 组件，实现动态的<strong>服务负载均衡</strong>。</p><a id="more"></a><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-工具介绍"><a href="#1-工具介绍" class="headerlink" title="1. 工具介绍"></a>1. 工具介绍</h2><h2 id="1-1-Nginx"><a href="#1-1-Nginx" class="headerlink" title="1.1. Nginx"></a>1.1. Nginx</h2><p>一个高性能的 <code>HTTP</code> 和<strong>反向代理服务器</strong>，用于前端访问流量到后台应用服务器<strong>负载均衡</strong>和<strong>请求转发</strong>。</p><h2 id="1-2-Consul-template"><a href="#1-2-Consul-template" class="headerlink" title="1.2. Consul-template"></a>1.2. Consul-template</h2><p><code>Consul-template</code> 是 <code>HashiCorp</code> 基于 <code>Consul</code> 所提供的可扩展的工具，通过监听 <code>Consul</code> 中的<strong>数据变化</strong>，动态地修改一些<strong>配置文件</strong>中地<strong>模板</strong>。常用于在 <code>Nginx</code>、<code>HAProxy</code> 上动态配置健康状态下的客户端反向代理信息。</p><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h2><ul><li>通过 <code>Nginx</code> 自身实现<strong>负载均衡</strong>和<strong>请求转发</strong>；</li><li>通过 <code>Consul-template</code> 的 <code>config</code> 功能实时监控 <code>Consul</code> 集群节点的<strong>服务</strong>和<strong>数据</strong>的变化；</li><li>实时的用 <code>Consul</code> 节点的信息<strong>替换</strong> <code>Nginx</code> 配置文件的<strong>模板</strong>，并<strong>重新加载</strong>配置文件；</li></ul><blockquote><p><code>Consul-template</code> 和 <code>nginx</code> 必须安装在同一台机器上，因为 <code>Consul-template</code> 需要动态修改 <code>nginx</code> 的配置文件 <code>nginx.conf</code>，然后执行 <code>nginx -s reload</code> 命令进行路由更新，达到<strong>动态负载均衡</strong>的目的。</p></blockquote><h3 id="2-1-传统负载均衡"><a href="#2-1-传统负载均衡" class="headerlink" title="2.1. 传统负载均衡"></a>2.1. 传统负载均衡</h3><p>传统的负载均衡，就是 <code>Client</code> 支姐访问 <code>Nginx</code>，然后被转发到后端某一台 <code>Web Server</code>。如果后端有<strong>添加</strong>/<strong>删除</strong> <code>Web Server</code>，运维需要手动改下 <code>nginx.conf</code> ，然后<strong>重新载入配置</strong>，就可以动态的调整负载均衡。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/tranditional_nginx3.png" alt=""></p><h3 id="2-2-自动负载均衡"><a href="#2-2-自动负载均衡" class="headerlink" title="2.2. 自动负载均衡"></a>2.2. 自动负载均衡</h3><p>再看看基于服务自动发现和注册的负载均衡，负载均衡的方式没有变，只是多了一些<strong>外围组件</strong>，当然这些组件对 <code>Client</code> 是不可见的，<code>client</code> 依然只能看到 <code>Nginx</code> 入口，访问方式也没变化。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/service_registry_nginx.png" alt=""></p><p><code>Nginx</code> 的动态负载均衡实现流程如下：</p><ol><li>以相同的 <code>Consul</code> <strong>标签</strong>对 <code>Web Server</code> 进行<strong>服务标记</strong>和<strong>分类</strong>，<strong>新增</strong>或者<strong>删除</strong> <code>Web Server</code> 服务器节点；</li><li><code>Registrator</code> <strong>监控</strong>到 <code>Web Server</code> 的状态更新，自动在 <code>Consul</code>服务注册中心将它<strong>注册</strong>或者<strong>注销</strong>；</li><li><code>Consul-template</code> 订阅了 <code>Consul</code> 服务注册中心的<strong>服务消息</strong>，接收到 <code>Consul</code> 的消息推送，即 <code>Web Server</code> 服务节点<strong>状态</strong>发生改变。</li><li><code>Consul-template</code> 自动去修改和<strong>替换</strong> <code>Nginx</code> 服务器下的 <code>nginx</code>配置文件中的<strong>模板</strong>，并<strong>重新加载</strong>服务达到自动负载均衡的目的。</li></ol><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3. 环境准备"></a>3. 环境准备</h2><h3 id="3-1-系统环境"><a href="#3-1-系统环境" class="headerlink" title="3.1. 系统环境"></a>3.1. 系统环境</h3><table><thead><tr><th style="text-align:left">软件</th><th style="text-align:left">版本</th></tr></thead><tbody><tr><td style="text-align:left">操作系统</td><td style="text-align:left">Ubuntu：16.04 x86_64，内核：4.8.0-58-generic</td></tr><tr><td style="text-align:left">docker</td><td style="text-align:left">Docker version 1.12.6, build 78d1802</td></tr><tr><td style="text-align:left">docker-compose</td><td style="text-align:left">docker-compose version 1.8.0</td></tr></tbody></table><h3 id="3-2-节点规划"><a href="#3-2-节点规划" class="headerlink" title="3.2. 节点规划"></a>3.2. 节点规划</h3><table><thead><tr><th style="text-align:left">主机IP</th><th style="text-align:left">组件</th></tr></thead><tbody><tr><td style="text-align:left">192.168.1.181</td><td style="text-align:left">Consul Server, Registrator, Nginx, Consul-template</td></tr><tr><td style="text-align:left">192.168.1.186</td><td style="text-align:left">Consul Server, Registrator, Nginx, Consul-template</td></tr><tr><td style="text-align:left">192.168.1.182</td><td style="text-align:left">Consul Client, Registrator, Client WebApp1, Server WebApp1, Server WebApp2</td></tr><tr><td style="text-align:left">192.168.1.183</td><td style="text-align:left">Consul Client, Registrator, Client WebApp2, Server WebApp3, Server WebApp4</td></tr><tr><td style="text-align:left">192.168.1.185</td><td style="text-align:left">Consul Client, Registrator, Client WebApp3, Server WebApp5, Server WebApp6</td></tr></tbody></table><ul><li><strong>Client WebApp</strong>：提供基于<code>Thrift</code>的<code>RPC</code>客户端和基于<code>Http</code>协议的<code>RESTful</code>客户端，用于访问 <code>Server</code> 程序。</li><li><strong>Server WebApp</strong>：提供基于<code>Thrift</code>的<code>RPC</code>服务端和基于<code>Http</code>协议的<code>RESTful</code>服务端，供 <code>Client</code> 程序调用。</li></ul><p>这里的3台主机 - <code>192.168.1.182</code>、<code>192.168.1.183</code> 和 <code>192.168.1.185</code>，每台主机部署两个 <code>Client WebApp</code> 容器和一个 <code>Client Server</code> 容器，用于模拟<strong>服务层</strong>的负载均衡。</p><h3 id="3-3-镜像构建"><a href="#3-3-镜像构建" class="headerlink" title="3.3. 镜像构建"></a>3.3. 镜像构建</h3><ul><li><strong>Consul</strong>：consul:latest</li><li><strong>Registrator</strong>：gliderlabs/registrator:latest</li><li><strong>Nginx</strong>和<strong>Consul-template</strong>：liberalman/nginx-consul-template:latest</li><li><strong>Client WebApp</strong>：test-client:latest</li><li><strong>Server WebApp</strong>：test-server:latest</li></ul><p>这里先说说 <code>test-client</code> 和 <code>test-server</code> 的镜像构建：</p><ol><li>克隆项目到本地项目环境： <a href="https://github.com/ostenant/spring-cloud-starter-thrift" target="_blank" rel="noopener">https://github.com/ostenant/spring-cloud-starter-thrift</a></li><li>切换到子模块 <code>spring-cloud-starter-thrift-examples</code> 下的 <code>test</code> 目录，执行命令 <code>mvn clean package</code> 进行程序打包。</li><li>分别将 <code>test-client</code> 和 <code>test-server</code> 项目<strong>根目录</strong>下的 <code>Dockerfile</code> 文件和<code>target</code>目录下的 <code>target/*.jar</code>程序拷贝到 <code>192.168.1.182</code> 、<code>192.168.1.183</code> 和 <code>192.168.1.185</code> 目录下。</li><li>进入<strong>客户端</strong> <code>Dockerfile</code> 所在目录，对<strong>客户端</strong>程序 <code>test-client</code> 进行镜像构建，命令如下：<code>docker build . -t test-client:latest</code></li><li>进入<strong>服务端</strong> <code>Dockerfile</code> 所在目录，对<strong>服务端</strong>程序 <code>test-server</code> 进行镜像构建，命令如下：<code>docker build . -t test-server:latest</code></li></ol><p>构建完成后查看本地镜像库：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Test_Client_Test_Server_docker_images.png" alt=""></p><h3 id="3-4-部署模型"><a href="#3-4-部署模型" class="headerlink" title="3.4. 部署模型"></a>3.4. 部署模型</h3><p>五台主机，其中 <code>192.168.1.181</code> 和 <code>192.168.1.186</code> 两台主机的主要作用如下：</p><ol><li>作为<strong>负载均衡转发器</strong> (这里只是演示，可以通过 <code>KeepAlived</code> 实现 <code>Nginx</code> 的<code>HA</code>)，将前端访问流量经过<strong>负载算法</strong>一次转发到后台 <code>Client WebApp</code> 。</li><li>以 <code>Server</code>模式启动 <code>Consul</code>节点，其中一台作为整个<strong>服务发现与注册集群</strong>的 <code>leader</code>， 用于<strong>同步</strong>和<strong>持久化</strong>其余三台 <code>Client</code> 模式的 <code>Consul</code> 节点的<strong>数据</strong>和<strong>状态信息</strong>。</li></ol><p>其余三台主机 - <code>192.168.1.182</code>、<code>192.168.1.183</code> 和 <code>192.168.1.185</code>，充当的角色如下：</p><ol><li>每台分别以 <code>Client</code> 模式部署 <code>Consul</code> 节点，用于<strong>注册</strong>和<strong>发现</strong>本机 <code>docker</code> 容器暴露的服务，同时和 <code>Consul Server</code> 的  <code>leader</code> 节点进行<strong>服务状态同步</strong>。</li><li>分别启动一个 <code>Client WebApp</code> 容器实例和两个 <code>Server WebApp</code> 容器实例，将 <code>Client WebApp</code> 的请求根据<strong>服务层</strong>的负载算法<strong>二次转发</strong>到 <code>Server WebApp</code> 中的任意一台上完成具体的业务处理。</li></ol><p><img src="http://ols3fdyll.bkt.clouddn.com/deploy_integration_1.png" alt=""></p><p>这里有两次服务转发操作：</p><ul><li><strong>接入层的转发：</strong>两台 <code>Nginx</code> 服务器将客户流量，经由<strong>一次转发</strong>至三个 <code>Client WebApp</code> 服务实例中任意一个做处理。</li><li><strong>服务层的转发：</strong>三个 <code>Client WebApp</code>服务实例其中之一，根据从<strong>服务注册中心</strong>拉取的健康的<strong>服务缓存列表</strong>，将请求<strong>二次转发</strong>至六个 <code>Server WebApp</code>服务实例其中之一做处理。</li></ul><h3 id="3-5-开始搭建"><a href="#3-5-开始搭建" class="headerlink" title="3.5. 开始搭建"></a>3.5. 开始搭建</h3><h3 id="3-5-1-Consul-Server主机"><a href="#3-5-1-Consul-Server主机" class="headerlink" title="3.5.1. Consul Server主机"></a>3.5.1. Consul Server主机</h3><p>(a). 分别编写 <code>docker-compose.yml</code>，注意 <code>Registrator</code> 需要配置各自的 <code>IP</code>地址。</p><ul><li><strong>主机：192.168.1.181</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  load_balancer:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">liberalman/nginx-consul-template:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">lb</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="attr">      - consul_server_master:</span><span class="string">consul</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  consul_server_master:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">consul_server_master</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-server</span> <span class="bullet">-bootstrap-expect</span> <span class="number">1</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="bullet">-node</span> <span class="string">consul_server_master</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">registrator</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="attr">      - consul_server_master:</span><span class="string">consul</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="attr">consul://192.168.1.181:8500</span></span><br></pre></td></tr></table></figure><ul><li><strong>主机：192.168.1.186</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  load_balancer:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">liberalman/nginx-consul-template:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">lb</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="attr">      - consul_server_slave:</span><span class="string">consul</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  consul_server_slave:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">consul_server_slave</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-server</span> <span class="bullet">-join=192.168.1.181</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.186</span> <span class="bullet">-node</span> <span class="string">consul_server_slave</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">registrator</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="attr">      - consul_server_slave:</span><span class="string">consul</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.186</span> <span class="attr">consul://192.168.1.186:8500</span></span><br></pre></td></tr></table></figure><p>(b). 在两台主机上分别通过 <code>docker-compose</code> 启动多容器应用，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>这是在主机 <code>192.168.1.181</code> 上运行启动命令时的输出，可以看到 <code>docker-compose</code> 启动时会先去检查<strong>目标镜像文件</strong>是否拉取到本地，然后依次<strong>创建</strong>并<strong>启动</strong> <code>docker-compose.yml</code> 文件配置的<strong>容器实例</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_compose_consul_server_1_console_output.png" alt=""></p><p>(c). 查看正常启动的容器进程，观察<code>Consul</code>、<code>Registrator</code> 和 <code>Nginx</code>/<code>Consul-template</code>的容器都正常启动。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_ps_consul_server_1.png" alt=""></p><p>(d). 利用 <code>docker-compose</code>，以相同的方式在主机 <code>192.168.1.186</code> 上启动所配置的容器服务实例，查看启动状态如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_ps_consul_server_2.png" alt=""></p><p>(e). 访问 <code>http://IP:8500</code> 查看 <code>Consul Server</code> 的<strong>节点信息</strong>和<strong>服务注册列表</strong>。</p><ul><li>节点信息：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_server_master_ui2.png" alt=""></p><ul><li>服务状态列表：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_server_master_ui.png" alt=""></p><p>两台 <code>Consul Server</code> 主机上的容器服务实例均正常启动！</p><h3 id="3-5-2-Consul-Client主机"><a href="#3-5-2-Consul-Client主机" class="headerlink" title="3.5.2. Consul Client主机"></a>3.5.2. Consul Client主机</h3><p>一般情况下，我们把 <code>Consul</code> 作为服务注册与发现中心，会使用它提供的<strong>服务定义</strong> (<code>Service Definition</code>) 和<strong>健康检查定义</strong> (<code>Health Check Definition</code>) 功能，相关配置说明参考如下：</p><h4 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h4><table><thead><tr><th style="text-align:left">环境变量Key</th><th style="text-align:left">环境变量Value</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SERVICE_ID</td><td style="text-align:left">web-001</td><td style="text-align:left">可以为GUID或者可读性更强变量，保证不重复</td></tr><tr><td style="text-align:left">SERVICE_NAME</td><td style="text-align:left">web</td><td style="text-align:left">如果ID没有设置，Consul会将name作为id，则有可能注册失败</td></tr><tr><td style="text-align:left">SERVICE_TAGS</td><td style="text-align:left">nodejs,web</td><td style="text-align:left">服务的标签，用逗号分隔，开发者可以根据标签来查询一些信息</td></tr><tr><td style="text-align:left">SERVICE_IP</td><td style="text-align:left">内网IP</td><td style="text-align:left">要使用Consul，可访问的IP</td></tr><tr><td style="text-align:left">SERVICE_PORT</td><td style="text-align:left">50001</td><td style="text-align:left">应用的IP, 如果应用监听了多个端口，理应被视为多个应用</td></tr><tr><td style="text-align:left">SERVICE_IGNORE</td><td style="text-align:left">Boolean</td><td style="text-align:left">是否忽略本Container，可以为一些不需要注册的Container添加此属性</td></tr></tbody></table><h4 id="服健康检查定义"><a href="#服健康检查定义" class="headerlink" title="服健康检查定义"></a>服健康检查定义</h4><p>配置原则为: <code>SERVICE_XXX_*</code>。如果你的应用监听的是 <code>5000</code> 端口，则改为 <code>SERVICE_5000_CHECK_HTTP</code>，其它环境变量配置同理。</p><table><thead><tr><th style="text-align:left">环境变量Key</th><th style="text-align:left">环境变量Value</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">— 以下为HTTP模式</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_80_CHECK_HTTP</td><td style="text-align:left">/path_to_health_check</td><td style="text-align:left">你的健康状态检查的路径如 /status</td></tr><tr><td style="text-align:left">SERVICE_80_CHECK_INTERVAL</td><td style="text-align:left">15s</td><td style="text-align:left">15秒检查一次</td></tr><tr><td style="text-align:left">SERVICE_80_CHECK_TIMEOUT</td><td style="text-align:left">2s</td><td style="text-align:left">状态检查超时时间</td></tr><tr><td style="text-align:left">— 以下为HTTPS模式</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_HTTPS</td><td style="text-align:left">/path_to_health_check</td><td style="text-align:left">你的健康状态检查的路径如 /status</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_INTERVAL</td><td style="text-align:left">15s</td><td style="text-align:left">15秒检查一次</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_TIMEOUT</td><td style="text-align:left">2s</td><td style="text-align:left">状态检查超时时间</td></tr><tr><td style="text-align:left">— 以下为TCP模式</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_TCP</td><td style="text-align:left">/path_to_health_check</td><td style="text-align:left">你的健康状态检查的路径如 /status</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_INTERVAL</td><td style="text-align:left">15s</td><td style="text-align:left">15秒检查一次</td></tr><tr><td style="text-align:left">SERVICE_443_CHECK_TIMEOUT</td><td style="text-align:left">2s</td><td style="text-align:left">状态检查超时时间</td></tr><tr><td style="text-align:left">— 使用脚本检查</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_CHECK_SCRIPT</td><td style="text-align:left">curl –silent –fail example.com</td><td style="text-align:left">如官方例子中的check_redis.py</td></tr><tr><td style="text-align:left">— 其他</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">SERVICE_CHECK_INITIAL_STATUS</td><td style="text-align:left">passing</td><td style="text-align:left">Consul默认注册后的服务为failed</td></tr></tbody></table><h4 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h4><p>(a). 分别编写 <code>docker-compose.yml</code>，同样注意 <code>Registrator</code> 需要配置各自的 <code>IP</code> 地址。<code>test-server</code> 和 <code>test-client</code> 的<strong>服务实例</strong>在配置时需要指定相关的<strong>环境变量</strong>。</p><ul><li><strong>主机：192.168.1.182</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  consul_client_01:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-retry-join</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.182</span> <span class="bullet">-node</span> <span class="string">consul_client_01</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.182</span> <span class="attr">consul://192.168.1.182:8500</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"16000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"30000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"18000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"32000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_client_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-client:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=my-web-server</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-client-http-service-01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/features</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:8080"</span></span><br></pre></td></tr></table></figure><ul><li><strong>主机：192.168.1.183</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  consul_client_02:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-retry-join</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.183</span> <span class="bullet">-node</span> <span class="string">consul_client_02</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.183</span> <span class="attr">consul://192.168.1.183:8500</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-03</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-03</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"16000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"30000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-04</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-04</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"18000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"32000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_client_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-client:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=my-web-server</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-client-http-service-02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/features</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:8080"</span></span><br></pre></td></tr></table></figure><ul><li><strong>主机：192.168.1.185</strong></li></ul><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  consul_client_03:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">consul:latest</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8300:8300"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8301:8301/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8302:8302/udp"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8400:8400"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8500:8500"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8600:8600"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">consul</span> <span class="string">agent</span> <span class="bullet">-retry-join</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.181</span> <span class="bullet">-advertise</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.185</span> <span class="bullet">-node</span> <span class="string">consul_client_03</span> <span class="bullet">-data-dir</span> <span class="string">/tmp/data-dir</span> <span class="bullet">-client</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="bullet">-ui</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  registrator:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gliderlabs/registrator:latest</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/tmp/docker.sock"</span></span><br><span class="line"><span class="attr">    command:</span>  <span class="bullet">-ip</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.185</span> <span class="attr">consul://192.168.1.185:8500</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-05</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-05</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"16000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"30000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_server_2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-server:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=test-server-http-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-server-http-service-06</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/health</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_NAME=test-server-thrift-service</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_TAGS=test-server-thrift-service-06</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_25000_CHECK_TCP=/</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"18000:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"32000:25000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  test_client_1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test-client:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_NAME=my-web-server</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_TAGS=test-client-http-service-03</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_INTERVAL=10s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_TIMEOUT=2s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVICE_8080_CHECK_HTTP=/features</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:8080"</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>我们使用的第三方镜像 <code>liberalman/nginx-consul-template</code>，<code>Nginx</code> 会把名称为 <code>my-web-server</code>的<strong>服务容器</strong>作为后台转发的<strong>目标服务器</strong>，因此，在 <code>test-client</code> 的配置项中，需要指定 <code>SERVICE_XXX_NAME</code> 为 <code>my-web-server</code>。当然你也可以自己<strong>制作镜像</strong>指定<strong>模板</strong>。</p></blockquote><p>(b). 在三台主机上使用 <code>docker-compose</code> 启动多容器应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>以主机 <code>192.168.1.182</code> 为例 (其余两台类似)，控制台日志显示，创建并启动 <code>docker-compose.yml</code> 文件配置的5个<strong>容器实例</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_compose_web_server_console_output.png" alt=""></p><p>(c). 查看正常启动的容器进程，观察到 <code>Consul</code>、一台<code>test-client</code> 和 两台<code>test-server</code>的容器都正常启动。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_ps_web_server_1.png" alt=""></p><p>(d). 在 <code>b</code> 操作中的控制台输出可以看到：<code>docker-compose</code> 并非按照 <code>docker-compose.yml</code> 文件中服务配置的<strong>先后顺序</strong>启动。 <code>registrator</code> 容器的启动依赖于 <code>consul</code> 容器，而此时 <code>consul</code> 还并未启动，就出现了 <code>registrator</code> 优先启动而<strong>异常退出</strong>的现象。解决方法是再运行一次 <code>docker-compose up -d</code> 命令。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_compose_web_server_console_output2.png" alt=""></p><p>(e). 再次查看容器进程，此时 <code>Registrator</code> 容器就已经正常启动了。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_ps_web_server_2.png" alt=""></p><p>(f). 以相同的方式在其余两台主机上<strong>重复</strong>以上操作，再次访问 <code>http://IP:8500</code> 查看 <code>Consul Server</code> 的<strong>节点信息</strong>和<strong>服务注册列表</strong>。</p><ul><li><code>Consul</code> 集群节点信息，包括两台 <code>Consul Server</code> 节点和一台 <code>Consul Client</code> 节点，节点右侧可以看到所有的<strong>服务注册列表</strong>和相关的<strong>健康检查结果</strong>：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_client_01%20.png" alt=""></p><ul><li><code>nginx</code> 服务状态列表，服务名称 <code>nginx-consul-template</code>，提供 <code>http</code> 服务，共有2个服务实例：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/nginx-consul-template.png" alt=""></p><ul><li><code>test-client</code> 服务状态列表，服务名称为 <code>my-web-server</code>，提供 <code>http</code> 服务，共有3个服务实例：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/my_web_app.png" alt=""></p><ul><li><code>test-server</code> 服务状态列表，服务名称为 <code>test-server-http-service</code> 和 <code>test-server-thrift-service</code>，分别对应6个 <code>http</code> 服务实例和 6个 <code>thrift</code> 服务实例：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/test-server-http-service.png" alt=""></p><p><img src="http://ols3fdyll.bkt.clouddn.com/test-server-thrift-service.png" alt=""></p><p>三台  <code>Consul Client</code> 主机上的容器服务实例均正常启动，服务注册和发现运行正常！</p><h2 id="4-结果验证"><a href="#4-结果验证" class="headerlink" title="4. 结果验证"></a>4. 结果验证</h2><h3 id="4-1-Nginx负载均衡"><a href="#4-1-Nginx负载均衡" class="headerlink" title="4.1. Nginx负载均衡"></a>4.1. Nginx负载均衡</h3><h4 id="4-1-1-访问Nginx"><a href="#4-1-1-访问Nginx" class="headerlink" title="4.1.1. 访问Nginx"></a>4.1.1. 访问Nginx</h4><p><code>Nginx</code> 默认访问端口号为<code>80</code>，任选一台 <code>Nginx</code> 访问，比如： <code>http://192.168.1.181/swagger-ui.html</code>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/test_client_swagger_ui.png" alt=""></p><p>请求转发至 <code>Test Client</code> 的 <code>Swagger</code>页面，表明 <code>nginx</code>配置文件 <code>nginx.conf</code> 被 <code>Consul-template</code> 成功修改。</p><h4 id="4-1-2-进入Nginx容器"><a href="#4-1-2-进入Nginx容器" class="headerlink" title="4.1.2. 进入Nginx容器"></a>4.1.2. 进入Nginx容器</h4><p>运行 <code>docker ps</code> 查看 <code>nginx-consul-template</code> 的容器 <code>ID</code>，比如这里是：<code>4f2731a7e0cb</code>。进入 <code>nginx-consul-template</code> 容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-enter 4f2731a7e0cb</span><br></pre></td></tr></table></figure><p>查看容器内部的进程列表：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/nginx_consul_template_ps_ef.png" alt=""></p><p>特别留意以下一行进程命令，这里完成了三步重要的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul-template -consul-addr=consul:8500 -template /etc/consul-templates/nginx.conf.ctmpl:/etc/nginx/conf.d/app.conf:nginx -s reload</span><br></pre></td></tr></table></figure><ol><li><code>Consul-template</code> 利用 <code>Consul</code> 上的<strong>服务信息</strong>对 <code>Nginx</code> 的<strong>配置文件模板</strong> <code>/etc/consul-templates/nginx.conf.ctmpl</code> 进行重新<strong>解析</strong>和<strong>渲染</strong>。</li><li><strong>渲染</strong>生成的 <code>nginx</code> 配置文件为 <code>/etc/nginx/conf.d/app.conf</code>。</li><li>进一步运行 <code>nginx -s reload</code> 重新加载 <code>app.conf</code>，更新<strong>路由转发列表</strong>。</li></ol><p>查看 <code>app.conf</code> 的配置项，发现三个 <code>test-client</code> 节点的 <code>IP:port</code> 都加入了<strong>路由转发列表</strong>中。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/nginx_consul_template_app_conf.png" alt=""></p><p>退出并关闭主机 <code>192.168.1.182</code> 上的 <code>test-client</code> 容器。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_stop_test-client.png" alt=""></p><p>再次查看 <code>app.conf</code>，可以发现<strong>路由节点</strong> <code>192.168.1.182:80</code> 已经从 <code>Nginx</code> 的<strong>路由转发列表</strong>上<strong>剔除</strong>掉了。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/nginx_consul_template_app_conf2.png" alt=""></p><p>同样的，重新启动 <code>test-client</code> 恢复容器，又可以发现 <code>Nginx</code> 的<strong>路由转发列表</strong> 再次自动将其添加!</p><h3 id="4-2-服务负载均衡"><a href="#4-2-服务负载均衡" class="headerlink" title="4.2. 服务负载均衡"></a>4.2. 服务负载均衡</h3><h4 id="4-2-1-接口测试"><a href="#4-2-1-接口测试" class="headerlink" title="4.2.1. 接口测试"></a>4.2.1. 接口测试</h4><p><code>test-client</code> 通过 <code>http</code> 通信方式请求任意一台 <code>test-server</code>，返回响应结果 (请求处理时间 <code>ms</code> )。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/test_clent_api_test2.png" alt=""></p><p><code>test-client</code> 通过 <code>thrift</code> 通信方式请求任意一台 <code>test-server</code>，返回响应结果 (请求处理时间 <code>ms</code> )。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/test_clent_api_test.png" alt=""></p><h4 id="4-2-3-日志分析"><a href="#4-2-3-日志分析" class="headerlink" title="4.2.3. 日志分析"></a>4.2.3. 日志分析</h4><p><strong>服务的负载均衡</strong>并不是很好观察，这里直接截取了一段 <code>test-client</code> 的<strong>服务缓存列表</strong>动态定时刷新时打印的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">2018-02-09 13:15:55.157  INFO 1 --- [erListUpdater-1] t.c.l.ThriftConsulServerListLoadBalancer : Refreshed thrift serverList: [</span><br><span class="line"><span class="built_in">test</span>-server-thrift-service: [</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-01], host=<span class="string">'192.168.1.182'</span>, port=30000, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-02], host=<span class="string">'192.168.1.182'</span>, port=32000, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-03], host=<span class="string">'192.168.1.183'</span>, port=30000, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-04], host=<span class="string">'192.168.1.183'</span>, port=32000, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-05], host=<span class="string">'192.168.1.185'</span>, port=30000, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'test-server-thrift-service'</span>, tags=[<span class="built_in">test</span>-server-thrift-service-06], host=<span class="string">'192.168.1.185'</span>, port=32000, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;</span><br><span class="line">],</span><br><span class="line"><span class="built_in">test</span>-server-http-service: [</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-01], host=<span class="string">'192.168.1.182'</span>, port=16000, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-02], host=<span class="string">'192.168.1.182'</span>, port=18000, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-03], host=<span class="string">'192.168.1.183'</span>, port=16000, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-04], host=<span class="string">'192.168.1.183'</span>, port=18000, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-05], host=<span class="string">'192.168.1.185'</span>, port=16000, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'test-server-http-service'</span>, tags=[<span class="built_in">test</span>-server-http-service-06], host=<span class="string">'192.168.1.185'</span>, port=18000, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;</span><br><span class="line">],</span><br><span class="line">my-web-server: [</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_01'</span>, serviceId=<span class="string">'my-web-server'</span>, tags=[<span class="built_in">test</span>-client-http-service-01], host=<span class="string">'192.168.1.182'</span>, port=80, address=<span class="string">'192.168.1.182'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_02'</span>, serviceId=<span class="string">'my-web-server'</span>, tags=[<span class="built_in">test</span>-client-http-service-02], host=<span class="string">'192.168.1.183'</span>, port=80, address=<span class="string">'192.168.1.183'</span>, isHealth=<span class="literal">true</span>&#125;,</span><br><span class="line">ThriftServerNode&#123;node=<span class="string">'consul_client_03'</span>, serviceId=<span class="string">'my-web-server'</span>, tags=[<span class="built_in">test</span>-client-http-service-03], host=<span class="string">'192.168.1.185'</span>, port=80, address=<span class="string">'192.168.1.185'</span>, isHealth=<span class="literal">true</span>&#125;</span><br><span class="line">]]</span><br></pre></td></tr></table></figure><h4 id="服务实例"><a href="#服务实例" class="headerlink" title="服务实例"></a>服务实例</h4><ul><li><code>test-server-http-service</code> 所有<strong>健康</strong>的服务实例：</li></ul><table><thead><tr><th>服务IP地址</th><th>服务端口</th><th>服务标签</th></tr></thead><tbody><tr><td>192.168.1.182</td><td>16000</td><td>test-server-http-service-01</td></tr><tr><td>192.168.1.182</td><td>18000</td><td>test-server-http-service-02</td></tr><tr><td>192.168.1.183</td><td>16000</td><td>test-server-http-service-03</td></tr><tr><td>192.168.1.183</td><td>18000</td><td>test-server-http-service-04</td></tr><tr><td>192.168.1.185</td><td>16000</td><td>test-server-http-service-05</td></tr><tr><td>192.168.1.185</td><td>18000</td><td>test-server-http-service-06</td></tr></tbody></table><ul><li><code>test-server-thrift-service</code> 所有<strong>健康</strong>的服务实例：</li></ul><table><thead><tr><th>服务IP地址</th><th>服务端口</th><th>服务标签</th></tr></thead><tbody><tr><td>192.168.1.182</td><td>30000</td><td>test-server-thrift-service-01</td></tr><tr><td>192.168.1.182</td><td>32000</td><td>test-server-thrift-service-02</td></tr><tr><td>192.168.1.183</td><td>30000</td><td>test-server-thrift-service-03</td></tr><tr><td>192.168.1.183</td><td>32000</td><td>test-server-thrift-service-04</td></tr><tr><td>192.168.1.185</td><td>30000</td><td>test-server-thrift-service-05</td></tr><tr><td>192.168.1.185</td><td>32000</td><td>test-server-thrift-service-06</td></tr></tbody></table><ul><li><code>my-web-server</code> 所有<strong>健康</strong>的服务实例：</li></ul><table><thead><tr><th>服务IP地址</th><th>服务端口</th><th>服务标签</th></tr></thead><tbody><tr><td>192.168.1.182</td><td>80</td><td>test-client-http-service-01</td></tr><tr><td>192.168.1.183</td><td>80</td><td>test-client-http-service-02</td></tr><tr><td>192.168.1.185</td><td>80</td><td>test-client-http-service-03</td></tr></tbody></table><p><code>spring-cloud-starter-thrift</code> 采用的<strong>轮询</strong>的转发策略，也就是说 <code>my-web-server</code> 会按<strong>次序循环往来</strong>地将 <code>http</code> 或者 <code>rpc</code> 请求分发到各自的 <code>6</code> 个<strong>服务实例</strong>完成处理。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文提供了一套基于<strong>微服务服务注册与发现体系</strong>和<strong>容器</strong>的<strong>高可用</strong> (<code>HA</code>) 解决方案，引入了<strong>接入层</strong>和<strong>服务层</strong>的<strong>自动负载均衡</strong>的实现，详细给出了<strong>实践方案</strong>和<strong>技术手段</strong>！</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章使用 &lt;code&gt;Consul&lt;/code&gt; 和 &lt;code&gt;Registrator&lt;/code&gt; 在 &lt;code&gt;docker&lt;/code&gt; 的容器环境中搭建了&lt;strong&gt;服务注册和发现&lt;/strong&gt;集群。在服务发现和注册的基础上，本文将引入 &lt;code&gt;Nginx&lt;/code&gt;反向代理服务器和 &lt;code&gt;Consul-template&lt;/code&gt; 组件，实现动态的&lt;strong&gt;服务负载均衡&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Consul" scheme="https://ostenant.coding.me/tags/Consul/"/>
    
      <category term="Nginx" scheme="https://ostenant.coding.me/tags/Nginx/"/>
    
      <category term="Consul-template" scheme="https://ostenant.coding.me/tags/Consul-template/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker + Consul + Registrator的服务注册与发现集群搭建</title>
    <link href="https://ostenant.coding.me/2018/02/05/%E5%9F%BA%E4%BA%8EDocker%20+%20Consul%20+%20Registrator%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://ostenant.coding.me/2018/02/05/基于Docker + Consul + Registrator的服务注册与发现集群搭建/</id>
    <published>2018-02-05T03:22:00.000Z</published>
    <updated>2018-05-08T02:49:46.096Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近年微服务架构在互联网应用领域中愈来愈火，引入微服务主要解决了单体应用<strong>多个模块的紧耦合</strong>、<strong>无法扩展</strong>和<strong>运维困难</strong>等问题。微服务架构就是按照<strong>功能粒度</strong>将业务模块进行<strong>垂直拆分</strong>，对单体应用本身进行<strong>服务化</strong>和<strong>组件化</strong>，每个组件单独部署为<strong>小应用</strong>（从<code>DB</code>到<code>UI</code>）。微服务与微服务之间通过<code>Service API</code>进行交互，同时为了支持<strong>水平扩展</strong>、<strong>性能提升</strong>和<strong>服务可用性</strong>，单个服务允许同时部署一个或者多个<strong>服务实例</strong>。在运行时，每个实例通常是一个<strong>云虚拟机</strong>或者<code>Docker</code><strong>容器</strong>。</p><a id="more"></a><p>微服务系统内部多个服务的实例之间如何通信？如何感知到彼此的存在和销毁？生产者服务如何知道消费者服务的地址？如何实现服务与注册中心的解耦？这就需要一个第三方的服务注册中心，提供对生产者服务节点的注册管理和消费者服务节点的发现管理。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-服务发现与注册"><a href="#1-服务发现与注册" class="headerlink" title="1. 服务发现与注册"></a>1. 服务发现与注册</h2><h3 id="1-1-具体流程"><a href="#1-1-具体流程" class="headerlink" title="1.1. 具体流程"></a>1.1. 具体流程</h3><ul><li><strong>服务注册中心：</strong>作为整个架构中的核心，要支持<strong>分布式</strong>、<strong>持久化存储</strong>，<strong>注册信息变动</strong>实时通知消费者。</li><li><strong>服务提供者：</strong>服务以 <code>docker</code> <strong>容器化</strong>方式部署(实现<strong>服务端口</strong>的<strong>动态生成</strong>)，可以通过 <code>docker-compose</code> 的方式来管理。通过 <code>Registrator</code> 检测到 <code>docker</code> 进程信息以完成服务的<strong>自动注册</strong>。</li><li><strong>服务消费者：</strong>要使用<strong>服务提供者</strong>提供的服务，和服务提供者往往是动态相互转位置的。</li></ul><p>一个较为完整的服务注册与发现流程如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Service_registry_component.png" alt=""></p><ol><li><strong>注册服务：</strong>服务提供者到注册中心<strong>注册</strong>；</li><li><strong>订阅服务：</strong>服务消费者到注册中心<strong>订阅</strong>服务信息，对其进行<strong>监听</strong>；</li><li><strong>缓存服务列表：</strong>本地<strong>缓存</strong>服务列表，减少与注册中心的网络通信；</li><li><strong>调用服务：</strong>先<strong>查找</strong>本地缓存，找不到再去注册中心<strong>拉取</strong>服务地址，然后发送服务请求；</li><li><strong>变更通知：</strong>服务节点<strong>变动</strong>时 (<strong>新增</strong>、<strong>删除</strong>等)，注册中心将通知监听节点，<strong>更新</strong>服务信息。</li></ol><h3 id="1-2-相关组件"><a href="#1-2-相关组件" class="headerlink" title="1.2. 相关组件"></a>1.2. 相关组件</h3><p>一个服务发现系统主要由三部分组成：</p><ol><li><strong>注册器(registrator)：</strong>根据服务运行状态，注册/注销服务。主要要解决的问题是，何时发起注册/注销动作。</li><li><strong>注册表(registry)：</strong>存储服务信息。常见的解决方案有zookeeper、etcd、cousul等。</li><li><strong>发现机制(discovery)：</strong>从注册表读取服务信息，给用户封装访问接口。</li></ol><h3 id="1-3-第三方实现"><a href="#1-3-第三方实现" class="headerlink" title="1.3. 第三方实现"></a>1.3. 第三方实现</h3><p>对于第三方的服务注册与发现的实现，现有的工具主要有以下三种：</p><ol><li><strong>zookeeper：</strong>一个高性能、分布式应用程序协调服务，用于名称服务、分布式锁定、共享资源同步和分布式配置管理。</li><li><strong>Etcd：</strong>一个采用HTTP协议的健/值对存储系统，主要用于共享配置和服务发现，提供的功能相对Zookeeper和Consul相对简单。</li><li><strong>Consul：</strong>一个分布式高可用的服务发现和配置共享的软件，支持服务发现与注册、多数据中心、健康检查和分布式键/值存储。</li></ol><p>简单对比：</p><blockquote><p>与Zookeeper和etcd不一样，Consul内嵌实现了服务发现系统，不需要构建自己的系统或使用第三方系统，客户只需要注册服务，并通过DNS或HTTP接口执行服务发现。</p></blockquote><h2 id="2-Consul和Registrator"><a href="#2-Consul和Registrator" class="headerlink" title="2. Consul和Registrator"></a>2. Consul和Registrator</h2><h3 id="2-1-Consul简介"><a href="#2-1-Consul简介" class="headerlink" title="2.1. Consul简介"></a>2.1. Consul简介</h3><p><strong>Consul是什么</strong></p><p><code>Consul</code> 是一种<strong>分布式</strong>的、<strong>高可用</strong>、<strong>支持水平扩展</strong>的的服务注册与发现工具。它大致包括以下特性：</p><ul><li><strong>服务发现：</strong> <code>Consul</code> 通过 <code>DNS</code> 或者 <code>HTTP</code> 接口使<strong>服务注册和服务发现</strong>变的很容易。一些外部服务，例如 <code>saas</code> 提供的也可以一样注册；</li><li><strong>健康检查：</strong>健康检测使 <code>consul</code> 可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面；</li><li><strong>键/值存储：</strong>一个用来<strong>存储动态配置</strong>的系统。提供简单的 <code>HTTP</code> 接口，可以在任何地方操作；</li><li><strong>多数据中心：</strong>支持<strong>多数据中心</strong>以避免<strong>单点故障</strong>，内外网的服务采用不同的端口进行监听。而其部署则需要考虑网络延迟, 分片等情况等。<code>zookeeper</code>和<code>etcd</code>均不提供多数据中心功能的支持；</li><li><strong>一致性算法：</strong>采用 <code>Raft</code> 一致性协议算法，比<code>Paxos</code>算法好用。 使用 <code>GOSSIP</code> 协议管理成员和广播消息, 并且支持 <code>ACL</code> 访问控制；</li><li><strong>服务管理Dashboard：</strong>提供一个 <code>Web UI</code> 的服务注册于<strong>健康状态监控</strong>的管理页面。</li></ul><p><strong>Consul的几个概念</strong></p><p>下图是<code>Consul</code>官方文档提供的架构设计图：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul-architecture.png" alt=""></p><p>图中包含两个<code>Consul</code>数据中心，每个数据中心都是一个<code>consul</code>的集群。在数据中心1中，可以看出<code>consul</code>的集群是由<code>N</code>个<code>SERVER</code>，加上<code>M</code>个<code>CLIENT</code>组成的。而不管是<code>SERVER</code>还是<code>CLIENT</code>，都是<code>consul</code>集群的一个节点。所有的服务都可以注册到这些节点上，正是通过这些节点实现服务注册信息的共享。除了这两个，还有一些小细节 一一 简单介绍。</p><ul><li><strong>CLIENT</strong></li></ul><p><code>CLIENT</code>表示<code>consul</code>的<code>client</code>模式，就是<strong>客户端模式</strong>。是<code>consul</code>节点的一种模式，这种模式下，所有注册到当前节点的服务会被<strong>转发</strong>到<code>SERVER</code>节点，本身是<strong>不持久化</strong>这些信息。</p><ul><li><strong>SERVER</strong></li></ul><p><code>SERVER</code>表示<code>consul</code>的<code>server</code>模式，表明这个<code>consul</code>是个<code>server</code>节点。这种模式下，功能和<code>CLIENT</code>都一样，唯一不同的是，它会把所有的信息<strong>持久化</strong>的本地。这样遇到故障，信息是可以被保留的。</p><ul><li><strong>SERVER-LEADER</strong></li></ul><p>中间那个<code>SERVER</code>下面有<code>LEADER</code>的描述，表明这个<code>SERVER</code>节点是它们的老大。和其它<code>SERVER</code>不一样的一点是，它需要负责<strong>同步注册信息</strong>给其它的<code>SERVER</code>，同时也要负责<strong>各个节点</strong>的<strong>健康监测</strong>。</p><ul><li><strong>其它信息</strong></li></ul><p>其它信息包括各个节点之间的<strong>通信方式</strong>，还有<strong>一些协议信息</strong>、<strong>算法</strong>。它们是用于保证节点之间的<strong>数据同步</strong>、<strong>实时性要求</strong>等等一系列集群问题的解决。这些有兴趣的自己看看官方文档。</p><h3 id="2-2-Registrator简介"><a href="#2-2-Registrator简介" class="headerlink" title="2.2. Registrator简介"></a>2.2. Registrator简介</h3><p><strong>什么是Registrator</strong><br><code>Registrator</code>是一个独立于服务注册表的<strong>自动服务注册/注销组件</strong>，一般以<code>Docker container</code>的方式进行部署。<code>Registrator</code>会自动侦测它所在的<strong>宿主机</strong>上的所有<code>Docker</code>容器状态（启用/销毁），并根据容器状态到对应的<strong>服务注册列表</strong>注册/注销服务。</p><p>事实上，<code>Registrator</code>通过读取同一台宿主机的其他容器<code>Container</code>的<strong>环境变量</strong>进行<strong>服务注册</strong>、<strong>健康检查定义</strong>等操作。</p><p><code>Registrator</code>支持<strong>可插拔式</strong>的<strong>服务注册表</strong>配置，目前支持包括<code>Consul</code>, <code>etcd</code>和<code>SkyDNS 2</code>三种注册工具。</p><h2 id="2-3-Docker安装Consul集群"><a href="#2-3-Docker安装Consul集群" class="headerlink" title="2.3. Docker安装Consul集群"></a>2.3. Docker安装Consul集群</h2><h3 id="2-3-1-集群节点规划"><a href="#2-3-1-集群节点规划" class="headerlink" title="2.3.1.  集群节点规划"></a>2.3.1.  集群节点规划</h3><p>我本地的使用的是<code>Ubuntu16.04</code>的虚拟机：</p><table><thead><tr><th>容器名称</th><th>容器IP地址</th><th>映射端口号</th><th>宿主机IP地址</th><th>服务运行模式</th></tr></thead><tbody><tr><td>node1</td><td>172.17.0.2</td><td>8500 -&gt; 8500</td><td>192.168.127.128</td><td>Server Master</td></tr><tr><td>node2</td><td>172.17.0.3</td><td>9500 -&gt; 8500</td><td>192.168.127.128</td><td>Server</td></tr><tr><td>node3</td><td>172.17.0.4</td><td>10500 -&gt; 8500</td><td>192.168.127.128</td><td>Server</td></tr><tr><td>node4</td><td>172.17.0.5</td><td>11500 -&gt; 8500</td><td>192.168.127.128</td><td>Client</td></tr></tbody></table><h3 id="2-3-2-Consul集群安装"><a href="#2-3-2-Consul集群安装" class="headerlink" title="2.3.2. Consul集群安装"></a>2.3.2. Consul集群安装</h3><p><code>Consul</code>的配置参数信息说明：</p><table><thead><tr><th>参数列表</th><th>参数的含义和使用场景说明</th></tr></thead><tbody><tr><td>advertise</td><td>通知展现地址用来改变我们给集群中的其他节点展现的地址，一般情况下-bind地址就是展现地址</td></tr><tr><td>bootstrap</td><td>用来控制一个server是否在bootstrap模式，在一个datacenter中只能有一个server处于bootstrap模式，当一个server处于bootstrap模式时，可以自己选举为raft leader</td></tr><tr><td>bootstrap-expect</td><td>在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用</td></tr><tr><td>bind</td><td>该地址用来在集群内部的通讯IP地址，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0</td></tr><tr><td>client</td><td>consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1</td></tr><tr><td>config-file</td><td>明确的指定要加载哪个配置文件</td></tr><tr><td>config-dir</td><td>配置文件目录，里面所有以.json结尾的文件都会被加载</td></tr><tr><td>data-dir</td><td>提供一个目录用来存放agent的状态，所有的agent允许都需要该目录，该目录必须是稳定的，系统重启后都继续存在</td></tr><tr><td>dc</td><td>该标记控制agent允许的datacenter的名称，默认是dc1</td></tr><tr><td>encrypt</td><td>指定secret key，使consul在通讯时进行加密，key可以通过consul keygen生成，同一个集群中的节点必须使用相同的key</td></tr><tr><td>join</td><td>加入一个已经启动的agent的ip地址，可以多次指定多个agent的地址。如果consul不能加入任何指定的地址中，则agent会启动失败，默认agent启动时不会加入任何节点</td></tr><tr><td>retry-interval</td><td>两次join之间的时间间隔，默认是30s</td></tr><tr><td>retry-max</td><td>尝试重复join的次数，默认是0，也就是无限次尝试</td></tr><tr><td>log-level</td><td>consul agent启动后显示的日志信息级别。默认是info，可选：trace、debug、info、warn、err</td></tr><tr><td>node</td><td>节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名</td></tr><tr><td>protocol</td><td>consul使用的协议版本</td></tr><tr><td>rejoin</td><td>使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中</td></tr><tr><td>server</td><td>定义agent运行在server模式，每个集群至少有一个server，建议每个集群的server不要超过5个</td></tr><tr><td>syslog</td><td>开启系统日志功能，只在linux/osx上生效</td></tr><tr><td>pid-file</td><td>提供一个路径来存放pid文件，可以使用该文件进行SIGINT/SIGHUP(关闭/更新)agent</td></tr></tbody></table><h2 id="2-4-Docker安装Consul集群"><a href="#2-4-Docker安装Consul集群" class="headerlink" title="2.4. Docker安装Consul集群"></a>2.4. Docker安装Consul集群</h2><h3 id="2-4-1-拉取consul官方镜像"><a href="#2-4-1-拉取consul官方镜像" class="headerlink" title="2.4.1. 拉取consul官方镜像"></a>2.4.1. 拉取consul官方镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker pull consul:latest</span><br></pre></td></tr></table></figure><h3 id="2-4-2-启动Server节点"><a href="#2-4-2-启动Server节点" class="headerlink" title="2.4.2. 启动Server节点"></a>2.4.2. 启动Server节点</h3><p>运行<code>consul</code>镜像，启动<code>Server Master</code>节点<code>node1</code>：</p><p><strong>node1</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=node1 --restart=always \</span><br><span class="line">             -e <span class="string">'CONSUL_LOCAL_CONFIG=&#123;"skip_leave_on_interrupt": true&#125;'</span> \</span><br><span class="line">             -p 8300:8300 \</span><br><span class="line">             -p 8301:8301 \</span><br><span class="line">             -p 8301:8301/udp \</span><br><span class="line">             -p 8302:8302/udp \</span><br><span class="line">             -p 8302:8302 \</span><br><span class="line">             -p 8400:8400 \</span><br><span class="line">             -p 8500:8500 \</span><br><span class="line">             -p 8600:8600 \</span><br><span class="line">             -h node1 \</span><br><span class="line">             consul agent -server -<span class="built_in">bind</span>=172.17.0.2 -bootstrap-expect=3 -node=node1 \</span><br><span class="line">             -data-dir=/tmp/data-dir -client 0.0.0.0 -ui</span><br></pre></td></tr></table></figure></p><p>查看<code>node1</code>的日志，追踪运行情况：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node1_logs_1.png" alt=""></p><p>现在集群中还没有选举<code>leader</code>节点，继续启动其余两台<code>Server</code>节点<code>node2</code>和<code>node3</code>：</p><p><strong>node2</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=node2 --restart=always \</span><br><span class="line">             -e <span class="string">'CONSUL_LOCAL_CONFIG=&#123;"skip_leave_on_interrupt": true&#125;'</span> \</span><br><span class="line">             -p 9300:8300  \</span><br><span class="line">             -p 9301:8301 \</span><br><span class="line">             -p 9301:8301/udp \</span><br><span class="line">             -p 9302:8302/udp \</span><br><span class="line">             -p 9302:8302 \</span><br><span class="line">             -p 9400:8400 \</span><br><span class="line">             -p 9500:8500 \</span><br><span class="line">             -p 9600:8600 \</span><br><span class="line">             -h node2 \</span><br><span class="line">             consul agent -server -<span class="built_in">bind</span>=172.17.0.3 \</span><br><span class="line">             -join=192.168.127.128 -node-id=$(uuidgen | awk <span class="string">'&#123;print tolower($0)&#125;'</span>) \</span><br><span class="line">             -node=node2 \</span><br><span class="line">             -data-dir=/tmp/data-dir -client 0.0.0.0 -ui</span><br></pre></td></tr></table></figure></p><p>查看<code>node2</code>节点的进程启动日志：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node2_logs_1.png" alt=""></p><p><strong>node3</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=node3 --restart=always \</span><br><span class="line">             -e <span class="string">'CONSUL_LOCAL_CONFIG=&#123;"skip_leave_on_interrupt": true&#125;'</span> \</span><br><span class="line">             -p 10300:8300  \</span><br><span class="line">             -p 10301:8301 \</span><br><span class="line">             -p 10301:8301/udp \</span><br><span class="line">             -p 10302:8302/udp \</span><br><span class="line">             -p 10302:8302 \</span><br><span class="line">             -p 10400:8400 \</span><br><span class="line">             -p 10500:8500 \</span><br><span class="line">             -p 10600:8600 \</span><br><span class="line">             -h node2 \</span><br><span class="line">             consul agent -server -<span class="built_in">bind</span>=172.17.0.4 \</span><br><span class="line">             -join=192.168.127.128 -node-id=$(uuidgen | awk <span class="string">'&#123;print tolower($0)&#125;'</span>) \</span><br><span class="line">             -node=node3 \</span><br><span class="line">             -data-dir=/tmp/data-dir -client 0.0.0.0 -ui</span><br></pre></td></tr></table></figure></p><p>查看<code>node3</code>节点的进程启动日志：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node3_logs_1.png" alt=""></p><p>当3个<code>Server</code>节点都启动并正常运行时，观察<code>node2</code>和<code>node3</code>的进程日志，可以发现<code>node1</code>被选举为<code>leader</code>节点，也就是这个<strong>数据中心</strong>的<code>Server Master</code>。</p><p>再次查看<code>node1</code>节点的进程启动日志：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node1_logs_2.png" alt=""></p><p>观察日志发现，<code>node2</code>和<code>node3</code>都成功join到了<code>node1</code>所在的数据中心<code>dc1</code>。当集群中有3台<code>Consul Server</code>启动时，<code>node1</code>被选举为<code>dc1</code>中的主节点。然后，<code>node1</code>会通过心跳检查的方式，不断地对<code>node2</code>和<code>node3</code>进行健康检查。</p><h3 id="2-4-4-启动Client节点"><a href="#2-4-4-启动Client节点" class="headerlink" title="2.4.4. 启动Client节点"></a>2.4.4. 启动Client节点</h3><p><strong>node4</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=node4  --restart=always \</span><br><span class="line">            -e <span class="string">'CONSUL_LOCAL_CONFIG=&#123;"leave_on_terminate": true&#125;'</span> \</span><br><span class="line">            -p 11300:8300 \</span><br><span class="line">            -p 11301:8301 \</span><br><span class="line">            -p 11301:8301/udp \</span><br><span class="line">            -p 11302:8302/udp \</span><br><span class="line">            -p 11302:8302 \</span><br><span class="line">            -p 11400:8400 \</span><br><span class="line">            -p 11500:8500 \</span><br><span class="line">            -p 11600:8600 \</span><br><span class="line">            -h node4 \</span><br><span class="line">            consul agent -<span class="built_in">bind</span>=172.17.0.5 -retry-join=192.168.127.128  \</span><br><span class="line">            -node-id=$(uuidgen | awk <span class="string">'&#123;print tolower($0)&#125;'</span>) \</span><br><span class="line">            -node=node4 -client 0.0.0.0 -ui</span><br></pre></td></tr></table></figure><p>查看<code>node4</code>节点的进程启动日志:</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_node4_logs_2.png" alt=""></p><p>可以发现：<code>node4</code>是以<code>Client</code>模式启动运行的。启动后完成后，把<code>dc1</code>数据中心中的以<code>Server</code>模式启动的节点<code>node1</code>、<code>node2</code>和<code>node3</code>都添加到<strong>本地缓存列表</strong>中。当客户端向<code>node4</code>发起服务发现的请求后，<code>node4</code>会通过<code>RPC</code>将请求转发给<code>Server</code>节点中的其中一台做处理。</p><h3 id="2-4-5-查看集群状态"><a href="#2-4-5-查看集群状态" class="headerlink" title="2.4.5. 查看集群状态"></a>2.4.5. 查看集群状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker <span class="built_in">exec</span> -t node1 consul members</span><br></pre></td></tr></table></figure><p><code>dc1</code>数据中心中的4个节点<code>node1</code>, <code>node2</code>, <code>node3</code>和<code>node4</code>分别成功启动，<code>Status</code>表示他们的状态，都为<code>alive</code>。<code>node1</code>, <code>node2</code>, <code>node3</code>以<code>Server</code>模式启动，而<code>node4</code>以<code>Client</code>模式启动。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_members.png" alt=""></p><h2 id="2-5-Docker安装Registrator"><a href="#2-5-Docker安装Registrator" class="headerlink" title="2.5. Docker安装Registrator"></a>2.5. Docker安装Registrator</h2><h3 id="2-5-1-拉取Registrator的镜像"><a href="#2-5-1-拉取Registrator的镜像" class="headerlink" title="2.5.1. 拉取Registrator的镜像"></a>2.5.1. 拉取Registrator的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker pull gliderlabs/registrator:latest</span><br></pre></td></tr></table></figure><h3 id="2-5-2-启动Registrator节点"><a href="#2-5-2-启动Registrator节点" class="headerlink" title="2.5.2. 启动Registrator节点"></a>2.5.2. 启动Registrator节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">madison@ubuntu:~$ docker run -d --name=registrator \</span><br><span class="line">             -v /var/run/docker.sock:/tmp/docker.sock \</span><br><span class="line">             --net=host \</span><br><span class="line">             gliderlabs/registrator -ip=<span class="string">"192.168.127.128"</span> consul://192.168.127.128:8500</span><br></pre></td></tr></table></figure><blockquote><p> –net指定为host表明使用主机模式。<br> -ip用于指定宿主机的IP地址，用于健康检查的通信地址。<br> consul://192.168.127.128:8500: 使用Consul作为服务注册表，指定具体的Consul通信地址进行服务注册和注销（注意：8500是Consul对外暴露的HTTP通信端口）。</p></blockquote><p>查看<code>Registrator</code>的容器进程启动日志：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/registrator_logs_1.png" alt=""></p><p><code>Registrator</code>在启动过程完成了以下几步操作：</p><ol><li>查看Consul数据中心的leader节点，作为服务注册表；</li><li>同步当前宿主机的启用容器，以及所有的服务端口；</li><li>分别将各个容器发布的服务地址/端口注册到Consul的服务注册列表。</li></ol><h3 id="2-5-3-查看Consul的注册状态"><a href="#2-5-3-查看Consul的注册状态" class="headerlink" title="2.5.3. 查看Consul的注册状态"></a>2.5.3. 查看Consul的注册状态</h3><p><code>Consul</code>提供了一个<code>Web UI</code>来可视化<strong>服务注册列表</strong>、<strong>通信节点</strong>、<strong>数据中心</strong>和<strong>键/值存储</strong>等，直接访问宿主机的<code>8500</code>端口。</p><p><strong>服务注册列表</strong>：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_ui_1.png" alt=""></p><p><code>NODES</code>节点下挂载着<code>dc1</code>数据中心中的所有的<code>Consul</code>节点，包括<code>Consul Server</code>和<code>Client</code>。</p><p><strong>通信节点列表</strong>：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_ui_2.png" alt=""></p><p>启动<code>Registrator</code>以后，宿主机中的所有容器把服务都注册到<code>Consul</code>的<code>SERVICES</code>上，测试完成！</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>单数据中心</strong>的<code>Consul</code>集群的搭建就完成了！！！后续章节我会介绍如何使用<code>Registrator</code>进行服务注册的<strong>标签化</strong>。然后通过<code>docker</code>部署<strong>多实例</strong>的<code>Web</code>容器来实现基于<code>HTTP</code>的<code>RESTful Service</code>和基于<code>TCP</code>的<code>RPC Service</code>的<strong>服务注册</strong>和<strong>健康检查定义</strong>，并演示如何以<strong>标签</strong>标识一个服务的多个实例。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;近年微服务架构在互联网应用领域中愈来愈火，引入微服务主要解决了单体应用&lt;strong&gt;多个模块的紧耦合&lt;/strong&gt;、&lt;strong&gt;无法扩展&lt;/strong&gt;和&lt;strong&gt;运维困难&lt;/strong&gt;等问题。微服务架构就是按照&lt;strong&gt;功能粒度&lt;/strong&gt;将业务模块进行&lt;strong&gt;垂直拆分&lt;/strong&gt;，对单体应用本身进行&lt;strong&gt;服务化&lt;/strong&gt;和&lt;strong&gt;组件化&lt;/strong&gt;，每个组件单独部署为&lt;strong&gt;小应用&lt;/strong&gt;（从&lt;code&gt;DB&lt;/code&gt;到&lt;code&gt;UI&lt;/code&gt;）。微服务与微服务之间通过&lt;code&gt;Service API&lt;/code&gt;进行交互，同时为了支持&lt;strong&gt;水平扩展&lt;/strong&gt;、&lt;strong&gt;性能提升&lt;/strong&gt;和&lt;strong&gt;服务可用性&lt;/strong&gt;，单个服务允许同时部署一个或者多个&lt;strong&gt;服务实例&lt;/strong&gt;。在运行时，每个实例通常是一个&lt;strong&gt;云虚拟机&lt;/strong&gt;或者&lt;code&gt;Docker&lt;/code&gt;&lt;strong&gt;容器&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Consul" scheme="https://ostenant.coding.me/tags/Consul/"/>
    
      <category term="Registrator" scheme="https://ostenant.coding.me/tags/Registrator/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud整合Thrift RPC(二) - 应用案例</title>
    <link href="https://ostenant.coding.me/2018/01/24/Spring%20Cloud%E6%95%B4%E5%90%88Thrift%20RPC(%E4%BA%8C)%20-%20%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>https://ostenant.coding.me/2018/01/24/Spring Cloud整合Thrift RPC(二) - 应用案例/</id>
    <published>2018-01-24T02:21:00.000Z</published>
    <updated>2018-05-08T02:49:46.092Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇简单的阐述了 <code>spring-cloud-thrift-starter</code> 这个插件的配置和使用，并引入了一个<code>calculator</code>的项目。本文将基于一个银行存款、取款的业务场景，给出一套<code>thrift</code>在生产环境的应用案例。</p><a id="more"></a><p>首先设计如下几张简单的数据库表：银行(<code>bank</code>)、分支(<code>branch</code>)、银行卡(<code>deposit_card</code>)、客户(<code>customer</code>)、存款历史纪录(<code>deposit_history</code>)、取款历史纪录(<code>withdraw_history</code>)。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring_cloud_thrift_deposit_table_design.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>项目结构如下，依然是由三个模块组成：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring-cloud-starter-thrift-deposit-project-structure.png" alt=""></p><ul><li>deposit<ul><li>deposit-client</li><li>deposit-iface</li><li>deposit-server</li></ul></li></ul><h3 id="Thrift-IDL编写"><a href="#Thrift-IDL编写" class="headerlink" title="Thrift IDL编写"></a>Thrift IDL编写</h3><p>关于 <code>thrift</code>更复杂的用法可以参考<code>Apache Thrift</code>基础学习系列，根据<strong>数据库表</strong>的设计编写 <code>deposit.thrift</code>。</p><p><code>deposit.thrift</code>定义了以下四个部分：<strong>命名空间</strong> (<code>namespace</code>)、<strong>枚举类型</strong> (<code>enum</code>)、<strong>结构类型</strong> (<code>struct</code>)和<strong>服务类型</strong> (<code>service</code>)。</p><p>(a). <strong>命名空间</strong> (<code>namespace</code>)</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定编译生成的源代码的包路径名称</span></span><br><span class="line"><span class="keyword">namespace</span> java com.icekredit.rpc.thrift.examples.thrift</span><br></pre></td></tr></table></figure><p>(b). <strong>枚举类型</strong> (<code>enum</code>)</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过枚举定义银行分支所属区域</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ThriftRegion</span> </span>&#123;</span><br><span class="line">   NORTH = <span class="number">1</span>,</span><br><span class="line">   CENTRAL = <span class="number">2</span>,</span><br><span class="line">   SOUTH = <span class="number">3</span>,</span><br><span class="line">   EAST = <span class="number">4</span>,</span><br><span class="line">   SOUTHWEST = <span class="number">5</span>,</span><br><span class="line">   NORTHWEST = <span class="number">6</span>,</span><br><span class="line">   NORTHEAST = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存款完成状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ThriftDepositStatus</span> </span>&#123;</span><br><span class="line">   FINISHED = <span class="number">1</span>,</span><br><span class="line">   PROCCEDING = <span class="number">2</span>,</span><br><span class="line">   FAILED = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取款完成状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ThriftWithdrawStatus</span> </span>&#123;</span><br><span class="line">   FINISHED = <span class="number">1</span>,</span><br><span class="line">   PROCCEDING = <span class="number">2</span>,</span><br><span class="line">   FAILED = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(c). <strong>结构类型</strong> (<code>struct</code>)</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 银行</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftBank</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">i64</span> id,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> code,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> name,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">optional</span> <span class="built_in">string</span> description,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> map&lt;ThriftRegion, list&lt;ThriftBranch&gt;&gt; branches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行分支</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftBranch</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">i64</span> id,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> code,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> name,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">required</span> <span class="built_in">string</span> address,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> <span class="built_in">i32</span> staffs,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> ThriftBank bank,</span><br><span class="line">   <span class="number">7</span>: <span class="keyword">optional</span> ThriftRegion region</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftCustomer</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> IDNumber,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> name,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> birthday,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">required</span> <span class="built_in">i32</span> sex = <span class="number">0</span>,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">required</span> <span class="built_in">i32</span> age,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> list&lt;<span class="keyword">string</span>&gt; address,</span><br><span class="line">   <span class="number">7</span>: <span class="keyword">optional</span> set&lt;ThriftDepositCard&gt; depositCards</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行卡</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftDepositCard</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> id,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">bool</span> isVip,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> openingTime,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">required</span> <span class="built_in">double</span> accountBalance,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> <span class="built_in">double</span> accountFlow,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> ThriftBranch branch,</span><br><span class="line">   <span class="number">7</span>: <span class="keyword">optional</span> ThriftCustomer customer,</span><br><span class="line">   <span class="number">8</span>: <span class="keyword">optional</span> list&lt;ThriftDeposit&gt; depositHistory,</span><br><span class="line">   <span class="number">9</span>: <span class="keyword">optional</span> list&lt;ThriftWithdraw&gt; WithdrawHistory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存款历史纪录</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftDeposit</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> serialNumber,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">double</span> transactionAmount,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> submittedTime,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">optional</span> <span class="built_in">string</span> finishedTime,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> ThriftDepositStatus status,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> ThriftDepositCard depositCard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取款历史纪录</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThriftWithdraw</span> </span>&#123;</span><br><span class="line">   <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> serialNumber,</span><br><span class="line">   <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">double</span> transactionAmount,</span><br><span class="line">   <span class="number">3</span>: <span class="keyword">required</span> <span class="built_in">string</span> submittedTime,</span><br><span class="line">   <span class="number">4</span>: <span class="keyword">optional</span> <span class="built_in">string</span> finishedTime,</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">optional</span> ThriftWithdrawStatus status,</span><br><span class="line">   <span class="number">6</span>: <span class="keyword">optional</span> ThriftDepositCard depositCard</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(d). <strong>服务类型</strong> (<code>service</code>)</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 银行 - 业务服务定义</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ThriftBankService</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span> registerNewBank(ThriftBank bank);</span><br><span class="line">   list&lt;ThriftBank&gt; queryAllBanks();</span><br><span class="line">   ThriftBank getBankById(<span class="built_in">i64</span> bankId);</span><br><span class="line">   map&lt;ThriftRegion, list&lt;ThriftBranch&gt;&gt; queryAllBranchesByRegion(<span class="built_in">i64</span> bankId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行分支 - 业务服务定义</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ThriftBranchService</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span> addNewBranch(<span class="built_in">i64</span> bankId, ThriftBranch branch);</span><br><span class="line">   list&lt;ThriftBranch&gt; queryAllBranches(<span class="built_in">i64</span> bankId);</span><br><span class="line">   ThriftBranch getBranchById(<span class="built_in">i64</span> branchId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户 - 业务服务定义</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ThriftCustomerService</span> </span>&#123;</span><br><span class="line">   ThriftCustomer getCustomerById(<span class="built_in">string</span> customerId);</span><br><span class="line">   list&lt;ThriftCustomer&gt; queryAllCustomers();</span><br><span class="line">   <span class="keyword">void</span> addNewUser(ThriftCustomer customer);</span><br><span class="line">   <span class="keyword">void</span> modifyUserById(<span class="built_in">string</span> customerId, ThriftCustomer customer);</span><br><span class="line">   <span class="built_in">i32</span> getTotalDepositCard(<span class="built_in">string</span> customerId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行卡 - 业务服务定义</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ThriftDepositCardService</span> </span>&#123;</span><br><span class="line">   set&lt;ThriftDepositCard&gt; queryAllDepositCards(<span class="built_in">string</span> customerId);</span><br><span class="line">   <span class="keyword">void</span> addNewDepositCard(<span class="built_in">string</span> customerId, ThriftDepositCard depositCard);</span><br><span class="line">   ThriftDepositStatus depositMoney(<span class="built_in">string</span> depositCardId, <span class="built_in">double</span> money);</span><br><span class="line">   ThriftWithdrawStatus withdrawMoney(<span class="built_in">string</span> depositCardId, <span class="built_in">double</span> money);</span><br><span class="line">   list&lt;ThriftDeposit&gt; queryDepositHistorys(<span class="built_in">string</span> depositCardId);</span><br><span class="line">   list&lt;ThriftWithdraw&gt; queryWithdrawHistorys(<span class="built_in">string</span> depositCardId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>src/main/thrift</code>目录，编译生成所需的<strong>枚举类</strong>、<strong>结构类</strong>和<strong>业务服务类</strong>的源文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -gen java ./deposit.thrift</span><br></pre></td></tr></table></figure><p>所有生成的源文件都位于同一个<strong>命名空间(包)</strong>下面：<code>com.icekredit.rpc.thrift.examples.thrift</code></p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring-cloud-starter-thrift-deposit-generate-code.png" alt=""></p><h2 id="中间契约-deposit-iface"><a href="#中间契约-deposit-iface" class="headerlink" title="中间契约(deposit-iface)"></a>中间契约(deposit-iface)</h2><p>将<strong>上述源文件</strong>拷贝到 <code>deposit-iface</code> 模块中。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring-cloud-starter-thrift-deposit-thrift-iface.png" alt=""></p><p>通过<code>Mybatis</code>逆向工程插件生成<code>SQLMapper</code>的<code>XML</code>和<strong>接口</strong>文件以及<strong>实体类</strong>。</p><blockquote><p><strong>友情提示</strong>：<code>Mybatis</code>逆向工程生成的<strong>实体类</strong> (<code>entity</code>)，需要和<code>Thrift</code>编译生成器生成的<strong>结构类</strong> (<code>struct</code>) 区分开来。而<code>Thrift</code>生成器生成的所有源文件，都一定程度封装了底层的<strong>通信方式</strong>和<strong>相关协议</strong>，开发人员是不应该动手脚的。</p></blockquote><p>为了在<code>Thrift</code>中通过<code>Mybatis</code>完成<strong>数据持久化</strong>，必须在<strong>实体类</strong> (<code>entity</code>)包装一层与<strong>结构类</strong> (<code>struct</code>)相互转换的方法。<br>在每个实体类中，根据业务添加以下两个方法，以<code>DepositCard</code>为例：</p><ul><li><strong>toThrift()</strong>：将<strong>实体类对象</strong>转换为<strong>结构类对象</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ThriftDepositCard <span class="title">toThrift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThriftDepositCard thriftDepositCard = <span class="keyword">new</span> ThriftDepositCard();</span><br><span class="line">    thriftDepositCard.setId(<span class="keyword">this</span>.getId());</span><br><span class="line">    thriftDepositCard.setAccountBalance(<span class="keyword">this</span>.getAccountBalance());</span><br><span class="line">    thriftDepositCard.setAccountFlow(<span class="keyword">this</span>.getAccountFlow());</span><br><span class="line">    thriftDepositCard.setIsVip(<span class="keyword">this</span>.getIsVip());</span><br><span class="line">    thriftDepositCard.setOpeningTime(<span class="keyword">this</span>.getOpeningTime());</span><br><span class="line"></span><br><span class="line">    ThriftBranch thriftBranch = <span class="keyword">new</span> ThriftBranch();</span><br><span class="line">    thriftBranch.setId(<span class="keyword">this</span>.getBranchId());</span><br><span class="line">    thriftDepositCard.setBranch(thriftBranch);</span><br><span class="line"></span><br><span class="line">    ThriftCustomer thriftCustomer = <span class="keyword">new</span> ThriftCustomer();</span><br><span class="line">    thriftCustomer.setIDNumber(<span class="keyword">this</span>.getCustomerId());</span><br><span class="line">    thriftDepositCard.setCustomer(thriftCustomer);</span><br><span class="line">    <span class="keyword">return</span> thriftDepositCard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>fromThrift()</strong>：<strong>静态</strong>方法，将<strong>结构类对象</strong>转换为<strong>实体类对象</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DepositCard <span class="title">fromThrift</span><span class="params">(ThriftDepositCard thriftDepositCard)</span> </span>&#123;</span><br><span class="line">    DepositCard depositCard = <span class="keyword">new</span> DepositCard();</span><br><span class="line">    depositCard.setId(thriftDepositCard.getId());</span><br><span class="line">    depositCard.setAccountBalance(thriftDepositCard.getAccountBalance());</span><br><span class="line">    depositCard.setAccountFlow(thriftDepositCard.getAccountFlow());</span><br><span class="line">    depositCard.setIsVip(thriftDepositCard.isIsVip());</span><br><span class="line"></span><br><span class="line">    ThriftCustomer thriftCustomer = thriftDepositCard.getCustomer();</span><br><span class="line">    <span class="keyword">if</span> (thriftCustomer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String customerIDNumber = thriftCustomer.getIDNumber();</span><br><span class="line">        depositCard.setCustomerId(customerIDNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThriftBranch thriftBranch = thriftDepositCard.getBranch();</span><br><span class="line">    <span class="keyword">if</span> (thriftBranch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Long branchId = thriftBranch.getId();</span><br><span class="line">        depositCard.setBranchId(branchId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depositCard.setOpeningTime(thriftDepositCard.getOpeningTime());</span><br><span class="line">    <span class="keyword">return</span> depositCard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端-deposit-server"><a href="#服务端-deposit-server" class="headerlink" title="服务端(deposit-server)"></a>服务端(deposit-server)</h2><p>在服务端模块引入：</p><ul><li><strong>spring-cloud-starter-thrift-server</strong>：<code>thrift</code>服务端的 <code>starter</code>程序。</li><li><strong>calculator-iface</strong>：中间契约模块，这里作为服务端骨架(<code>Skeleton</code>)程序。</li></ul><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Thrift相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-thrift-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringBoot依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Swagger依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中配置<code>thrift</code>服务端的<strong>运行参数</strong>、<strong>数据源连接池参数</strong>和<code>Mybatis</code>相关属性：</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">  actuator:</span></span><br><span class="line"><span class="attr">    sensitive:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    druid:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://localhost:3306/deposit?useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">      driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  thrift:</span></span><br><span class="line"><span class="attr">    server:</span></span><br><span class="line"><span class="attr">      service-id:</span> <span class="string">deposit-server-rpc</span></span><br><span class="line"><span class="attr">      service-model:</span> <span class="string">hsHa</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">25000</span></span><br><span class="line"><span class="attr">      worker-queue-capacity:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">      hs-ha:</span></span><br><span class="line"><span class="attr">        min-worker-threads:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        max-worker-threads:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">        keep-alived-time:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  mapper-locations:</span> <span class="attr">classpath:mapper/*.xml</span></span><br><span class="line"><span class="attr">  type-aliases-package:</span> <span class="string">com.icekredit.rpc.thrift.examples.http.entities</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    root:</span> <span class="string">INFO</span></span><br><span class="line"><span class="attr">    com:</span></span><br><span class="line"><span class="attr">      icekredit:</span></span><br><span class="line"><span class="attr">        rpc:</span></span><br><span class="line"><span class="attr">          thrift:</span></span><br><span class="line"><span class="attr">            examples:</span></span><br><span class="line"><span class="attr">              mapper:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><p>服务端程序启动入口类，设置 <code>Swagger API</code>所在的包路径名称。</p><p>Application.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestfulApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.icekredit.rpc.thrift.examples.service.http.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"Deposit Server"</span>)</span><br><span class="line">                .description(<span class="string">"Deposit Server"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写服务端的<code>Thrift</code>的实现，以<code>ThriftDepositCardService</code>为例，由实现类<code>ThriftDepositCardServiceImpl</code>实现<code>ThriftDepositCardService.Iface</code>接口的方法：</p><p>ThriftDepositCardServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftService</span>(name = <span class="string">"thriftDepositCardService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThriftDepositCardServiceImpl</span> <span class="keyword">implements</span> <span class="title">ThriftDepositCardService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BranchMapper branchMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DepositCardMapper depositCardMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerMapper customerMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DepositHistoryMapper depositHistoryMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WithdrawHistoryMapper withdrawHistoryMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThriftDepositCardServiceImpl</span><span class="params">(BranchMapper branchMapper, DepositCardMapper depositCardMapper, CustomerMapper customerMapper, DepositHistoryMapper depositHistoryMapper, WithdrawHistoryMapper withdrawHistoryMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.branchMapper = branchMapper;</span><br><span class="line">        <span class="keyword">this</span>.depositCardMapper = depositCardMapper;</span><br><span class="line">        <span class="keyword">this</span>.customerMapper = customerMapper;</span><br><span class="line">        <span class="keyword">this</span>.depositHistoryMapper = depositHistoryMapper;</span><br><span class="line">        <span class="keyword">this</span>.withdrawHistoryMapper = withdrawHistoryMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ThriftDepositCard&gt; <span class="title">queryAllDepositCards</span><span class="params">(String customerId)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        List&lt;DepositCard&gt; depositCardList = depositCardMapper.queryAllDepositCards(customerId);</span><br><span class="line">        <span class="comment">// 查询客户持有的银行卡</span></span><br><span class="line">        <span class="keyword">return</span> depositCardList.stream().map(depositCard -&gt; &#123;</span><br><span class="line">            ThriftDepositCard thriftDepositCard = depositCard.toThrift();</span><br><span class="line">            Long branchId = depositCard.getBranchId();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(branchId) &amp;&amp; branchId &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                Branch branch = branchMapper.findById(branchId);</span><br><span class="line">                ThriftBranch thriftBranch = branch.toThrift();</span><br><span class="line">                ThriftBank thriftBank = <span class="keyword">new</span> ThriftBank();</span><br><span class="line">                thriftBank.setId(branch.getBankId());</span><br><span class="line">                thriftBranch.setBank(thriftBank);</span><br><span class="line">                thriftDepositCard.setBranch(thriftBranch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Customer customer = customerMapper.findById(customerId);</span><br><span class="line">            ThriftCustomer thriftCustomer = customer.toThrift();</span><br><span class="line">            thriftDepositCard.setCustomer(thriftCustomer);</span><br><span class="line">            <span class="keyword">return</span> thriftDepositCard;</span><br><span class="line">        &#125;).collect(Collectors.toSet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewDepositCard</span><span class="params">(String customerId, ThriftDepositCard depositCard)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        DepositCard newDepositCard = DepositCard.fromThrift(depositCard);</span><br><span class="line">        <span class="comment">// 新增银行卡信息</span></span><br><span class="line">        depositCardMapper.save(newDepositCard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThriftDepositStatus <span class="title">depositMoney</span><span class="params">(String depositCardId, <span class="keyword">double</span> money)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DepositHistory depositHistory = <span class="keyword">new</span> DepositHistory();</span><br><span class="line">            depositHistory.setSubmittedTime(sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            depositCardMapper.incrementMoney(depositCardId, money);</span><br><span class="line">            depositHistory.setFinishedTime(sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            depositHistory.setSerialNumber(UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">            depositHistory.setTransactionAmount(money);</span><br><span class="line">            depositHistory.setDepositCardId(depositCardId);</span><br><span class="line">            depositHistory.setStatus(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 新增存款历史记录</span></span><br><span class="line">            depositHistoryMapper.save(depositHistory);</span><br><span class="line">            <span class="keyword">return</span> ThriftDepositStatus.FINISHED;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> ThriftDepositStatus.FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThriftWithdrawStatus <span class="title">withdrawMoney</span><span class="params">(String depositCardId, <span class="keyword">double</span> money)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WithdrawHistory withdrawHistory = <span class="keyword">new</span> WithdrawHistory();</span><br><span class="line">            withdrawHistory.setSubmittedTime(sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            depositCardMapper.decrementMoney(depositCardId, money);</span><br><span class="line">            withdrawHistory.setFinishedTime(sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            withdrawHistory.setSerialNumber(UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">            withdrawHistory.setTransactionAmount(money);</span><br><span class="line">            withdrawHistory.setDepositCardId(depositCardId);</span><br><span class="line">            withdrawHistory.setStatus(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 新增取款历史记录</span></span><br><span class="line">            withdrawHistoryMapper.save(withdrawHistory);</span><br><span class="line">            <span class="keyword">return</span> ThriftWithdrawStatus.FINISHED;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> ThriftWithdrawStatus.FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ThriftDeposit&gt; <span class="title">queryDepositHistorys</span><span class="params">(String depositCardId)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        List&lt;DepositHistory&gt; depositHistory = depositHistoryMapper.queryDepositHistoryList(depositCardId);</span><br><span class="line">        <span class="comment">// 查询存款历史纪录</span></span><br><span class="line">        <span class="keyword">return</span> depositHistory.stream().map(DepositHistory::toThrift).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ThriftWithdraw&gt; <span class="title">queryWithdrawHistorys</span><span class="params">(String depositCardId)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        List&lt;WithdrawHistory&gt; withdrawHistory = withdrawHistoryMapper.queryWithdrawHistoryList(depositCardId);</span><br><span class="line">        <span class="comment">// 查询取款历史纪录</span></span><br><span class="line">        <span class="keyword">return</span> withdrawHistory.stream().map(WithdrawHistory::toThrift).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Mybatis</code>持久层，还是以<code>DepositCardMapper</code>为例：</p><p>DepositCardMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepositCardMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">(DepositCard record)</span></span>;</span><br><span class="line">    <span class="function">List&lt;DepositCard&gt; <span class="title">queryAllDepositCards</span><span class="params">(@Param(<span class="string">"customerId"</span>)</span> String customerId)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decrementMoney</span><span class="params">(@Param(<span class="string">"depositCardId"</span>)</span> String depositCardId, @<span class="title">Param</span><span class="params">(<span class="string">"money"</span>)</span> Double money)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incrementMoney</span><span class="params">(@Param(<span class="string">"depositCardId"</span>)</span> String depositCardId, @<span class="title">Param</span><span class="params">(<span class="string">"money"</span>)</span> Double money)</span>;</span><br><span class="line">    <span class="function">Long <span class="title">countRowsByCustomerId</span><span class="params">(@Param(<span class="string">"customerId"</span>)</span> String customerId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DepositCardMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"com.icekredit.rpc.thrift.examples.http.entities.DepositCard"</span>&gt;</span></span><br><span class="line">    INSERT INTO deposit_card (id, is_vip, opening_time,</span><br><span class="line">                              account_balance, account_flow, branch_id,</span><br><span class="line">                              customer_id)</span><br><span class="line">    VALUES (#&#123;id,jdbcType=VARCHAR&#125;, #&#123;isVip,jdbcType=BIT&#125;, #&#123;openingTime,jdbcType=VARCHAR&#125;,</span><br><span class="line">            #&#123;accountBalance,jdbcType=DOUBLE&#125;, #&#123;accountFlow,jdbcType=DOUBLE&#125;, #&#123;branchId,jdbcType=BIGINT&#125;,</span><br><span class="line">            #&#123;customerId,jdbcType=VARCHAR&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryAllDepositCards"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span>/&gt;</span></span><br><span class="line">    FROM deposit_card</span><br><span class="line">    WHERE customer_id = #&#123;customerId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"countRowsByCustomerId"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Long"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">    SELECT COUNT(id)</span><br><span class="line">    FROM deposit_card</span><br><span class="line">    WHERE customer_id = #&#123;customerId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"decrementMoney"</span>&gt;</span></span><br><span class="line">    UPDATE deposit_card</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"money != null"</span>&gt;</span></span><br><span class="line">            account_balance = account_balance - #&#123;money&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE id = #&#123;depositCardId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"incrementMoney"</span>&gt;</span></span><br><span class="line">    UPDATE deposit_card</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"money != null"</span>&gt;</span></span><br><span class="line">            account_balance = account_balance + #&#123;money&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE id = #&#123;depositCardId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="客户端-deposit-client"><a href="#客户端-deposit-client" class="headerlink" title="客户端(deposit-client)"></a>客户端(deposit-client)</h2><p>同样，在客户端模块引入：</p><ul><li><strong>spring-cloud-starter-thrift-client</strong>：<code>thrift</code>客户端的 <code>starter</code>程序。</li><li><strong>deposit-iface</strong>：中间契约模块，这里作为客户端桩(<code>Stub</code>)程序。</li></ul><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Thrift相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-thrift-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deposit-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringBoot依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Cloud Consul服务注册与发现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Cloud声明式Restful客户端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Swagger依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中配置<code>thrift</code><strong>的客户端</strong>的的运行参数和 <code>Consul</code> <strong>的服务注册与发现</strong>的参数：</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">  actuator:</span></span><br><span class="line"><span class="attr">    sensitive:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        register:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">        register-health-check:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        health-check-interval:</span> <span class="number">30</span><span class="string">s</span></span><br><span class="line"><span class="attr">      retry:</span></span><br><span class="line"><span class="attr">        max-attempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">        max-interval:</span> <span class="number">2000</span></span><br><span class="line"><span class="attr">  thrift:</span></span><br><span class="line"><span class="attr">    client:</span></span><br><span class="line"><span class="attr">      package-to-scan:</span> <span class="string">com.icekredit.rpc.thrift.examples.thrift.client</span></span><br><span class="line"><span class="attr">      service-model:</span> <span class="string">hsHa</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        retry-times:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">        pool-max-total-per-key:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">        pool-min-idle-per-key:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">        pool-max-idle-per-key:</span> <span class="number">40</span></span><br><span class="line"><span class="attr">        pool-max-wait:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">        connect-timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p><strong>客户端程序</strong>启动入口类，设置 <code>Swagger API</code>所在的<strong>包路径名称</strong>，同时允许自身作为<strong>注册程序</strong>注册到<strong>注册中心</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestfulApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.icekredit.rpc.thrift.examples"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"Deposit Client"</span>)</span><br><span class="line">                .description(<span class="string">"Deposit Client"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>客户端</strong>使用<code>@ThriftClient</code>注解标识<strong>服务端</strong>的<code>thrift</code><strong>服务代理接口</strong>，<strong>代理服务</strong><code>ID</code>为<code>deposit-server-rpc</code>，<strong>代理的目标类</strong>是<code>ThriftDepositCardService</code>。</p><p>DepositCardThriftClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftClient</span>(serviceId = <span class="string">"deposit-server-rpc"</span>, refer = ThriftDepositCardService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepositCardThriftClient</span> <span class="keyword">extends</span> <span class="title">ThriftClientAware</span>&lt;<span class="title">ThriftDepositCardService</span>.<span class="title">Client</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BankThriftClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftClient</span>(serviceId = <span class="string">"deposit-server-rpc"</span>, refer = ThriftBankService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BankThriftClient</span> <span class="keyword">extends</span> <span class="title">ThriftClientAware</span>&lt;<span class="title">ThriftBankService</span>.<span class="title">Client</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端控制器中通过<code>ThriftReferer</code>注入需要使用的<strong>服务代理接口</strong>，通过 <code>thriftClient.client()</code>即可获取<code>Thrift</code><strong>客户端</strong>桩对象，然后实现远程服务的调用。</p><p>DepositCardRpcController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rpc/deposit"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepositCardRpcController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ThriftReferer</span></span><br><span class="line">    <span class="keyword">private</span> DepositCardThriftClient thriftClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/queryAllDepositCards"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DepositCard&gt; <span class="title">queryAllDepositCards</span><span class="params">(@RequestParam(<span class="string">"customerId"</span>)</span> String customerId)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().queryAllDepositCards(customerId)</span><br><span class="line">                .stream().map(DepositCard::fromThrift)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/addNewDepositCard"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewDepositCard</span><span class="params">(DepositCard depositCard)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        thriftClient.client().addNewDepositCard(depositCard.getCustomerId(), depositCard.toThrift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/depositMoney"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThriftDepositStatus <span class="title">depositMoney</span><span class="params">(@RequestParam(<span class="string">"depositCardId"</span>)</span> String depositCardId,</span></span><br><span class="line"><span class="function">                                            @<span class="title">RequestParam</span><span class="params">(<span class="string">"money"</span>)</span> <span class="keyword">double</span> money) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().depositMoney(depositCardId, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/withdrawMoney"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThriftWithdrawStatus <span class="title">withdrawMoney</span><span class="params">(@RequestParam(<span class="string">"depositCardId"</span>)</span> String depositCardId,</span></span><br><span class="line"><span class="function">                                              @<span class="title">RequestParam</span><span class="params">(<span class="string">"money"</span>)</span> <span class="keyword">double</span> money) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().withdrawMoney(depositCardId, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/queryDepositHistory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DepositHistory&gt; <span class="title">queryDepositHistory</span><span class="params">(@RequestParam(<span class="string">"depositCardId"</span>)</span> String depositCardId)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().queryDepositHistorys(depositCardId)</span><br><span class="line">                .stream().map(DepositHistory::fromThrift)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/queryWithdrawHistory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;WithdrawHistory&gt; <span class="title">queryWithdrawHistory</span><span class="params">(@RequestParam(<span class="string">"depositCardId"</span>)</span> String depositCardId)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thriftClient.client().queryWithdrawHistorys(depositCardId)</span><br><span class="line">                .stream().map(WithdrawHistory::fromThrift)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BankRpcController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rpc/bank"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankRpcController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ThriftReferer</span></span><br><span class="line">    <span class="keyword">private</span> BankThriftClient thriftClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/addNewBank"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewBank</span><span class="params">(Bank bank)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        thriftClient.client().registerNewBank(bank.toThrift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getBankById"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bank <span class="title">getBankById</span><span class="params">(@RequestParam(<span class="string">"bankId"</span>)</span> Long bankId) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bank.fromThrift(thriftClient.client().getBankById(bankId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/queryAllBranchesByRegion"</span>)</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Region, List&lt;Branch&gt;&gt; queryAllBranchesByRegion(<span class="meta">@RequestParam</span>(<span class="string">"bankId"</span>) Long bankId) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;ThriftRegion, List&lt;ThriftBranch&gt;&gt; thriftRegionListMap = thriftClient.client()</span><br><span class="line">                .queryAllBranchesByRegion(bankId);</span><br><span class="line">        Map&lt;Region, List&lt;Branch&gt;&gt; regionListMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ThriftRegion, List&lt;ThriftBranch&gt;&gt; entry : thriftRegionListMap.entrySet()) &#123;</span><br><span class="line">            ThriftRegion thriftRegion = entry.getKey();</span><br><span class="line">            Region region = Region.findByValue(thriftRegion.getValue());</span><br><span class="line"></span><br><span class="line">            List&lt;ThriftBranch&gt; thriftBranches = entry.getValue();</span><br><span class="line">            List&lt;Branch&gt; branchList = thriftBranches.stream().map(Branch::fromThrift).collect(Collectors.toList());</span><br><span class="line">            regionListMap.put(region, branchList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> regionListMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<strong>服务代理客户端接口</strong>使用<code>@ThriftClient</code>标识，通过(服务ID + 客户端桩 + 版本号)唯一标识, 即使同时注入多个<strong>服务代理客户端接口</strong>，<code>@ThriftReferer</code>也可忽略<strong>注解属性</strong>的配置。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有一点是肯定的，那就是在已有技术框架(比如说：<code>Spring</code> + <code>Mybatis/JPA</code>)内，为了提高服务的<strong>性能</strong>和<strong>吞吐量</strong>，而引入诸如<code>Thrift</code>的<code>RPC</code>框架，<strong>编程难度</strong>和<strong>复杂度</strong>是会大大提高的。好比一把双刃剑，技术选型时还需要多方面权衡利弊。</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇简单的阐述了 &lt;code&gt;spring-cloud-thrift-starter&lt;/code&gt; 这个插件的配置和使用，并引入了一个&lt;code&gt;calculator&lt;/code&gt;的项目。本文将基于一个银行存款、取款的业务场景，给出一套&lt;code&gt;thrift&lt;/code&gt;在生产环境的应用案例。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Thrift" scheme="https://ostenant.coding.me/tags/Thrift/"/>
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
      <category term="Spring Cloud" scheme="https://ostenant.coding.me/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud整合Thrift RPC(一) - 使用指南</title>
    <link href="https://ostenant.coding.me/2018/01/18/Spring%20Cloud%E6%95%B4%E5%90%88Thrift%20RPC(%E4%B8%80)%20-%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://ostenant.coding.me/2018/01/18/Spring Cloud整合Thrift RPC(一) - 使用指南/</id>
    <published>2018-01-18T07:07:00.000Z</published>
    <updated>2018-05-08T02:49:46.092Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面几篇博客，着重对<code>Apache Thrift</code>的使用和原理做了介绍。在微服架构流行的今天，自然而然就会想到<code>Spring Boot</code>和<code>Spring Cloud</code>作为<strong>微服务</strong>的基础框架。然而，<code>Spring Cloud</code>从诞生以来，就基于<code>HTTP</code>协议的<strong>轻量级</strong><code>Restful API</code>作为服务之间的通信方式。</p><a id="more"></a><p>在微服务架构设计中，可以分为<strong>外部服务</strong>和<strong>内部服务</strong>。两者主要区别是：</p><ul><li><strong>外部服务</strong>：基于<code>Restful</code>风格的<code>HTTP</code>协议，通过<strong>外网</strong>向外部提供服务，相对来说<strong>简单并且通用</strong>。</li><li><strong>内部服务</strong>：基于<code>RPC</code>消息通信的<code>TCP/IP</code>协议，提供<strong>内网</strong>服务与服务之间的调用，以达到<strong>减少带宽</strong>、<strong>降低延迟率</strong>、<strong>提高性能</strong>。</li></ul><p>一些应用场景，尤其是<strong>内部服务</strong>需要高频地调用，就需要考虑是否需要改造为<code>RPC</code>实现，来<strong>提高吞吐量</strong>和<strong>系统性能</strong>，比如说<strong>鉴权服务</strong>一类。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>下载 <code>spring-cloud-starter-thrift</code>并导入<code>IDEA</code>开发环境，项目地址：<a href="https://github.com/ostenant/spring-cloud-starter-thrift" target="_blank" rel="noopener">https://github.com/ostenant/spring-cloud-starter-thrift</a></p><p><img src="http://ols3fdyll.bkt.clouddn.com/Spring-cloud-starter-thrift2.png" alt=""><br><code>spring-cloud-starter-thrift</code> 提供 <code>Spring Cloud</code> 对<strong>可伸缩</strong>的<strong>跨语言</strong>服务调用框架<code>Apache Thrift</code>的封装和集成。</p><p><code>spring-cloud-starter-thrift</code>包括<strong>客户端</strong><code>spring-cloud-starter-thrift-client</code>和<strong>服务端</strong><code>spring-cloud-starter-thrift-server</code>两个模块。而<code>spring-cloud-starter-thrift-examples</code> 子模块提供了<code>3</code>个示例项目：<code>calculator</code>、<code>deposit</code>和<code>test</code>。</p><ul><li><strong>calculator</strong>：简单上手项目示例。</li><li><strong>deposit</strong>：复杂业务场景项目示例。</li><li><strong>test</strong>：性能测试项目示例。</li></ul><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li>支持 <code>Apache Thrift</code>的各种原生<strong>线程服务模型</strong>，包括<strong>单线程阻塞模型</strong>(<code>simple</code>)、<strong>单线程非阻塞模型</strong>(<code>nonBlocking</code>)、<strong>线程池阻塞模型</strong>(<code>threadPool</code>)、<strong>半同步半异步模型</strong>(<code>hsHa</code>)和<strong>线程选择器模型</strong>(<code>threadedSelector</code>)。</li><li>支持 <code>Apache Thrift 0.10.0</code>版本后提供的<strong>多路复用处理器</strong>，提供服务的统一注册管理功能。</li><li>支持由<strong>服务签名</strong> (服务<code>ID</code> + 客户端<code>Stub</code>接口名称 + 服务版本号) 唯一标识服务<code>Stub</code>的<strong>具体实现类</strong>，支持服务版本的<strong>平滑升级</strong>。</li><li>支持<code>Server Group</code>形式的启动方式，每个<strong>服务实例</strong>可以开启多台<code>Thrift Server</code>，通过不同的<strong>端口号</strong>暴露给客户端。</li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>支持由<strong>服务签名</strong> (服务<code>ID</code> + 客户端<code>Stub</code>接口名称 + 服务版本号) 唯一标识和调用服务端的<code>Stub</code><strong>具体实现类</strong>。</li><li>支持<code>Apache Thrift</code>的<code>Transport</code>层的<strong>连接池管理</strong>，<strong>减少</strong>了客户端与服务端之间<strong>连接</strong>的频繁<strong>创建</strong>和<strong>销毁</strong>。</li><li>支持与<code>Spring Cloud Consul</code>的<strong>无缝集成</strong>，客户端通过<strong>心跳检测</strong>与<strong>服务注册中心</strong><code>Consul</code>保持连接，动态定时的<strong>刷新服务列表</strong>、<strong>监测</strong>服务的<strong>启用</strong>、<strong>关闭</strong>和<strong>健康状态</strong>。</li><li>支持<strong>客户端负载均衡</strong>，包括<strong>随机</strong>、<strong>轮询</strong>的负载均衡策略，客户端的<code>Thrift</code>程序通过本地的<strong>服务缓存列表</strong>实现调用的动态转发。</li></ol><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>项目结构：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/spring-cloud-thrift-starter-example-calculator.png" alt=""></p><ul><li>calculator<ul><li>calculator-client</li><li>calculator-iface</li><li>calculator-server</li></ul></li></ul><p><code>spring-cloud-starter-thrift</code> 使用的是 <code>0.10.0</code>版本的 <code>thrift</code>。以<code>calculator</code>项目入手，首先，通过 <code>Thrift IDL</code> (接口描述语言) 编写<strong>客户端桩</strong><code>Stub</code>和<strong>服务端骨架</strong><code>Skeleton</code>，通过<code>.thrift</code>文件定义接口规范。</p><p>首先进入 <code>spring-cloud-starter-thrift</code> 根目录，<code>pom.xml</code> 定义如下：</p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>calculator-client<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>calculator-server<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>calculator-iface<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Dalston.SR4<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将项目打包并<strong>安装</strong>到本地<code>Maven</code>仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><h3 id="Thrift-IDL编写"><a href="#Thrift-IDL编写" class="headerlink" title="Thrift IDL编写"></a>Thrift IDL编写</h3><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java com.icekredit.rpc.thrift.example</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">CalculatorService</span> </span>&#123;</span><br><span class="line">    <span class="built_in">i32</span> add(<span class="number">1</span>: <span class="built_in">i32</span> arg1, <span class="number">2</span>: <span class="built_in">i32</span> arg2)</span><br><span class="line">    <span class="built_in">i32</span> subtract(<span class="number">1</span>: <span class="built_in">i32</span> arg1, <span class="number">2</span>: <span class="built_in">i32</span> arg2)</span><br><span class="line">    <span class="built_in">i32</span> multiply(<span class="number">1</span>: <span class="built_in">i32</span> arg1, <span class="number">2</span>: <span class="built_in">i32</span> arg2)</span><br><span class="line">    <span class="built_in">i32</span> division(<span class="number">1</span>: <span class="built_in">i32</span> arg1, <span class="number">2</span>: <span class="built_in">i32</span> arg2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载并安装<code>0.10.0</code>的 <code>Thrift IDL</code><strong>编译生成器</strong>，下载地址：<a href="http://thrift.apache.org/docs/install" target="_blank" rel="noopener">http://thrift.apache.org/docs/install</a>。通过<strong>编译器</strong>生成<code>.java</code>的<code>Stub</code>类文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -gen java ./CalculatorService.thrift</span><br></pre></td></tr></table></figure><p>编译器生成的<code>CalculatorService.java</code>文件。<code>CalculatorService.java</code>有成千上万行代码。对于开发人员而言，只需要关注以下<strong>四个核心接口/类</strong>：<code>Iface</code>、<code>AsyncIface</code>、<code>Client</code>和<code>AsyncClient</code>。</p><ul><li><strong>Iface</strong>：<strong>服务端</strong>通过实现 <code>HelloWorldService.Iface</code> 接口，向<strong>客户端</strong>的提供具体的<strong>同步</strong>业务逻辑。</li><li><strong>AsyncIface</strong>：<strong>服务端</strong>通过实现 <code>HelloWorldService.Iface</code> 接口，向<strong>客户端</strong>的提供具体的<strong>异步</strong>业务逻辑。</li><li><strong>Client</strong>：<strong>客户端</strong>通过 <code>HelloWorldService.Client</code> 的实例对象，以<strong>同步</strong>的方式<strong>访问服务端</strong>提供的服务方法。</li><li><strong>AsyncClient</strong>：<strong>客户端</strong>通过 <code>HelloWorldService.AsyncClient</code> 的实例对象，以<strong>异步</strong>的方式<strong>访问服务端</strong>提供的服务方法。</li></ul><h3 id="中间契约-calculator-iface"><a href="#中间契约-calculator-iface" class="headerlink" title="中间契约(calculator-iface)"></a>中间契约(calculator-iface)</h3><p>在<strong>中间契约模块</strong>引入<code>thrift</code>的<code>maven</code>依赖，拷贝上一步<code>thrift</code>编译生成器生成的 <code>CalculatorService</code>源文件到此模块。</p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务端-calculator-server"><a href="#服务端-calculator-server" class="headerlink" title="服务端(calculator-server)"></a>服务端(calculator-server)</h3><p>在<strong>服务端模块</strong>引入：</p><ul><li><strong>spring-cloud-starter-thrift-server</strong>：<code>thrift</code>服务端的 <code>starter</code>程序。</li><li><strong>calculator-iface</strong>：中间契约模块，这里作为服务端骨架(<code>Skeleton</code>)程序。</li></ul><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-thrift-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中配置<code>thrift</code>服务端的运行参数：</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 服务端Restful服务所在的HTTP端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 用于Consul健康检查</span></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">  actuator:</span></span><br><span class="line"><span class="attr">    sensitive:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Spring Thrift服务端配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  thrift:</span></span><br><span class="line"><span class="attr">    server:</span></span><br><span class="line"><span class="attr">      service-id:</span> <span class="string">thrift-rpc-calculator</span> <span class="comment">##</span></span><br><span class="line"><span class="attr">      service-model:</span> <span class="string">hsHa</span>  <span class="comment">## 半同步/半异步服务模型</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">25000</span>  <span class="comment">## 服务端RPC服务所在的TCP端口号</span></span><br><span class="line"><span class="attr">      worker-queue-capacity:</span> <span class="number">1000</span></span><br><span class="line">      <span class="comment">## 半同步/半异步服务模型参数配置</span></span><br><span class="line"><span class="attr">      hs-ha:</span></span><br><span class="line"><span class="attr">        min-worker-threads:</span> <span class="number">5</span>  <span class="comment">## 最少工作线程数</span></span><br><span class="line"><span class="attr">        max-worker-threads:</span> <span class="number">20</span>  <span class="comment">## 最大工作线程数</span></span><br><span class="line"><span class="attr">        keep-alived-time:</span> <span class="number">3</span>  <span class="comment">## 空闲线程存活时间</span></span><br></pre></td></tr></table></figure><p>实现<code>Thrift IDL</code>生成的骨架(<code>Skeleton</code>)类<code>CalculatorService</code>的内部接口<code>Iface</code>，编写具体的业务逻辑：</p><p>这里需要注意几点：</p><ul><li>实现 <code>CalculatorService.Iface</code>接口。</li><li>实现类标记 <code>@ThriftService</code>注解，包含以下属性：<ul><li><strong>name</strong>：通过<code>name</code>标识<strong>服务名称</strong>，缺省时默认为<strong>类名称首字母小写</strong>。</li><li><strong>version</strong>：通过<code>version</code>标识<strong>服务版本</strong>，缺省值为<code>1.0</code>，也就是说同一个<strong>服务名称</strong>可以拥有<strong>多个版本实现</strong>。</li></ul></li></ul><p>RpcCalculatorService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftService</span>(name = <span class="string">"rpcCalculatorService"</span>, version = <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcCalculatorService</span> <span class="keyword">implements</span> <span class="title">CalculatorService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        BigDecimal arg1Decimal = <span class="keyword">new</span> BigDecimal(arg1);</span><br><span class="line">        BigDecimal arg2Decimal = <span class="keyword">new</span> BigDecimal(arg2);</span><br><span class="line">        <span class="keyword">return</span> arg1Decimal.add(arg2Decimal).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        BigDecimal arg1Decimal = <span class="keyword">new</span> BigDecimal(arg1);</span><br><span class="line">        BigDecimal arg2Decimal = <span class="keyword">new</span> BigDecimal(arg2);</span><br><span class="line">        <span class="keyword">return</span> arg1Decimal.subtract(arg2Decimal).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        BigDecimal arg1Decimal = <span class="keyword">new</span> BigDecimal(arg1);</span><br><span class="line">        BigDecimal arg2Decimal = <span class="keyword">new</span> BigDecimal(arg2);</span><br><span class="line">        <span class="keyword">return</span> arg1Decimal.multiply(arg2Decimal).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        BigDecimal arg1Decimal = <span class="keyword">new</span> BigDecimal(arg1);</span><br><span class="line">        BigDecimal arg2Decimal = <span class="keyword">new</span> BigDecimal(arg2);</span><br><span class="line">        <span class="keyword">return</span> arg1Decimal.divide(arg2Decimal).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对服务端程序进行打包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>编写 <code>Dockerfile</code> 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/spring-boot-thrift-server-0.0.1-SNAPSHOT.jar calculator-server.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"calculator-server.jar"</span>]</span></span><br></pre></td></tr></table></figure><p>将<code>Dockerfile</code> 和 <code>target/spring-boot-thrift-server-0.0.1-SNAPSHOT.jar</code>拷贝到服务器上，构建 <code>Thrift Server</code> 的服务镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t icekredit/calculator-server</span><br></pre></td></tr></table></figure><h3 id="客户端-calculator-client"><a href="#客户端-calculator-client" class="headerlink" title="客户端(calculator-client)"></a>客户端(calculator-client)</h3><p>在<strong>客户端模块</strong>引入：</p><ul><li><strong>spring-cloud-starter-thrift-client</strong>：<code>thrift</code>客户端的 <code>starter</code>程序。</li><li><strong>calculator-iface</strong>：中间契约模块，这里作为客户端桩(<code>Stub</code>)程序。</li></ul><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-thrift-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icekredit.rpc.thrift.examples<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>calculator-iface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>application.yml</code>中配置 <code>thrift</code><strong>客户端</strong>的运行参数，需要与<strong>服务端</strong>配置保持一致：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 客户端Restful服务所在的HTTP端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 用于Consul健康检查</span></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">  actuator:</span></span><br><span class="line"><span class="attr">    sensitive:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Spring Thrift客户端配置(Thrift Client的自动配置取决于Spring Cloud Consul的正确配置)</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">thrift-calculator-client</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>  <span class="comment">## Consul的IP地址</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span>  <span class="comment">## Consul的HTTP端口号</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        register:</span> <span class="literal">false</span>  <span class="comment">## 不使用SpringCloud提供的基于服务的程序注册方式</span></span><br><span class="line"><span class="attr">        register-health-check:</span> <span class="literal">false</span>  <span class="comment">## 不使用Spring Cloud进行健康检查</span></span><br><span class="line"><span class="attr">      retry:</span></span><br><span class="line"><span class="attr">        max-attempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">        max-interval:</span> <span class="number">2000</span></span><br><span class="line">  <span class="comment">## Thrift Client配置</span></span><br><span class="line"><span class="attr">  thrift:</span></span><br><span class="line"><span class="attr">    client:</span></span><br><span class="line"><span class="attr">      package-to-scan:</span> <span class="string">com.icekredit.rpc.thrift.example.rpc</span>  <span class="comment">## 标记由有注解@ThriftClient接口的包路径</span></span><br><span class="line"><span class="attr">      service-model:</span> <span class="string">hsHa</span>  <span class="comment">##服务线程模型（这里必须与服务端保持一致, 默认都是hsHa）</span></span><br><span class="line">      <span class="comment">## 客户端连接池配置</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        retry-times:</span> <span class="number">3</span>  <span class="comment">## 异常失败，连接超时后的重试次数</span></span><br><span class="line">        <span class="comment">## key由IP + Port组成，唯一标识一个服务实例</span></span><br><span class="line"><span class="attr">        pool-max-total-per-key:</span> <span class="number">200</span> <span class="comment">## 客户端保持的最大连接数，包含不同的服务和服务实例</span></span><br><span class="line"><span class="attr">        pool-min-idle-per-key:</span> <span class="number">10</span>  <span class="comment">## 每个服务实例最小的空闲连接数</span></span><br><span class="line"><span class="attr">        pool-max-idle-per-key:</span> <span class="number">40</span>  <span class="comment">## 每个服务实例最大的空闲连接数</span></span><br><span class="line"><span class="attr">        pool-max-wait:</span> <span class="number">30000</span>  <span class="comment">## 空闲连接最大存活时间</span></span><br><span class="line"><span class="attr">        connect-timeout:</span> <span class="number">2000</span>  <span class="comment">## 连接超时时间</span></span><br></pre></td></tr></table></figure><p>编写 <code>Thrift Client</code>的<strong>客户端代理接口</strong>，这里有两点注意事项：</p><ul><li>接口需要继承于<strong>父接口</strong> <code>ThriftClientAware</code>，且 <code>ThriftClientAware</code> 里的<strong>泛型参数</strong>填写为 <code>Thrift IDL</code> 生成的 <code>Stub</code> 类 <code>CalculatorService</code> 中的 <code>Client</code> 内部类。</li><li>接口需要标识 <code>@ThriftClient</code> 注解， <code>@ThriftClient</code> 包含如下属性：<ul><li><strong>serviceId</strong>：此客户端代理接口绑定的 <code>Thrift</code> <strong>服务端</strong>的<strong>服务注册ID</strong> (与服务端<strong>保持一致</strong>)。</li><li><strong>refer</strong>：客户端桩 <code>Stub</code>的类型，例如这里是<code>CalculatorService.class</code>。</li><li><strong>version</strong>：具体业务实现类的<strong>版本号</strong>(不填写默认为<code>1.0</code>)，需要与服务端<strong>保持一致</strong>。</li></ul></li></ul><p>CalculatorThriftClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThriftClient</span>(serviceId = <span class="string">"thrift-rpc-calculator"</span>, refer = CalculatorService.class, version = <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculatorThriftClient</span> <span class="keyword">extends</span> <span class="title">ThriftClientAware</span>&lt;<span class="title">CalculatorService</span>.<span class="title">Client</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解 <code>@ThriftReferer</code>，在客户端的 <code>Controller</code> 中注入 <code>CalculatorThriftClient</code>。 使用时，通过 <code>CalculatorThriftClient.thriftClient()</code> 方法，即可调用<code>Thrift Server</code>的服务方法。</p><p>RpcCalculatorController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rpc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcCalculatorController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ThriftReferer</span></span><br><span class="line">    <span class="keyword">private</span> CalculatorThriftClient calculators;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(@RequestParam(<span class="string">"arg1"</span>)</span> <span class="keyword">int</span> arg1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"arg2"</span>)</span> <span class="keyword">int</span> arg2) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculators.client().add(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/subtract"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtract</span><span class="params">(@RequestParam(<span class="string">"arg1"</span>)</span> <span class="keyword">int</span> arg1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"arg2"</span>)</span> <span class="keyword">int</span> arg2) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculators.client().subtract(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/multiply"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(@RequestParam(<span class="string">"arg1"</span>)</span> <span class="keyword">int</span> arg1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"arg2"</span>)</span> <span class="keyword">int</span> arg2) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculators.client().multiply(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/division"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">division</span><span class="params">(@RequestParam(<span class="string">"arg1"</span>)</span> <span class="keyword">int</span> arg1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"arg2"</span>)</span> <span class="keyword">int</span> arg2) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculators.client().division(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方便，在<strong>本地开发环境</strong>配置<code>Consul</code>的地址，运行<strong>客户端程序</strong>即可。对于<strong>容器环境</strong>测试，配置对客户端程序进行打包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>编写 <code>Dockerfile</code> 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/spring-boot-thrift-client-0.0.1-SNAPSHOT.jar calculator-client.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"calculator-client.jar"</span>]</span></span><br></pre></td></tr></table></figure><p>将<code>Dockerfile</code> 和 <code>target/spring-boot-thrift-client-0.0.1-SNAPSHOT.jar</code>拷贝到服务器上，构建 <code>Thrift Client</code> 的服务镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t icekredit/calculator-client</span><br></pre></td></tr></table></figure><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><h3 id="发布服务端程序"><a href="#发布服务端程序" class="headerlink" title="发布服务端程序"></a>发布服务端程序</h3><p>为了方便测试，在一台主机上启动三个 <code>Thrift Server</code> 的 <code>docker</code> 容器，以不同的<strong>端口</strong>区分，分别指定对应的<strong>端口号</strong>和 <code>Consul</code> 注册信息：</p><p><code>Thrift Server</code>实例1(<code>25001</code>端口)：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 8081:8080 -p 25001:25000 --name calculator-server-01 \</span></span><br><span class="line"><span class="bash">    -e <span class="string">"SERVICE_25000_NAME=thrift-rpc-calculator"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TCP=/"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_INTERVAL=30s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TIMEOUT=3s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_TAGS=thrift-rpc-calculator-25001"</span> \</span></span><br><span class="line"><span class="bash">  icekredit/calculator-server</span></span><br></pre></td></tr></table></figure><p><code>Thrift Server</code>实例2(<code>25002</code>端口)：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 8081:8080 -p 25002:25000 --name calculator-server-01 \</span></span><br><span class="line"><span class="bash">    -e <span class="string">"SERVICE_25000_NAME=thrift-rpc-calculator"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TCP=/"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_INTERVAL=30s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TIMEOUT=3s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_TAGS=thrift-rpc-calculator-25002"</span> \</span></span><br><span class="line"><span class="bash">  icekredit/calculator-server</span></span><br></pre></td></tr></table></figure><p><code>Thrift Server</code>实例3(<code>25003</code>端口)：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 8081:8080 -p 25003:25000 --name calculator-server-01 \</span></span><br><span class="line"><span class="bash">    -e <span class="string">"SERVICE_25000_NAME=thrift-rpc-calculator"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TCP=/"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_INTERVAL=30s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_CHECK_TIMEOUT=3s"</span> \</span></span><br><span class="line"><span class="bash">  -e <span class="string">"SERVICE_25000_TAGS=thrift-rpc-calculator-25003"</span> \</span></span><br><span class="line"><span class="bash">    icekredit/calculator-server</span></span><br></pre></td></tr></table></figure><p>观察各个容器的启动日志，如果包含以下<strong>几行输出信息</strong>，则表明 <code>Thrift Server</code> 成功启动并正常提供 <code>RPC</code> 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-11-19 22:28:47.779  INFO 12960 --- [           main] c.i.r.t.s.context.ThriftServerContext    : Build thrift server from HsHaServerContext</span><br><span class="line">2017-11-19 22:28:47.820  INFO 12960 --- [           main] c.i.r.t.s.p.TRegisterProcessorFactory    : Processor bean org.ostenant.springboot.learning.examples.CalculatorService<span class="variable">$Processor</span>@445bce9a with signature [thrift-rpc-calculator<span class="variable">$org</span>.ostenant.springboot.learning.examples.CalculatorService<span class="variable">$2</span>.0] is instantiated</span><br><span class="line">2017-11-19 22:28:47.822  INFO 12960 --- [           main] c.i.r.t.s.p.TRegisterProcessorFactory    : Single processor org.ostenant.springboot.learning.examples.CalculatorService<span class="variable">$Processor</span>@445bce9a register onto multiplexed processor with signature [thrift-rpc-calculator<span class="variable">$org</span>.ostenant.springboot.learning.examples.CalculatorService<span class="variable">$2</span>.0]</span><br><span class="line">2017-11-19 22:28:47.822  INFO 12960 --- [           main] c.i.r.t.s.p.TRegisterProcessorFactory    : Multiplexed processor totally owns 1 service processors</span><br></pre></td></tr></table></figure><p>启动 <code>Consul</code> 和<code>Registrator</code> 容器，<code>Thrift Server</code> 的三个服务实例成功注册到<code>Consul</code>服务列表：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/consul_server_calculator.png" alt=""></p><p>有关 <code>Consul</code>和 <code>Registrator</code>的安装配置以及使用，请参考：<strong>Docker+Consul+Registrator(一) 搭建服务发现与注册集群</strong>！</p><p>服务端程序成功运行，<code>Thrift RPC</code>服务正常发布！</p><h3 id="启动客户端程序"><a href="#启动客户端程序" class="headerlink" title="启动客户端程序"></a>启动客户端程序</h3><p>在本地 <code>8080</code> 端口号启动 <code>Thrift</code> 客户端，正常启动后观察启动日志如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2017-11-20 11:00:20.025  INFO 4052 --- [           main] .r.t.c.ThriftClientBeanScannerConfigurer : Base package org.ostenant.springboot.learning.examples.rpc is to be scanned with com.icekredit.rpc.thrift.client.scanner.ThriftClientBeanScanner@37496720</span><br><span class="line">2017-11-20 11:00:20.029  INFO 4052 --- [           main] c.i.r.t.c.s.ThriftClientBeanScanner      : Packages scanned by thriftClientBeanDefinitionScanner is [org.ostenant.springboot.learning.examples.rpc]</span><br><span class="line">2017-11-20 11:00:20.029  INFO 4052 --- [           main] c.i.r.t.c.s.ThriftClientBeanScanner      : Scanned and found thrift client, bean calculatorThriftClient assigned from org.ostenant.springboot.learning.examples.rpc.CalculatorThriftClient</span><br><span class="line">2017-11-20 11:00:20.050  INFO 4052 --- [           main] f.a.AutowiredAnnotationBeanPostProcessor : JSR-330 <span class="string">'javax.inject.Inject'</span> annotation found and supported <span class="keyword">for</span> autowiring</span><br><span class="line">2017-11-20 11:00:20.134  INFO 4052 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">'org.ostenant.springboot.learning.examples.rest.CalculatorFeignClient'</span> of <span class="built_in">type</span> [org.springframework.cloud.netflix.feign.FeignClientFactoryBean] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2017-11-20 11:00:20.136  WARN 4052 --- [           main] c.i.r.t.c.s.ThriftClientFactoryBean      : Bean class is not found</span><br><span class="line">2017-11-20 11:00:20.142  INFO 4052 --- [           main] c.i.r.t.c.s.ThriftClientFactoryBean      : Succeed to instantiate an instance of ThriftClientFactoryBean: com.icekredit.rpc.thrift.client.scanner.ThriftClientFactoryBean@7bac686b</span><br><span class="line">2017-11-20 11:00:20.142  INFO 4052 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">'calculatorThriftClient'</span> of <span class="built_in">type</span> [com.icekredit.rpc.thrift.client.scanner.ThriftClientFactoryBean] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2017-11-20 11:00:20.411  INFO 4052 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">'org.springframework.cloud.netflix.metrics.MetricsInterceptorConfiguration$MetricsRestTemplateConfiguration'</span> of <span class="built_in">type</span> [org.springframework.cloud.netflix.metrics.MetricsInterceptorConfiguration<span class="variable">$MetricsRestTemplateConfiguration</span>$<span class="variable">$EnhancerBySpringCGLIB</span>$<span class="variable">$a9ef18dc</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2017-11-20 11:00:20.423  INFO 4052 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">'org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration'</span> of <span class="built_in">type</span> [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$<span class="variable">$EnhancerBySpringCGLIB</span>$<span class="variable">$93dc7598</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2017-11-20 11:00:21.592  INFO 4052 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)</span><br></pre></td></tr></table></figure><p>启动过程中，所有的标记有注解 <code>@ThriftClient</code>的接口都生成了<strong>代理对象</strong>，并通过注解 <code>@ThriftReferer</code>注入到 <code>Controller</code>中。</p><p>同时，<strong>客户端</strong>启动时开启了一个<code>ServerUpdater</code>，<strong>定时动态</strong>的去<code>Consul</code>服务注册列表抓取<strong>健康的服务节点信息</strong>，缓存到<strong>本地服务列表</strong>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-11-20 11:02:26.726  INFO 4052 --- [erListUpdater-0] t.c.l.ThriftConsulServerListLoadBalancer : Refreshed thrift serverList: [thrift-rpc-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25001], host=<span class="string">'192.168.91.128'</span>, port=25001, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25002], host=<span class="string">'192.168.91.128'</span>, port=25002, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25003], host=<span class="string">'192.168.91.128'</span>, port=25003, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8301: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8302: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], thrift-rest-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8081], host=<span class="string">'192.168.91.128'</span>, port=8081, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8082], host=<span class="string">'192.168.91.128'</span>, port=8082, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8083], host=<span class="string">'192.168.91.128'</span>, port=8083, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;]]</span><br><span class="line">2017-11-20 11:02:56.752  INFO 4052 --- [erListUpdater-0] t.c.l.ThriftConsulServerListLoadBalancer : Refreshed thrift serverList: [thrift-rpc-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25001], host=<span class="string">'192.168.91.128'</span>, port=25001, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25002], host=<span class="string">'192.168.91.128'</span>, port=25002, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25003], host=<span class="string">'192.168.91.128'</span>, port=25003, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8301: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8302: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], thrift-rest-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8081], host=<span class="string">'192.168.91.128'</span>, port=8081, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8082], host=<span class="string">'192.168.91.128'</span>, port=8082, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8083], host=<span class="string">'192.168.91.128'</span>, port=8083, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;]]</span><br><span class="line">2017-11-20 11:03:26.764  INFO 4052 --- [erListUpdater-0] t.c.l.ThriftConsulServerListLoadBalancer : Refreshed thrift serverList: [thrift-rpc-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25001], host=<span class="string">'192.168.91.128'</span>, port=25001, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25002], host=<span class="string">'192.168.91.128'</span>, port=25002, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rpc-calculator'</span>, tags=[thrift-rpc-calculator-25003], host=<span class="string">'192.168.91.128'</span>, port=25003, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8301: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8301'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10301, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], consul-8302: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=8302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=9302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'consul-8302'</span>, tags=[udp], host=<span class="string">'192.168.91.128'</span>, port=10302, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;], thrift-rest-calculator: [ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8081], host=<span class="string">'192.168.91.128'</span>, port=8081, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8082], host=<span class="string">'192.168.91.128'</span>, port=8082, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;, ThriftServerNode&#123;node=<span class="string">'node1'</span>, serviceId=<span class="string">'thrift-rest-calculator'</span>, tags=[thrift-rest-calculator-8083], host=<span class="string">'192.168.91.128'</span>, port=8083, address=<span class="string">'192.168.91.128'</span>, isHealth=<span class="literal">true</span>&#125;]]</span><br></pre></td></tr></table></figure><p>访问本地<code>Thrift</code>客户端：</p><table><thead><tr><th style="text-align:left">访问地址</th><th style="text-align:center">参数arg1</th><th style="text-align:center">参数arg2</th><th style="text-align:center">页面输出结果</th></tr></thead><tbody><tr><td style="text-align:left">/rpc/add</td><td style="text-align:center">200</td><td style="text-align:center">100</td><td style="text-align:center">300</td></tr><tr><td style="text-align:left">/rpc/subtract</td><td style="text-align:center">200</td><td style="text-align:center">100</td><td style="text-align:center">100</td></tr><tr><td style="text-align:left">/rpc/multiply</td><td style="text-align:center">200</td><td style="text-align:center">100</td><td style="text-align:center">20000</td></tr><tr><td style="text-align:left">/rpc/division</td><td style="text-align:center">200</td><td style="text-align:center">100</td><td style="text-align:center">2</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单地介绍了如何利用 <code>starter</code> 将 <code>Apache Thrift</code> 整合进入 <code>Spring Cloud</code> 中，关于更复杂的应用场景和<code>starter</code>内部的设计、实现原理，后续会一步步的给出具体的介绍！</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面几篇博客，着重对&lt;code&gt;Apache Thrift&lt;/code&gt;的使用和原理做了介绍。在微服架构流行的今天，自然而然就会想到&lt;code&gt;Spring Boot&lt;/code&gt;和&lt;code&gt;Spring Cloud&lt;/code&gt;作为&lt;strong&gt;微服务&lt;/strong&gt;的基础框架。然而，&lt;code&gt;Spring Cloud&lt;/code&gt;从诞生以来，就基于&lt;code&gt;HTTP&lt;/code&gt;协议的&lt;strong&gt;轻量级&lt;/strong&gt;&lt;code&gt;Restful API&lt;/code&gt;作为服务之间的通信方式。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Thrift" scheme="https://ostenant.coding.me/tags/Thrift/"/>
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
      <category term="Spring Cloud" scheme="https://ostenant.coding.me/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>阿里云CentOS 7上安装配置Docker</title>
    <link href="https://ostenant.coding.me/2018/01/18/%E9%98%BF%E9%87%8C%E4%BA%91CentOS%207%E4%B8%8A%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEDocker/"/>
    <id>https://ostenant.coding.me/2018/01/18/阿里云CentOS 7上安装配置Docker/</id>
    <published>2018-01-18T01:44:00.000Z</published>
    <updated>2018-05-08T02:49:46.097Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Docker</code>是一个开源工具，它可以让创建和管理<code>Linux</code>容器变得简单。<strong>容器</strong>就像是<strong>轻量级</strong>的<strong>虚拟机</strong>，并且可以以<strong>毫秒级</strong>的速度来启动或停止。<code>Docker</code>帮助系统管理员和程序员<strong>在容器中开发应用程序</strong>，并且可以扩展到成千上万的节点。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_logo.png" alt=""></p><p>这是一只鲸鱼，它托着许多集装箱。我们可以把<strong>宿主机</strong>可当做这只<strong>鲸鱼</strong>，把<strong>相互隔离</strong>的<strong>容器</strong>可看成<strong>集装箱</strong>，每个集装箱中都包含自己的<strong>应用程序</strong>。</p><hr><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><h2 id="Docker与传统虚拟区别"><a href="#Docker与传统虚拟区别" class="headerlink" title="Docker与传统虚拟区别"></a>Docker与传统虚拟区别</h2><ul><li>传统虚拟化技术的体系架构：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/virtualization_host_architecture.png" alt=""></p><ul><li><code>Docker</code>技术的体系架构：</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_architecture.png" alt=""></p><p><strong>容器</strong>和<strong>虚拟机</strong>(<code>VM</code>)的主要区别是：</p><ul><li>容器提供了基于<strong>进程</strong>的隔离，而虚拟机提供了<strong>资源</strong>(<code>CPU</code>、内存和硬盘)的<strong>完全隔离</strong>。</li><li>虚拟机可能需要<strong>一分钟</strong>来启动，而容器只需要<strong>一秒钟</strong>或更短。</li><li>虚拟机占用的<strong>内存空间</strong>可达到<strong>几个</strong><code>G</code>，而容器可能只需要<strong>几百兆</strong>。</li><li>容器使用<strong>宿主操作系统</strong>的内核，而虚拟机使用<strong>独立</strong>的内核。</li></ul><h2 id="Docker平台的基本构成"><a href="#Docker平台的基本构成" class="headerlink" title="Docker平台的基本构成"></a>Docker平台的基本构成</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_component.jpg" alt=""></p><p><code>Docker</code>平台基本上由三部分组成：</p><ul><li><strong>客户端</strong>：用户使用<code>Docker</code>提供的工具(<code>CLI</code>以及<code>API</code>等)来构建，<strong>上传镜像</strong>并发布命令来<strong>创建</strong>和<strong>启动容器</strong>。</li><li><strong>Docker主机</strong>：从<code>Docker registry</code>上下载<strong>镜像</strong>并<strong>启动</strong>和<strong>托管</strong>容器。</li><li><strong>Docker registry</strong>：<code>Docker</code>镜像仓库，用于<strong>保存镜像</strong>，并提供镜像上传和下载。</li></ul><h2 id="Docker容器的状态机"><a href="#Docker容器的状态机" class="headerlink" title="Docker容器的状态机"></a>Docker容器的状态机</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_lifecycle.jpg" alt=""></p><p>一个容器在某个时刻可能处于以下几种状态之一：</p><p><strong>created</strong>：已经被创建 (使用<code>docker ps -a</code>命令可以列出) 但是还没有被启动，使用<code>docker ps</code>命令还无法列出。<br><strong>running</strong>：容器在这正常运行中。<br><strong>paused</strong>：容器的进程被暂停了。<br><strong>restarting</strong>：容器的进程正在重启过程中。<br><strong>exited</strong>：上图中的<code>stopped</code>状态，表示容器之前运行过但是现在处于停止状态 (要区别于<code>created</code>状态，它是指一个<strong>新创建</strong>的<strong>尚未运行过</strong>的容器)。可以通过<code>start</code>命令使其重新进入<code>running</code>状态。<br><strong>destroyed</strong>：容器从宿主机删除了，再也不存在了。</p><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><p><code>RedHat/CentOS</code>必须要<code>6.6</code>版本以上，或者<code>7.x</code>才能安装<code>docker</code>，建议在<code>RedHat/CentOS 7</code>上使用<code>docker</code>，因为<code>RedHat/CentOS 7</code>的<strong>内核</strong>升级到了<code>kernel 3.10</code>，对<code>lxc</code>容器支持更好。</p><p>查看<code>Linux</code><strong>内核版本</strong>(内核版本必须是<code>3.10</code>或者以上)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line"></span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line">lsb_release -a</span><br><span class="line"></span><br><span class="line"><span class="comment">##无法执行命令安装</span></span><br><span class="line">yum install -y redhat-lsb</span><br></pre></td></tr></table></figure><p>更新<code>yum</code>安装源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker -y</span><br></pre></td></tr></table></figure><p>检查<code>docker</code>版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>安装完成后，使用下面的命令来启动<code>docker</code>服务，并将其设置为<strong>开机启动</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">chkconfig docker on</span><br></pre></td></tr></table></figure><p>下载官方的<code>CentOS</code>的<code>docker</code>镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p>检查<code>CentOS</code>镜像是否被成功拉取到本地宿主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地镜像列表</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi &lt;image id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像(针对多个相同image id的镜像)</span></span><br><span class="line">docker rmi repository:tag</span><br></pre></td></tr></table></figure><p>镜像下载完成后，你应该会看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze74fkxrls31tr2ia2fZ ~]<span class="comment"># docker images centos</span></span><br><span class="line">REPOSITORY       TAG        IMAGE ID     CREATED         SIZE</span><br><span class="line">docker.io/centos latest    3fa822599e10    3weeks ago   203.5 MB</span><br></pre></td></tr></table></figure><p>如果看到以上输出，说明你可以使用<code>docker.io/centos</code>这个镜像了，或将其称为<strong>仓库</strong>(<code>Repository</code>)，该镜像有一个名为<code>latest</code>的<strong>标签</strong>(<code>Tag</code>)，此外还有一个名为<code>3fa822599e10</code>的镜像<code>ID</code> (可能您所看到的镜像 ID 与此处的不一致，那是正常现象，因为这个数字是随机生成的)。<br>此外，我们可以看到该镜像只有<code>203.5MB</code>，非常小巧，而不像虚拟机的镜像文件那样庞大。</p><p>重命名<code>TAG</code>为<code>centos</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker tag IMAGE_ID(镜像id) REPOSITORY:TAG(仓库：标签)</span></span><br><span class="line">docker tag 3fa822599e10  docker.io/centos:centos</span><br></pre></td></tr></table></figure><p>启动<code>CentOS</code>的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t -v /root/software/:/mnt/software/ 3fa822599e10 /bin/bash</span><br></pre></td></tr></table></figure><p>命令参数说明：<br>docker run &lt;相关参数&gt; &lt;镜像ID&gt; &lt;初始命令&gt;</p><ul><li><code>-i</code>：表示以<strong>交互模式</strong>运行容器</li><li><code>-t</code>：表示容器启动后会进入其命令行</li><li><code>-v</code>：表示需要将本地哪个目录<strong>挂载</strong>到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;</li></ul><p>更多参数详解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">  -d, --detach=<span class="literal">false</span>         指定容器运行于前台还是后台，默认为<span class="literal">false</span></span><br><span class="line">  -i, --interactive=<span class="literal">false</span>   打开STDIN，用于控制台交互</span><br><span class="line">  -t, --tty=<span class="literal">false</span>            分配tty设备，该可以支持终端登录，默认为<span class="literal">false</span></span><br><span class="line">  -u, --user=<span class="string">""</span>              指定容器的用户</span><br><span class="line">  -a, --attach=[]            登录容器（必须是以docker run -d启动的容器）</span><br><span class="line">  -w, --workdir=<span class="string">""</span>           指定容器的工作目录</span><br><span class="line">  -c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用</span><br><span class="line">  -e, --env=[]               指定环境变量，容器中可以使用该环境变量</span><br><span class="line">  -m, --memory=<span class="string">""</span>            指定容器的内存上限</span><br><span class="line">  -P, --publish-all=<span class="literal">false</span>    指定容器暴露的端口</span><br><span class="line">  -p, --publish=[]           指定容器暴露的端口</span><br><span class="line">  -h, --hostname=<span class="string">""</span>          指定容器的主机名</span><br><span class="line">  -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录</span><br><span class="line">  --volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录</span><br><span class="line">  --<span class="built_in">cap</span>-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">  --<span class="built_in">cap</span>-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">  --cidfile=<span class="string">""</span>               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</span><br><span class="line">  --cpuset=<span class="string">""</span>                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</span><br><span class="line">  --device=[]                添加主机设备给容器，相当于设备直通</span><br><span class="line">  --dns=[]                   指定容器的dns服务器</span><br><span class="line">  --dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</span><br><span class="line">  --entrypoint=<span class="string">""</span>            覆盖image的入口点</span><br><span class="line">  --env-file=[]              指定环境变量文件，文件格式为每行一个环境变量</span><br><span class="line">  --expose=[]                指定容器暴露的端口，即修改镜像的暴露端口</span><br><span class="line">  --link=[]                  指定容器间的关联，使用其他容器的IP、env等信息</span><br><span class="line">  --lxc-conf=[]              指定容器的配置文件，只有在指定--<span class="built_in">exec</span>-driver=lxc时使用</span><br><span class="line">  --name=<span class="string">""</span>                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</span><br><span class="line">  --net=<span class="string">"bridge"</span>             容器网络设置:</span><br><span class="line">                                bridge 使用docker daemon指定的网桥</span><br><span class="line">                                host     //容器使用主机的网络</span><br><span class="line">                                container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源</span><br><span class="line">                                none 容器使用自己的网络（类似--net=bridge），但是不进行配置</span><br><span class="line">  --privileged=<span class="literal">false</span>         指定容器是否为特权容器，特权容器拥有所有的capabilities</span><br><span class="line">  --restart=<span class="string">"no"</span>             指定容器停止后的重启策略:</span><br><span class="line">                                no：容器退出时不重启</span><br><span class="line">                                on-failure：容器故障退出（返回值非零）时重启</span><br><span class="line">                                always：容器退出时总是重启</span><br><span class="line">  --rm=<span class="literal">false</span>                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</span><br><span class="line">  --sig-proxy=<span class="literal">true</span>           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</span><br></pre></td></tr></table></figure><h2 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h2><p>我们可以把<code>Docker</code>的命令大概地分类如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 镜像操作：</span></span><br><span class="line">    build     Build an image from a Dockerfile</span><br><span class="line">    commit    Create a new image from a container<span class="string">'s changes</span></span><br><span class="line"><span class="string">    images    List images</span></span><br><span class="line"><span class="string">    load      Load an image from a tar archive or STDIN</span></span><br><span class="line"><span class="string">    pull      Pull an image or a repository from a registry</span></span><br><span class="line"><span class="string">    push      Push an image or a repository to a registry</span></span><br><span class="line"><span class="string">    rmi       Remove one or more images</span></span><br><span class="line"><span class="string">    search    Search the Docker Hub for images</span></span><br><span class="line"><span class="string">    tag       Tag an image into a repository</span></span><br><span class="line"><span class="string">    save      Save one or more images to a tar archive</span></span><br><span class="line"><span class="string">    history   显示某镜像的历史</span></span><br><span class="line"><span class="string">    inspect   获取镜像的详细信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 容器及其中应用的生命周期操作：</span></span><br><span class="line"><span class="string">    create    创建一个容器</span></span><br><span class="line"><span class="string">    kill      Kill one or more running containers</span></span><br><span class="line"><span class="string">    inspect   Return low-level information on a container, image or task</span></span><br><span class="line"><span class="string">    pause     Pause all processes within one or more containers</span></span><br><span class="line"><span class="string">    ps        List containers</span></span><br><span class="line"><span class="string">    rm        删除一个或者多个容器</span></span><br><span class="line"><span class="string">    rename    Rename a container</span></span><br><span class="line"><span class="string">    restart   Restart a container</span></span><br><span class="line"><span class="string">    run       创建并启动一个容器</span></span><br><span class="line"><span class="string">    start     启动一个处于停止状态的容器</span></span><br><span class="line"><span class="string">    stats     显示容器实时的资源消耗信息</span></span><br><span class="line"><span class="string">    stop      停止一个处于运行状态的容器</span></span><br><span class="line"><span class="string">    top       Display the running processes of a container</span></span><br><span class="line"><span class="string">    unpause   Unpause all processes within one or more containers</span></span><br><span class="line"><span class="string">    update    Update configuration of one or more containers</span></span><br><span class="line"><span class="string">    wait      Block until a container stops, then print its exit code</span></span><br><span class="line"><span class="string">    attach    Attach to a running container</span></span><br><span class="line"><span class="string">    exec      Run a command in a running container</span></span><br><span class="line"><span class="string">    port      List port mappings or a specific mapping for the container</span></span><br><span class="line"><span class="string">    logs      获取容器的日志</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 容器文件系统操作：</span></span><br><span class="line"><span class="string">    cp        Copy files/folders between a container and the local filesystem</span></span><br><span class="line"><span class="string">    diff      Inspect changes on a container'</span>s filesystem</span><br><span class="line">    <span class="built_in">export</span>    Export a container<span class="string">'s filesystem as a tar archive</span></span><br><span class="line"><span class="string">    import    Import the contents from a tarball to create a filesystem image</span></span><br><span class="line"><span class="string">    Docker registry 操作：</span></span><br><span class="line"><span class="string">    login     Log in to a Docker registry.</span></span><br><span class="line"><span class="string">    logout    Log out from a Docker registry.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Volume操作：</span></span><br><span class="line"><span class="string">    volume    Manage Docker volumes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 网络操作：</span></span><br><span class="line"><span class="string">    network   Manage Docker networks</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Swarm 相关操作：</span></span><br><span class="line"><span class="string">    swarm     Manage Docker Swarm</span></span><br><span class="line"><span class="string">    service   Manage Docker services</span></span><br><span class="line"><span class="string">    node      Manage Docker Swarm nodes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 系统操作：</span></span><br><span class="line"><span class="string">    version   Show the Docker version information</span></span><br><span class="line"><span class="string">    events    持续返回docker 事件</span></span><br><span class="line"><span class="string">    info      显示Docker 主机系统范围内的信息</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line">按Ctrl+D 即可退出当前容器【但退出后会停止容器】</span><br><span class="line"><span class="comment"># 退出不停止容器：</span></span><br><span class="line">组合键：Ctrl+P+Q</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start 容器名或ID</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker attach 容器名或ID</span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop 容器名或ID</span><br><span class="line"><span class="comment"># 暂停容器</span></span><br><span class="line">docker pause 容器名或ID</span><br><span class="line"><span class="comment">#继续容器</span></span><br><span class="line">docker unpause 容器名或ID</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm 容器名或ID</span><br><span class="line"><span class="comment"># 删除全部容器--慎用</span></span><br><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br><span class="line"><span class="comment">#保存容器，生成镜像</span></span><br><span class="line">docker commit 容器ID 镜像名称</span><br><span class="line"><span class="comment">#从 host 拷贝文件到 container 里面</span></span><br><span class="line">docker cp /home/soft centos:/webapp</span><br></pre></td></tr></table></figure><h2 id="docker-run与start的区别"><a href="#docker-run与start的区别" class="headerlink" title="docker run与start的区别"></a>docker run与start的区别</h2><p><code>docker run</code>只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令<code>docker start</code> 即可。</p><p><code>docker run</code>相当于执行了两步操作：将镜像放入容器中(<code>docker create</code>)，然后将容器启动，使之变成运行时容器(<code>docker start</code>)。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_run_docker_start.png" alt=""></p><p>而<code>docker start</code>的作用是，重新启动已存在的镜像。也就是说，如果使用这个命令，我们必须事先知道这个<strong>容器</strong>的<code>ID</code>，或者这个容器的<strong>名字</strong>，我们可以使用<code>docker ps</code>找到这个容器的信息。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/docker_rename_ps.png" alt=""></p><p>因为容器的<code>ID</code>是<strong>随机码</strong>，而容器的名字又是看似无意义的命名，我们可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename jovial_cori  centos</span><br></pre></td></tr></table></figure><p>给这个容器命名。这样以后，我们再次启动或停止容器时，就可以直接使用这个名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [stop] [start]  new_name</span><br></pre></td></tr></table></figure><p>而要显示出所有容器，包括没有启动的，可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h2 id="Docker的配置"><a href="#Docker的配置" class="headerlink" title="Docker的配置"></a>Docker的配置</h2><p>更改存储目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制docker存储目录</span></span><br><span class="line">rsync -aXS /var/lib/docker/. /home/docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#更改 docker 存储文件目录</span></span><br><span class="line">ln -s  /home/docker  /var/lib/docker</span><br></pre></td></tr></table></figure><p>查看启动容器的具体信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;container_id&gt;</span><br></pre></td></tr></table></figure><p>要获取所有容器名称及其<code>IP</code>地址只需一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">'&#123;&#123;.Name&#125;&#125; - &#123;&#123;.NetworkSettings.IPAddress &#125;&#125;'</span> $(docker ps -aq)</span><br><span class="line"></span><br><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;'</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure><h2 id="Docker镜像加速器"><a href="#Docker镜像加速器" class="headerlink" title="Docker镜像加速器"></a>Docker镜像加速器</h2><p>注册一个阿里云帐号：</p><p><a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></p><p>阿里云会自动为用户分配一个镜像加速器的地址，登录后进入”管理中心” —&gt; ”加速器”，里面有分配给你的镜像加速器的地址以及各个环境的使用说明。</p><p>镜像加速器地址示例：<a href="https://xxxxx.mirror.aliyuncs.com" target="_blank" rel="noopener">https://xxxxx.mirror.aliyuncs.com</a></p><h3 id="如何配置镜像加速器"><a href="#如何配置镜像加速器" class="headerlink" title="如何配置镜像加速器"></a>如何配置镜像加速器</h3><p>针对<code>Docker</code>客户端版本大于<code>1.10.0</code>的用户，可以通过修改<code>daemon</code>配置文件<code>/etc/docker/daemon.json</code><strong>来使用</strong>加速器**：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [<span class="string">"&lt;your accelerate address&gt;"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启<code>Docker Daemon</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;是一个开源工具，它可以让创建和管理&lt;code&gt;Linux&lt;/code&gt;容器变得简单。&lt;strong&gt;容器&lt;/strong&gt;就像是&lt;strong&gt;轻量级&lt;/strong&gt;的&lt;strong&gt;虚拟机&lt;/strong&gt;，并且可以以&lt;strong&gt;毫秒级&lt;/strong&gt;的速度来启动或停止。&lt;code&gt;Docker&lt;/code&gt;帮助系统管理员和程序员&lt;strong&gt;在容器中开发应用程序&lt;/strong&gt;，并且可以扩展到成千上万的节点。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker学习系列" scheme="https://ostenant.coding.me/categories/Docker%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="CentOS" scheme="https://ostenant.coding.me/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Apache Thrift系列详解(三) - 序列化机制</title>
    <link href="https://ostenant.coding.me/2018/01/16/Apache%20Thrift%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3(%E4%B8%89)%20-%20%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>https://ostenant.coding.me/2018/01/16/Apache Thrift系列详解(三) - 序列化机制/</id>
    <published>2018-01-16T07:37:00.000Z</published>
    <updated>2018-05-08T02:49:46.087Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Thrift</code>支持<strong>二进制</strong>，<strong>压缩格式</strong>，以及<code>json</code>格式数据的<strong>序列化</strong>和<strong>反序列化</strong>。开发人员可以更加灵活的选择协议的具体形式。协议是可<strong>自由扩展</strong>的，新版本的协议，完全<strong>兼容</strong>老的版本！</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="数据交换格式简介"><a href="#数据交换格式简介" class="headerlink" title="数据交换格式简介"></a>数据交换格式简介</h2><p>当前流行的<strong>数据交换格式</strong>可以分为如下几类：</p><h3 id="一-自解析型"><a href="#一-自解析型" class="headerlink" title="(一) 自解析型"></a>(一) 自解析型</h3><p>序列化的数据包含<strong>完整</strong>的结构， 包含了<code>field</code><strong>名称</strong>和<code>value</code><strong>值</strong>。比如<code>xml/json/java serizable</code>，大百度的<code>mcpack/compack</code>，都属于此类。即调整不同属性的<strong>顺序</strong>对<strong>序列化/反序列化</strong>不造成影响。</p><h3 id="二-半解析型"><a href="#二-半解析型" class="headerlink" title="(二) 半解析型"></a>(二) 半解析型</h3><p>序列化的数据，丢弃了部分信息， 比如<code>field</code>名称， 但引入了<code>index</code>(常常是<code>id</code>+<code>type</code>的方式)来对应具体<strong>属性</strong>和<strong>值</strong>。这方面的代表有<code>google protobuf/thrift</code>也属于此类。</p><h3 id="三-无解析型"><a href="#三-无解析型" class="headerlink" title="(三) 无解析型"></a>(三) 无解析型</h3><p>传说中大百度的<code>infpack</code>实现，就是借助该种方式来实现，丢弃了很多<strong>有效信息</strong>，<strong>性能/压缩</strong>比最好，不过向后兼容需要开发做一定的工作， 详情不知。</p><table><thead><tr><th>交换格式</th><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Xml</td><td>文本</td><td>易读</td><td>臃肿，不支持二进制数据类型</td></tr><tr><td>JSON</td><td>文本</td><td>易读</td><td>丢弃了类型信息，比如”score”:100，对score类型是int/double解析有二义性， 不支持二进制数据类型</td></tr><tr><td>Java serizable</td><td>二进制</td><td>使用简单</td><td>臃肿，只限制在JAVA领域</td></tr><tr><td>Thrift</td><td>二进制</td><td>高效</td><td>不易读，向后兼容有一定的约定限制</td></tr><tr><td>Google Protobuf</td><td>二进制</td><td>高效</td><td>不易读，向后兼容有一定的约定限制</td></tr></tbody></table><h2 id="Thrift的数据类型"><a href="#Thrift的数据类型" class="headerlink" title="Thrift的数据类型"></a>Thrift的数据类型</h2><ol><li><strong>基本类型：</strong><br>　　<strong>bool</strong>: 布尔值<br>　　<strong>byte</strong>: 8位有符号整数<br>　　<strong>i16</strong>: 16位有符号整数<br>　　<strong>i32</strong>: 32位有符号整数<br>　　<strong>i64</strong>: 64位有符号整数<br>　　<strong>double</strong>: 64位浮点数<br>　　<strong>string</strong>: UTF-8编码的字符串<br>　　<strong>binary</strong>: 二进制串</li><li><strong>结构体类型：</strong><br>　　<strong>struct</strong>: 定义的结构体对象</li><li><strong>容器类型：</strong><br>　　<strong>list</strong>: 有序元素列表<br>　　<strong>set</strong>: 无序无重复元素集合<br>　　<strong>map</strong>: 有序的key/value集合</li><li><strong>异常类型：</strong><br>　　<strong>exception</strong>: 异常类型</li><li><strong>服务类型：</strong><br>　　<strong>service</strong>: 具体对应服务的类</li></ol><h2 id="Thrift的序列化协议"><a href="#Thrift的序列化协议" class="headerlink" title="Thrift的序列化协议"></a>Thrift的序列化协议</h2><p><code>Thrift</code>可以让用户选择<strong>客户端</strong>与<strong>服务端</strong>之间<strong>传输通信协议</strong>的类别，在<strong>传输协议</strong>上总体划分为<strong>文本</strong>(<code>text</code>)和<strong>二进制</strong>(<code>binary</code>)传输协议。为<strong>节约带宽</strong>，<strong>提高传输效率</strong>，一般情况下使用<strong>二进制</strong>类型的传输协议为多数，有时还会使用基于<strong>文本类型</strong>的协议，这需要根据项目/产品中的实际需求。常用协议有以下几种：</p><ul><li>TBinaryProtocol：<strong>二进制</strong>编码格式进行数据传输</li><li>TCompactProtocol：<strong>高效率</strong>的、<strong>密集</strong>的<strong>二进制</strong>编码格式进行数据传输</li><li>TJSONProtocol： 使用<code>JSON</code><strong>文本</strong>的数据编码协议进行数据传输</li><li>TSimpleJSONProtocol：只提供<code>JSON</code><strong>只写</strong>的协议，适用于通过<strong>脚本语言解析</strong></li></ul><h2 id="Thrift的序列化测试"><a href="#Thrift的序列化测试" class="headerlink" title="Thrift的序列化测试"></a>Thrift的序列化测试</h2><p>(a). 首先编写一个简单的<code>thrift</code>文件<code>pair.thrift</code>：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">string</span> key</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里标识了<code>required</code>的字段，要求在使用时必须正确赋值，否则运行时会抛出<code>TProtocolException</code>异常。缺省和指定为<code>optional</code>时，则运行时不做字段非空校验。</p></blockquote><p>(b). 编译并生成<code>java</code>源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -gen java pair.thrift</span><br></pre></td></tr></table></figure><p>(c). 编写序列化和反序列化的测试代码：</p><ul><li>序列化测试，将<code>Pair</code>对象写入文件中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> <span class="keyword">throws</span> IOException， TException </span>&#123;</span><br><span class="line">    Pair pair = <span class="keyword">new</span> Pair();</span><br><span class="line">    pair.setKey(<span class="string">"key1"</span>).setValue(<span class="string">"value1"</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"pair.txt"</span>));</span><br><span class="line">    pair.write(<span class="keyword">new</span> TBinaryProtocol(<span class="keyword">new</span> TIOStreamTransport(fos)));</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反序列化测试，从文件中解析生成<code>Pair</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> <span class="keyword">throws</span> TException， IOException </span>&#123;</span><br><span class="line">    Pair pair = <span class="keyword">new</span> Pair();</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"pair.txt"</span>));</span><br><span class="line">    pair.read(<span class="keyword">new</span> TBinaryProtocol(<span class="keyword">new</span> TIOStreamTransport(fis)));</span><br><span class="line">    System.out.println(<span class="string">"key =&gt; "</span> + pair.getKey());</span><br><span class="line">    System.out.println(<span class="string">"value =&gt; "</span> + pair.getValue());</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(d) 观察运行结果，正常输出表明<strong>序列化</strong>和<strong>反序列化</strong>过程正常完成。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Serialization_Pair.png" alt=""></p><h2 id="Thrift协议源码"><a href="#Thrift协议源码" class="headerlink" title="Thrift协议源码"></a>Thrift协议源码</h2><h3 id="一-writeData-分析"><a href="#一-writeData-分析" class="headerlink" title="(一) writeData()分析"></a>(一) writeData()分析</h3><p>首先查看<code>thrift</code>的<strong>序列化机制</strong>，即数据写入实现，这里采用<strong>二进制协议</strong><code>TBinaryProtocol</code>，切入点为<code>pair.write(TProtocol)</code>：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_write.png" alt=""></p><p>查看<code>scheme()</code>方法，决定采用<strong>元组计划</strong>(<code>TupleScheme</code>)还是<strong>标准计划</strong>(<code>StandardScheme</code>)来实现序列化，默认采用的是<strong>标准计划</strong><code>StandardScheme</code>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_Scheme.png" alt=""></p><p><strong>标准计划</strong>(<code>StandardScheme</code>)下的<code>write()</code>方法：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_Standard_Scheme_Write.png" alt=""></p><p>这里完成了几步操作：</p><p>(a). 根据<code>Thrift IDL</code>文件中定义了<code>required</code>的字段验证字段是否正确赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">  <span class="comment">// check for required fields</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'key' was not present! Struct: "</span> + toString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'value' was not present! Struct: "</span> + toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(b). 通过<code>writeStructBegin()</code>记录<strong>写入结构</strong>的<strong>开始标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructBegin</span><span class="params">(TStruct struct)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>(c). 逐一写入<code>Pair</code>对象的各个字段，包括字段<strong>字段开始标记</strong>、<strong>字段的值</strong>和<strong>字段结束标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (struct.key != <span class="keyword">null</span>) &#123;</span><br><span class="line">  oprot.writeFieldBegin(KEY_FIELD_DESC);</span><br><span class="line">  oprot.writeString(struct.key);</span><br><span class="line">  oprot.writeFieldEnd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略...</span></span><br></pre></td></tr></table></figure><p>(1). 首先是<strong>字段开始标记</strong>，包括<code>type</code>和<code>field-id</code>。<code>type</code>是字段的<strong>数据类型的标识号</strong>，<code>field-id</code>是<code>Thrift IDL</code>定义的<strong>字段次序</strong>，比如说<code>key</code>为1，<code>value</code>为2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  writeByte(field.type);</span><br><span class="line">  writeI16(field.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thrift</code>提供了<code>TType</code>，对不同的<strong>数据类型</strong>(<code>type</code>)提供了唯一标识的<code>typeID</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STOP   = <span class="number">0</span>;   <span class="comment">// 数据读写完成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> VOID   = <span class="number">1</span>;   <span class="comment">// 空值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BOOL   = <span class="number">2</span>;   <span class="comment">// 布尔值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BYTE   = <span class="number">3</span>;   <span class="comment">// 字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DOUBLE = <span class="number">4</span>;   <span class="comment">// 双精度浮点型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I16    = <span class="number">6</span>;   <span class="comment">// 短整型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I32    = <span class="number">8</span>;   <span class="comment">// 整型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I64    = <span class="number">10</span>;  <span class="comment">// 长整型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRING = <span class="number">11</span>;  <span class="comment">// 字符串类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRUCT = <span class="number">12</span>;  <span class="comment">// 引用类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAP    = <span class="number">13</span>;  <span class="comment">// Map</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SET    = <span class="number">14</span>;  <span class="comment">// 集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LIST   = <span class="number">15</span>;  <span class="comment">// 列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ENUM   = <span class="number">16</span>;  <span class="comment">// 枚举</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2). 然后是写入<strong>字段的值</strong>，根据字段的数据类型又归纳为以下实现：<code>writeByte()</code>、<code>writeBool()</code>、<code>writeI32()</code>、<code>writeI64()</code>、<code>writeDouble()</code>、<code>writeString()</code>和<code>writeBinary()</code>方法。</p><p><code>TBinaryProtocol</code>通过一个长度为<code>8</code>的<code>byte</code>字节数组缓存<strong>写入</strong>或<strong>读取</strong>的临时字节数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] inoutTemp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong>常识1：</strong>16进制的介绍。以0x开始的数据表示16进制，0xff换成十进制为255。在16进制中，A、B、C、D、E、F这五个字母来分别表示10、11、12、13、14、15。</p></blockquote><p><code>16</code><strong>进制</strong>变<strong>十进制</strong>：f表示15。第n位的权值为16的n次方，由右到左从0位起：0xff = 15<em>16^1 + 15</em>16^0 = 255<br><code>16</code><strong>进制</strong>变<strong>二进制</strong>再变<strong>十进制</strong>：0xff = 1111 1111 = 2^8 - 1 = 255</p><blockquote><p><strong>常识2：</strong>位运算符的使用。&gt;&gt;表示代表右移符号，如：int i=15; i&gt;&gt;2的结果是3，移出的部分将被抛弃。而&lt;&lt;表示左移符号，与&gt;&gt;刚好相反。</p></blockquote><p>转为<strong>二进制</strong>的形式可能更好理解，0000 1111(15)右移2位的结果是0000 0011(3)，0001 1010(18)右移3位的结果是0000 0011(3)。</p><ul><li><strong>writeByte()</strong>：写入<strong>单个字节</strong>数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  inoutTemp[<span class="number">0</span>] = b;</span><br><span class="line">  trans_.write(inoutTemp， <span class="number">0</span>， <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeBool()</strong>：写入<strong>布尔值</strong>数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  writeByte(b ? (<span class="keyword">byte</span>)<span class="number">1</span> : (<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeI16()</strong>：写入<strong>短整型</strong><code>short</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI16</span><span class="params">(<span class="keyword">short</span> i16)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  inoutTemp[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i16 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">  inoutTemp[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i16));</span><br><span class="line">  trans_.write(inoutTemp， <span class="number">0</span>， <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeI32()</strong>：写入<strong>整型</strong><code>int</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI32</span><span class="params">(<span class="keyword">int</span> i32)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  inoutTemp[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">  inoutTemp[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">  inoutTemp[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">  inoutTemp[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32));</span><br><span class="line">  trans_.write(inoutTemp， <span class="number">0</span>， <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeI64()</strong>：写入<strong>长整型</strong><code>long</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  inoutTemp[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">56</span>));</span><br><span class="line">  inoutTemp[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">48</span>));</span><br><span class="line">  inoutTemp[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">40</span>));</span><br><span class="line">  inoutTemp[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">32</span>));</span><br><span class="line">  inoutTemp[<span class="number">4</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">  inoutTemp[<span class="number">5</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">  inoutTemp[<span class="number">6</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">  inoutTemp[<span class="number">7</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64));</span><br><span class="line">  trans_.write(inoutTemp， <span class="number">0</span>， <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeDouble()</strong>：写入<strong>双浮点型</strong><code>double</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> dub)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  writeI64(Double.doubleToLongBits(dub));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeString()</strong>：写入<strong>字符串类型</strong>，这里先写入<strong>字符串长度</strong>，再写入<strong>字符串内容</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] dat = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">    writeI32(dat.length);</span><br><span class="line">    trans_.write(dat， <span class="number">0</span>， dat.length);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>writeBinary</strong>：写入<strong>二进制数组</strong>类型数据，这里数据输入是<code>NIO</code>中的<code>ByteBuffer</code>类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(ByteBuffer bin)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> length = bin.limit() - bin.position();</span><br><span class="line">  writeI32(length);</span><br><span class="line">  trans_.write(bin.array()， bin.position() + bin.arrayOffset()， length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3). 每个字段写入完成后，都需要记录<strong>字段结束标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>(d). 当所有的字段都写入以后，需要记录<strong>字段停止标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldStop</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  writeByte(TType.STOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(e). 当所有数据写入完成后，通过<code>writeStructEnd()</code>记录<strong>写入结构</strong>的<strong>完成标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="二-readData-分析"><a href="#二-readData-分析" class="headerlink" title="(二) readData()分析"></a>(二) readData()分析</h3><p>查看<code>thrift</code>的<strong>反序列化机制</strong>，即<strong>数据读取</strong>实现，同样采用<strong>二进制协议</strong><code>TBinaryProtocol</code>，切入点为<code>pair.read(TProtocol)</code>：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_scheme2.png" alt=""></p><p><strong>数据读取</strong>和<strong>数据写入</strong>一样，也是采用的<strong>标准计划</strong><code>StandardScheme</code>。<strong>标准计划</strong>(<code>StandardScheme</code>)下的<code>read()</code>方法：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Thrift_Pair_read.png" alt=""></p><p>这里完成的几步操作：</p><p>(a). 通过<code>readStructBegin</code>读取<strong>结构</strong>的<strong>开始标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iprot.readStructBegin();</span><br></pre></td></tr></table></figure><p>(b). 循环读取<strong>结构</strong>中的<strong>所有字段数据</strong>到<code>Pair</code>对象中，直到读取到<code>org.apache.thrift.protocol.TType.STOP</code>为止。<code>iprot.readFieldBegin()</code>指明开始读取<strong>下一个字段</strong>的前需要读取<strong>字段开始标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  schemeField = iprot.readFieldBegin();</span><br><span class="line">  <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STOP) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 字段的读取，省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(c). 根据<code>Thrift IDL</code>定义的<code>field-id</code>读取对应的字段，并赋值到<code>Pair</code>对象中，并设置<code>Pair</code>对象相应的字段为<strong>已读状态</strong>(前提：字段在<code>IDL</code>中被定义为<code>required</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (schemeField.id) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// KEY</span></span><br><span class="line">    <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STRING) &#123;</span><br><span class="line">      struct.key = iprot.readString();</span><br><span class="line">      struct.setKeyIsSet(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      org.apache.thrift.protocol.TProtocolUtil.skip(iprot， schemeField.type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STRING) &#123;</span><br><span class="line">      struct.value = iprot.readString();</span><br><span class="line">      struct.setValueIsSet(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      org.apache.thrift.protocol.TProtocolUtil.skip(iprot， schemeField.type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    org.apache.thrift.protocol.TProtocolUtil.skip(iprot， schemeField.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<strong>读取字段</strong>的值，根据字段的<strong>数据类型</strong>也分为以下实现：<code>readByte()</code>、<code>readBool()</code>、<code>readI32()</code>、<code>readI64()</code>、<code>readDouble()</code>、<code>readString()</code>和<code>readBinary()</code>方法。</p><ul><li><strong>readByte()</strong>：读取<strong>单个字节</strong>数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">byte</span> b = trans_.getBuffer()[trans_.getBufferPosition()];</span><br><span class="line">    trans_.consumeBuffer(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">  readAll(inoutTemp， <span class="number">0</span>， <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> inoutTemp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readBool()</strong>：读取<strong>布尔值</strong>数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (readByte() == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readI16()</strong>：读取<strong>短整型</strong><code>short</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] buf = inoutTemp;</span><br><span class="line">  <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    buf = trans_.getBuffer();</span><br><span class="line">    off = trans_.getBufferPosition();</span><br><span class="line">    trans_.consumeBuffer(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readAll(inoutTemp， <span class="number">0</span>， <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">short</span>) (((buf[off] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">                 ((buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readI32()</strong>：读取<strong>整型</strong><code>int</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readI32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] buf = inoutTemp;</span><br><span class="line">  <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">    buf = trans_.getBuffer();</span><br><span class="line">    off = trans_.getBufferPosition();</span><br><span class="line">    trans_.consumeBuffer(<span class="number">4</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readAll(inoutTemp， <span class="number">0</span>， <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((buf[off] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">         ((buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         ((buf[off+<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">         ((buf[off+<span class="number">3</span>] &amp; <span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readI64()</strong>：读取<strong>长整型</strong><code>long</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readI64</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] buf = inoutTemp;</span><br><span class="line">  <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">    buf = trans_.getBuffer();</span><br><span class="line">    off = trans_.getBufferPosition();</span><br><span class="line">    trans_.consumeBuffer(<span class="number">8</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readAll(inoutTemp， <span class="number">0</span>， <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">long</span>)(buf[off]   &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">56</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">4</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">5</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">6</span>] &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">         ((<span class="keyword">long</span>)(buf[off+<span class="number">7</span>] &amp; <span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readDouble()</strong>：读取<strong>双精度浮点</strong><code>double</code>类型数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Double.longBitsToDouble(readI64());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readString()</strong>：读取<strong>字符串类型</strong>的数据，首先读取并校验<code>4</code>字节的<strong>字符串长度</strong>，然后检查<code>NIO</code><strong>缓冲区</strong>中是否有对应长度的字节<strong>未消费</strong>。如果有，直接从<strong>缓冲区</strong>中读取；否则，从<strong>传输通道</strong>中读取数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = readI32();</span><br><span class="line">  checkStringReadLength(size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String s = <span class="keyword">new</span> String(trans_.getBuffer()， trans_.getBufferPosition()， size， <span class="string">"UTF-8"</span>);</span><br><span class="line">      trans_.consumeBuffer(size);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> readStringBody(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是从<strong>传输通道</strong>中读取数据，查看<code>readStringBody()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readStringBody</span><span class="params">(<span class="keyword">int</span> size)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    trans_.readAll(buf， <span class="number">0</span>， size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf， <span class="string">"UTF-8"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readBinary()</strong>：读取<strong>二进制数组</strong>类型数据，和<strong>字符串读取</strong>类似，返回一个<code>ByteBuffer</code>字节缓存对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">readBinary</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = readI32();</span><br><span class="line">  checkStringReadLength(size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.wrap(trans_.getBuffer()， trans_.getBufferPosition()， size);</span><br><span class="line">    trans_.consumeBuffer(size);</span><br><span class="line">    <span class="keyword">return</span> bb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">  trans_.readAll(buf， <span class="number">0</span>， size);</span><br><span class="line">  <span class="keyword">return</span> ByteBuffer.wrap(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(d). 每个字段数据读取完成后，都需要再读取一个<strong>字段结束标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>(e). 当所有字段读取完成后，需要通过<code>readStructEnd()</code>再读入一个<strong>结构完成标记</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStructEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>(f). 读取结束后，同样需要校验在<code>Thrift IDL</code>中定义为<code>required</code>的字段是否为空，是否合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">  <span class="comment">// check for required fields</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'key' was not present! Struct: "</span> + toString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'value' was not present! Struct: "</span> + toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实到这里，对于<code>Thrift</code>的<strong>序列化机制</strong>和<strong>反序列化机制</strong>的<strong>具体实现</strong>和<strong>高效性</strong>，相信各位已经有了比较深入的认识！</p><hr><p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Thrift&lt;/code&gt;支持&lt;strong&gt;二进制&lt;/strong&gt;，&lt;strong&gt;压缩格式&lt;/strong&gt;，以及&lt;code&gt;json&lt;/code&gt;格式数据的&lt;strong&gt;序列化&lt;/strong&gt;和&lt;strong&gt;反序列化&lt;/strong&gt;。开发人员可以更加灵活的选择协议的具体形式。协议是可&lt;strong&gt;自由扩展&lt;/strong&gt;的，新版本的协议，完全&lt;strong&gt;兼容&lt;/strong&gt;老的版本！&lt;/p&gt;
    
    </summary>
    
      <category term="RPC通信框架系列" scheme="https://ostenant.coding.me/categories/RPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Thrift" scheme="https://ostenant.coding.me/tags/Thrift/"/>
    
      <category term="Apache" scheme="https://ostenant.coding.me/tags/Apache/"/>
    
      <category term="RPC" scheme="https://ostenant.coding.me/tags/RPC/"/>
    
  </entry>
  
</feed>
