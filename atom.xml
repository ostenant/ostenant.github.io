<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Icarus&#39;s Blog</title>
  
  <subtitle>上善若水任方猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ostenant.coding.me/"/>
  <updated>2018-08-23T02:55:18.311Z</updated>
  <id>https://ostenant.coding.me/</id>
  
  <author>
    <name>Chen Icarus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入剖析Redis系列(二) - Redis哨兵模式与高可用集群</title>
    <link href="https://ostenant.coding.me/2018/08/17/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Redis%E7%B3%BB%E5%88%97(%E4%BA%8C)%20-%20Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/"/>
    <id>https://ostenant.coding.me/2018/08/17/深入剖析Redis系列(二) - Redis哨兵模式与高可用集群/</id>
    <published>2018-08-17T15:02:00.000Z</published>
    <updated>2018-08-23T02:55:18.311Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Redis</code> 的 <strong>主从复制</strong> 模式下，一旦 <strong>主节点</strong> 由于故障不能提供服务，需要手动将 <strong>从节点</strong> 晋升为 <strong>主节点</strong>，同时还要通知 <strong>客户端</strong> 更新 <strong>主节点地址</strong>，这种故障处理方式从一定程度上是无法接受的。<code>Redis 2.8</code> 以后提供了 <code>Redis Sentinel</code> <strong>哨兵机制</strong> 来解决这个问题。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61de7471a?w=1772&amp;h=591&amp;f=jpeg&amp;s=46258" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-Redis高可用概述"><a href="#1-Redis高可用概述" class="headerlink" title="1. Redis高可用概述"></a>1. Redis高可用概述</h2><p>在 <code>Web</code> 服务器中，<strong>高可用</strong> 是指服务器可以 <strong>正常访问</strong> 的时间，衡量的标准是在 <strong>多长时间</strong> 内可以提供正常服务（<code>99.9%</code>、<code>99.99%</code>、<code>99.999%</code> 等等）。在 <code>Redis</code> 层面，<strong>高可用</strong> 的含义要宽泛一些，除了保证提供 <strong>正常服务</strong>（如 <strong>主从分离</strong>、<strong>快速容灾技术</strong> 等），还需要考虑 <strong>数据容量扩展</strong>、<strong>数据安全</strong> 等等。</p><p>在 <code>Redis</code> 中，实现 <strong>高可用</strong> 的技术主要包括 <strong>持久化</strong>、<strong>复制</strong>、<strong>哨兵</strong> 和 <strong>集群</strong>，下面简单说明它们的作用，以及解决了什么样的问题：</p><ul><li><p><strong>持久化</strong>：持久化是 <strong>最简单的</strong> 高可用方法。它的主要作用是 <strong>数据备份</strong>，即将数据存储在 <strong>硬盘</strong>，保证数据不会因进程退出而丢失。</p></li><li><p><strong>复制</strong>：复制是高可用 <code>Redis</code> 的基础，<strong>哨兵</strong> 和 <strong>集群</strong> 都是在 <strong>复制基础</strong> 上实现高可用的。复制主要实现了数据的多机备份以及对于读操作的负载均衡和简单的故障恢复。缺陷是故障恢复无法自动化、写操作无法负载均衡、存储能力受到单机的限制。</p></li><li><p><strong>哨兵</strong>：在复制的基础上，哨兵实现了 <strong>自动化</strong> 的 <strong>故障恢复</strong>。缺陷是 <strong>写操作</strong> 无法 <strong>负载均衡</strong>，<strong>存储能力</strong> 受到 <strong>单机</strong> 的限制。</p></li><li><p><strong>集群</strong>：通过集群，<code>Redis</code> 解决了 <strong>写操作</strong> 无法 <strong>负载均衡</strong> 以及 <strong>存储能力</strong> 受到 <strong>单机限制</strong> 的问题，实现了较为 <strong>完善</strong> 的 <strong>高可用方案</strong>。</p></li></ul><h2 id="2-Redis-Sentinel的基本概念"><a href="#2-Redis-Sentinel的基本概念" class="headerlink" title="2. Redis Sentinel的基本概念"></a>2. Redis Sentinel的基本概念</h2><p><code>Redis Sentinel</code> 是 <code>Redis</code> <strong>高可用</strong> 的实现方案。<code>Sentinel</code> 是一个管理多个 <code>Redis</code> 实例的工具，它可以实现对 <code>Redis</code> 的 <strong>监控</strong>、<strong>通知</strong>、<strong>自动故障转移</strong>。下面先对 <code>Redis Sentinel</code> 的 <strong>基本概念</strong> 进行简单的介绍。</p><p>基本名词说明：</p><table><thead><tr><th style="text-align:left">基本名词</th><th style="text-align:left">逻辑结构</th><th style="text-align:left">物理结构</th></tr></thead><tbody><tr><td style="text-align:left">Redis数据节点</td><td style="text-align:left">主节点和从节点</td><td style="text-align:left">主节点和从节点的进程</td></tr><tr><td style="text-align:left">主节点(master)</td><td style="text-align:left">Redis主数据库</td><td style="text-align:left">一个独立的Redis进程</td></tr><tr><td style="text-align:left">从节点(slave)</td><td style="text-align:left">Redis从数据库</td><td style="text-align:left">一个独立的Redis进程</td></tr><tr><td style="text-align:left">Sentinel节点</td><td style="text-align:left">监控Redis数据节点</td><td style="text-align:left">一个独立的Sentinel进程</td></tr><tr><td style="text-align:left">Sentinel节点集合</td><td style="text-align:left">若干Sentinel节点的抽象组合</td><td style="text-align:left">若干Sentinel节点进程</td></tr><tr><td style="text-align:left">Redis Sentinel</td><td style="text-align:left">Redis高可用实现方案</td><td style="text-align:left">Sentinel节点集合和Redis数据节点进程</td></tr><tr><td style="text-align:left">应用客户端</td><td style="text-align:left">泛指一个或多个客户端</td><td style="text-align:left">一个或者多个客户端进程或者线程</td></tr></tbody></table><p>如图所示，<code>Redis</code> 的 <strong>主从复制模式</strong> 和 <code>Sentinel</code> <strong>高可用架构</strong> 的示意图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce611d8c4a5?w=1033&amp;h=601&amp;f=png&amp;s=37825" alt=""></p><h2 id="3-Redis主从复制的问题"><a href="#3-Redis主从复制的问题" class="headerlink" title="3. Redis主从复制的问题"></a>3. Redis主从复制的问题</h2><p><code>Redis</code> <strong>主从复制</strong> 可将 <strong>主节点</strong> 数据同步给 <strong>从节点</strong>，从节点此时有两个作用：</p><ol><li>一旦 <strong>主节点宕机</strong>，<strong>从节点</strong> 作为 <strong>主节点</strong> 的 <strong>备份</strong> 可以随时顶上来。</li><li>扩展 <strong>主节点</strong> 的 <strong>读能力</strong>，分担主节点读压力。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61dbb9d7e?w=394&amp;h=338&amp;f=png&amp;s=13268" alt=""></p><p><strong>主从复制</strong> 同时存在以下几个问题：</p><ol><li><p>一旦 <strong>主节点宕机</strong>，<strong>从节点</strong> 晋升成 <strong>主节点</strong>，同时需要修改 <strong>应用方</strong> 的 <strong>主节点地址</strong>，还需要命令所有 <strong>从节点</strong> 去 <strong>复制</strong> 新的主节点，整个过程需要 <strong>人工干预</strong>。</p></li><li><p><strong>主节点</strong> 的 <strong>写能力</strong> 受到 <strong>单机的限制</strong>。</p></li><li><p><strong>主节点</strong> 的 <strong>存储能力</strong> 受到 <strong>单机的限制</strong>。</p></li><li><p><strong>原生复制</strong> 的弊端在早期的版本中也会比较突出，比如：<code>Redis</code> <strong>复制中断</strong> 后，<strong>从节点</strong> 会发起 <code>psync</code>。此时如果 <strong>同步不成功</strong>，则会进行 <strong>全量同步</strong>，<strong>主库</strong> 执行 <strong>全量备份</strong> 的同时，可能会造成毫秒或秒级的 <strong>卡顿</strong>。</p></li></ol><h2 id="4-Redis-Sentinel深入探究"><a href="#4-Redis-Sentinel深入探究" class="headerlink" title="4. Redis Sentinel深入探究"></a>4. Redis Sentinel深入探究</h2><h3 id="4-1-Redis-Sentinel的架构"><a href="#4-1-Redis-Sentinel的架构" class="headerlink" title="4.1. Redis Sentinel的架构"></a>4.1. Redis Sentinel的架构</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61dbc4eeb?w=478&amp;h=550&amp;f=png&amp;s=28698" alt=""></p><h3 id="4-2-Redis-Sentinel的主要功能"><a href="#4-2-Redis-Sentinel的主要功能" class="headerlink" title="4.2. Redis Sentinel的主要功能"></a>4.2. Redis Sentinel的主要功能</h3><p><code>Sentinel</code> 的主要功能包括 <strong>主节点存活检测</strong>、<strong>主从运行情况检测</strong>、<strong>自动故障转移</strong> （<code>failover</code>）、<strong>主从切换</strong>。<code>Redis</code> 的 <code>Sentinel</code> 最小配置是 <strong>一主一从</strong>。</p><p><code>Redis</code> 的 <code>Sentinel</code> 系统可以用来管理多个 <code>Redis</code> 服务器，该系统可以执行以下四个任务：</p><ul><li><strong>监控</strong></li></ul><p><code>Sentinel</code> 会不断的检查 <strong>主服务器</strong> 和 <strong>从服务器</strong> 是否正常运行。</p><ul><li><strong>通知</strong></li></ul><p>当被监控的某个 <code>Redis</code> 服务器出现问题，<code>Sentinel</code> 通过 <code>API</code> <strong>脚本</strong> 向 <strong>管理员</strong> 或者其他的 <strong>应用程序</strong> 发送通知。</p><ul><li><strong>自动故障转移</strong></li></ul><p>当 <strong>主节点</strong> 不能正常工作时，<code>Sentinel</code> 会开始一次 <strong>自动的</strong> 故障转移操作，它会将与 <strong>失效主节点</strong> 是 <strong>主从关系</strong> 的其中一个 <strong>从节点</strong> 升级为新的 <strong>主节点</strong>，并且将其他的 <strong>从节点</strong> 指向 <strong>新的主节点</strong>。</p><ul><li><strong>配置提供者</strong></li></ul><p>在 <code>Redis Sentinel</code> 模式下，<strong>客户端应用</strong> 在初始化时连接的是 <code>Sentinel</code> <strong>节点集合</strong>，从中获取 <strong>主节点</strong> 的信息。</p><h3 id="4-3-主观下线和客观下线"><a href="#4-3-主观下线和客观下线" class="headerlink" title="4.3. 主观下线和客观下线"></a>4.3. 主观下线和客观下线</h3><p>默认情况下，<strong>每个</strong> <code>Sentinel</code> 节点会以 <strong>每秒一次</strong> 的频率对 <code>Redis</code> 节点和 <strong>其它</strong> 的 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，并通过节点的 <strong>回复</strong> 来判断节点是否在线。</p><ul><li><strong>主观下线</strong></li></ul><p><strong>主观下线</strong> 适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。如果在 <code>down-after-milliseconds</code> 毫秒内，<code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong>。</p><ul><li><strong>客观下线</strong></li></ul><p><strong>客观下线</strong> 只适用于 <strong>主节点</strong>。如果 <strong>主节点</strong> 出现故障，<code>Sentinel</code> 节点会通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 <code>Sentinel</code> 节点询问对该节点的 <strong>状态判断</strong>。如果超过 <code>&lt;quorum&gt;</code> 个数的节点判定 <strong>主节点</strong> 不可达，则该 <code>Sentinel</code> 节点会判断 <strong>主节点</strong> 为 <strong>客观下线</strong>。</p><h3 id="4-4-Sentinel的通信命令"><a href="#4-4-Sentinel的通信命令" class="headerlink" title="4.4. Sentinel的通信命令"></a>4.4. Sentinel的通信命令</h3><p><code>Sentinel</code> 节点连接一个 <code>Redis</code> 实例的时候，会创建 <code>cmd</code> 和 <code>pub/sub</code> 两个 <strong>连接</strong>。<code>Sentinel</code> 通过 <code>cmd</code> 连接给 <code>Redis</code> 发送命令，通过 <code>pub/sub</code> 连接到 <code>Redis</code> 实例上的其他 <code>Sentinel</code> 实例。</p><p><code>Sentinel</code> 与 <code>Redis</code> <strong>主节点</strong> 和 <strong>从节点</strong> 交互的命令，主要包括：</p><table><thead><tr><th>命令</th><th>作 用</th></tr></thead><tbody><tr><td>PING</td><td><code>Sentinel</code> 向 <code>Redis</code> 节点发送 <code>PING</code> 命令，检查节点的状态</td></tr><tr><td>INFO</td><td><code>Sentinel</code> 向 <code>Redis</code> 节点发送 <code>INFO</code> 命令，获取它的 <strong>从节点信息</strong></td></tr><tr><td>PUBLISH</td><td><code>Sentinel</code> 向其监控的 <code>Redis</code> 节点 <code>__sentinel__:hello</code> 这个 <code>channel</code> 发布 <strong>自己的信息</strong> 及 <strong>主节点</strong> 相关的配置</td></tr><tr><td>SUBSCRIBE</td><td><code>Sentinel</code> 通过订阅 <code>Redis</code> <strong>主节点</strong> 和 <strong>从节点</strong> 的 <code>__sentinel__:hello</code> 这个 <code>channnel</code>，获取正在监控相同服务的其他 <code>Sentinel</code> 节点</td></tr></tbody></table><p><code>Sentinel</code> 与 <code>Sentinel</code> 交互的命令，主要包括：</p><table><thead><tr><th>命令</th><th>作 用</th></tr></thead><tbody><tr><td>PING</td><td><code>Sentinel</code> 向其他 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，检查节点的状态</td></tr><tr><td>SENTINEL:is-master-down-by-addr</td><td>和其他 <code>Sentinel</code> 协商 <strong>主节点</strong> 的状态，如果 <strong>主节点</strong> 处于 <code>SDOWN</code> 状态，则投票自动选出新的 <strong>主节点</strong></td></tr></tbody></table><h3 id="4-5-Redis-Sentinel的工作原理"><a href="#4-5-Redis-Sentinel的工作原理" class="headerlink" title="4.5. Redis Sentinel的工作原理"></a>4.5. Redis Sentinel的工作原理</h3><p>每个 <code>Sentinel</code> 节点都需要 <strong>定期执行</strong> 以下任务：</p><ul><li>每个 <code>Sentinel</code> 以 <strong>每秒钟</strong> 一次的频率，向它所知的 <strong>主服务器</strong>、<strong>从服务器</strong> 以及其他 <code>Sentinel</code> <strong>实例</strong> 发送一个 <code>PING</code> 命令。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61df44c4d?w=692&amp;h=493&amp;f=png&amp;s=24384" alt=""></p><ol start="2"><li>如果一个 <strong>实例</strong>（<code>instance</code>）距离 <strong>最后一次</strong> 有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code> 所指定的值，那么这个实例会被 <code>Sentinel</code> 标记为 <strong>主观下线</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61dc739de?w=692&amp;h=521&amp;f=png&amp;s=30028" alt=""></p><ol start="3"><li>如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，那么正在 <strong>监视</strong> 这个 <strong>主服务器</strong> 的所有 <code>Sentinel</code> 节点，要以 <strong>每秒一次</strong> 的频率确认 <strong>主服务器</strong> 的确进入了 <strong>主观下线</strong> 状态。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647a39535?w=692&amp;h=521&amp;f=png&amp;s=33399" alt=""></p><ol start="4"><li>如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，并且有 <strong>足够数量</strong> 的 <code>Sentinel</code>（至少要达到 <strong>配置文件</strong> 指定的数量）在指定的 <strong>时间范围</strong> 内同意这一判断，那么这个 <strong>主服务器</strong> 被标记为 <strong>客观下线</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647c2583e?w=692&amp;h=521&amp;f=png&amp;s=36443" alt=""></p><ol start="5"><li>在一般情况下， 每个 <code>Sentinel</code> 会以每 <code>10</code> 秒一次的频率，向它已知的所有 <strong>主服务器</strong> 和 <strong>从服务器</strong> 发送 <code>INFO</code> 命令。当一个 <strong>主服务器</strong> 被 <code>Sentinel</code> 标记为 <strong>客观下线</strong> 时，<code>Sentinel</code> 向 <strong>下线主服务器</strong> 的所有 <strong>从服务器</strong> 发送 <code>INFO</code> 命令的频率，会从 <code>10</code> 秒一次改为 <strong>每秒一次</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6738a30db?w=752&amp;h=511&amp;f=png&amp;s=38521" alt=""></p><ol start="6"><li><code>Sentinel</code> 和其他 <code>Sentinel</code> 协商 <strong>主节点</strong> 的状态，如果 <strong>主节点</strong> 处于 <code>SDOWN</code> 状态，则投票自动选出新的 <strong>主节点</strong>。将剩余的 <strong>从节点</strong> 指向 <strong>新的主节点</strong> 进行 <strong>数据复制</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce676a95a54?w=752&amp;h=569&amp;f=png&amp;s=39887" alt=""></p><ol start="7"><li>当没有足够数量的 <code>Sentinel</code> 同意 <strong>主服务器</strong> 下线时， <strong>主服务器</strong> 的 <strong>客观下线状态</strong> 就会被移除。当 <strong>主服务器</strong> 重新向 <code>Sentinel</code> 的 <code>PING</code> 命令返回 <strong>有效回复</strong> 时，<strong>主服务器</strong> 的 <strong>主观下线状态</strong> 就会被移除。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6759c1cb3?w=1489&amp;h=569&amp;f=png&amp;s=44771" alt=""></p><blockquote><p>注意：一个有效的 <code>PING</code> 回复可以是：<code>+PONG</code>、<code>-LOADING</code> 或者 <code>-MASTERDOWN</code>。如果 <strong>服务器</strong> 返回除以上三种回复之外的其他回复，又或者在 <strong>指定时间</strong> 内没有回复 <code>PING</code> 命令， 那么 <code>Sentinel</code> 认为服务器返回的回复 <strong>无效</strong>（<code>non-valid</code>）。</p></blockquote><h2 id="5-Redis-Sentinel搭建"><a href="#5-Redis-Sentinel搭建" class="headerlink" title="5. Redis Sentinel搭建"></a>5. Redis Sentinel搭建</h2><h3 id="5-1-Redis-Sentinel的部署须知"><a href="#5-1-Redis-Sentinel的部署须知" class="headerlink" title="5.1. Redis Sentinel的部署须知"></a>5.1. Redis Sentinel的部署须知</h3><ol><li><p>一个稳健的 <code>Redis Sentinel</code> 集群，应该使用至少 <strong>三个</strong> <code>Sentinel</code> 实例，并且保证讲这些实例放到 <strong>不同的机器</strong> 上，甚至不同的 <strong>物理区域</strong>。</p></li><li><p><code>Sentinel</code> 无法保证 <strong>强一致性</strong>。</p></li><li><p>常见的 <strong>客户端应用库</strong> 都支持 <code>Sentinel</code>。</p></li><li><p><code>Sentinel</code> 需要通过不断的 <strong>测试</strong> 和 <strong>观察</strong>，才能保证高可用。</p></li></ol><h3 id="5-2-Redis-Sentinel的配置文件"><a href="#5-2-Redis-Sentinel的配置文件" class="headerlink" title="5.2. Redis Sentinel的配置文件"></a>5.2. Redis Sentinel的配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口，默认26379  </span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 </span></span><br><span class="line"><span class="comment">## ip：主机ip地址</span></span><br><span class="line"><span class="comment">## port：哨兵端口号</span></span><br><span class="line"><span class="comment">## master-name：可以自己命名的主节点名字（只能由字母A-z、数字0-9 、这三个字符".-_"组成。）</span></span><br><span class="line"><span class="comment">## quorum：当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了  </span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;  </span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass &lt;foobared&gt;，所有连接Redis实例的客户端都要提供密码。</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;  </span></span><br><span class="line">sentinel auth-pass mymaster 123456  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定主节点应答哨兵sentinel的最大时间间隔，超过这个时间，哨兵主观上认为主节点下线，默认30秒  </span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定了在发生failover主备切换时，最多可以有多少个slave同时对新的master进行同步。这个数字越小，完成failover所需的时间就越长；反之，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为1，来保证每次只有一个slave，处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间failover-timeout，默认三分钟，可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">## 1. 同一个sentinel对同一个master两次failover之间的间隔时间。  </span></span><br><span class="line"><span class="comment">## 2. 当一个slave从一个错误的master那里同步数据时开始，直到slave被纠正为从正确的master那里同步数据时结束。  </span></span><br><span class="line"><span class="comment">## 3. 当想要取消一个正在进行的failover时所需要的时间。</span></span><br><span class="line"><span class="comment">## 4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来同步数据了</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;  </span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本。一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment"># 对于脚本的运行结果有以下规则：  </span></span><br><span class="line"><span class="comment">## 1. 若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10。</span></span><br><span class="line"><span class="comment">## 2. 若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。  </span></span><br><span class="line"><span class="comment">## 3. 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;  </span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure><h3 id="5-3-Redis-Sentinel的节点规划"><a href="#5-3-Redis-Sentinel的节点规划" class="headerlink" title="5.3. Redis Sentinel的节点规划"></a>5.3. Redis Sentinel的节点规划</h3><table><thead><tr><th style="text-align:left">角色</th><th style="text-align:left">IP地址</th><th style="text-align:left">端口号</th></tr></thead><tbody><tr><td style="text-align:left">Redis Master</td><td style="text-align:left">10.206.20.231</td><td style="text-align:left">16379</td></tr><tr><td style="text-align:left">Redis Slave1</td><td style="text-align:left">10.206.20.231</td><td style="text-align:left">26379</td></tr><tr><td style="text-align:left">Redis Slave2</td><td style="text-align:left">10.206.20.231</td><td style="text-align:left">36379</td></tr><tr><td style="text-align:left">Redis Sentinel1</td><td style="text-align:left">10.206.20.231</td><td style="text-align:left">16380</td></tr><tr><td style="text-align:left">Redis Sentinel2</td><td style="text-align:left">10.206.20.231</td><td style="text-align:left">26380</td></tr><tr><td style="text-align:left">Redis Sentinel3</td><td style="text-align:left">10.206.20.231</td><td style="text-align:left">36380</td></tr></tbody></table><h3 id="5-4-Redis-Sentinel的配置搭建"><a href="#5-4-Redis-Sentinel的配置搭建" class="headerlink" title="5.4. Redis Sentinel的配置搭建"></a>5.4. Redis Sentinel的配置搭建</h3><h4 id="5-4-1-Redis-Server的配置管理"><a href="#5-4-1-Redis-Server的配置管理" class="headerlink" title="5.4.1. Redis-Server的配置管理"></a>5.4.1. Redis-Server的配置管理</h4><p>分别拷贝三份 <code>redis.conf</code> 文件到 <code>/usr/local/redis-sentinel</code> 目录下面。三个配置文件分别对应 <code>master</code>、<code>slave1</code> 和 <code>slave2</code> 三个 <code>Redis</code> 节点的 <strong>启动配置</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/redis.conf /usr/<span class="built_in">local</span>/redis-sentinel/redis-16379.conf</span><br><span class="line">$ sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/redis.conf /usr/<span class="built_in">local</span>/redis-sentinel/redis-26379.conf</span><br><span class="line">$ sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/redis.conf /usr/<span class="built_in">local</span>/redis-sentinel/redis-36379.conf</span><br></pre></td></tr></table></figure><p>分别修改三份配置文件如下：</p><ul><li>主节点：redis-16379.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-16379.pid</span><br><span class="line">logfile /var/log/redis/redis-16379.log</span><br><span class="line">port 16379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-16379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><ul><li>从节点1：redis-26379.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-26379.pid</span><br><span class="line">logfile /var/log/redis/redis-26379.log</span><br><span class="line">port 26379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-26379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br><span class="line">slaveof 127.0.0.1 16379</span><br></pre></td></tr></table></figure><ul><li>从节点2：redis-36379.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-36379.pid</span><br><span class="line">logfile /var/log/redis/redis-36379.log</span><br><span class="line">port 36379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-36379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br><span class="line">slaveof 127.0.0.1 16379</span><br></pre></td></tr></table></figure><blockquote><p>如果要做 <strong>自动故障转移</strong>，建议所有的 <code>redis.conf</code> 都设置 <code>masterauth</code>。因为 <strong>自动故障</strong> 只会重写 <strong>主从关系</strong>，即 <code>slaveof</code>，不会自动写入 <code>masterauth</code>。如果 <code>Redis</code> 原本没有设置密码，则可以忽略。</p></blockquote><h4 id="5-4-2-Redis-Server启动验证"><a href="#5-4-2-Redis-Server启动验证" class="headerlink" title="5.4.2. Redis-Server启动验证"></a>5.4.2. Redis-Server启动验证</h4><p>按顺序分别启动 <code>16379</code>，<code>26379</code> 和 <code>36379</code> 三个 <code>Redis</code> 节点，启动命令和启动日志如下：</p><p><code>Redis</code> 的启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo redis-server /usr/<span class="built_in">local</span>/redis-sentinel/redis-16379.conf</span><br><span class="line">$ sudo redis-server /usr/<span class="built_in">local</span>/redis-sentinel/redis-26379.conf</span><br><span class="line">$ sudo redis-server /usr/<span class="built_in">local</span>/redis-sentinel/redis-36379.conf</span><br></pre></td></tr></table></figure><p>查看 <code>Redis</code> 的启动进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep redis-server</span><br><span class="line">    0  7127     1   0  2:16下午 ??         0:01.84 redis-server 0.0.0.0:16379 </span><br><span class="line">    0  7133     1   0  2:16下午 ??         0:01.73 redis-server 0.0.0.0:26379 </span><br><span class="line">    0  7137     1   0  2:16下午 ??         0:01.70 redis-server 0.0.0.0:36379</span><br></pre></td></tr></table></figure><p>查看 <code>Redis</code> 的启动日志：</p><ul><li>节点 <code>redis-16379</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/<span class="built_in">log</span>/redis/redis-16379.log </span><br><span class="line">7126:C 22 Aug 14:16:38.907 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">7126:C 22 Aug 14:16:38.908 <span class="comment"># Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7126, just started</span></span><br><span class="line">7126:C 22 Aug 14:16:38.908 <span class="comment"># Configuration loaded</span></span><br><span class="line">7127:M 22 Aug 14:16:38.910 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">7127:M 22 Aug 14:16:38.912 * Running mode=standalone, port=16379.</span><br><span class="line">7127:M 22 Aug 14:16:38.913 <span class="comment"># Server initialized</span></span><br><span class="line">7127:M 22 Aug 14:16:38.913 * Ready to accept connections</span><br><span class="line">7127:M 22 Aug 14:16:48.416 * Slave 127.0.0.1:26379 asks <span class="keyword">for</span> synchronization</span><br><span class="line">7127:M 22 Aug 14:16:48.416 * Full resync requested by slave 127.0.0.1:26379</span><br><span class="line">7127:M 22 Aug 14:16:48.416 * Starting BGSAVE <span class="keyword">for</span> SYNC with target: disk</span><br><span class="line">7127:M 22 Aug 14:16:48.416 * Background saving started by pid 7134</span><br><span class="line">7134:C 22 Aug 14:16:48.433 * DB saved on disk</span><br><span class="line">7127:M 22 Aug 14:16:48.487 * Background saving terminated with success</span><br><span class="line">7127:M 22 Aug 14:16:48.494 * Synchronization with slave 127.0.0.1:26379 succeeded</span><br><span class="line">7127:M 22 Aug 14:16:51.848 * Slave 127.0.0.1:36379 asks <span class="keyword">for</span> synchronization</span><br><span class="line">7127:M 22 Aug 14:16:51.849 * Full resync requested by slave 127.0.0.1:36379</span><br><span class="line">7127:M 22 Aug 14:16:51.849 * Starting BGSAVE <span class="keyword">for</span> SYNC with target: disk</span><br><span class="line">7127:M 22 Aug 14:16:51.850 * Background saving started by pid 7138</span><br><span class="line">7138:C 22 Aug 14:16:51.862 * DB saved on disk</span><br><span class="line">7127:M 22 Aug 14:16:51.919 * Background saving terminated with success</span><br><span class="line">7127:M 22 Aug 14:16:51.923 * Synchronization with slave 127.0.0.1:36379 succeeded</span><br></pre></td></tr></table></figure><p>以下两行日志日志表明，<code>redis-16379</code> 作为 <code>Redis</code> 的 <strong>主节点</strong>，<code>redis-26379</code> 和 <code>redis-36379</code> 作为 <strong>从节点</strong>，从 <strong>主节点</strong> 同步数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7127:M 22 Aug 14:16:48.416 * Slave 127.0.0.1:26379 asks <span class="keyword">for</span> synchronization</span><br><span class="line">7127:M 22 Aug 14:16:51.848 * Slave 127.0.0.1:36379 asks <span class="keyword">for</span> synchronization</span><br></pre></td></tr></table></figure><ul><li>节点 <code>redis-26379</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/<span class="built_in">log</span>/redis/redis-26379.log </span><br><span class="line">7132:C 22 Aug 14:16:48.407 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">7132:C 22 Aug 14:16:48.408 <span class="comment"># Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7132, just started</span></span><br><span class="line">7132:C 22 Aug 14:16:48.408 <span class="comment"># Configuration loaded</span></span><br><span class="line">7133:S 22 Aug 14:16:48.410 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">7133:S 22 Aug 14:16:48.412 * Running mode=standalone, port=26379.</span><br><span class="line">7133:S 22 Aug 14:16:48.413 <span class="comment"># Server initialized</span></span><br><span class="line">7133:S 22 Aug 14:16:48.413 * Ready to accept connections</span><br><span class="line">7133:S 22 Aug 14:16:48.413 * Connecting to MASTER 127.0.0.1:16379</span><br><span class="line">7133:S 22 Aug 14:16:48.413 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">7133:S 22 Aug 14:16:48.414 * Non blocking connect <span class="keyword">for</span> SYNC fired the event.</span><br><span class="line">7133:S 22 Aug 14:16:48.414 * Master replied to PING, replication can <span class="built_in">continue</span>...</span><br><span class="line">7133:S 22 Aug 14:16:48.415 * Partial resynchronization not possible (no cached master)</span><br><span class="line">7133:S 22 Aug 14:16:48.417 * Full resync from master: 211d3b4eceaa3af4fe5c77d22adf06e1218e0e7b:0</span><br><span class="line">7133:S 22 Aug 14:16:48.494 * MASTER &lt;-&gt; SLAVE sync: receiving 176 bytes from master</span><br><span class="line">7133:S 22 Aug 14:16:48.495 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class="line">7133:S 22 Aug 14:16:48.496 * MASTER &lt;-&gt; SLAVE sync: Loading DB <span class="keyword">in</span> memory</span><br><span class="line">7133:S 22 Aug 14:16:48.498 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure><ul><li>节点 <code>redis-36379</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/<span class="built_in">log</span>/redis/redis-36379.log </span><br><span class="line">7136:C 22 Aug 14:16:51.839 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">7136:C 22 Aug 14:16:51.840 <span class="comment"># Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7136, just started</span></span><br><span class="line">7136:C 22 Aug 14:16:51.841 <span class="comment"># Configuration loaded</span></span><br><span class="line">7137:S 22 Aug 14:16:51.843 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">7137:S 22 Aug 14:16:51.845 * Running mode=standalone, port=36379.</span><br><span class="line">7137:S 22 Aug 14:16:51.845 <span class="comment"># Server initialized</span></span><br><span class="line">7137:S 22 Aug 14:16:51.846 * Ready to accept connections</span><br><span class="line">7137:S 22 Aug 14:16:51.846 * Connecting to MASTER 127.0.0.1:16379</span><br><span class="line">7137:S 22 Aug 14:16:51.847 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">7137:S 22 Aug 14:16:51.847 * Non blocking connect <span class="keyword">for</span> SYNC fired the event.</span><br><span class="line">7137:S 22 Aug 14:16:51.847 * Master replied to PING, replication can <span class="built_in">continue</span>...</span><br><span class="line">7137:S 22 Aug 14:16:51.848 * Partial resynchronization not possible (no cached master)</span><br><span class="line">7137:S 22 Aug 14:16:51.850 * Full resync from master: 211d3b4eceaa3af4fe5c77d22adf06e1218e0e7b:14</span><br><span class="line">7137:S 22 Aug 14:16:51.923 * MASTER &lt;-&gt; SLAVE sync: receiving 176 bytes from master</span><br><span class="line">7137:S 22 Aug 14:16:51.923 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class="line">7137:S 22 Aug 14:16:51.924 * MASTER &lt;-&gt; SLAVE sync: Loading DB <span class="keyword">in</span> memory</span><br><span class="line">7137:S 22 Aug 14:16:51.927 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure><h4 id="5-4-3-Sentinel的配置管理"><a href="#5-4-3-Sentinel的配置管理" class="headerlink" title="5.4.3. Sentinel的配置管理"></a>5.4.3. Sentinel的配置管理</h4><p>分别拷贝三份 <code>redis-sentinel.conf</code> 文件到 <code>/usr/local/redis-sentinel</code> 目录下面。三个配置文件分别对应 <code>master</code>、<code>slave1</code> 和 <code>slave2</code> 三个 <code>Redis</code> 节点的 <strong>哨兵配置</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/sentinel.conf /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-16380.conf</span><br><span class="line">$ sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/sentinel.conf /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-26380.conf</span><br><span class="line">$ sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/sentinel.conf /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-36380.conf</span><br></pre></td></tr></table></figure><ul><li>节点1：sentinel-16380.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 16380</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor master 127.0.0.1 16379 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 180000</span><br><span class="line">sentinel parallel-syncs master 1</span><br><span class="line">sentinel auth-pass master 123456</span><br><span class="line">logfile /var/log/redis/sentinel-16380.log</span><br></pre></td></tr></table></figure><ul><li>节点2：sentinel-26380.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 26380</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor master 127.0.0.1 16379 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 180000</span><br><span class="line">sentinel parallel-syncs master 1</span><br><span class="line">sentinel auth-pass master 123456</span><br><span class="line">logfile /var/log/redis/sentinel-26380.log</span><br></pre></td></tr></table></figure><ul><li>节点3：sentinel-36380.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 36380</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor master 127.0.0.1 16379 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 180000</span><br><span class="line">sentinel parallel-syncs master 1</span><br><span class="line">sentinel auth-pass master 123456</span><br><span class="line">logfile /var/log/redis/sentinel-36380.log</span><br></pre></td></tr></table></figure><h4 id="5-4-4-Sentinel启动验证"><a href="#5-4-4-Sentinel启动验证" class="headerlink" title="5.4.4. Sentinel启动验证"></a>5.4.4. Sentinel启动验证</h4><p>按顺序分别启动 <code>16380</code>，<code>26380</code> 和 <code>36380</code> 三个 <code>Sentinel</code> 节点，启动命令和启动日志如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo redis-sentinel /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-16380.conf</span><br><span class="line">$ sudo redis-sentinel /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-26380.conf</span><br><span class="line">$ sudo redis-sentinel /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-36380.conf</span><br></pre></td></tr></table></figure><p>查看 <code>Sentinel</code> 的启动进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep redis-sentinel</span><br><span class="line">    0  7954     1   0  3:30下午 ??         0:00.05 redis-sentinel 0.0.0.0:16380 [sentinel] </span><br><span class="line">    0  7957     1   0  3:30下午 ??         0:00.05 redis-sentinel 0.0.0.0:26380 [sentinel] </span><br><span class="line">    0  7960     1   0  3:30下午 ??         0:00.04 redis-sentinel 0.0.0.0:36380 [sentinel]</span><br></pre></td></tr></table></figure><p>查看 <code>Sentinel</code> 的启动日志：</p><ul><li>节点 <code>sentinel-16380</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/<span class="built_in">log</span>/redis/sentinel-16380.log </span><br><span class="line">7953:X 22 Aug 15:30:27.245 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">7953:X 22 Aug 15:30:27.245 <span class="comment"># Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7953, just started</span></span><br><span class="line">7953:X 22 Aug 15:30:27.245 <span class="comment"># Configuration loaded</span></span><br><span class="line">7954:X 22 Aug 15:30:27.247 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">7954:X 22 Aug 15:30:27.249 * Running mode=sentinel, port=16380.</span><br><span class="line">7954:X 22 Aug 15:30:27.250 <span class="comment"># Sentinel ID is 69d05b86a82102a8919231fd3c2d1f21ce86e000</span></span><br><span class="line">7954:X 22 Aug 15:30:27.250 <span class="comment"># +monitor master master 127.0.0.1 16379 quorum 2</span></span><br><span class="line">7954:X 22 Aug 15:30:32.286 <span class="comment"># +sdown sentinel fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 127.0.0.1 36380 @ master 127.0.0.1 16379</span></span><br><span class="line">7954:X 22 Aug 15:30:34.588 <span class="comment"># -sdown sentinel fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 127.0.0.1 36380 @ master 127.0.0.1 16379</span></span><br></pre></td></tr></table></figure><p><code>sentinel-16380</code> 节点的 <code>Sentinel ID</code> 为 <code>69d05b86a82102a8919231fd3c2d1f21ce86e000</code>，并通过 <code>Sentinel ID</code> 把自身加入 <code>sentinel</code> 集群中。</p><ul><li>节点 <code>sentinel-26380</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/<span class="built_in">log</span>/redis/sentinel-26380.log </span><br><span class="line">7956:X 22 Aug 15:30:30.900 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">7956:X 22 Aug 15:30:30.901 <span class="comment"># Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7956, just started</span></span><br><span class="line">7956:X 22 Aug 15:30:30.901 <span class="comment"># Configuration loaded</span></span><br><span class="line">7957:X 22 Aug 15:30:30.904 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">7957:X 22 Aug 15:30:30.905 * Running mode=sentinel, port=26380.</span><br><span class="line">7957:X 22 Aug 15:30:30.906 <span class="comment"># Sentinel ID is 21e30244cda6a3d3f55200bcd904d0877574e506</span></span><br><span class="line">7957:X 22 Aug 15:30:30.906 <span class="comment"># +monitor master master 127.0.0.1 16379 quorum 2</span></span><br><span class="line">7957:X 22 Aug 15:30:30.907 * +slave slave 127.0.0.1:26379 127.0.0.1 26379 @ master 127.0.0.1 16379</span><br><span class="line">7957:X 22 Aug 15:30:30.911 * +slave slave 127.0.0.1:36379 127.0.0.1 36379 @ master 127.0.0.1 16379</span><br><span class="line">7957:X 22 Aug 15:30:36.311 * +sentinel sentinel fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 127.0.0.1 36380 @ master 127.0.0.1 16379</span><br></pre></td></tr></table></figure><p><code>sentinel-26380</code> 节点的 <code>Sentinel ID</code> 为 <code>21e30244cda6a3d3f55200bcd904d0877574e506</code>，并通过 <code>Sentinel ID</code> 把自身加入 <code>sentinel</code> 集群中。此时 <code>sentinel</code> 集群中已有 <code>sentinel-16380</code> 和 <code>sentinel-26380</code> 两个节点。</p><ul><li>节点 <code>sentinel-36380</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/<span class="built_in">log</span>/redis/sentinel-36380.log </span><br><span class="line">7959:X 22 Aug 15:30:34.273 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">7959:X 22 Aug 15:30:34.274 <span class="comment"># Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7959, just started</span></span><br><span class="line">7959:X 22 Aug 15:30:34.274 <span class="comment"># Configuration loaded</span></span><br><span class="line">7960:X 22 Aug 15:30:34.276 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">7960:X 22 Aug 15:30:34.277 * Running mode=sentinel, port=36380.</span><br><span class="line">7960:X 22 Aug 15:30:34.278 <span class="comment"># Sentinel ID is fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7</span></span><br><span class="line">7960:X 22 Aug 15:30:34.278 <span class="comment"># +monitor master master 127.0.0.1 16379 quorum 2</span></span><br><span class="line">7960:X 22 Aug 15:30:34.279 * +slave slave 127.0.0.1:26379 127.0.0.1 26379 @ master 127.0.0.1 16379</span><br><span class="line">7960:X 22 Aug 15:30:34.283 * +slave slave 127.0.0.1:36379 127.0.0.1 36379 @ master 127.0.0.1 16379</span><br><span class="line">7960:X 22 Aug 15:30:34.993 * +sentinel sentinel 21e30244cda6a3d3f55200bcd904d0877574e506 127.0.0.1 26380 @ master 127.0.0.1 16379</span><br></pre></td></tr></table></figure><p><code>sentinel-36380</code> 节点的 <code>Sentinel ID</code> 为 <code>fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7</code>，并通过 <code>Sentinel ID</code> 把自身加入 <code>sentinel</code> 集群中。此时 <code>sentinel</code> 集群中已有 <code>sentinel-16380</code>，<code>sentinel-26380</code> 和 <code>sentinel-36380</code> 三个节点。</p><h4 id="5-4-5-Sentinel配置刷新"><a href="#5-4-5-Sentinel配置刷新" class="headerlink" title="5.4.5. Sentinel配置刷新"></a>5.4.5. Sentinel配置刷新</h4><ul><li>节点1：sentinel-16380.conf</li></ul><p><code>sentinel-16380.conf</code> 文件新生成如下的配置项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel"</span></span><br><span class="line">sentinel config-epoch master 0</span><br><span class="line">sentinel leader-epoch master 0</span><br><span class="line">sentinel known-slave master 127.0.0.1 36379</span><br><span class="line">sentinel known-slave master 127.0.0.1 26379</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 26380 21e30244cda6a3d3f55200bcd904d0877574e506</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 36380 fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><p>可以注意到，<code>sentinel-16380.conf</code> 刷新写入了 <code>Redis</code> 主节点关联的所有 <strong>从节点</strong> <code>redis-26379</code> 和 <code>redis-36379</code>，同时写入了其余两个 <code>Sentinel</code> 节点 <code>sentinel-26380</code> 和 <code>sentinel-36380</code> 的 <code>IP</code> 地址，<strong>端口号</strong> 和 <code>Sentinel ID</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel"</span></span><br><span class="line">sentinel config-epoch master 0</span><br><span class="line">sentinel leader-epoch master 0</span><br><span class="line">sentinel known-slave master 127.0.0.1 26379</span><br><span class="line">sentinel known-slave master 127.0.0.1 36379</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 36380 fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 16380 69d05b86a82102a8919231fd3c2d1f21ce86e000</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><p>可以注意到，<code>sentinel-26380.conf</code> 刷新写入了 <code>Redis</code> 主节点关联的所有 <strong>从节点</strong> <code>redis-26379</code> 和 <code>redis-36379</code>，同时写入了其余两个 <code>Sentinel</code> 节点 <code>sentinel-36380</code> 和 <code>sentinel-16380</code> 的 <code>IP</code> 地址，<strong>端口号</strong> 和 <code>Sentinel ID</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel"</span></span><br><span class="line">sentinel config-epoch master 0</span><br><span class="line">sentinel leader-epoch master 0</span><br><span class="line">sentinel known-slave master 127.0.0.1 36379</span><br><span class="line">sentinel known-slave master 127.0.0.1 26379</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 16380 69d05b86a82102a8919231fd3c2d1f21ce86e000</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 26380 21e30244cda6a3d3f55200bcd904d0877574e506</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><p>可以注意到，<code>sentinel-36380.conf</code> 刷新写入了 <code>Redis</code> 主节点关联的所有 <strong>从节点</strong> <code>redis-26379</code> 和 <code>redis-36379</code>，同时写入了其余两个 <code>Sentinel</code> 节点 <code>sentinel-16380</code> 和 <code>sentinel-26380</code> 的 <code>IP</code> 地址，<strong>端口号</strong> 和 <code>Sentinel ID</code>。</p><h4 id="5-5-Sentinel时客户端命令"><a href="#5-5-Sentinel时客户端命令" class="headerlink" title="5.5. Sentinel时客户端命令"></a>5.5. Sentinel时客户端命令</h4><ul><li>检查其他 <code>Sentinel</code> 节点的状态，返回 <code>PONG</code> 为正常。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; PING sentinel</span><br></pre></td></tr></table></figure><ul><li>显示被监控的所有 <strong>主节点</strong> 以及它们的状态。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SENTINEL masters</span><br></pre></td></tr></table></figure><ul><li>显示指定 <strong>主节点</strong> 的信息和状态。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SENTINEL master &lt;master_name&gt;</span><br></pre></td></tr></table></figure><ul><li>显示指定 <strong>主节点</strong> 的所有 <strong>从节点</strong> 以及它们的状态。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SENTINEL slaves &lt;master_name&gt;</span><br></pre></td></tr></table></figure><p>返回指定 <strong>主节点</strong> 的 <code>IP</code> 地址和 <strong>端口</strong>。如果正在进行 <code>failover</code> 或者 <code>failover</code> 已经完成，将会显示被提升为 <strong>主节点</strong> 的 <strong>从节点</strong> 的 <code>IP</code> 地址和 <strong>端口</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SENTINEL get-master-addr-by-name &lt;master_name&gt;</span><br></pre></td></tr></table></figure><ul><li>重置名字匹配该 <strong>正则表达式</strong> 的所有的 <strong>主节点</strong> 的状态信息，清除它之前的 <strong>状态信息</strong>，以及 <strong>从节点</strong> 的信息。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SENTINEL reset &lt;pattern&gt;</span><br></pre></td></tr></table></figure><ul><li>强制当前 <code>Sentinel</code> 节点执行 <code>failover</code>，并且不需要得到其他 <code>Sentinel</code> 节点的同意。但是 <code>failover</code> 后会将 <strong>最新的配置</strong> 发送给其他 <code>Sentinel</code> 节点。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL failover &lt;master_name&gt;</span><br></pre></td></tr></table></figure><h2 id="6-Redis-Sentinel故障切换与恢复"><a href="#6-Redis-Sentinel故障切换与恢复" class="headerlink" title="6. Redis Sentinel故障切换与恢复"></a>6. Redis Sentinel故障切换与恢复</h2><h3 id="6-1-Redis-CLI客户端跟踪"><a href="#6-1-Redis-CLI客户端跟踪" class="headerlink" title="6.1. Redis CLI客户端跟踪"></a>6.1. Redis CLI客户端跟踪</h3><p>上面的日志显示，<code>redis-16379</code> 节点为 <strong>主节点</strong>，它的进程 <code>ID</code> 为 <code>7127</code>。为了模拟 <code>Redis</code> 主节点故障，强制杀掉这个进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 7127</span><br></pre></td></tr></table></figure><p>使用 <code>redis-cli</code> 客户端命令进入 <code>sentinel-16380</code> 节点，查看 <code>Redis</code> <strong>节点</strong> 的状态信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 16380</span><br></pre></td></tr></table></figure><ul><li>查看 <code>Redis</code> 主从集群的 <strong>主节点</strong> 信息。可以发现 <code>redis-26379</code> 晋升为 <strong>新的主节点</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:16380&gt; SENTINEL master master</span><br><span class="line"> 1) <span class="string">"name"</span></span><br><span class="line"> 2) <span class="string">"master"</span></span><br><span class="line"> 3) <span class="string">"ip"</span></span><br><span class="line"> 4) <span class="string">"127.0.0.1"</span></span><br><span class="line"> 5) <span class="string">"port"</span></span><br><span class="line"> 6) <span class="string">"26379"</span></span><br><span class="line"> 7) <span class="string">"runid"</span></span><br><span class="line"> 8) <span class="string">"b8ca3b468a95d1be5efe1f50c50636cafe48c59f"</span></span><br><span class="line"> 9) <span class="string">"flags"</span></span><br><span class="line">10) <span class="string">"master"</span></span><br><span class="line">11) <span class="string">"link-pending-commands"</span></span><br><span class="line">12) <span class="string">"0"</span></span><br><span class="line">13) <span class="string">"link-refcount"</span></span><br><span class="line">14) <span class="string">"1"</span></span><br><span class="line">15) <span class="string">"last-ping-sent"</span></span><br><span class="line">16) <span class="string">"0"</span></span><br><span class="line">17) <span class="string">"last-ok-ping-reply"</span></span><br><span class="line">18) <span class="string">"588"</span></span><br><span class="line">19) <span class="string">"last-ping-reply"</span></span><br><span class="line">20) <span class="string">"588"</span></span><br><span class="line">21) <span class="string">"down-after-milliseconds"</span></span><br><span class="line">22) <span class="string">"5000"</span></span><br><span class="line">23) <span class="string">"info-refresh"</span></span><br><span class="line">24) <span class="string">"9913"</span></span><br><span class="line">25) <span class="string">"role-reported"</span></span><br><span class="line">26) <span class="string">"master"</span></span><br><span class="line">27) <span class="string">"role-reported-time"</span></span><br><span class="line">28) <span class="string">"663171"</span></span><br><span class="line">29) <span class="string">"config-epoch"</span></span><br><span class="line">30) <span class="string">"1"</span></span><br><span class="line">31) <span class="string">"num-slaves"</span></span><br><span class="line">32) <span class="string">"2"</span></span><br><span class="line">33) <span class="string">"num-other-sentinels"</span></span><br><span class="line">34) <span class="string">"2"</span></span><br><span class="line">35) <span class="string">"quorum"</span></span><br><span class="line">36) <span class="string">"2"</span></span><br><span class="line">37) <span class="string">"failover-timeout"</span></span><br><span class="line">38) <span class="string">"180000"</span></span><br><span class="line">39) <span class="string">"parallel-syncs"</span></span><br><span class="line">40) <span class="string">"1"</span></span><br></pre></td></tr></table></figure><h3 id="6-2-Redis-Sentinel日志跟踪"><a href="#6-2-Redis-Sentinel日志跟踪" class="headerlink" title="6.2. Redis Sentinel日志跟踪"></a>6.2. Redis Sentinel日志跟踪</h3><p>查看任意 <code>Sentinel</code> 节点的日志如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">7954:X 22 Aug 18:40:22.504 <span class="comment"># +tilt #tilt mode entered</span></span><br><span class="line">7954:X 22 Aug 18:40:32.197 <span class="comment"># +tilt #tilt mode entered</span></span><br><span class="line">7954:X 22 Aug 18:41:02.241 <span class="comment"># -tilt #tilt mode exited</span></span><br><span class="line">7954:X 22 Aug 18:48:24.550 <span class="comment"># +sdown master master 127.0.0.1 16379</span></span><br><span class="line">7954:X 22 Aug 18:48:24.647 <span class="comment"># +new-epoch 1</span></span><br><span class="line">7954:X 22 Aug 18:48:24.651 <span class="comment"># +vote-for-leader fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 1</span></span><br><span class="line">7954:X 22 Aug 18:48:25.678 <span class="comment"># +odown master master 127.0.0.1 16379 #quorum 3/2</span></span><br><span class="line">7954:X 22 Aug 18:48:25.678 <span class="comment"># Next failover delay: I will not start a failover before Wed Aug 22 18:54:24 2018</span></span><br><span class="line">7954:X 22 Aug 18:48:25.709 <span class="comment"># +config-update-from sentinel fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 127.0.0.1 36380 @ master 127.0.0.1 16379</span></span><br><span class="line">7954:X 22 Aug 18:48:25.710 <span class="comment"># +switch-master master 127.0.0.1 16379 127.0.0.1 26379</span></span><br><span class="line">7954:X 22 Aug 18:48:25.710 * +slave slave 127.0.0.1:36379 127.0.0.1 36379 @ master 127.0.0.1 26379</span><br><span class="line">7954:X 22 Aug 18:48:25.711 * +slave slave 127.0.0.1:16379 127.0.0.1 16379 @ master 127.0.0.1 26379</span><br><span class="line">7954:X 22 Aug 18:48:30.738 <span class="comment"># +sdown slave 127.0.0.1:16379 127.0.0.1 16379 @ master 127.0.0.1 26379</span></span><br><span class="line">7954:X 22 Aug 19:38:23.479 <span class="comment"># -sdown slave 127.0.0.1:16379 127.0.0.1 16379 @ master 127.0.0.1 26379</span></span><br></pre></td></tr></table></figure><ul><li>分析日志，可以发现 <code>redis-16329</code> 节点先进入 <code>sdown</code> <strong>主观下线</strong> 状态。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+sdown master master 127.0.0.1 16379</span><br></pre></td></tr></table></figure><ul><li>哨兵检测到 <code>redis-16329</code> 出现故障，<code>Sentinel</code> 进入一个 <strong>新纪元</strong>，从 <code>0</code> 变为 <code>1</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+new-epoch 1</span><br></pre></td></tr></table></figure><ul><li>三个 <code>Sentinel</code> 节点开始协商 <strong>主节点</strong> 的状态，判断其是否需要 <strong>客观下线</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+vote-for-leader fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 1</span><br></pre></td></tr></table></figure><ul><li>超过 <code>quorum</code> 个数的 <code>Sentinel</code> 节点认为 <strong>主节点</strong> 出现故障，<code>redis-16329</code> 节点进入 <strong>客观下线</strong> 状态。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+odown master master 127.0.0.1 16379 <span class="comment">#quorum 3/2</span></span><br></pre></td></tr></table></figure><ul><li><code>Sentinal</code> 进行 <strong>自动故障切换</strong>，协商选定 <code>redis-26329</code> 节点作为新的 <strong>主节点</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+switch-master master 127.0.0.1 16379 127.0.0.1 26379</span><br></pre></td></tr></table></figure><ul><li><code>redis-36329</code> 节点和已经 <strong>客观下线</strong> 的 <code>redis-16329</code> 节点成为 <code>redis-26479</code> 的 <strong>从节点</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7954:X 22 Aug 18:48:25.710 * +slave slave 127.0.0.1:36379 127.0.0.1 36379 @ master 127.0.0.1 26379</span><br><span class="line">7954:X 22 Aug 18:48:25.711 * +slave slave 127.0.0.1:16379 127.0.0.1 16379 @ master 127.0.0.1 26379</span><br></pre></td></tr></table></figure><h3 id="6-3-Redis的配置文件"><a href="#6-3-Redis的配置文件" class="headerlink" title="6.3. Redis的配置文件"></a>6.3. Redis的配置文件</h3><p>分别查看三个 <code>redis</code> 节点的配置文件，发生 <strong>主从切换</strong> 时 <code>redis.conf</code> 的配置会自动发生刷新。</p><ul><li>节点 redis-16379</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile <span class="string">"/var/run/redis-16379.pid"</span></span><br><span class="line">logfile <span class="string">"/var/log/redis/redis-16379.log"</span></span><br><span class="line">port 16379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename <span class="string">"dump-16379.db"</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel/redis-workdir"</span></span><br><span class="line">masterauth <span class="string">"123456"</span></span><br><span class="line">requirepass <span class="string">"123456"</span></span><br></pre></td></tr></table></figure><ul><li>节点 redis-26379</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile <span class="string">"/var/run/redis-26379.pid"</span></span><br><span class="line">logfile <span class="string">"/var/log/redis/redis-26379.log"</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename <span class="string">"dump-26379.db"</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel/redis-workdir"</span></span><br><span class="line">masterauth <span class="string">"123456"</span></span><br><span class="line">requirepass <span class="string">"123456"</span></span><br></pre></td></tr></table></figure><ul><li>节点 redis-36379</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile <span class="string">"/var/run/redis-36379.pid"</span></span><br><span class="line">logfile <span class="string">"/var/log/redis/redis-36379.log"</span></span><br><span class="line">port 36379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename <span class="string">"dump-36379.db"</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel/redis-workdir"</span></span><br><span class="line">masterauth <span class="string">"123456"</span></span><br><span class="line">requirepass <span class="string">"123456"</span></span><br><span class="line">slaveof 127.0.0.1 26379</span><br></pre></td></tr></table></figure><blockquote><p><strong>分析</strong>：<code>redis-26379</code> 节点 <code>slaveof</code> 配置被移除，晋升为 <strong>主节点</strong>。<code>redis-16379</code> 节点处于 <strong>宕机状态</strong>。<code>redis-36379</code> 的 <code>slaveof</code> 配置更新为 <code>127.0.0.1 redis-26379</code>，成为 <code>redis-26379</code> 的 <strong>从节点</strong>。</p></blockquote><p>重启节点 <code>redis-16379</code>。待正常启动后，再次查看它的 <code>redis.conf</code> 文件，配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile <span class="string">"/var/run/redis-16379.pid"</span></span><br><span class="line">logfile <span class="string">"/var/log/redis/redis-16379.log"</span></span><br><span class="line">port 16379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename <span class="string">"dump-16379.db"</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel/redis-workdir"</span></span><br><span class="line">masterauth <span class="string">"123456"</span></span><br><span class="line">requirepass <span class="string">"123456"</span></span><br><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">slaveof 127.0.0.1 26379</span><br></pre></td></tr></table></figure><p>节点 <code>redis-16379</code> 的配置文件新增一行 <code>slaveof</code> 配置属性，指向 <code>redis-26379</code>，即成为 <strong>新的主节点</strong> 的 <strong>从节点</strong>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文首先对 <code>Redis</code> 实现高可用的几种模式做出了阐述，指出了 <code>Redis</code> <strong>主从复制</strong> 的不足之处，进一步引入了 <code>Redis Sentinel</code> <strong>哨兵模式</strong> 的相关概念，深入说明了 <code>Redis Sentinel</code> 的 <strong>具体功能</strong>，<strong>基本原理</strong>，<strong>高可用搭建</strong> 和 <strong>自动故障切换</strong> 验证等。</p><p>当然，<code>Redis Sentinel</code> 仅仅解决了 <strong>高可用</strong> 的问题，对于 <strong>主节点</strong> 单点写入和单节点无法扩容等问题，还需要引入 <code>Redis Cluster</code> <strong>集群模式</strong> 予以解决。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis 开发与运维》</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5dcc40392?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; 的 &lt;strong&gt;主从复制&lt;/strong&gt; 模式下，一旦 &lt;strong&gt;主节点&lt;/strong&gt; 由于故障不能提供服务，需要手动将 &lt;strong&gt;从节点&lt;/strong&gt; 晋升为 &lt;strong&gt;主节点&lt;/strong&gt;，同时还要通知 &lt;strong&gt;客户端&lt;/strong&gt; 更新 &lt;strong&gt;主节点地址&lt;/strong&gt;，这种故障处理方式从一定程度上是无法接受的。&lt;code&gt;Redis 2.8&lt;/code&gt; 以后提供了 &lt;code&gt;Redis Sentinel&lt;/code&gt; &lt;strong&gt;哨兵机制&lt;/strong&gt; 来解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis学习系列" scheme="https://ostenant.coding.me/categories/Redis%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Redis" scheme="https://ostenant.coding.me/tags/Redis/"/>
    
      <category term="Redis Sentinel" scheme="https://ostenant.coding.me/tags/Redis-Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Redis系列(一) - Redis入门简介与主从搭建</title>
    <link href="https://ostenant.coding.me/2018/08/16/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Redis%E7%B3%BB%E5%88%97(%E4%B8%80)%20-%20Redis%08%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/"/>
    <id>https://ostenant.coding.me/2018/08/16/深入剖析Redis系列(一) - Redis入门简介与主从搭建/</id>
    <published>2018-08-16T05:36:00.000Z</published>
    <updated>2018-08-22T11:34:11.828Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Redis</code> 是一种基于 <strong>键值对</strong> 的 <code>NoSQL</code> 数据库。与很多键值对数据库不同，<code>Redis</code> 提供了丰富的 <strong>值数据存储结构</strong>，包括 <code>string</code>(<strong>字符串</strong>)、<code>hash</code>(<strong>哈希</strong>)、<code>list</code>(<strong>列表</strong>)、<code>set</code>(<strong>集合</strong>)、<code>zset</code>(<strong>有序集合</strong>)、<code>bitmap</code>(<strong>位图</strong>)等等。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/redis_black.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><code>Redis</code> 是一个使用 <code>ANSI C</code> 编写的开源、支持 <strong>网络</strong>、基于 <strong>内存</strong>、<strong>单线程模型</strong>、<strong>可选持久性</strong> 的 <strong>键值对存储数据库</strong>。</p><h2 id="1-Redis的特性"><a href="#1-Redis的特性" class="headerlink" title="1. Redis的特性"></a>1. Redis的特性</h2><ol><li><p>速度快，最快可达到 <code>10w QPS</code>（基于 <strong>内存</strong>，<code>C</code> 语言，<strong>单线程</strong> 架构）；</p></li><li><p>基于 <strong>键值对</strong> (<code>key/value</code>) 的数据结构服务器。全称 <code>Remote Dictionary Server</code>。包括 <code>string</code>(<strong>字符串</strong>)、<code>hash</code>(<strong>哈希</strong>)、<code>list</code>(<strong>列表</strong>)、<code>set</code>(<strong>集合</strong>)、<code>zset</code>(<strong>有序集合</strong>)、<code>bitmap</code>(<strong>位图</strong>)。同时在 <strong>字符串</strong> 的基础上演变出 <strong>位图</strong>（<code>BitMaps</code>）和 <code>HyperLogLog</code> 两种数据结构。<code>3.2</code> 版本中加入 <code>GEO</code>（<strong>地理信息位置</strong>）。</p></li><li><p>丰富的功能。例如：<strong>键过期</strong>（缓存），<strong>发布订阅</strong>（消息队列）， <code>Lua</code> 脚本（自己实现 <code>Redis</code> 命令），<strong>事务</strong>，<strong>流水线</strong>（<code>Pipeline</code>，用于减少网络开销）。</p></li><li><p>简单稳定。无外部库依赖，单线程模型。</p></li><li><p>客户端语言多。</p></li><li><p><strong>持久化</strong>（支持两种 <strong>持久化</strong> 方式 <code>RDB</code> 和 <code>AOF</code>）。</p></li><li><p><strong>主从复制</strong>（分布式的基础）。</p></li><li><p><strong>高可用</strong>（<code>Redis Sentinel</code>），<strong>分布式</strong>（<code>Redis Cluster</code>）和 <strong>水平扩容</strong>。</p></li></ol><h2 id="2-Redis的应用场景"><a href="#2-Redis的应用场景" class="headerlink" title="2. Redis的应用场景"></a>2. Redis的应用场景</h2><h3 id="2-1-缓存"><a href="#2-1-缓存" class="headerlink" title="2.1. 缓存"></a>2.1. 缓存</h3><p>合理的使用 <strong>缓存</strong> 能够明显加快访问的速度，同时降低数据源的压力。这也是 <code>Redis</code> 最常用的功能。<code>Redis</code> 提供了 <strong>键值过期时间</strong>（<code>EXPIRE key seconds</code>）设置，并且也提供了灵活控制 <strong>最大内存</strong> 和 <strong>内存溢出</strong> 后的 <strong>淘汰策略</strong>。</p><h3 id="2-2-排行榜"><a href="#2-2-排行榜" class="headerlink" title="2.2. 排行榜"></a>2.2. 排行榜</h3><p>每个网站都有自己的排行榜，例如按照 <strong>热度排名</strong> 的排行榜，<strong>发布时间</strong> 的排行榜，<strong>答题排行榜</strong> 等等。<code>Redis</code> 提供了 <strong>列表</strong>（<code>list</code>）和 <strong>有序集合</strong>（<code>zset</code>）数据结构，合理的使用这些数据结构，可以很方便的构建各种排行榜系统。</p><h3 id="2-3-计数器"><a href="#2-3-计数器" class="headerlink" title="2.3. 计数器"></a>2.3. 计数器</h3><p><strong>计数器</strong> 在网站应用中非常重要。例如：<strong>点赞数</strong>加 <code>1</code>，<strong>浏览数</strong> 加 <code>1</code>。还有常用的 <strong>限流操作</strong>，限制每个用户每秒 <strong>访问系统的次数</strong> 等等。<code>Redis</code> 支持 <strong>计数功能</strong>（<code>INCR key</code>），而且计数的 <strong>性能</strong> 也非常好，计数的同时也可以设置 <strong>超时时间</strong>，这样就可以 <strong>实现限流</strong>。</p><h3 id="2-4-社交网络"><a href="#2-4-社交网络" class="headerlink" title="2.4. 社交网络"></a>2.4. 社交网络</h3><p>赞/踩，粉丝，共同好友/喜好，推送，下拉刷新等是社交网站必备的功能。由于社交网站 <strong>访问量通常比较大</strong>，而且 <strong>传统的数据库</strong> 不太适合保存这类数据，<code>Redis</code> 提供的 <strong>数据结构</strong> 可以相对比较容易实现这些功能。</p><h3 id="2-5-消息队列"><a href="#2-5-消息队列" class="headerlink" title="2.5. 消息队列"></a>2.5. 消息队列</h3><p><code>Redis</code> 提供的 <strong>发布订阅</strong>（<code>PUB/SUB</code>）和 <strong>阻塞队列</strong> 的功能，虽然和专业的消息队列比，还 <strong>不够强大</strong>，但对于一般的消息队列功能基本满足。</p><h2 id="3-Redis的安装配置"><a href="#3-Redis的安装配置" class="headerlink" title="3. Redis的安装配置"></a>3. Redis的安装配置</h2><p>下面介绍一下 <code>Redis</code> 的安装流程。我会按照如下的顺序，逐步搭建出 <strong>高可用</strong> 的 <code>Redis</code> 缓存服务器集群。</p><ul><li><code>Redis</code> <strong>单机服务器</strong> 搭建</li><li><code>Redis</code> <strong>主从复制</strong> 搭建</li><li><code>Redis-Sentinel</code> <strong>高可用</strong> 搭建</li></ul><h3 id="3-1-Redis单机服务器安装"><a href="#3-1-Redis单机服务器安装" class="headerlink" title="3.1. Redis单机服务器安装"></a>3.1. Redis单机服务器安装</h3><h4 id="3-1-1-下载并解压"><a href="#3-1-1-下载并解压" class="headerlink" title="3.1.1. 下载并解压"></a>3.1.1. 下载并解压</h4><p>首先从 <code>Redis</code> 官网下载 <code>Redis</code> 源代码并解压，这里使用的是 <strong>最新稳定版本</strong> <code>4.0.11</code>。依次执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">wget http://download.redis.io/releases/redis-4.0.11.tar.gz</span><br><span class="line">tar -zxvf redis-4.0.2.tar.gz</span><br></pre></td></tr></table></figure><h4 id="3-1-2-编译并安装"><a href="#3-1-2-编译并安装" class="headerlink" title="3.1.2. 编译并安装"></a>3.1.2. 编译并安装</h4><p>下载并解压完毕后，则对 <strong>源码包</strong> 进行 <strong>编译安装</strong>，这里 <code>Redis</code> 安装路径为 <code>/usr/local/redis</code>。</p><blockquote><p><strong>注意</strong>：<code>make install PREFIX</code>=目标安装路径</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis-4.0.11</span><br><span class="line">make install PREFIX=/usr/<span class="built_in">local</span>/redis</span><br></pre></td></tr></table></figure><p>安装完成时，<code>/usr/local/redis/bin</code> 目录下会生成的几个可执行的文件。</p><table><thead><tr><th style="text-align:left">可执行文件</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">redis-server</td><td style="text-align:left">启动 redis 服务</td></tr><tr><td style="text-align:left">redis-cli    redis</td><td style="text-align:left">命令行客户端</td></tr><tr><td style="text-align:left">redis-benchmark</td><td style="text-align:left">redis 基准测试工具</td></tr><tr><td style="text-align:left">redis-check-aof</td><td style="text-align:left">redis AOF 持久化文件检测和修复工具</td></tr><tr><td style="text-align:left">redis-check-dump</td><td style="text-align:left">redis RDB 持久化文件检测和修复工具</td></tr><tr><td style="text-align:left">redis-sentinel</td><td style="text-align:left">启动 redis sentinel</td></tr></tbody></table><p>复制 <code>Redis</code> 相关命令到 <code>/usr/local/bin</code> 目录下，这样就可以直接执行这些命令，不用写全路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis/bin/</span><br><span class="line">$ sudo sudo cp redis-cli redis-server redis-sentinel /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><h4 id="3-1-3-修改Redis配置文件"><a href="#3-1-3-修改Redis配置文件" class="headerlink" title="3.1.3. 修改Redis配置文件"></a>3.1.3. 修改Redis配置文件</h4><p>安装完成之后将 <code>Redis</code> 配置文件拷贝到 <code>/usr/local</code> 下，<code>redis.conf</code> 是 <code>Redis</code> 的配置文件，<code>redis.conf</code> 在 <code>Redis</code> 源码目录，<code>port</code> 默认是 <code>6379</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/redis.conf /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure><p><code>Redis</code> 配置文件主要参数解析参考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis进程是否以守护进程的方式运行，yes为是，no为否(不以守护进程的方式运行会占用一个终端)。</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="comment"># 指定redis进程的PID文件存放位置</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"><span class="comment"># redis进程的端口号</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 绑定的主机地址</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1</span><br><span class="line"><span class="comment"># 客户端闲置多长时间后关闭连接，默认此参数为0即关闭此功能</span></span><br><span class="line">timeout 300</span><br><span class="line"><span class="comment"># redis日志级别，可用的级别有debug.verbose.notice.warning</span></span><br><span class="line">loglevel verbose</span><br><span class="line"><span class="comment"># log文件输出位置，如果进程以守护进程的方式运行，此处又将输出文件设置为stdout的话，就会将日志信息输出到/dev/null里面去了</span></span><br><span class="line">logfile stdout</span><br><span class="line"><span class="comment"># 设置数据库的数量，默认为0可以使用select &lt;dbid&gt;命令在连接上指定数据库id</span></span><br><span class="line">databases 16</span><br><span class="line"><span class="comment"># 指定在多少时间内刷新次数达到多少的时候会将数据同步到数据文件</span></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"><span class="comment"># 指定存储至本地数据库时是否压缩文件，默认为yes即启用存储</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment"># 指定本地数据库文件名</span></span><br><span class="line">dbfilename dump.db</span><br><span class="line"><span class="comment"># 指定本地数据问就按存放位置</span></span><br><span class="line">dir ./</span><br><span class="line"><span class="comment"># 指定当本机为slave服务时，设置master服务的IP地址及端口，在redis启动的时候他会自动跟master进行数据同步</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment"># 当master设置了密码保护时，slave服务连接master的密码</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"><span class="comment"># 设置redis连接密码，如果配置了连接密码，客户端在连接redis是需要通过AUTH&lt;password&gt;命令提供密码，默认关闭</span></span><br><span class="line">requirepass footbared</span><br><span class="line"><span class="comment"># 设置同一时间最大客户连接数，默认无限制。redis可以同时连接的客户端数为redis程序可以打开的最大文件描述符，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回 max number of clients reached 错误信息</span></span><br><span class="line">maxclients 128</span><br><span class="line"><span class="comment"># 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key。当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span></span><br><span class="line">maxmemory&lt;bytes&gt;</span><br><span class="line"><span class="comment"># 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no。</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># 指定跟新日志文件名默认为appendonly.aof</span></span><br><span class="line">appendfilename appendonly.aof</span><br><span class="line"><span class="comment"># 指定更新日志的条件，有三个可选参数 - no：表示等操作系统进行数据缓存同步到磁盘(快)，always：表示每次更新操作后手动调用fsync()将数据写到磁盘(慢，安全)， everysec：表示每秒同步一次(折衷，默认值)；</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><ul><li>设置后台启动</li></ul><p>由于 <code>Redis</code> 默认是 <strong>前台启动</strong>，不建议使用。修改 <code>Redis</code> 配置文件，把 <code>daemonize no</code> 改为 <code>daemonize yes</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><ul><li>设置远程访问</li></ul><p><code>Redis</code> 默认只允许 <strong>本机访问</strong>，把 <code>bind</code> 修改为 <code>bind 0.0.0.0</code> 此设置会变成 <strong>允许所有远程访问</strong>。如果想指定限制访问，可设置对应的 <code>IP</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br></pre></td></tr></table></figure><ul><li>配置 <code>Redis</code> 日志记录</li></ul><p>找到 <code>logfile</code> 配置，默认是：<code>logfile &quot;&quot;</code>，改为自定义日志文件路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile /var/<span class="built_in">log</span>/redis_6379.log</span><br></pre></td></tr></table></figure><ul><li>设置 <code>Redis</code> 请求密码</li></ul><p>把 <code>requirepass</code> 修改为 <code>123456</code>，修改之后重启下服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass <span class="string">"123456"</span></span><br></pre></td></tr></table></figure><p>有了密码之后，进入客户端，就得这样访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379 -a 123456</span><br></pre></td></tr></table></figure><h4 id="3-1-4-Redis的常用命令"><a href="#3-1-4-Redis的常用命令" class="headerlink" title="3.1.4. Redis的常用命令"></a>3.1.4. Redis的常用命令</h4><ul><li>启动命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server /usr/<span class="built_in">local</span>/redis.conf</span><br></pre></td></tr></table></figure><ul><li>关闭命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379 shutdown</span><br></pre></td></tr></table></figure><ul><li>查看是否启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep redis</span><br></pre></td></tr></table></figure><ul><li>进入客户端</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure><ul><li>关闭客户端</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli shutdown</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不建议使用 <code>kill -9</code>，这种方式不但不会做持久化操作，还会造成缓冲区等资源不能优雅关闭。极端情况下造成 <code>AOF</code> 和 <strong>复制丢失数据</strong> 的情况。<code>shutdown</code> 还有一个参数，代表是否在关闭 <code>redis</code> 前，生成 <strong>持久化文件</strong>，命令为 <code>redis-cli shutdown nosave|save</code>。</p></blockquote><ul><li>设置为开机自动启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"redis-server /usr/local/redis.conf"</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure><ul><li>开放防火墙端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加规则</span></span><br><span class="line">iptables -I INPUT -p tcp -m tcp --dport 6379 -j ACCEPT</span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br><span class="line"><span class="comment"># 重启iptables</span></span><br><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><h4 id="3-1-5-注册Redis为系统服务"><a href="#3-1-5-注册Redis为系统服务" class="headerlink" title="3.1.5. 注册Redis为系统服务"></a>3.1.5. 注册Redis为系统服务</h4><p>在 <code>/etc/init.d</code> 目录下添加 <code>Redis</code> 服务的 <strong>启动</strong>，<strong>暂停</strong> 和 <strong>重启</strong> 脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/redis</span><br></pre></td></tr></table></figure><p>脚本的内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># redis - this script starts and stops the redis-server daemon  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># chkconfig:   - 85 15  </span></span><br><span class="line"><span class="comment"># description:  Redis is a persistent key-value database  </span></span><br><span class="line"><span class="comment"># processname: redis-server  </span></span><br><span class="line"><span class="comment"># config:      /usr/local/redis/bin/redis-server</span></span><br><span class="line"><span class="comment"># config:      /etc/redis.conf  </span></span><br><span class="line"><span class="comment"># Source function library.  </span></span><br><span class="line">. /etc/rc.d/init.d/<span class="built_in">functions</span>  </span><br><span class="line"><span class="comment"># Source networking configuration.  </span></span><br><span class="line">. /etc/sysconfig/network  </span><br><span class="line"><span class="comment"># Check that networking is up.  </span></span><br><span class="line">[ <span class="string">"<span class="variable">$NETWORKING</span>"</span> = <span class="string">"no"</span> ] &amp;&amp; <span class="built_in">exit</span> 0  </span><br><span class="line">redis=<span class="string">"/usr/local/redis/bin/redis-server"</span> </span><br><span class="line">prog=$(basename <span class="variable">$redis</span>)  </span><br><span class="line">REDIS_CONF_FILE=<span class="string">"/etc/redis.conf"</span> </span><br><span class="line">[ -f /etc/sysconfig/redis ] &amp;&amp; . /etc/sysconfig/redis  </span><br><span class="line">lockfile=/var/lock/subsys/redis  </span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;  </span><br><span class="line">    [ -x <span class="variable">$redis</span> ] || <span class="built_in">exit</span> 5  </span><br><span class="line">    [ -f <span class="variable">$REDIS_CONF_FILE</span> ] || <span class="built_in">exit</span> 6  </span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Starting <span class="variable">$prog</span>: "</span>  </span><br><span class="line">    daemon <span class="variable">$redis</span> <span class="variable">$REDIS_CONF_FILE</span>  </span><br><span class="line">    retval=$?  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; touch <span class="variable">$lockfile</span>  </span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;  </span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Stopping <span class="variable">$prog</span>: "</span>  </span><br><span class="line">    killproc <span class="variable">$prog</span> -QUIT  </span><br><span class="line">    retval=$?  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; rm -f <span class="variable">$lockfile</span>  </span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">restart</span></span>() &#123;  </span><br><span class="line">    stop  </span><br><span class="line">    start  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">reload</span></span>() &#123;  </span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Reloading <span class="variable">$prog</span>: "</span>  </span><br><span class="line">    killproc <span class="variable">$redis</span> -HUP  </span><br><span class="line">    RETVAL=$?  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">force_reload</span></span>() &#123;  </span><br><span class="line">    restart  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">rh_status</span></span>() &#123;  </span><br><span class="line">    status <span class="variable">$prog</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">rh_status_q</span></span>() &#123;  </span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span>  </span><br><span class="line">    start)  </span><br><span class="line">        rh_status_q &amp;&amp; <span class="built_in">exit</span> 0  </span><br><span class="line">        <span class="variable">$1</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    stop)  </span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 0  </span><br><span class="line">        <span class="variable">$1</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    restart|configtest)  </span><br><span class="line">        <span class="variable">$1</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    reload)  </span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 7  </span><br><span class="line">        <span class="variable">$1</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    force-reload)  </span><br><span class="line">        force_reload  </span><br><span class="line">        ;;  </span><br><span class="line">    status)  </span><br><span class="line">        rh_status  </span><br><span class="line">        ;;  </span><br><span class="line">    condrestart|try-restart)  </span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 0  </span><br><span class="line">    ;;  </span><br><span class="line">    *)  </span><br><span class="line">        <span class="built_in">echo</span> $<span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop|status|restart|condrestart|try-restart|reload|orce-reload&#125;"</span>  </span><br><span class="line">        <span class="built_in">exit</span> 2  </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>赋予脚本文件可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 755 /etc/init.d/redis</span><br></pre></td></tr></table></figure><p>启动、停止和重启 <code>redis</code> 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service redis start</span><br><span class="line">service redis stop</span><br><span class="line">service redis restart</span><br></pre></td></tr></table></figure><h3 id="3-2-Redis主从复制集群安装"><a href="#3-2-Redis主从复制集群安装" class="headerlink" title="3.2. Redis主从复制集群安装"></a>3.2. Redis主从复制集群安装</h3><h4 id="3-2-1-Redis-Server配置说明"><a href="#3-2-1-Redis-Server配置说明" class="headerlink" title="3.2.1. Redis-Server配置说明"></a>3.2.1. Redis-Server配置说明</h4><table><thead><tr><th style="text-align:left">角色</th><th style="text-align:left">IP地址</th><th style="text-align:left">端口号</th></tr></thead><tbody><tr><td style="text-align:left">Redis Master</td><td style="text-align:left">10.206.20.231</td><td style="text-align:left">16379</td></tr><tr><td style="text-align:left">Redis Slave</td><td style="text-align:left">10.206.20.231</td><td style="text-align:left">26379</td></tr></tbody></table><h4 id="3-2-2-Redis主从架构配置"><a href="#3-2-2-Redis主从架构配置" class="headerlink" title="3.2.2. Redis主从架构配置"></a>3.2.2. Redis主从架构配置</h4><ul><li>编辑 <strong>从机</strong> 的 <code>Redis</code> 配置文件，找到 <code>210</code> 行（大概）- <code>#slaveof &lt;masterip&gt; &lt;masterport&gt;</code><br>。去掉该注释，填写 <strong>主服务器</strong> 的 <code>IP</code> 和 <strong>端口</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 10.206.20.231 16379</span><br></pre></td></tr></table></figure><ul><li>如果 <strong>主服务器</strong> 设置了密码，还需要找到 <code>masterauth &lt;master-password&gt;</code> 这一行，去掉注释，改为 <code>masterauth</code> 的主机密码。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><ul><li>配置完成后重启 <strong>从服务器</strong> 的 <code>Redis</code> 服务。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service redis restart</span><br></pre></td></tr></table></figure><ul><li>重启完成之后，进入 <strong>主服务器</strong> 的 <code>redis-cli</code> 模式下，命令为 <code>redis-cli -h 127.0.0.1 -p 16379 -a 123456</code>。输入 <code>INFO replication</code> 查询到 <strong>当前主机</strong> 的 <code>Redis</code> 的状态，连接上 <strong>主服务器</strong> 的 <strong>从服务器</strong>。</li></ul><p><code>Redis</code> <strong>主服务器</strong> 的配置文件：</p><ul><li>redis.conf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-16379.pid</span><br><span class="line">logfile /var/<span class="built_in">log</span>/redis/redis-16379.log</span><br><span class="line">port 16379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-16379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><p><code>Redis</code> <strong>从服务器</strong> 的配置文件：</p><ul><li>redis.conf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-26379.pid</span><br><span class="line">logfile /var/<span class="built_in">log</span>/redis/redis-26379.log</span><br><span class="line">port 26379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-26379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br><span class="line">slaveof 127.0.0.1 16379</span><br></pre></td></tr></table></figure><p><code>Redis</code> <strong>主服务器</strong> 的状态如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=10.206.20.231,port=16379,state=online,offset=28,lag=1</span><br><span class="line">master_replid:625ae9f362643da5337835beaeabfdca426198c7</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:28</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:28</span><br></pre></td></tr></table></figure><p><code>Redis</code> <strong>从服务器</strong> 的状态如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:10.206.20.231</span><br><span class="line">master_port:26379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:210</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:625ae9f362643da5337835beaeabfdca426198c7</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:210</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:210</span><br></pre></td></tr></table></figure><h4 id="3-2-3-Redis主从配置验证"><a href="#3-2-3-Redis主从配置验证" class="headerlink" title="3.2.3. Redis主从配置验证"></a>3.2.3. Redis主从配置验证</h4><p>上面完成了基本的 <strong>主从配置</strong>，可以简单的测试一下效果：</p><ul><li>进入 <strong>主服务器</strong> 的 <code>redis-cli</code> 模式，然后 <code>set</code> 一个值，比如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> master_port <span class="string">"16379"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li>切换进入 <strong>从服务器</strong> 的 <code>redis-cli</code> 的模式，查询刚刚设置的值看是否存在：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; get master_port</span><br><span class="line"><span class="string">"16379"</span></span><br></pre></td></tr></table></figure><p>此时，我们可以发现是可以获取到值的，<code>Redis</code> 的 <strong>主从模式</strong> 正常工作。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文简单的说明了 <code>Redis</code> 的相关 <strong>特性</strong> 和 <strong>应用场景</strong>，详细地给出 <code>Redis</code> 单服务器的 <strong>编译</strong>，<strong>安装</strong>，<strong>配置</strong> 和 <strong>启动</strong>，进一步引入了 <code>Redis</code> <strong>主从复制</strong> 的相关原理和详细配置。关于 <code>Redis</code> 的 <strong>高可用机制</strong> 和 <strong>集群搭建</strong>，下文将给出详细的说明。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis 开发与运维》</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5dcc40392?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; 是一种基于 &lt;strong&gt;键值对&lt;/strong&gt; 的 &lt;code&gt;NoSQL&lt;/code&gt; 数据库。与很多键值对数据库不同，&lt;code&gt;Redis&lt;/code&gt; 提供了丰富的 &lt;strong&gt;值数据存储结构&lt;/strong&gt;，包括 &lt;code&gt;string&lt;/code&gt;(&lt;strong&gt;字符串&lt;/strong&gt;)、&lt;code&gt;hash&lt;/code&gt;(&lt;strong&gt;哈希&lt;/strong&gt;)、&lt;code&gt;list&lt;/code&gt;(&lt;strong&gt;列表&lt;/strong&gt;)、&lt;code&gt;set&lt;/code&gt;(&lt;strong&gt;集合&lt;/strong&gt;)、&lt;code&gt;zset&lt;/code&gt;(&lt;strong&gt;有序集合&lt;/strong&gt;)、&lt;code&gt;bitmap&lt;/code&gt;(&lt;strong&gt;位图&lt;/strong&gt;)等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis学习系列" scheme="https://ostenant.coding.me/categories/Redis%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Redis" scheme="https://ostenant.coding.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列(七) - JVM线上监控工具</title>
    <link href="https://ostenant.coding.me/2018/08/06/JVM%E7%B3%BB%E5%88%97(%E4%B8%83)%20-%20JVM%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
    <id>https://ostenant.coding.me/2018/08/06/JVM系列(七) - JVM线上监控工具/</id>
    <published>2018-08-06T07:21:00.000Z</published>
    <updated>2018-08-13T10:02:51.220Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过上一篇的 <code>JVM</code> 垃圾回收知识，我们了解了 <code>JVM</code> 具体的 <strong>垃圾回收算法</strong> 和几种 <strong>垃圾回收器</strong>。理论是指导实践的工具，有了理论指导，定位问题的时候，知识和经验是关键基础，数据可以为我们提供依据。</p><a id="more"></a><p>在线上我们经常会遇见如下几个问题：</p><ul><li>内存泄露；</li><li>某个进程突然 <code>CPU</code> 飙升；</li><li>线程死锁；</li><li>响应变慢。</li></ul><p>如果遇到了以上这种问题，在 <strong>线下环境</strong> 可以有各种 <strong>可视化的本地工具</strong> 支持查看。但是一旦到 <strong>线上环境</strong>，就没有这么多的 <strong>本地调试工具</strong> 支持，我们该如何基于 <strong>监控工具</strong> 来进行定位问题？</p><p>我们一般会基于 <strong>数据收集</strong> 来定位问题，而数据的收集离不开 <strong>监控工具</strong> 的处理，比如：<strong>运行日志</strong>、<strong>异常堆栈</strong>、<code>GC</code> <strong>日志</strong>、<strong>线程快照</strong>、<strong>堆内存快照</strong> 等。为了解决以上问题，我们常用的 <code>JVM</code> <strong>性能调优监控工具</strong> 大致有：<code>jps</code>、<code>jstat</code>、<code>jstack</code>、<code>jmap</code>、<code>jhat</code>、<code>hprof</code>、<code>jinfo</code>。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>如果想要查看 <code>Java</code> 进程中 <strong>线程堆栈</strong> 的信息，可以选择 <code>jstack</code> 命令。如果要查看 <strong>堆内存</strong>，可以使用 <code>jmap</code> 导出并使用 <code>jhat</code> 来进行分析，包括查看 <strong>类的加载信息</strong>，<code>GC</code> <strong>算法</strong>，<strong>对象</strong> 的使用情况等。可以使用 <code>jstat</code> 来对 <code>JVM</code> 进行 <strong>统计监测</strong>，包括查看各个 <strong>区内存</strong> 和 <code>GC</code> 的情况，还可以使用 <code>hprof</code> 查看 <code>CPU</code> <strong>使用率</strong>，统计 <strong>堆内存</strong> 使用情况。下面会详细的介绍这几个工具的用法。</p><h2 id="JVM常见监控工具-amp-指令"><a href="#JVM常见监控工具-amp-指令" class="headerlink" title="JVM常见监控工具 &amp; 指令"></a>JVM常见监控工具 &amp; 指令</h2><h3 id="1-jps进程监控工具"><a href="#1-jps进程监控工具" class="headerlink" title="1. jps进程监控工具"></a>1. jps进程监控工具</h3><p><code>jps</code> 是用于查看有权访问的 <code>hotspot</code> <strong>虚拟机</strong> 的进程。当未指定 <code>hostid</code> 时，默认查看 <strong>本机</strong> <code>jvm</code> 进程，否则查看指定的 <code>hostid</code> 机器上的 <code>jvm</code> 进程，此时 <code>hostid</code> 所指机器必须开启 <code>jstatd</code> 服务。</p><p><code>jps</code> 可以列出 <code>jvm</code> 进程 <code>lvmid</code>，<strong>主类类名</strong>，<code>main</code> 函数参数, <code>jvm</code> 参数，<code>jar</code> 名称等信息。</p><p>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usage: jps [-<span class="built_in">help</span>]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure><p>参数含义如下：</p><ul><li>-q: 不输出 <strong>类名称</strong>、<code>Jar</code> <strong>名称</strong> 和传入 <code>main</code> 方法的 <strong>参数</strong>；</li><li>-l: 输出 <code>main</code> 类或 <code>Jar</code> 的 <strong>全限定名称</strong>；</li><li>-m: 输出传入 <code>main</code> 方法的 <strong>参数</strong>；</li><li>-v: 输出传入 <code>JVM</code> 的参数。</li></ul><h3 id="2-jinfo配置信息查看工具"><a href="#2-jinfo配置信息查看工具" class="headerlink" title="2. jinfo配置信息查看工具"></a>2. jinfo配置信息查看工具</h3><p><code>jinfo</code>（<code>JVM Configuration info</code>）这个命令作用是实时查看和调整 <strong>虚拟机运行参数</strong>。之前的 <code>jps -v</code> 命令只能查看到显示 <strong>指定的参数</strong>，如果想要查看 <strong>未显示</strong> 的参数的值就要使用 <code>jinfo</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br></pre></td></tr></table></figure><p>参数含义如下：</p><ul><li>pid：本地 <code>jvm</code> 服务的进程 <code>ID</code>；</li><li>executable core：打印 <strong>堆栈跟踪</strong> 的核心文件；</li><li>remote server IP/hostname：远程 <code>debug</code> 服务的 <strong>主机名</strong> 或 <code>IP</code> 地址；</li><li>server id：远程 <code>debug</code> 服务的 <strong>进程</strong> <code>ID</code>。</li></ul><p>参数选项说明如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">flag</td><td style="text-align:left">输出指定 <code>args</code> 参数的值</td></tr><tr><td style="text-align:left">flags</td><td style="text-align:left">不需要 <code>args</code> 参数，输出所有 <code>JVM</code> 参数的值</td></tr><tr><td style="text-align:left">sysprops</td><td style="text-align:left">输出系统属性，等同于 <code>System.getProperties()</code></td></tr></tbody></table><ul><li>查看正在运行的 <code>jvm</code> 进程的 <strong>扩展参数</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flags 31983 </span><br><span class="line">Attaching to process ID 31983, please <span class="built_in">wait</span>… </span><br><span class="line">Debugger attached successfully. </span><br><span class="line">Server compiler detected. </span><br><span class="line">JVM version is 25.91-b14 </span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=20971520 -XX:MaxHeapFreeRatio=90 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=2097152 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=2097152 -XX:OldSize=18874368 -XX:+PrintGC -XX:+PrintGCDetails -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC </span><br><span class="line">Command line: -Xmx20m -Xms20m -Xmn2m -javaagent:/opt/idea-IU-181.4668.68/lib/idea_rt.jar=34989:/opt/idea-IU-181.4668.68/bin -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure><ul><li>查看正在运行的 <code>jvm</code> 进程的所有 <strong>参数信息</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo 31983</span><br><span class="line">Attaching to process ID 31983, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.91-b14</span><br><span class="line">Java System Properties:</span><br><span class="line"></span><br><span class="line">java.runtime.name = Java(TM) SE Runtime Environment</span><br><span class="line">java.vm.version = 25.91-b14</span><br><span class="line">sun.boot.library.path = /opt/jdk1.8.0_91/jre/lib/amd64</span><br><span class="line">java.vendor.url = http://java.oracle.com/</span><br><span class="line">java.vm.vendor = Oracle Corporation</span><br><span class="line">path.separator = :</span><br><span class="line">file.encoding.pkg = sun.io</span><br><span class="line">java.vm.name = Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line">sun.os.patch.level = unknown</span><br><span class="line">sun.java.launcher = SUN_STANDARD</span><br><span class="line">user.country = CN</span><br><span class="line">user.dir = /home/linchen/projects</span><br><span class="line">java.vm.specification.name = Java Virtual Machine Specification</span><br><span class="line">java.runtime.version = 1.8.0_91-b14</span><br><span class="line">java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment</span><br><span class="line">os.arch = amd64</span><br><span class="line">java.endorsed.dirs = /opt/jdk1.8.0_91/jre/lib/endorsed</span><br><span class="line">java.io.tmpdir = /tmp</span><br><span class="line">line.separator = </span><br><span class="line"></span><br><span class="line">java.vm.specification.vendor = Oracle Corporation</span><br><span class="line">os.name = Linux</span><br><span class="line">sun.jnu.encoding = UTF-8</span><br><span class="line">java.library.path = /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</span><br><span class="line">java.specification.name = Java Platform API Specification</span><br><span class="line">java.class.version = 52.0</span><br><span class="line">sun.management.compiler = HotSpot 64-Bit Tiered Compilers</span><br><span class="line">os.version = 4.15.0-24-generic</span><br><span class="line">user.home = /home/linchen</span><br><span class="line">user.timezone = </span><br><span class="line">java.awt.printerjob = sun.print.PSPrinterJob</span><br><span class="line">file.encoding = UTF-8</span><br><span class="line">java.specification.version = 1.8</span><br><span class="line">user.name = linchen</span><br><span class="line">java.class.path = /opt/jdk1.8.0_91/jre/lib/charsets.jar:/opt/jdk1.8.0_91/jre/lib/deploy.jar:/opt/jdk1.8.0_91/jre/lib/ext/cldrdata.jar:/opt/jdk1.8.0_91/jre/lib/ext/dnsns.jar:/opt/jdk1.8.0_91/jre/lib/ext/jaccess.jar:/opt/jdk1.8.0_91/jre/lib/ext/jfxrt.jar:/opt/jdk1.8.0_91/jre/lib/ext/localedata.jar:/opt/jdk1.8.0_91/jre/lib/ext/nashorn.jar:/opt/jdk1.8.0_91/jre/lib/ext/sunec.jar:/opt/jdk1.8.0_91/jre/lib/ext/sunjce_provider.jar:/opt/jdk1.8.0_91/jre/lib/ext/sunpkcs11.jar:/opt/jdk1.8.0_91/jre/lib/ext/zipfs.jar:/opt/jdk1.8.0_91/jre/lib/javaws.jar:/opt/jdk1.8.0_91/jre/lib/jce.jar:/opt/jdk1.8.0_91/jre/lib/jfr.jar:/opt/jdk1.8.0_91/jre/lib/jfxswt.jar:/opt/jdk1.8.0_91/jre/lib/jsse.jar:/opt/jdk1.8.0_91/jre/lib/management-agent.jar:/opt/jdk1.8.0_91/jre/lib/plugin.jar:/opt/jdk1.8.0_91/jre/lib/resources.jar:/opt/jdk1.8.0_91/jre/lib/rt.jar:/home/linchen/IdeaProjects/core_java/target/classes:/home/linchen/.m2/repository/io/netty/netty-all/4.1.7.Final/netty-all-4.1.7.Final.jar:/home/linchen/.m2/repository/junit/junit/4.12/junit-4.12.jar:/home/linchen/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:/home/linchen/.m2/repository/com/lmax/disruptor/3.3.0/disruptor-3.3.0.jar:/home/linchen/.m2/repository/com/rabbitmq/amqp-client/5.3.0/amqp-client-5.3.0.jar:/home/linchen/.m2/repository/org/slf4j/slf4j-api/1.7.25/slf4j-api-1.7.25.jar:/opt/idea-IU-181.4668.68/lib/idea_rt.jar</span><br><span class="line">java.vm.specification.version = 1.8</span><br><span class="line">sun.arch.data.model = 64</span><br><span class="line">sun.java.command = com.own.learn.jvm.JinfoTest</span><br><span class="line">java.home = /opt/jdk1.8.0_91/jre</span><br><span class="line">user.language = zh</span><br><span class="line">java.specification.vendor = Oracle Corporation</span><br><span class="line">awt.toolkit = sun.awt.X11.XToolkit</span><br><span class="line">java.vm.info = mixed mode</span><br><span class="line">java.version = 1.8.0_91</span><br><span class="line">java.ext.dirs = /opt/jdk1.8.0_91/jre/lib/ext:/usr/java/packages/lib/ext</span><br><span class="line">sun.boot.class.path = /opt/jdk1.8.0_91/jre/lib/resources.jar:/opt/jdk1.8.0_91/jre/lib/rt.jar:/opt/jdk1.8.0_91/jre/lib/sunrsasign.jar:/opt/jdk1.8.0_91/jre/lib/jsse.jar:/opt/jdk1.8.0_91/jre/lib/jce.jar:/opt/jdk1.8.0_91/jre/lib/charsets.jar:/opt/jdk1.8.0_91/jre/lib/jfr.jar:/opt/jdk1.8.0_91/jre/classes</span><br><span class="line">java.vendor = Oracle Corporation</span><br><span class="line">file.separator = /</span><br><span class="line">java.vendor.url.bug = http://bugreport.sun.com/bugreport/</span><br><span class="line">sun.io.unicode.encoding = UnicodeLittle</span><br><span class="line">sun.cpu.endian = little</span><br><span class="line">sun.desktop = gnome</span><br><span class="line">sun.cpu.isalist = </span><br><span class="line"></span><br><span class="line">VM Flags:</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=20971520 -XX:MaxHeapFreeRatio=90 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=2097152 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=2097152 -XX:OldSize=18874368 -XX:+PrintGC -XX:+PrintGCDetails -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC </span><br><span class="line">Command line:  -Xmx20m -Xms20m -Xmn2m -javaagent:/opt/idea-IU-181.4668.68/lib/idea_rt.jar=34989:/opt/idea-IU-181.4668.68/bin -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure><ul><li>查看正在运行的 <code>jvm</code> 进程的 <strong>环境变量信息</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -sysprops 31983 </span><br><span class="line">Attaching to process ID 31983, please <span class="built_in">wait</span>… </span><br><span class="line">Debugger attached successfully. </span><br><span class="line">Server compiler detected. </span><br><span class="line">JVM version is 25.91-b14 </span><br><span class="line">java.runtime.name = Java(TM) SE Runtime Environment </span><br><span class="line">java.vm.version = 25.91-b14 </span><br><span class="line">sun.boot.library.path = /opt/jdk1.8.0_91/jre/lib/amd64 </span><br><span class="line">java.vendor.url = http://java.oracle.com/ </span><br><span class="line">java.vm.vendor = Oracle Corporation </span><br><span class="line">path.separator = : </span><br><span class="line">file.encoding.pkg = sun.io </span><br><span class="line">java.vm.name = Java HotSpot(TM) 64-Bit Server VM </span><br><span class="line">sun.os.patch.level = unknown </span><br><span class="line">sun.java.launcher = SUN_STANDARD </span><br><span class="line">user.country = CN </span><br><span class="line">user.dir = /home/linchen/projects </span><br><span class="line">java.vm.specification.name = Java Virtual Machine Specification </span><br><span class="line">java.runtime.version = 1.8.0_91-b14 </span><br><span class="line">java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment </span><br><span class="line">os.arch = amd64 </span><br><span class="line">java.endorsed.dirs = /opt/jdk1.8.0_91/jre/lib/endorsed </span><br><span class="line">java.io.tmpdir = /tmp </span><br><span class="line">line.separator =</span><br></pre></td></tr></table></figure><h3 id="2-jstat信息统计监控工具"><a href="#2-jstat信息统计监控工具" class="headerlink" title="2. jstat信息统计监控工具"></a>2. jstat信息统计监控工具</h3><p><code>jstat</code> 是用于识别 <strong>虚拟机</strong> 各种 <strong>运行状态信息</strong> 的命令行工具。它可以显示 <strong>本地</strong> 或者 <strong>远程虚拟机</strong> 进程中的 <strong>类装载</strong>、<strong>内存</strong>、<strong>垃圾收集</strong>、<code>jit</code> <strong>编译</strong> 等运行数据，它是 <strong>线上</strong> 定位 <code>jvm</code> <strong>性能</strong> 的首选工具。</p><p><code>jstat</code> 工具提供如下的 <code>jvm</code> 监控功能：</p><ol><li><strong>类的加载</strong> 及 <strong>卸载</strong> 的情况；</li><li>查看 <strong>新生代</strong>、<strong>老生代</strong> 及 <strong>元空间</strong>（<code>MetaSpace</code>）的 <strong>容量</strong> 及使用情况；</li><li>查看 <strong>新生代</strong>、<strong>老生代</strong> 及 <strong>元空间</strong>（<code>MetaSpace</code>）的 <strong>垃圾回收情况</strong>，包括垃圾回收的 <strong>次数</strong>，垃圾回收所占用的 <strong>时间</strong>；</li><li>查看 <strong>新生代</strong> 中 <code>Eden</code> 区及 <code>Survior</code> 区中 <strong>容量</strong> 及 <strong>分配情况</strong> 等。</li></ol><p>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: jstat -<span class="built_in">help</span>|-options</span><br><span class="line">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure><p>参数含义如下:</p><ul><li>option: 参数选项。<ul><li>-t: 可以在打印的列加上 <code>timestamp</code> 列，用于显示系统运行的时间。</li><li>-h: 可以在 <strong>周期性数据</strong> 的时候，可以在指定输出多少行以后输出一次 <strong>表头</strong>。</li></ul></li><li>vmid: Virtual Machine ID（进程的 <code>pid</code>）。</li><li>lines: <strong>表头</strong> 与 <strong>表头</strong> 的间隔行数。</li><li>interval: 执行每次的 <strong>间隔时间</strong>，单位为 <strong>毫秒</strong>。</li><li>count: 用于指定输出记录的 <strong>次数</strong>，缺省则会一直打印。</li></ul><p>参数选项说明如下：</p><ul><li>class: 显示 <strong>类加载</strong> <code>ClassLoad</code> 的相关信息；</li><li>compiler: 显示 <code>JIT</code> <strong>编译</strong> 的相关信息；</li><li>gc: 显示和 <code>gc</code> 相关的 <strong>堆信息</strong>；</li><li>gccapacity: 显示 <strong>各个代</strong> 的 <strong>容量</strong> 以及 <strong>使用情况</strong>；</li><li>gcmetacapacity: 显示 <strong>元空间</strong> <code>metaspace</code> 的大小；</li><li>gcnew: 显示 <strong>新生代</strong> 信息；</li><li>gcnewcapacity: 显示 <strong>新生代大小</strong> 和 <strong>使用情况</strong>；</li><li>gcold: 显示 <strong>老年代</strong> 和 <strong>永久代</strong> 的信息；</li><li>gcoldcapacity: 显示 <strong>老年代</strong> 的大小；</li><li>gcutil: 显示 <strong>垃圾回收信息</strong>；</li><li>gccause: 显示 <strong>垃圾回收</strong> 的相关信息（同 <code>-gcutil</code>），同时显示 <strong>最后一次</strong> 或 <strong>当前</strong> 正在发生的垃圾回收的 <strong>诱因</strong>；</li><li>printcompilation: 输出 <code>JIT</code> <strong>编译</strong> 的方法信息；</li></ul><h4 id="2-1-class"><a href="#2-1-class" class="headerlink" title="2.1. class"></a>2.1. class</h4><p>显示和监视 <strong>类装载</strong>、<strong>卸载数量</strong>、<strong>总空间</strong> 以及 <strong>耗费的时间</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -class 8615</span><br><span class="line">Loaded  Bytes     Unloaded  Bytes      Time</span><br><span class="line">  7271 13325.8        1      0.9       2.98</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">Loaded</td><td style="text-align:left">已经装载的类的数量</td></tr><tr><td style="text-align:left">Bytes</td><td style="text-align:left">装载类所占用的字节数</td></tr><tr><td style="text-align:left">Unloaded</td><td style="text-align:left">已经卸载类的数量</td></tr><tr><td style="text-align:left">Bytes</td><td style="text-align:left">卸载类的字节数</td></tr><tr><td style="text-align:left">Time</td><td style="text-align:left">装载和卸载类所花费的时间</td></tr></tbody></table><h4 id="2-2-compiler"><a href="#2-2-compiler" class="headerlink" title="2.2. compiler"></a>2.2. compiler</h4><p>显示虚拟机 <strong>实时编译</strong>（<code>JIT</code>）的 <strong>次数</strong> 和 <strong>耗时</strong> 等信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -compiler 8615</span><br><span class="line">Compiled   Failed  Invalid  Time     FailedType   FailedMethod</span><br><span class="line">  3886        0       0     1.29          0</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">Compiled</td><td style="text-align:left">编译任务执行数量</td></tr><tr><td style="text-align:left">Failed</td><td style="text-align:left">编译任务执行失败数量</td></tr><tr><td style="text-align:left">Invalid</td><td style="text-align:left">编译任务执行失效数量</td></tr><tr><td style="text-align:left">Time</td><td style="text-align:left">编译任务消耗时间</td></tr><tr><td style="text-align:left">FailedType</td><td style="text-align:left">最后一个编译失败任务的类型</td></tr><tr><td style="text-align:left">FailedMethod</td><td style="text-align:left">最后一个编译失败任务所在的类及方法</td></tr></tbody></table><h4 id="2-3-gc"><a href="#2-3-gc" class="headerlink" title="2.3. gc"></a>2.3. gc</h4><p>显示 <strong>垃圾回收</strong>（<code>gc</code>）相关的 <strong>堆信息</strong>，查看 <code>gc</code> 的 <strong>次数</strong> 及 <strong>时间</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 8615</span><br><span class="line"> S0C      S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">20480.0 10752.0  0.0    0.0   262128.0 130750.7  165376.0   24093.7   35456.0 33931.0 4992.0 4582.0      5    0.056   2      0.075    0.131</span><br></pre></td></tr></table></figure><p>比如下面输出的是 <code>GC</code> 信息，采样 <strong>时间间隔</strong> 为 <code>250ms</code>，采样数为 <code>4</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 8615 250 4</span><br><span class="line"> S0C      S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">20480.0 10752.0  0.0    0.0   262144.0 130750.7  165376.0   24093.7   35456.0 33931.0 4992.0 4582.0      5    0.056   2      0.075    0.131</span><br><span class="line">20480.0 10752.0  0.0    0.0   262872.0 130750.7  165376.0   24093.7   35456.0 33931.0 4992.0 4582.0      5    0.056   2      0.075    0.131</span><br><span class="line">20480.0 10752.0  0.0    0.0   262720.0 130750.7  165376.0   24093.7   35456.0 33931.0 4992.0 4582.0      5    0.056   2      0.075    0.131</span><br><span class="line">20480.0 10752.0  0.0    0.0   262446.0 130750.7  165376.0   24093.7   35456.0 33931.0 4992.0 4582.0      5    0.056   2      0.075    0.131</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">S0C</td><td style="text-align:left">年轻代中第一个 <code>survivor</code> 的容量</td></tr><tr><td style="text-align:left">S1C</td><td style="text-align:left">年轻代中第二个 <code>survivor</code> 的容量</td></tr><tr><td style="text-align:left">S0U</td><td style="text-align:left">年轻代中第一个 <code>survivor</code> 目前已使用空间</td></tr><tr><td style="text-align:left">S1U</td><td style="text-align:left">年轻代中第二个 <code>survivor</code> 目前已使用空间</td></tr><tr><td style="text-align:left">EC</td><td style="text-align:left">年轻代中 <code>Eden</code> 的容量</td></tr><tr><td style="text-align:left">EU</td><td style="text-align:left">年轻代中 <code>Eden</code> 目前已使用空间</td></tr><tr><td style="text-align:left">OC</td><td style="text-align:left">老年代的容量</td></tr><tr><td style="text-align:left">OU</td><td style="text-align:left">老年代目前已使用空间</td></tr><tr><td style="text-align:left">MC</td><td style="text-align:left">元空间 <code>metaspace</code> 的容量</td></tr><tr><td style="text-align:left">MU</td><td style="text-align:left">元空间 <code>metaspace</code> 目前已使用空间</td></tr><tr><td style="text-align:left">YGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> <strong>次数</strong></td></tr><tr><td style="text-align:left">YGCT</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> <strong>所用时间</strong></td></tr><tr><td style="text-align:left">FGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> 中 <code>gc</code> <strong>次数</strong></td></tr><tr><td style="text-align:left">FGCT</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> 中 <code>gc</code> <strong>所用时间</strong></td></tr><tr><td style="text-align:left">GCT</td><td style="text-align:left">从应用程序启动到采样时 <code>gc</code> 用的 <strong>总时间</strong></td></tr></tbody></table><h4 id="2-4-gccapacity"><a href="#2-4-gccapacity" class="headerlink" title="2.4. gccapacity"></a>2.4. gccapacity</h4><p>显示 <strong>虚拟机内存</strong> 中三代 <strong>年轻代</strong>（<code>young</code>)，<strong>老年代</strong>（<code>old</code>），<strong>元空间</strong>（<code>metaspace</code>）对象的使用和占用大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccapacity 8615</span><br><span class="line"> NGCMN     NGCMX     NGC      S0C     S1C      EC       OGCMN      OGCMX       OGC        OC         MCMN   MCMX       MC        CCSMN  CCSMX     CCSC      YGC    FGC </span><br><span class="line"> 87040.0 1397760.0 372736.0 20480.0 10752.0 262144.0   175104.0  2796544.0   165376.0   165376.0      0.0 1079296.0  35456.0      0.0 1048576.0   4992.0      5     2</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">NGCMN</td><td style="text-align:left">年轻代的 <strong>初始化</strong>（最小）容量</td></tr><tr><td style="text-align:left">NGCMX</td><td style="text-align:left">年轻代的 <strong>最大容量</strong></td></tr><tr><td style="text-align:left">NGC</td><td style="text-align:left">年轻代 <strong>当前的容量</strong></td></tr><tr><td style="text-align:left">S0C</td><td style="text-align:left">年轻代中 <strong>第一个</strong> <code>survivor</code> 区的容量</td></tr><tr><td style="text-align:left">S1C</td><td style="text-align:left">年轻代中 <strong>第二个</strong> <code>survivor</code> 区的容量</td></tr><tr><td style="text-align:left">EC</td><td style="text-align:left">年轻代中 <code>Eden</code>（<strong>伊甸园</strong>）的容量</td></tr><tr><td style="text-align:left">OGCMN</td><td style="text-align:left">老年代中 <strong>初始化</strong>（最小）容量</td></tr><tr><td style="text-align:left">OGCMX</td><td style="text-align:left">老年代的 <strong>最大容量</strong></td></tr><tr><td style="text-align:left">OGC</td><td style="text-align:left">老年代 <strong>当前新生成</strong> 的容量</td></tr><tr><td style="text-align:left">OC</td><td style="text-align:left">老年代的容量大小</td></tr><tr><td style="text-align:left">MCMN</td><td style="text-align:left"><strong>元空间</strong> 的 <strong>初始化容量</strong></td></tr><tr><td style="text-align:left">MCMX</td><td style="text-align:left"><strong>元空间</strong> 的 <strong>最大容量</strong></td></tr><tr><td style="text-align:left">MC</td><td style="text-align:left"><strong>元空间</strong> 当前 <strong>新生成</strong> 的容量</td></tr><tr><td style="text-align:left">CCSMN</td><td style="text-align:left"><strong>最小</strong> 压缩类空间大小</td></tr><tr><td style="text-align:left">CCSMX</td><td style="text-align:left"><strong>最大</strong> 压缩类空间大小</td></tr><tr><td style="text-align:left">CCSC</td><td style="text-align:left"><strong>当前</strong> 压缩类空间大小</td></tr><tr><td style="text-align:left">YGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中的 <code>gc</code> 次数</td></tr><tr><td style="text-align:left">FGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> 中的 <code>gc</code> 次数</td></tr></tbody></table><h4 id="2-5-gcmetacapacity"><a href="#2-5-gcmetacapacity" class="headerlink" title="2.5. gcmetacapacity"></a>2.5. gcmetacapacity</h4><p>显示 <strong>元空间</strong>（<code>metaspace</code>）中 <strong>对象</strong> 的信息及其占用量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcmetacapacity 8615</span><br><span class="line">MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT   </span><br><span class="line">0.0      1079296.0   35456.0     0.0     1048576.0    4992.0     5     2    0.075    0.131</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">MCMN</td><td style="text-align:left"><strong>最小</strong> 元数据空间容量</td></tr><tr><td style="text-align:left">MCMX</td><td style="text-align:left"><strong>最大</strong> 元数据空间容量</td></tr><tr><td style="text-align:left">MC</td><td style="text-align:left"><strong>当前</strong> 元数据空间容量</td></tr><tr><td style="text-align:left">CCSMN</td><td style="text-align:left"><strong>最小压缩</strong> 类空间容量</td></tr><tr><td style="text-align:left">CCSMX</td><td style="text-align:left"><strong>最大压缩</strong> 类空间容量</td></tr><tr><td style="text-align:left">CCSC</td><td style="text-align:left"><strong>当前</strong> 压缩类空间容量</td></tr><tr><td style="text-align:left">YGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> 次数</td></tr><tr><td style="text-align:left">FGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> 中 <code>gc</code> 次数</td></tr><tr><td style="text-align:left">FGCT</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> <code>gc</code> <strong>所用时间</strong></td></tr><tr><td style="text-align:left">GCT</td><td style="text-align:left">从应用程序启动到采样时 <code>gc</code> 用的 <strong>总时间</strong></td></tr></tbody></table><h4 id="2-6-gcnew"><a href="#2-6-gcnew" class="headerlink" title="2.6. gcnew"></a>2.6. gcnew</h4><p>显示 <strong>年轻代对象</strong> 的相关信息，包括两个 <code>survivor</code> 区和 一个 <code>Eden</code> 区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnew 8615</span><br><span class="line"> S0C      S1C      S0U    S1U TTv MTT  DSS      EC       EU       YGC     YGCT  </span><br><span class="line">20480.0 10752.0    0.0    0.0  6  15 20480.0 262144.0 131406.0      5    0.056</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">S0C</td><td style="text-align:left">年轻代中第一个 <code>survivor</code> 的容量</td></tr><tr><td style="text-align:left">S1C</td><td style="text-align:left">年轻代中第二个 <code>survivor</code> 的容量</td></tr><tr><td style="text-align:left">S0U</td><td style="text-align:left">年轻代中第一个 <code>survivor</code> 目前已使用空间</td></tr><tr><td style="text-align:left">S1U</td><td style="text-align:left">年轻代中第二个 <code>survivor</code> 目前已使用空间</td></tr><tr><td style="text-align:left">TT</td><td style="text-align:left">持有次数限制</td></tr><tr><td style="text-align:left">MTT</td><td style="text-align:left">最大持有次数限制</td></tr><tr><td style="text-align:left">DSS</td><td style="text-align:left">期望的 <strong>幸存区</strong> 大小</td></tr><tr><td style="text-align:left">EC</td><td style="text-align:left">年轻代中 <code>Eden</code> 的容量</td></tr><tr><td style="text-align:left">EU</td><td style="text-align:left">年轻代中 <code>Eden</code> 目前已使用空间</td></tr><tr><td style="text-align:left">YGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> <strong>次数</strong></td></tr><tr><td style="text-align:left">YGCT</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> <strong>所用时间</strong></td></tr></tbody></table><h4 id="2-7-gcnewcapacity"><a href="#2-7-gcnewcapacity" class="headerlink" title="2.7. gcnewcapacity"></a>2.7. gcnewcapacity</h4><p>查看 <strong>年轻代</strong> 对象的信息及其占用量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnewcapacity 8615</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line"> 87040.0   1397760.0   372736.0  465920.0  20480.0 465920.0  10752.0  1396736.0   262144.0   5     2</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">NGCMN</td><td style="text-align:left">年轻代中初始化(最小)的大小</td></tr><tr><td style="text-align:left">NGCMX</td><td style="text-align:left">年轻代的最大容量</td></tr><tr><td style="text-align:left">NGC</td><td style="text-align:left">年轻代中当前的容量</td></tr><tr><td style="text-align:left">S0CMX</td><td style="text-align:left">年轻代中第一个 <code>survivor</code> 的最大容量</td></tr><tr><td style="text-align:left">S0C</td><td style="text-align:left">年轻代中第一个 <code>survivor</code>的容量</td></tr><tr><td style="text-align:left">S1CMX</td><td style="text-align:left">年轻代中第二个 <code>survivor</code> 的最大容量</td></tr><tr><td style="text-align:left">S1C</td><td style="text-align:left">年轻代中第二个 <code>survivor</code> 的容量</td></tr><tr><td style="text-align:left">ECMX</td><td style="text-align:left">年轻代中 <code>Eden</code> 的最大容量</td></tr><tr><td style="text-align:left">EC</td><td style="text-align:left">年轻代中 <code>Eden</code> 的容量</td></tr><tr><td style="text-align:left">YGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> 次数</td></tr><tr><td style="text-align:left">FGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> 中 <code>gc</code> 次数</td></tr></tbody></table><h4 id="2-8-gcold"><a href="#2-8-gcold" class="headerlink" title="2.8. gcold"></a>2.8. gcold</h4><p>显示 <strong>老年代对象</strong> 的相关信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcold 8615</span><br><span class="line">   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT   </span><br><span class="line"> 35456.0  33931.0   4992.0   4582.0    165376.0     24093.7      5     2    0.075    0.131</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">MC</td><td style="text-align:left"><strong>元空间</strong>（<code>metaspace</code>）的容量</td></tr><tr><td style="text-align:left">MU</td><td style="text-align:left"><strong>元空间</strong>（<code>metaspace</code>）目前已使用空间</td></tr><tr><td style="text-align:left">CCSC</td><td style="text-align:left">压缩类空间大小</td></tr><tr><td style="text-align:left">CCSU</td><td style="text-align:left">压缩类空间 <strong>使用</strong> 大小</td></tr><tr><td style="text-align:left">OC</td><td style="text-align:left"><strong>老年代</strong> 的容量</td></tr><tr><td style="text-align:left">OU</td><td style="text-align:left"><strong>老年代</strong> 目前已使用空间</td></tr><tr><td style="text-align:left">YGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> 次数</td></tr><tr><td style="text-align:left">FGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> 中 <code>gc</code> 次数</td></tr><tr><td style="text-align:left">FGCT</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> <code>gc</code> <strong>所用时间</strong></td></tr><tr><td style="text-align:left">GCT</td><td style="text-align:left">从应用程序启动到采样时 <code>gc</code> 用的 <strong>总时间</strong></td></tr></tbody></table><h4 id="2-9-gcoldcapacity"><a href="#2-9-gcoldcapacity" class="headerlink" title="2.9. gcoldcapacity"></a>2.9. gcoldcapacity</h4><p>查看 <strong>老年代</strong> 对象的信息及其占用量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcoldcapacity 8615</span><br><span class="line">   OGCMN       OGCMX        OGC         OC        YGC   FGC    FGCT     GCT   </span><br><span class="line">  175104.0   2796544.0    165376.0    165376.0     5     2    0.075    0.131</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">OGCMN</td><td style="text-align:left"><strong>老年代</strong> 中初始化(最小)的大小</td></tr><tr><td style="text-align:left">OGCMX</td><td style="text-align:left"><strong>老年代</strong> 的最大容量</td></tr><tr><td style="text-align:left">OGC</td><td style="text-align:left"><strong>老年代</strong> 当前新生成的容量</td></tr><tr><td style="text-align:left">OC</td><td style="text-align:left"><strong>老年代</strong> 的容量</td></tr><tr><td style="text-align:left">YGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> 的次数</td></tr><tr><td style="text-align:left">FGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> 中 <code>gc</code> 的次数</td></tr><tr><td style="text-align:left">FGCT</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> 中 <code>gc</code> 所用时间</td></tr><tr><td style="text-align:left">GCT</td><td style="text-align:left">从应用程序启动到采样时 <code>gc</code> 用的 <strong>总时间</strong></td></tr></tbody></table><h4 id="2-10-gcutil"><a href="#2-10-gcutil" class="headerlink" title="2.10. gcutil"></a>2.10. gcutil</h4><p>显示 <strong>垃圾回收</strong>（<code>gc</code>）过程中的信息，包括各个 <strong>内存的使用占比</strong>，垃圾回收 <strong>时间</strong> 和回收 <strong>次数</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcutil 8615</span><br><span class="line">   S0     S1     E      O      M     CCS     YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00   0.00  50.13  14.57  95.70  91.79      5    0.056     2    0.075    0.131</span><br></pre></td></tr></table></figure><p>参数列表及含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">S0</td><td style="text-align:left">年轻代中 <strong>第一个</strong> <code>survivor</code> 区 <strong>已使用</strong> 的占当前容量百分比</td></tr><tr><td style="text-align:left">S1</td><td style="text-align:left">年轻代中 <strong>第二个</strong> <code>survivor</code> 区 <strong>已使用</strong> 的占当前容量百分比</td></tr><tr><td style="text-align:left">E</td><td style="text-align:left">年轻代中 <code>Eden</code> 区 <strong>已使用</strong> 的占当前容量百分比</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left"><strong>老年代</strong> 中 <strong>已使用</strong> 的占当前容量百分比</td></tr><tr><td style="text-align:left">M</td><td style="text-align:left"><strong>元空间</strong>（<code>metaspace</code>）中 <strong>已使用</strong> 的占当前容量百分比</td></tr><tr><td style="text-align:left">YGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> <strong>次数</strong></td></tr><tr><td style="text-align:left">YGCT</td><td style="text-align:left">从应用程序启动到采样时 <strong>年轻代</strong> 中 <code>gc</code> <strong>所用时间</strong></td></tr><tr><td style="text-align:left">FGC</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> <code>gc</code> <strong>次数</strong></td></tr><tr><td style="text-align:left">FGCT</td><td style="text-align:left">从应用程序启动到采样时 <strong>老年代</strong> <code>gc</code> <strong>所用时间</strong></td></tr><tr><td style="text-align:left">GCT</td><td style="text-align:left">从应用程序启动到采样时 <code>gc</code> 用的 <strong>总时间</strong></td></tr></tbody></table><h3 id="3-jmap堆内存统计工具"><a href="#3-jmap堆内存统计工具" class="headerlink" title="3. jmap堆内存统计工具"></a>3. jmap堆内存统计工具</h3><p><code>jmap</code> (<code>JVM Memory Map</code>) 命令用来查看 <strong>堆内存</strong> 使用状况，一般结合 <code>jhat</code> 使用，用于生成 <code>heap dump</code> 文件。<code>jmap</code> 不仅能生成 <code>dump</code> 文件，还可以查询 <code>finalize</code> <strong>执行队列</strong>、<code>Java</code> <strong>堆</strong> 和 <strong>元空间</strong> <code>metaspace</code> 的详细信息，如当前 <strong>使用率</strong>、当前使用的是哪种 <strong>收集器</strong> 等等。</p><blockquote><p>如果不使用这个命令，还可以使用 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数来让虚拟机出现 <code>OOM</code> 的时候，自动生成 <code>dump</code> 文件。</p></blockquote><p>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br></pre></td></tr></table></figure><p>参数含义如下：</p><ul><li>pid：本地 <code>jvm</code> 服务的进程 <code>ID</code>；</li><li>executable core：打印 <strong>堆栈跟踪</strong> 的核心文件；</li><li>remote server IP/hostname：远程 <code>debug</code> 服务的 <strong>主机名</strong> 或 <code>IP</code> 地址；</li><li>server id：远程 <code>debug</code> 服务的 <strong>进程</strong> <code>ID</code>。</li></ul><p>参数选项说明如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">heap</td><td style="text-align:left">显示 <strong>堆</strong> 中的摘要信息</td></tr><tr><td style="text-align:left">histo</td><td style="text-align:left">显示 <strong>堆</strong> 中对象的统计信息</td></tr><tr><td style="text-align:left">histo[:live]</td><td style="text-align:left">只显示 <strong>堆</strong> 中 <strong>存活对象</strong> 的统计信息</td></tr><tr><td style="text-align:left">clstats</td><td style="text-align:left">显示 <strong>类加载</strong> 的统计信息</td></tr><tr><td style="text-align:left">finalizerinfo</td><td style="text-align:left">显示在 <code>F-Queue</code> <strong>队列</strong> 等待 <code>Finalizer</code> 线程执行 <code>finalizer</code> 方法的对象</td></tr><tr><td style="text-align:left">dump</td><td style="text-align:left">导出内存转储快照</td></tr></tbody></table><blockquote><p>注意：<code>dump</code> 内存快照分析基本上包含了 <code>histo</code>、<code>clstats</code>、<code>finalizerinfo</code> 等功能。</p></blockquote><h5 id="3-1-heap"><a href="#3-1-heap" class="headerlink" title="3.1. heap"></a>3.1. heap</h5><p>显示 <strong>堆</strong> 中的摘要信息。包括 <strong>堆内存</strong> 的使用情况，正在使用的 <code>GC</code> <strong>算法</strong>、<strong>堆配置参数</strong> 和 <strong>各代中堆内存</strong> 使用情况。可以用此来判断内存目前的 <strong>使用情况</strong> 以及 <strong>垃圾回收</strong> 情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 11368</span><br><span class="line">Attaching to process ID 11368, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.101-b13</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 2 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 2684354560 (2560.0MB)</span><br><span class="line">   NewSize                  = 1073741824 (1024.0MB)</span><br><span class="line">   MaxNewSize               = 1073741824 (1024.0MB)</span><br><span class="line">   OldSize                  = 1610612736 (1536.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 852492288 (813.0MB)</span><br><span class="line">   used     = 420427144 (400.95056915283203MB)</span><br><span class="line">   free     = 432065144 (412.04943084716797MB)</span><br><span class="line">   49.31741317993014% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 113770496 (108.5MB)</span><br><span class="line">   used     = 2299712 (2.19317626953125MB)</span><br><span class="line">   free     = 111470784 (106.30682373046875MB)</span><br><span class="line">   2.021360617079493% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 107479040 (102.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 107479040 (102.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 1610612736 (1536.0MB)</span><br><span class="line">   used     = 50883368 (48.526161193847656MB)</span><br><span class="line">   free     = 1559729368 (1487.4738388061523MB)</span><br><span class="line">   3.1592552860577903% used</span><br><span class="line"></span><br><span class="line">27595 interned Strings occupying 3138384 bytes.</span><br></pre></td></tr></table></figure><p>这里主要对 <code>heap configuration</code> 的参数列表说明一下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">对应启动参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">MinHeapFreeRatio</td><td style="text-align:left">-XX:MinHeapFreeRatio</td><td style="text-align:left">JVM堆最小空闲比率(default 40)</td></tr><tr><td style="text-align:left">MaxHeapFreeRatio</td><td style="text-align:left">-XX:MaxHeapFreeRatio</td><td style="text-align:left">JVM堆最大空闲比率(default 70)</td></tr><tr><td style="text-align:left">MaxHeapSize</td><td style="text-align:left">XX:Xmx</td><td style="text-align:left">JVM堆的最大大小</td></tr><tr><td style="text-align:left">NewSize</td><td style="text-align:left">-XX:NewSize</td><td style="text-align:left">JVM堆新生代的默认（初始化）大小</td></tr><tr><td style="text-align:left">MaxNewSize</td><td style="text-align:left">-XX:MaxNewSize</td><td style="text-align:left">JVM堆新生代的最大大小</td></tr><tr><td style="text-align:left">OldSize</td><td style="text-align:left">-XX:OldSize</td><td style="text-align:left">JVM堆老年代的默认（初始化）大小</td></tr><tr><td style="text-align:left">NewRatio</td><td style="text-align:left">-XX:NewRatio</td><td style="text-align:left">JVM堆新生代和老年代的大小比例</td></tr><tr><td style="text-align:left">SurvivorRatio</td><td style="text-align:left">-XX:SurvivorRatio</td><td style="text-align:left">JVM堆年轻代中Eden区与Survivor区的大小比值</td></tr><tr><td style="text-align:left">MetaspaceSize</td><td style="text-align:left">-XX:MetaspaceSize</td><td style="text-align:left">JVM元空间（metaspace）初始化大小</td></tr><tr><td style="text-align:left">MaxMetaspaceSize</td><td style="text-align:left">-XX:MaxMetaspaceSize</td><td style="text-align:left">JVM元空间（metaspace）最大大小</td></tr><tr><td style="text-align:left">CompressedClass SpaceSize</td><td style="text-align:left">-XX:CompressedClass SpaceSize</td><td style="text-align:left">JVM类指针压缩空间大小, 默认为1G</td></tr><tr><td style="text-align:left">G1HeapRegionSize</td><td style="text-align:left">-XX:G1HeapRegionSize</td><td style="text-align:left">使用G1垃圾回收器时单个Region的大小，取值为1M至32M</td></tr></tbody></table><h4 id="3-2-histo"><a href="#3-2-histo" class="headerlink" title="3.2. histo"></a>3.2. histo</h4><p>打印堆的 <strong>对象统计</strong>，包括 <strong>对象实例数</strong>、<strong>内存大小</strong> 等等。因为在 <code>histo:live</code> 前会进行 <code>full gc</code>，如果带上 <code>live</code> 则只统计 <strong>活对象</strong>。不加 <code>live</code> 的堆大小要大于加 <code>live</code> 堆的大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -histo:live 12498</span><br><span class="line"> num     <span class="comment">#instances         #bytes  class name</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         50358        7890344  [C</span><br><span class="line">   2:         22887        2014056  java.lang.reflect.Method</span><br><span class="line">   3:          3151        1485512  [B</span><br><span class="line">   4:         49267        1182408  java.lang.String</span><br><span class="line">   5:          7836         871384  java.lang.Class</span><br><span class="line">   6:         24149         772768  java.util.concurrent.ConcurrentHashMap<span class="variable">$Node</span></span><br><span class="line">   7:         20785         482256  [Ljava.lang.Class;</span><br><span class="line">   8:          8357         435248  [Ljava.lang.Object;</span><br><span class="line">   9:         10035         401400  java.util.LinkedHashMap<span class="variable">$Entry</span></span><br><span class="line">  10:          4803         369488  [Ljava.util.HashMap<span class="variable">$Node</span>;</span><br><span class="line">  11:         10763         344416  java.util.HashMap<span class="variable">$Node</span></span><br><span class="line">  12:          5205         291480  java.util.LinkedHashMap</span><br><span class="line">  13:          3055         219960  java.lang.reflect.Field</span><br><span class="line">  14:           120         193408  [Ljava.util.concurrent.ConcurrentHashMap<span class="variable">$Node</span>;</span><br><span class="line">  15:         11224         179584  java.lang.Object</span><br><span class="line">  16:          1988         146152  [Ljava.lang.reflect.Method;</span><br><span class="line">  17:          3036         145728  org.aspectj.weaver.reflect.ShadowMatchImpl</span><br><span class="line">  18:          1771         141680  java.lang.reflect.Constructor</span><br><span class="line">  19:          4903         117672  org.springframework.core.MethodClassKey</span><br><span class="line">  20:          3263         104416  java.lang.ref.WeakReference</span><br><span class="line">  21:          2507         100280  java.lang.ref.SoftReference</span><br><span class="line">  22:          2523          97600  [I</span><br><span class="line">  23:          3036          97152  org.aspectj.weaver.patterns.ExposedState</span><br><span class="line">  24:          2072          95280  [Ljava.lang.String;</span><br><span class="line">  25:           954          91584  org.springframework.beans.GenericTypeAwarePropertyDescriptor</span><br><span class="line">  26:          1633          91448  java.lang.Class<span class="variable">$ReflectionData</span></span><br><span class="line">  27:          3142          90520  [Z</span><br><span class="line">  28:          1671          80208  java.util.HashMap</span><br><span class="line">  29:          3244          77856  java.util.ArrayList</span><br><span class="line">  30:          3037          72880  [Lorg.aspectj.weaver.ast.Var;</span><br><span class="line">  31:          1809          72360  java.util.WeakHashMap<span class="variable">$Entry</span></span><br><span class="line">  32:          1967          62944  java.util.LinkedList</span><br></pre></td></tr></table></figure><p>其中，<code>class name</code> 是 <strong>对象类型</strong>，对象 <strong>缩写类型</strong> 与 <strong>真实类型</strong> 的对应说明如下：</p><table><thead><tr><th style="text-align:left">对象缩写类型</th><th style="text-align:left">对象真实类型</th></tr></thead><tbody><tr><td style="text-align:left">B</td><td style="text-align:left">byte</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">char</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">double</td></tr><tr><td style="text-align:left">F</td><td style="text-align:left">float</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">int</td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">long</td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">boolean</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">数组，如[I表示int[]</td></tr><tr><td style="text-align:left">[L+类名</td><td style="text-align:left">其他对象</td></tr></tbody></table><h4 id="3-3-dump"><a href="#3-3-dump" class="headerlink" title="3.3. dump"></a>3.3. dump</h4><p><code>dump</code> 用于导出内存转储快照。常用的方式是通过 <code>jmap</code> 把进程 <strong>内存使用情况</strong> <code>dump</code> 到文件中，再用 <code>jhat</code> 分析查看。<code>jmap</code> 进行 <code>dump</code> 的命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dumpFileName</span><br></pre></td></tr></table></figure><p>参数含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">dump</td><td style="text-align:left">堆到文件</td></tr><tr><td style="text-align:left">format</td><td style="text-align:left">指定输出格式</td></tr><tr><td style="text-align:left">live</td><td style="text-align:left">指明是活着的对象</td></tr><tr><td style="text-align:left">file</td><td style="text-align:left">指定文件名</td></tr></tbody></table><ul><li>通过 <code>jmap</code> 导出 <strong>内存快照</strong>，文件命名为 <code>dump.dat</code>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dump.dat 12498</span><br><span class="line">Dumping heap to /Users/XXX/dump.dat ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><p>导出的 <code>dump</code> 文件可以通过 <code>MAT</code>、<code>VisualVM</code> 和 <code>jhat</code> 等工具查看分析，后面会详细介绍。</p><h3 id="4-jhat堆快照分析工具"><a href="#4-jhat堆快照分析工具" class="headerlink" title="4. jhat堆快照分析工具"></a>4. jhat堆快照分析工具</h3><p><code>jhat</code>（<code>JVM Heap Analysis Tool</code>）命令通常与 <code>jmap</code> 搭配使用，用来分析 <code>jmap</code> 生成的 <code>dump</code>。<code>jhat</code> 内置了一个微型的 <code>HTTP/HTML</code> <strong>服务器</strong>，生成 <code>dump</code> 的分析结果后，可以在浏览器中查看。</p><blockquote><p>注意：一般不会直接在 <strong>服务器</strong> 上 <strong>进行分析</strong>，因为使用 <code>jhat</code> 是一个 <strong>耗时</strong> 并且 <strong>耗费硬件资源</strong> 的过程，一般的做法是，把 <strong>服务器</strong> 生成的 <code>dump</code> 文件复制到 <strong>本地</strong> 或 <strong>其他机器</strong> 上进行分析。</p></blockquote><p>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-<span class="built_in">help</span>] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">-J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">  example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">-stack <span class="literal">false</span>:     Turn off tracking object allocation call stack.</span><br><span class="line">-refs <span class="literal">false</span>:      Turn off tracking of references to objects</span><br><span class="line">-port &lt;port&gt;:     Set the port <span class="keyword">for</span> the HTTP server.  Defaults to 7000</span><br><span class="line">-exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">  be excluded from the reachableFrom query.</span><br><span class="line">-baseline &lt;file&gt;: Specify a baseline object dump.  Objects <span class="keyword">in</span></span><br><span class="line">  both heap dumps with the same ID and same class will</span><br><span class="line">  be marked as not being <span class="string">"new"</span>.</span><br><span class="line">-debug &lt;int&gt;:     Set debug level.</span><br><span class="line">    0:  No debug output</span><br><span class="line">    1:  Debug hprof file parsing</span><br><span class="line">    2:  Debug hprof file parsing, no server</span><br><span class="line">-version          Report version number</span><br><span class="line">-h|-<span class="built_in">help</span>          Print this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">&lt;file&gt;            The file to <span class="built_in">read</span></span><br></pre></td></tr></table></figure><p>参数含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数值默认值</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">stack</td><td style="text-align:left">true</td><td style="text-align:left">关闭 <strong>对象分配调用栈跟踪</strong>。如果分配位置信息在堆转储中不可用。则必须将此标志设置为false。</td></tr><tr><td style="text-align:left">refs</td><td style="text-align:left">true</td><td style="text-align:left">关闭 <strong>对象引用跟踪</strong>。默认情况下，返回的指针是指向其他特定对象的对象。如 <strong>反向链接</strong> 或 <strong>输入引用</strong>，会统计/计算堆中的所有对象</td></tr><tr><td style="text-align:left">port</td><td style="text-align:left">7000</td><td style="text-align:left">设置jhat HTTP server的端口号</td></tr><tr><td style="text-align:left">exclude</td><td style="text-align:left">—</td><td style="text-align:left">指定对象查询时需要排除的数据成员列表文件</td></tr><tr><td style="text-align:left">baseline</td><td style="text-align:left">—</td><td style="text-align:left">指定一个 <strong>基准堆转储</strong>。在两个heap dumps中有相同object ID的对象时，会被标记为不是新的，其他对象被标记为新的。在比较两个不同的堆转储时很有用</td></tr><tr><td style="text-align:left">debug</td><td style="text-align:left">0</td><td style="text-align:left">设置debug级别，0表示不输出调试信息。值越大则表示输出更详细的debug信息</td></tr><tr><td style="text-align:left">version</td><td style="text-align:left">—</td><td style="text-align:left">启动后只显示版本信息就退出</td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">—</td><td style="text-align:left">jhat命令实际上会启动一个JVM来执行，通过-J可以在启动JVM时传入一些 <strong>启动参数</strong>。例如， -J-Xmx512m则指定运行jhat 的Java虚拟机使用的最大堆内存为512MB。</td></tr></tbody></table><ul><li>前面提到，通过 <code>jmap dump</code> 出来的文件可以用 <code>MAT</code>、<code>VisualVM</code> 等工具查看，这里我们用 <code>jhat</code> 查看：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jhat -port 7000 dump.dat</span><br><span class="line">Reading from dump.dat...</span><br><span class="line">Dump file created Sun Aug 12 12:15:02 CST 2018</span><br><span class="line">Snapshot <span class="built_in">read</span>, resolving...</span><br><span class="line">Resolving 1788693 objects...</span><br><span class="line">Chasing references, expect 357 dots.....................................................................................................................................................................................................................................................................................................................................................................</span><br><span class="line">Eliminating duplicate references.....................................................................................................................................................................................................................................................................................................................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><ul><li>打开浏览器，输入 <code>http://localhost:7000</code>，查看 <code>jhat</code> 的分析报表页面：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/12/1652e8d753092849?w=2880&amp;h=1696&amp;f=png&amp;s=769053" alt=""></p><ul><li>可以按照 <strong>包名称</strong> 查看项目模块中的具体 <strong>对象示例</strong>：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/12/1652e8d752efb04c?w=2880&amp;h=1726&amp;f=png&amp;s=769036" alt=""></p><p>除此之外，报表分析的最后一页，还提供了一些扩展查询：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/12/1652e8d752fbdf18?w=2880&amp;h=468&amp;f=png&amp;s=120137" alt=""></p><ul><li>显示所有的 <code>Root</code> 集合；</li><li>显示所有 <code>class</code> 的当前 <strong>对象实例数量</strong>（包含 <code>JVM</code> 平台相关类）；</li><li>显示所有 <code>class</code> 的当前 <strong>对象实例数量</strong>（除去 <code>JVM</code> 平台相关类）；</li><li>显示 <strong>堆内存</strong> 中实例对象的 <strong>统计直方图</strong>（和直接使用 <code>jmap</code> 没有区别）；</li><li>显示 <code>finalizer</code> 虚拟机 <strong>二次回收</strong> 的信息摘要；</li><li>执行 <code>jhat</code> 提供的 <strong>对象查询语言</strong>（<code>OQL</code>）获取指定对象的实例信息。</li></ul><blockquote><p>注意：<code>jhat</code> 支持根据某些条件来 <strong>过滤</strong> 或 <strong>查询</strong> 堆的对象。可以在 <code>jhat</code> 的 <code>html</code> 页面中执行 <code>OQL</code> 语句，来查询符合条件的对象。<code>OQL</code> `具体的语法可以直接访问 <a href="http://localhost:7000/oqlhelp。" target="_blank" rel="noopener">http://localhost:7000/oqlhelp。</a></p></blockquote><p>在具体排查时，需要结合代码，观察是否 <strong>大量应该被回收</strong> 的对象 <strong>一直被引用</strong>，或者是否有 <strong>占用内存特别大</strong> 的对象 <strong>无法被回收</strong>。</p><h3 id="5-jstack堆栈跟踪工具"><a href="#5-jstack堆栈跟踪工具" class="headerlink" title="5. jstack堆栈跟踪工具"></a>5. jstack堆栈跟踪工具</h3><p><code>jstack</code> 用于生成 <code>java</code> 虚拟机当前时刻的 <strong>线程快照</strong>。<strong>线程快照</strong> 是当前 <code>java</code> 虚拟机内 <strong>每一条线程</strong> 正在执行的 <strong>方法堆栈</strong> 的 <strong>集合</strong>。生成线程快照的主要目的是定位线程出现 <strong>长时间停顿</strong> 的原因，如 <strong>线程间死锁</strong>、<strong>死循环</strong>、<strong>请求外部资源</strong> 导致的 <strong>长时间等待</strong> 等等。</p><p>线程出现 <strong>停顿</strong> 的时候，通过 <code>jstack</code> 来查看 <strong>各个线程</strong> 的 <strong>调用堆栈</strong>，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。如果 <code>java</code> 程序 <strong>崩溃</strong> 生成 <code>core</code> <strong>文件</strong>，<code>jstack</code> 工具可以通过 <code>core</code> 文件获取 <code>java stack</code> 和 <code>native stack</code> 的信息，从而定位程序崩溃的原因。</p><p>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br></pre></td></tr></table></figure><p>参数含义如下：</p><ul><li>pid：本地 <code>jvm</code> 服务的进程 <code>ID</code>；</li><li>executable core：打印 <strong>堆栈跟踪</strong> 的核心文件；</li><li>remote server IP/hostname：远程 <code>debug</code> 服务的 <strong>主机名</strong> 或 <code>IP</code> 地址；</li><li>server id：远程 <code>debug</code> 服务的 <strong>进程</strong> <code>ID</code>。</li></ul><p>参数选项说明如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">参数含义</th></tr></thead><tbody><tr><td style="text-align:left">F</td><td style="text-align:left">当正常输出请求 <strong>不被响应</strong> 时，强制输出 <strong>线程堆栈</strong></td></tr><tr><td style="text-align:left">l</td><td style="text-align:left">除堆栈外，显示关于 <strong>锁的附加信息</strong></td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">如果调用到 <strong>本地方法</strong> 的话，可以显示 <code>C/C++</code> 的堆栈</td></tr></tbody></table><blockquote><p>注意：在实际运行中，往往一次 <code>dump</code> 的信息，还不足以确认问题。建议产生三次 <code>dump</code> 信息，如果每次 <code>dump</code> 都指向同一个问题，才能确定问题的典型性。</p></blockquote><h4 id="5-1-系统线程状态"><a href="#5-1-系统线程状态" class="headerlink" title="5.1. 系统线程状态"></a>5.1. 系统线程状态</h4><p>在 <code>dump</code> 文件里，值得关注的 <strong>线程状态</strong> 有：</p><ol><li>死锁：Deadlock（重点关注）</li><li>执行中：Runnable</li><li>等待资源：Waiting on condition（重点关注） </li><li>等待获取监视器：Waiting on monitor entry（重点关注）</li><li>暂停：Suspended</li><li>对象等待中：Object.wait() 或 TIMED_WAITING</li><li>阻塞：Blocked（重点关注）  </li><li>停止：Parked</li></ol><p>具体的含义如下所示：</p><p><strong>(a). Deadlock</strong></p><blockquote><p><strong>死锁线程</strong>，一般指多个线程调用期间发生 <strong>资源的相互占用</strong>，导致一直等待无法释放的情况。</p></blockquote><p><strong>(b). Runnable</strong></p><blockquote><p>一般指该线程正在 <strong>执行状态</strong> 中，该线程占用了 <strong>资源</strong>，正在 <strong>处理某个请求</strong>。有可能正在传递 <code>SQL</code> 到数据库执行，有可能在对某个文件操作，有可能进行数据类型等转换。</p></blockquote><p><strong>(c). Waiting on condition</strong></p><blockquote><p>该状态在线程等待 <strong>某个条件</strong> 的发生。具体是什么原因，可以结合 <code>stacktrace</code> 来分析。线程处于这种 <strong>等待状态</strong>，一旦有数据准备好读之后，线程会重新激活，读取并处理数据。</p></blockquote><p>线程正处于等待资源或等待某个条件的发生，具体的原因需要结合下面堆栈信息进行分析。</p><ul><li><p>如果 <strong>堆栈信息</strong> 明确是 <strong>应用代码</strong>，则证明该线程正在 <strong>等待资源</strong>。一般是大量 <strong>读取某种资源</strong> 且该资源采用了 <strong>资源锁</strong> 的情况下，线程进入 <strong>等待状态</strong>。</p></li><li><p>如果发现有 <strong>大量的线程</strong> 都正处于这种状态，并且堆栈信息中得知正在 <strong>等待网络读写</strong>，这是因为 <strong>网络阻塞</strong> 导致 <strong>线程无法执行</strong>，很有可能是一个 <strong>网络瓶颈</strong> 的征兆：</p><ul><li>网络非常 <strong>繁忙</strong>，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；</li><li>网络可能是 <strong>空闲的</strong>，但由于 <strong>路由</strong> 或 <strong>防火墙</strong> 等原因，导致包无法正常到达。</li></ul></li><li><p>还有一种常见的情况是该线程在 <code>sleep</code>，等待 <code>sleep</code> 的时间到了，将被唤醒。</p></li></ul><p><strong>(d). Locked</strong></p><blockquote><p><strong>线程阻塞</strong>，是指当前线程执行过程中，所需要的资源 <strong>长时间等待</strong> 却 <strong>一直未能获取到</strong>，被容器的线程管理器标识为 <strong>阻塞状态</strong>，可以理解为 <strong>等待资源超时</strong> 的线程。</p></blockquote><p><strong>(e). Waiting for monitor entry 和 in Object.wait()</strong></p><blockquote><p><code>Monitor</code> 是 <code>Java</code> 中实现线程之间的 <strong>互斥与协作</strong> 的主要手段，它可以看成是 <strong>对象</strong> 或者 <code>Class</code> 的 <strong>锁</strong>。每一个对象都有一个 <code>monitor</code>。</p></blockquote><h4 id="5-1-死锁示例"><a href="#5-1-死锁示例" class="headerlink" title="5.1. 死锁示例"></a>5.1. 死锁示例</h4><p>下面给出一个 <strong>死锁</strong> 的案例，在 <code>IntLock</code> 中定义了两个静态的 <strong>可重入锁</strong> 实例，在主方法中声明了 <strong>两个线程</strong> 对 <strong>两把锁</strong> 进行资源竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockRunner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntLock r1 = <span class="keyword">new</span> IntLock(<span class="number">1</span>);</span><br><span class="line">        IntLock r2 = <span class="keyword">new</span> IntLock(<span class="number">2</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IntLock</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line">                    lock1.lock();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    lock2.lock();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lock2.lock();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    lock1.lock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock1.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock2.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-dump日志分析"><a href="#5-2-dump日志分析" class="headerlink" title="5.2. dump日志分析"></a>5.2. dump日志分析</h4><p>启动 <code>DeadLockRunner</code> 的 <code>main()</code> 方法，使用 <code>jps</code> 查看阻塞的 <code>jvm</code> 进程的 <code>id</code>，然后使用 <code>jstack</code> 查看 <strong>线程堆栈信息</strong>，可以发现两个线程相互 <strong>竞争资源</strong>，<strong>出现死锁</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ jstack -l 15584</span><br><span class="line">2018-08-12 20:35:40</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.172-b11 mixed mode):</span><br><span class="line"></span><br><span class="line">// 省略...</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer 0x000000076ad61180, (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>),</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">"Thread-0"</span></span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer 0x000000076ad611b0, (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>),</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">"Thread-1"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x000000076ad61180&gt; (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>.lock(ReentrantLock.java:209)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)</span><br><span class="line">at io.ostenant.deadlock.DeadLockRunner<span class="variable">$IntLock</span>.run(DeadLockRunner.java:47)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x000000076ad611b0&gt; (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>.lock(ReentrantLock.java:209)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)</span><br><span class="line">at io.ostenant.deadlock.DeadLockRunner<span class="variable">$IntLock</span>.run(DeadLockRunner.java:37)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社</p><hr><p>欢迎关注技术公众号：零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bd1fd0856?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过上一篇的 &lt;code&gt;JVM&lt;/code&gt; 垃圾回收知识，我们了解了 &lt;code&gt;JVM&lt;/code&gt; 具体的 &lt;strong&gt;垃圾回收算法&lt;/strong&gt; 和几种 &lt;strong&gt;垃圾回收器&lt;/strong&gt;。理论是指导实践的工具，有了理论指导，定位问题的时候，知识和经验是关键基础，数据可以为我们提供依据。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA虚拟机系列" scheme="https://ostenant.coding.me/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JVM" scheme="https://ostenant.coding.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列(六) - JVM垃圾回收器</title>
    <link href="https://ostenant.coding.me/2018/08/03/JVM%E7%B3%BB%E5%88%97(%E5%85%AD)%20-%20JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://ostenant.coding.me/2018/08/03/JVM系列(六) - JVM垃圾回收器/</id>
    <published>2018-08-02T22:58:00.000Z</published>
    <updated>2018-08-04T02:43:52.468Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的几篇博客中，我们大致介绍了，常见的 <strong>垃圾回收算法</strong> 及 <code>JVM</code> 中常见的分类回收算法。这些都是从算法和规范上分析 <code>Java</code> 中的垃圾回收，属于方法论。在 <code>JVM</code> 中，垃圾回收的具体实现是由 <strong>垃圾回收器</strong>（<code>Garbage Collector</code>）负责。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/JVM.jpg" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在了解 <strong>垃圾回收器</strong> 之前，首先得了解一下垃圾回收器的几个名词。</p><h3 id="1-吞吐量"><a href="#1-吞吐量" class="headerlink" title="1. 吞吐量"></a>1. 吞吐量</h3><p><code>CPU</code> 用于运行用户代码的时间与 <code>CPU</code> 总消耗时间的比值。比如说虚拟机总运行了 <code>100</code> 分钟，<strong>用户代码</strong> 时间 <code>99</code> 分钟，<strong>垃圾回收</strong> 时间 <code>1</code> 分钟，那么吞吐量就是 <code>99%</code>。</p><blockquote><p>吞吐量 = 运行用户代码时间/（运行用户代码时间 + 垃圾回收时间）</p></blockquote><h3 id="2-停顿时间"><a href="#2-停顿时间" class="headerlink" title="2. 停顿时间"></a>2. 停顿时间</h3><p><strong>停顿时间</strong> 指垃圾回收器正在运行时，<strong>应用程序</strong> 的 <strong>暂停时间</strong>。对于 <strong>独占回收器</strong> 而言，停顿时间可能会比较长。使用 <strong>并发回收器</strong> 时，由于垃圾回收器和应用程序 <strong>交替运行</strong>，程序的 <strong>停顿时间</strong> 会变短，但是，由于其 <strong>效率</strong> 很可能不如独占垃圾回收器，故系统的 <strong>吞吐量</strong> 可能会较低。</p><h3 id="3-GC的名词"><a href="#3-GC的名词" class="headerlink" title="3. GC的名词"></a>3. GC的名词</h3><h4 id="3-1-新生代GC（Minor-GC）"><a href="#3-1-新生代GC（Minor-GC）" class="headerlink" title="3.1. 新生代GC（Minor GC）"></a>3.1. 新生代GC（Minor GC）</h4><p>指发生在 <strong>新生代</strong> 的垃圾回收动作，因为 <code>Java</code> 对象大多都具备 <strong>朝生夕死</strong> 的特性，所以 <code>Minor GC</code> 通常 <strong>非常频繁</strong>，一般回收速度也比较快。</p><h4 id="3-2-老年代GC（Major-GC）"><a href="#3-2-老年代GC（Major-GC）" class="headerlink" title="3.2. 老年代GC（Major GC）"></a>3.2. 老年代GC（Major GC）</h4><p>指发生在 <strong>老年代</strong> 的垃圾回收动作，出现了 <code>Major GC</code>，经常会伴随至少一次的 <code>Minor GC</code>（发生这种情况，那么 <strong>整个堆</strong> 都 <code>GC</code> 一遍，通常称为 <code>Full GC</code>）。<code>Major GC</code> 的速度一般会比 <code>Minor GC</code> 慢 <code>10</code> 倍以上。</p><h3 id="4-并发与并行"><a href="#4-并发与并行" class="headerlink" title="4. 并发与并行"></a>4. 并发与并行</h3><h4 id="4-1-串行（Parallel）"><a href="#4-1-串行（Parallel）" class="headerlink" title="4.1. 串行（Parallel）"></a>4.1. 串行（Parallel）</h4><p><strong>单线程</strong> 进行垃圾回收工作，但此时 <strong>用户线程</strong> 仍然处于 <strong>等待状态</strong>。</p><h4 id="4-2-并发（Concurrent）"><a href="#4-2-并发（Concurrent）" class="headerlink" title="4.2. 并发（Concurrent）"></a>4.2. 并发（Concurrent）</h4><p>这里的并发指 <strong>用户线程</strong> 与 <strong>垃圾回收线程</strong> 交替执行。</p><h4 id="4-3-并行（Parallel）"><a href="#4-3-并行（Parallel）" class="headerlink" title="4.3. 并行（Parallel）"></a>4.3. 并行（Parallel）</h4><p>这里的并行指 <strong>用户线程</strong> 和多条 <strong>垃圾回收线程</strong> 分别在不同 <code>CPU</code> 上同时工作。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-根搜索算法"><a href="#1-根搜索算法" class="headerlink" title="1. 根搜索算法"></a>1. 根搜索算法</h3><p><strong>根搜索算法</strong> 是从 <strong>离散数学</strong> 中的图论引入的，程序把所有引用关系看作一张图，从一个节点 <code>GC ROOT</code> 开始，寻找对应的 <strong>引用节点</strong>，找到这个节点后，继续寻找 <strong>这个节点</strong> 的 <strong>引用节点</strong>。当所有的引用节点寻找完毕后，<strong>剩余的节点</strong> 则被认为是 <strong>没有被引用到</strong> 的节点，即 <strong>无用</strong> 的节点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b876b28f6?w=720&amp;h=281&amp;f=jpeg&amp;s=24288" alt=""></p><p>上图 <strong>红色</strong> 为无用的节点，可以被 <strong>回收</strong>。目前 <code>Java</code> 中可以作为 <code>GC ROOT</code> 的对象有：</p><ol><li><p><strong>虚拟机栈</strong> 中引用的对象（本地变量表）；</p></li><li><p><strong>方法区</strong> 中 <strong>静态变量</strong> 引用的对象；</p></li><li><p><strong>方法区</strong> 中 <strong>常量</strong> 引用的对象；</p></li><li><p><strong>本地方法栈</strong> 中引用的对象（<code>Native</code> 对象）。</p></li></ol><blockquote><p>基本所有 <code>GC</code> 算法都引用 <strong>根搜索算法</strong> 这种概念。</p></blockquote><h3 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记 - 清除算法"></a>2. 标记 - 清除算法</h3><p><strong>标记-清除算法</strong> 从 <strong>根集合</strong> 进行扫描，对 <strong>存活的对象</strong> 进行 <strong>标记</strong>。标记完毕后，再扫描整个空间中 <strong>未被标记</strong> 的对象进行 <strong>直接回收</strong>，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b87f0e86b?w=720&amp;h=457&amp;f=jpeg&amp;s=40109" alt=""></p><p><strong>标记-清除算法</strong> 不需要进行 <strong>对象的移动</strong>，并且仅对 <strong>不存活</strong> 的对象进行处理，在 <strong>存活</strong> 的对象 <strong>比较多</strong> 的情况下 <strong>极为高效</strong>。但由于 <strong>标记-清除算法</strong> 直接回收不存活的对象，并没有对还存活的对象进行 <strong>整理</strong>，因此会导致 <strong>内存碎片</strong>。</p><h3 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3. 复制算法"></a>3. 复制算法</h3><p><strong>复制算法</strong> 将内存划分为 <strong>两个区间</strong>，使用此算法时，所有 <strong>动态分配</strong> 的对象都只能分配在 <strong>其中一个</strong> 区间（<strong>活动区间</strong>），而 <strong>另外一个</strong> 区间（<strong>空间区间</strong>）则是 <strong>空闲</strong> 的。</p><p><strong>复制算法</strong> 同样从 <strong>根集合</strong> 扫描，将 <strong>存活</strong> 的对象 <strong>复制</strong> 到 <strong>空闲区间</strong>。当扫描完毕活动区间后，会的将 <strong>活动区间</strong> 一次性全部 <strong>回收</strong>。此时原本的 <strong>空闲区间</strong> 变成了 <strong>活动区间</strong>。下次 <code>GC</code> 时候又会重复刚才的操作，以此循环。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b885c24bf?w=720&amp;h=379&amp;f=jpeg&amp;s=31098" alt=""></p><p><strong>复制算法</strong> 在存活对象 <strong>比较少</strong> 的时候，极为高效，但是带来的成本是 <strong>牺牲一半的内存空间</strong> 用于进行 <strong>对象的移动</strong>。所以 <strong>复制算法</strong> 的使用场景，必须是对象的 <strong>存活率非常低</strong> 才行。最重要的是，我们需要克服 <code>50%</code> 的 <strong>内存浪费</strong>。</p><h3 id="4-标记-整理算法"><a href="#4-标记-整理算法" class="headerlink" title="4. 标记 - 整理算法"></a>4. 标记 - 整理算法</h3><p><strong>标记-整理算法</strong> 采用 <strong>标记-清除算法</strong> 一样的方式进行对象的 <strong>标记</strong>，但在回收 <strong>不存活的对象</strong> 占用的空间后，会将所有 <strong>存活的对象</strong> 往 左端空闲空间 <strong>移动</strong>，并更新对应的指针。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb0960af8?w=720&amp;h=539&amp;f=jpeg&amp;s=53137" alt=""></p><p><strong>标记-整理</strong> 是在 <strong>标记-清除</strong> 之上，又进行了 <strong>对象的移动排序整理</strong>，因此 <strong>成本更高</strong>，但却解决了 <strong>内存碎片</strong> 的问题。</p><blockquote><p><code>JVM</code> 为了 <strong>优化内存</strong> 的回收，使用了 <strong>分代回收</strong> 的方式。对于 <strong>新生代内存</strong> 的回收（<code>Minor GC</code>）主要采用 <strong>复制算法</strong>。而对于 <strong>老年代内存</strong> 的回收（<code>Major GC</code>），大多采用 <strong>标记-整理算法</strong>。</p></blockquote><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="1-垃圾回收器分类标准"><a href="#1-垃圾回收器分类标准" class="headerlink" title="1. 垃圾回收器分类标准"></a>1. 垃圾回收器分类标准</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b8a61ea51?w=720&amp;h=299&amp;f=jpeg&amp;s=34991" alt=""></p><h3 id="2-七种垃圾回收器概述"><a href="#2-七种垃圾回收器概述" class="headerlink" title="2. 七种垃圾回收器概述"></a>2. 七种垃圾回收器概述</h3><p>在 <code>JVM</code> 中，具体实现有 <code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>CMS</code>、<code>Serial Old（MSC）</code>、<code>Parallel Old</code>、<code>G1</code> 等。在下图中，你可以看到 <strong>不同垃圾回收器</strong> 适合于 <strong>不同的内存区域</strong>，如果两个垃圾回收器之间 <strong>存在连线</strong>，那么表示两者可以 <strong>配合使用</strong>。</p><p>如果当 <strong>垃圾回收器</strong> 进行垃圾清理时，必须 <strong>暂停</strong> 其他所有的 <strong>工作线程</strong>，直到它完全收集结束。我们称这种需要暂停工作线程才能进行清理的策略为 <code>Stop-the-World</code>。以上回收器中，   <code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Serial Old</code>、<code>Parallel Old</code> 均采用的是 <code>Stop-the-World</code> 的策略。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bd1ebf8c4?w=547&amp;h=374&amp;f=jpeg&amp;s=19750" alt=""></p><p>图中有 <code>7</code> 种不同的 <strong>垃圾回收器</strong>，它们分别用于不同分代的垃圾回收。</p><ul><li><p><strong>新生代回收器</strong>：Serial、ParNew、Parallel Scavenge</p></li><li><p><strong>老年代回收器</strong>：Serial Old、Parallel Old、CMS</p></li><li><p><strong>整堆回收器</strong>：G1</p></li></ul><p>两个 <strong>垃圾回收器</strong> 之间有连线表示它们可以 <strong>搭配使用</strong>，可选的搭配方案如下：</p><table><thead><tr><th style="text-align:left">新生代</th><th style="text-align:left">老年代</th></tr></thead><tbody><tr><td style="text-align:left">Serial</td><td style="text-align:left">Serial Old</td></tr><tr><td style="text-align:left">Serial</td><td style="text-align:left">CMS</td></tr><tr><td style="text-align:left">ParNew</td><td style="text-align:left">Serial Old</td></tr><tr><td style="text-align:left">ParNew</td><td style="text-align:left">CMS</td></tr><tr><td style="text-align:left">Parallel Scavenge</td><td style="text-align:left">Serial Old</td></tr><tr><td style="text-align:left">Parallel Scavenge</td><td style="text-align:left">Parallel Old</td></tr><tr><td style="text-align:left">G1</td><td style="text-align:left">G1</td></tr></tbody></table><h3 id="3-单线程垃圾回收器"><a href="#3-单线程垃圾回收器" class="headerlink" title="3. 单线程垃圾回收器"></a>3. 单线程垃圾回收器</h3><h4 id="3-1-Serial（-XX-UseSerialGC）"><a href="#3-1-Serial（-XX-UseSerialGC）" class="headerlink" title="3.1. Serial（-XX:+UseSerialGC）"></a>3.1. Serial（-XX:+UseSerialGC）</h4><p><code>Serial</code> 回收器是最基本的 <strong>新生代</strong> 垃圾回收器，是 <strong>单线程</strong> 的垃圾回收器。由于垃圾清理时，<code>Serial</code> <strong>回收器</strong> 不存在 <strong>线程间的切换</strong>，因此，特别是在单 <code>CPU</code> 的环境下，它的 <strong>垃圾清除效率</strong> 比较高。对于 <code>Client</code> 运行模式的程序，选择 <code>Serial</code> 回收器是一个不错的选择。</p><p><code>Serial</code> <strong>新生代回收器</strong> 采用的是 <strong>复制算法</strong>。</p><h4 id="3-2-Serial-Old（-XX-UseSerialGC）"><a href="#3-2-Serial-Old（-XX-UseSerialGC）" class="headerlink" title="3.2. Serial Old（-XX:+UseSerialGC）"></a>3.2. Serial Old（-XX:+UseSerialGC）</h4><p><code>Serial Old</code> 回收器是 <code>Serial</code> 回收器的 <strong>老生代版本</strong>，属于 <strong>单线程回收器</strong>，它使用 <strong>标记-整理</strong> 算法。对于 <code>Server</code> 模式下的虚拟机，在 <code>JDK1.5</code> 及其以前，它常与 <code>Parallel Scavenge</code> 回收器配合使用，达到较好的 <strong>吞吐量</strong>，另外它也是 <code>CMS</code> 回收器在 <code>Concurrent Mode Failure</code> 时的 <strong>后备方案</strong>。</p><p><code>Serial</code> 回收器和 <code>Serial Old</code> 回收器的执行效果如下：</p><blockquote><p><code>Serial Old</code> <strong>老年代回收器</strong> 采用的是 <strong>标记 - 整理算法</strong>。</p></blockquote><h3 id="4-多线程垃圾回收器（吞吐量优先）"><a href="#4-多线程垃圾回收器（吞吐量优先）" class="headerlink" title="4. 多线程垃圾回收器（吞吐量优先）"></a>4. 多线程垃圾回收器（吞吐量优先）</h3><h4 id="4-1-ParNew（-XX-UseParNewGC）"><a href="#4-1-ParNew（-XX-UseParNewGC）" class="headerlink" title="4.1. ParNew（-XX:+UseParNewGC）"></a>4.1. ParNew（-XX:+UseParNewGC）</h4><p><code>ParNew</code> 回收器是在 <code>Serial</code> 回收器的基础上演化而来的，属于 <code>Serial</code> 回收器的 <strong>多线程版本</strong>，同样运行在 <strong>新生代区域</strong>。在实现上，两者共用很多代码。在不同运行环境下，根据 <code>CPU</code> 核数，开启 <strong>不同的线程数</strong>，从而达到 <strong>最优</strong> 的垃圾回收效果。对于那些 <code>Server</code> 模式的应用程序，如果考虑采用 <code>CMS</code> 作为 <strong>老生代回收器</strong> 时，<code>ParNew</code> 回收器是一个不错的选择。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b88cda952?w=952&amp;h=343&amp;f=png&amp;s=36670" alt=""></p><blockquote><p><code>ParNew</code> <strong>新生代回收器</strong> 采用的是 <strong>复制算法</strong>。</p></blockquote><h4 id="4-2-Parallel-Scavenge（-XX-UseParallelGC）"><a href="#4-2-Parallel-Scavenge（-XX-UseParallelGC）" class="headerlink" title="4.2. Parallel Scavenge（-XX:+UseParallelGC）"></a>4.2. Parallel Scavenge（-XX:+UseParallelGC）</h4><p>和 <code>ParNew</code> 回收一样，<code>Parallel Scavenge</code> 回收器也是运行在 <strong>新生代区域</strong>，属于 <strong>多线程</strong> 的回收器。但不同的是，<code>ParNew</code> 回收器是通过控制 <strong>垃圾回收</strong> 的 <strong>线程数</strong> 来进行参数调整，而 <code>Parallel Scavenge</code> 回收器更关心的是 <strong>程序运行的吞吐量</strong>。即一段时间内，<strong>用户代码</strong> 运行时间占 <strong>总运行时间</strong> 的百分比。</p><blockquote><p><code>Parallel Scavenge</code> <strong>新生代回收器</strong> 采用的是 <strong>复制算法</strong>。</p></blockquote><h4 id="4-3-Parallel-Old（-XX-UseParallelOldGC）"><a href="#4-3-Parallel-Old（-XX-UseParallelOldGC）" class="headerlink" title="4.3. Parallel Old（-XX:+UseParallelOldGC）"></a>4.3. Parallel Old（-XX:+UseParallelOldGC）</h4><p><code>Parallel Old</code> 回收器是 <code>Parallel Scavenge</code> 回收器的 <strong>老生代版本</strong>，属于 <strong>多线程回收器</strong>，采用 <strong>标记-整理算法</strong>。<code>Parallel Old</code> 回收器和 <code>Parallel Scavenge</code> 回收器同样考虑了 <strong>吞吐量优先</strong> 这一指标，非常适合那些 <strong>注重吞吐量</strong> 和 <code>CPU</code> <strong>资源敏感</strong> 的场合。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b8a60fa35?w=958&amp;h=337&amp;f=png&amp;s=30557" alt=""></p><blockquote><p><code>Parallel Old</code> <strong>老年代回收器</strong> 采用的是 <strong>标记 - 整理算法</strong>。</p></blockquote><h3 id="5-其他的回收器（停顿时间优先）"><a href="#5-其他的回收器（停顿时间优先）" class="headerlink" title="5. 其他的回收器（停顿时间优先）"></a>5. 其他的回收器（停顿时间优先）</h3><h4 id="5-1-CMS（-XX-UseConcMarkSweepGC）"><a href="#5-1-CMS（-XX-UseConcMarkSweepGC）" class="headerlink" title="5.1. CMS（-XX:+UseConcMarkSweepGC）"></a>5.1. CMS（-XX:+UseConcMarkSweepGC）</h4><p><code>CMS（Concurrent Mark Sweep）</code> 回收器是在 <strong>最短回收停顿时间</strong> 为前提的回收器，属于 <strong>多线程回收器</strong>，采用 <strong>标记-清除算法</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb00da43d?w=1038&amp;h=337&amp;f=png&amp;s=38094" alt=""></p><p>相比之前的回收器，<code>CMS</code> 回收器的运作过程比较复杂，分为四步：</p><ol><li><strong>初始标记（CMS initial mark）</strong></li></ol><p><strong>初始标记</strong> 仅仅是标记 <code>GC Roots</code> 内 <strong>直接关联</strong> 的对象。这个阶段 <strong>速度很快</strong>，需要 <code>Stop the World</code>。</p><ol start="2"><li><strong>并发标记（CMS concurrent mark）</strong></li></ol><p><strong>并发标记</strong> 进行的是 <code>GC Tracing</code>，从 <code>GC Roots</code> 开始对堆进行 <strong>可达性分析</strong>，找出 <strong>存活对象</strong>。</p><ol start="3"><li><strong>重新标记（CMS remark）</strong></li></ol><p><strong>重新标记</strong> 阶段为了 <strong>修正</strong> 并发期间由于 <strong>用户进行运作</strong> 导致的 <strong>标记变动</strong> 的那一部分对象的 <strong>标记记录</strong>。这个阶段的 <strong>停顿时间</strong> 一般会比 <strong>初始标记阶段</strong> 稍长一些，但远比 <strong>并发标记</strong> 的时间短，也需要 <code>Stop The World</code>。</p><ol start="4"><li><strong>并发清除（CMS concurrent sweep）</strong></li></ol><p><strong>并发清除</strong> 阶段会清除垃圾对象。</p><blockquote><p><strong>初始标记</strong>（<code>CMS initial mark</code>）和 <strong>重新标记</strong>（<code>CMS remark</code>）会导致 <strong>用户线程</strong> 卡顿，<code>Stop the World</code> 现象发生。</p></blockquote><p>在整个过程中，<code>CMS</code> 回收器的 <strong>内存回收</strong> 基本上和 <strong>用户线程</strong> 并发执行，如下所示：</p><p>由于 <code>CMS</code> 回收器 <strong>并发收集</strong>、<strong>停顿低</strong>，因此有些地方成为 <strong>并发低停顿回收器</strong>（<code>Concurrent Low Pause Sweep Collector</code>）。</p><p><code>CMS</code> 回收器的缺点：</p><ol><li><strong>CMS回收器对CPU资源非常依赖</strong></li></ol><p><code>CMS</code> 回收器过分依赖于 <strong>多线程环境</strong>，默认情况下，开启的 <strong>线程数</strong> 为<code>（CPU 的数量 + 3）/ 4</code>，当 <code>CPU</code> 数量少于 <code>4</code> 个时，<code>CMS</code> 对 <strong>用户查询</strong> 的影响将会很大，因为他们要分出一半的运算能力去 <strong>执行回收器线程</strong>；</p><ol start="2"><li><strong>CMS回收器无法清除浮动垃圾</strong></li></ol><p>由于 <code>CMS</code> 回收器 <strong>清除已标记的垃圾</strong> （处于最后一个阶段）时，<strong>用户线程</strong> 还在运行，因此会有新的垃圾产生。但是这部分垃圾 <strong>未被标记</strong>，在下一次 <code>GC</code> 才能清除，因此被成为 <strong>浮动垃圾</strong>。</p><p>由于 <strong>内存回收</strong> 和 <strong>用户线程</strong> 是同时进行的，内存在被 <strong>回收</strong> 的同时，也在被 <strong>分配</strong>。当 <strong>老生代</strong> 中的内存使用超过一定的比例时，系统将会进行 <strong>垃圾回收</strong>；当 <strong>剩余内存</strong> 不能满足程序运行要求时，系统将会出现 <code>Concurrent Mode Failure</code>，临时采用 <code>Serial Old</code> 算法进行 <strong>清除</strong>，此时的 <strong>性能</strong> 将会降低。</p><ol start="3"><li><strong>垃圾收集结束后残余大量空间碎片</strong></li></ol><p><code>CMS</code> 回收器采用的 <strong>标记清除算法</strong>，本身存在垃圾收集结束后残余 <strong>大量空间碎片</strong> 的缺点。<code>CMS</code> 配合适当的 <strong>内存整理策略</strong>，在一定程度上可以解决这个问题。</p><h4 id="5-2-G1回收器（垃圾区域Region优先）"><a href="#5-2-G1回收器（垃圾区域Region优先）" class="headerlink" title="5.2. G1回收器（垃圾区域Region优先）"></a>5.2. G1回收器（垃圾区域Region优先）</h4><p><code>G1</code> 是 <code>JDK 1.7</code> 中正式投入使用的用于取代 <code>CMS</code> 的 <strong>压缩回收器</strong>。它虽然没有在物理上隔断 <strong>新生代</strong> 与 <strong>老生代</strong>，但是仍然属于 <strong>分代垃圾回收器</strong>。<code>G1</code> 仍然会区分 <strong>年轻代</strong> 与 <strong>老年代</strong>，年轻代依然分有 <code>Eden</code> 区与 <code>Survivor</code> 区。</p><p><code>G1</code> 首先将 <strong>堆</strong> 分为 <strong>大小相等</strong> 的  <code>Region</code>，避免 <strong>全区域</strong> 的垃圾回收。然后追踪每个 <code>Region</code> 垃圾 <strong>堆积的价值大小</strong>，在后台维护一个 <strong>优先列表</strong>，根据允许的回收时间优先回收价值最大的 <code>Region</code>。同时 <code>G1</code>采用 <code>Remembered Set</code> 来存放 <code>Region</code> 之间的 <strong>对象引用</strong> ，其他回收器中的 <strong>新生代</strong> 与 <strong>老年代</strong> 之间的对象引用，从而避免 <strong>全堆扫描</strong>。<code>G1</code> 的分区示例如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb5454a60?w=678&amp;h=380&amp;f=jpeg&amp;s=29106" alt=""></p><p>这种使用 <code>Region</code> 划分 <strong>内存空间</strong> 以及有 <strong>优先级</strong> 的区域回收方式，保证 <code>G1</code> 回收器在有限的时间内可以获得尽可能 <strong>高的回收效率</strong>。</p><p><code>G1</code> 和 <code>CMS</code> 运作过程有很多相似之处，整个过程也分为 <code>4</code> 个步骤：</p><ol><li><strong>初始标记（CMS initial mark）</strong></li></ol><p><strong>初始标记</strong> 仅仅是标记 <code>GC Roots</code> 内 <strong>直接关联</strong> 的对象。这个阶段 <strong>速度很快</strong>，需要 <code>Stop the World</code>。</p><ol start="2"><li><strong>并发标记（CMS concurrent mark）</strong></li></ol><p><strong>并发标记</strong> 进行的是 <code>GC Tracing</code>，从 <code>GC Roots</code> 开始对堆进行 <strong>可达性分析</strong>，找出 <strong>存活对象</strong>。</p><ol start="3"><li><strong>重新标记（CMS remark）</strong></li></ol><p><strong>重新标记</strong> 阶段为了 <strong>修正</strong> 并发期间由于 <strong>用户进行运作</strong> 导致的 <strong>标记变动</strong> 的那一部分对象的 <strong>标记记录</strong>。这个阶段的 <strong>停顿时间</strong> 一般会比 <strong>初始标记阶段</strong> 稍长一些，但远比 <strong>并发标记</strong> 的时间短，也需要 <code>Stop The World</code>。</p><ol start="4"><li><strong>筛选回收</strong></li></ol><p>首先对各个 <code>Region</code> 的 <strong>回收价值</strong> 和 <strong>成本</strong> 进行排序，根据用户所期望的 <code>GC</code> <strong>停顿时间</strong> 来制定回收计划。这个阶段可以与用户程序一起 <strong>并发执行</strong>，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿 <strong>用户线程</strong> 将大幅提高回收效率。</p><blockquote><p>与其它 <code>GC</code> 回收相比，<code>G1</code> 具备如下 <code>4</code> 个特点：</p></blockquote><ul><li><strong>并行与并发</strong></li></ul><p>使用多个 <code>CPU</code> 来缩短 <code>Stop-the-World</code> 的 <strong>停顿时间</strong>，部分其他回收器需要停顿 <code>Java</code> 线程执行的 <code>GC</code> 动作，<code>G1</code> 回收器仍然可以通过 <strong>并发的方式</strong> 让 <code>Java</code> 程序继续执行。</p><ul><li><strong>分代回收</strong></li></ul><p>与其他回收器一样，<strong>分代概念</strong> 在 <code>G1</code> 中依然得以保留。虽然 <code>G1</code> 可以不需要 <strong>其他回收器配合</strong> 就能独立管理 <strong>整个GC堆</strong>，但它能够采用 <strong>不同的策略</strong> 去处理 <strong>新创建的对象</strong> 和 <strong>已经存活</strong> 一段时间、<strong>熬过多次</strong> <code>GC</code> 的旧对象，以获取更好的回收效果。<strong>新生代</strong> 和 <strong>老年代</strong> 不再是 <strong>物理隔离</strong>，是多个 <strong>大小相等</strong> 的独立 <code>Region</code>。</p><ul><li><strong>空间整合</strong></li></ul><p>与 <code>CMS</code> 的 <strong>标记—清理</strong> 算法不同，<code>G1</code> 从 <strong>整体</strong> 来看是基于 <strong>标记—整理</strong> 算法实现的回收器。从 <strong>局部</strong>（两个 <code>Region</code> 之间）上来看是基于 <strong>复制算法</strong> 实现的。</p><p>但无论如何，这 <strong>两种算法</strong> 都意味着 <code>G1</code> 运作期间 <strong>不会产生内存空间碎片</strong>，回收后能提供规整的可用内存。这种特性有利于程序长时间运行，<strong>分配大对象</strong> 时不会因为无法找到 <strong>连续内存空间</strong> 而提前触发 <strong>下一次</strong> <code>GC</code>。</p><ul><li><strong>可预测的停顿</strong></li></ul><p>这是 <code>G1</code> 相对于 <code>CMS</code> 的另一大优势，<strong>降低停顿时间</strong> 是 <code>G1</code> 和 <code>CMS</code> 共同的关注点。<code>G1</code> 除了追求 <strong>低停顿</strong> 外，还能建立 <strong>可预测</strong> 的 <strong>停顿时间模型</strong>，能让使用者明确指定在一个 <strong>长度</strong> 为 <code>M</code> 毫秒的 <strong>时间片段</strong> 内，消耗在 <strong>垃圾回收</strong> 上的时间不得超过 <code>N</code> 毫秒。（后台维护的 <strong>优先列表</strong>，优先回收 <strong>价值大</strong> 的 <code>Region</code>）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社</p><hr><p>欢迎关注技术公众号：零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bd1fd0856?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在之前的几篇博客中，我们大致介绍了，常见的 &lt;strong&gt;垃圾回收算法&lt;/strong&gt; 及 &lt;code&gt;JVM&lt;/code&gt; 中常见的分类回收算法。这些都是从算法和规范上分析 &lt;code&gt;Java&lt;/code&gt; 中的垃圾回收，属于方法论。在 &lt;code&gt;JVM&lt;/code&gt; 中，垃圾回收的具体实现是由 &lt;strong&gt;垃圾回收器&lt;/strong&gt;（&lt;code&gt;Garbage Collector&lt;/code&gt;）负责。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA虚拟机系列" scheme="https://ostenant.coding.me/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JVM" scheme="https://ostenant.coding.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Nginx服务器的内部核心架构设计</title>
    <link href="https://ostenant.coding.me/2018/07/15/%E6%B5%85%E8%B0%88Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://ostenant.coding.me/2018/07/15/浅谈Nginx服务器的内部核心架构设计/</id>
    <published>2018-07-15T10:50:00.000Z</published>
    <updated>2018-07-15T23:47:46.842Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Nginx</code> 是一个 <strong>免费的</strong>，<strong>开源的</strong>，<strong>高性能</strong> 的 <code>HTTP</code> 服务器和 <strong>反向代理</strong>，以及 <code>IMAP</code>/<code>POP3</code> 代理服务器。 <code>Nginx</code> 以其高性能，稳定性，丰富的功能，简单的配置和低资源消耗而闻名。<code>Nginx</code>是一个 <code>Web</code> 服务器，也可以用作 <strong>反向代理</strong>，<strong>负载均衡器</strong> 和 <code>HTTP</code> <strong>缓存</strong>。</p><a id="more"></a><p>很多高知名度的网站都使用 <code>Nginx</code>，如：<code>Netflix</code>，<code>GitHub</code>，<code>SoundCloud</code>，<code>MaxCDN</code> 等。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bd16fbfc9?w=626&amp;h=144&amp;f=png&amp;s=32239" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-Nginx的整体架构"><a href="#1-Nginx的整体架构" class="headerlink" title="1. Nginx的整体架构"></a>1. Nginx的整体架构</h2><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bce75a47b?w=944&amp;h=587&amp;f=png&amp;s=128919" alt=""></p><h3 id="1-1-主进程"><a href="#1-1-主进程" class="headerlink" title="1.1. 主进程"></a>1.1. 主进程</h3><p><code>Nginx</code> 启动时，会生成两种类型的 <strong>进程*</strong>，一个是 <strong>主进程</strong>（<code>master</code>），<strong>一个</strong>（<code>windows</code> 版本的目前只有一个）或 <strong>多个工作进程</strong>（<code>worker</code>）。<strong>主进程</strong> 并不处理网络请求，主要负责 <strong>调度工作进程</strong>，也就是图示的 <code>3</code> 项：<strong>加载配置</strong>、<strong>启动工作进程</strong> 及 <strong>非停升级</strong>。所以，<code>Nginx</code> 启动以后，查看操作系统的进程列表，我们就能看到 <strong>至少有两个</strong> <code>Nginx</code> 进程。</p><h3 id="1-2-工作进程"><a href="#1-2-工作进程" class="headerlink" title="1.2. 工作进程"></a>1.2. 工作进程</h3><p>服务器实际 <strong>处理网络请求</strong> 及 <strong>响应</strong> 的是 <strong>工作进程</strong>（<code>worker</code>），在类 <code>unix</code> 系统上，<code>Nginx</code> 可以配置 <strong>多个</strong> <code>worker</code>，而每个 <code>worker</code> <strong>进程</strong> 都可以同时处理 <strong>数以千计</strong> 的 <strong>网络请求</strong>。</p><h3 id="1-3-模块化设计"><a href="#1-3-模块化设计" class="headerlink" title="1.3. 模块化设计"></a>1.3. 模块化设计</h3><p><code>Nginx</code> 的 <code>worker</code> 进程，包括 <strong>核心</strong> 和 <strong>功能性模块</strong>，<strong>核心模块</strong> 负责维持一个 <strong>运行循环</strong>（<code>run-loop</code>），执行网络请求处理的 <strong>不同阶段</strong> 的模块功能，比如：<strong>网络读写</strong>、<strong>存储读写</strong>、<strong>内容传输</strong>、<strong>外出过滤</strong>，以及 <strong>将请求发往上游服务器</strong> 等。而其代码的 <strong>模块化设计</strong>，也使得我们可以根据需要对 <strong>功能模块</strong> 进行适当的 <strong>选择</strong> 和 <strong>修改</strong>，编译成具有 <strong>特定功能</strong> 的服务器。</p><h3 id="1-4-事件驱动模型"><a href="#1-4-事件驱动模型" class="headerlink" title="1.4. 事件驱动模型"></a>1.4. 事件驱动模型</h3><p>基于 <strong>异步及非阻塞</strong> 的 <strong>事件驱动模型</strong>，可以说是 <code>Nginx</code> 得以获得 <strong>高并发</strong>、<strong>高性能</strong> 的关键因素，同时也得益于对 <code>Linux</code>、<code>Solaris</code> 及类 <code>BSD</code> 等操作系统内核中 <strong>事件通知</strong> 及 <code>I/O</code> <strong>性能增强功能</strong> 的采用，如 <code>kqueue</code>、<code>epoll</code> 及 <code>event ports</code>。</p><h3 id="1-5-代理（proxy）设计"><a href="#1-5-代理（proxy）设计" class="headerlink" title="1.5. 代理（proxy）设计"></a>1.5. 代理（proxy）设计</h3><p><strong>代理设计</strong>，可以说是 <code>Nginx</code> 深入骨髓的设计，无论是对于 <code>HTTP</code>，还是对于 <code>FastCGI</code>、<code>Memcache</code>、<code>Redis</code> 等的网络请求或响应，本质上都采用了 <strong>代理机制</strong>。所以，<code>Nginx</code> 天生就是高性能的 <strong>代理服务器</strong>。</p><h2 id="2-Nginx的模块化设计"><a href="#2-Nginx的模块化设计" class="headerlink" title="2. Nginx的模块化设计"></a>2. Nginx的模块化设计</h2><p><strong>高度模块化</strong> 的设计是 <code>Nginx</code> 的架构基础。<code>Nginx</code> 服务器被分解为 <strong>多个模块</strong>，每个模块就是一个 <strong>功能模块</strong>，只负责自身的功能，模块之间严格遵循 <strong>“高内聚，低耦合”</strong> 的原则。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bd21be9ae?w=640&amp;h=479&amp;f=webp&amp;s=19204" alt=""></p><h3 id="2-1-核心模块"><a href="#2-1-核心模块" class="headerlink" title="2.1. 核心模块"></a>2.1. 核心模块</h3><p><strong>核心模块</strong> 是 <code>Nginx</code> 服务器正常运行 <strong>必不可少</strong> 的模块，提供 <strong>错误日志记录</strong>、<strong>配置文件解析</strong>、<strong>事件驱动机制</strong>、<strong>进程管理</strong> 等核心功能。 </p><h3 id="2-2-标准HTTP模块"><a href="#2-2-标准HTTP模块" class="headerlink" title="2.2. 标准HTTP模块"></a>2.2. 标准HTTP模块</h3><p>标准 <code>HTTP</code> 模块提供 <code>HTTP</code> 协议解析相关的功能，比如：<strong>端口配置</strong>、<strong>网页编码设置</strong>、<code>HTTP</code> <strong>响应头设置</strong> 等等。</p><h3 id="2-3-可选HTTP模块"><a href="#2-3-可选HTTP模块" class="headerlink" title="2.3. 可选HTTP模块"></a>2.3. 可选HTTP模块</h3><p>可选 <code>HTTP</code> 模块主要用于 <strong>扩展</strong> 标准的 <code>HTTP</code> 功能，让  <code>Nginx</code> 能处理一些特殊的服务，比如：<code>Flash</code> <strong>多媒体传输</strong>、解析 <code>GeoIP</code> 请求、<strong>网络传输压缩</strong>、<strong>安全协议</strong> <code>SSL</code> 支持等。</p><h3 id="2-4-邮件服务模块"><a href="#2-4-邮件服务模块" class="headerlink" title="2.4. 邮件服务模块"></a>2.4. 邮件服务模块</h3><p><strong>邮件服务模块</strong> 主要用于支持 <code>Nginx</code> 的 <strong>邮件服务</strong>，包括对 <code>POP3</code> 协议、<code>IMAP</code> 协议和 <code>SMTP</code> 协议的支持。</p><h3 id="2-5-第三方模块"><a href="#2-5-第三方模块" class="headerlink" title="2.5. 第三方模块"></a>2.5. 第三方模块</h3><p><strong>第三方模块</strong> 是为了扩展 <code>Nginx</code> 服务器应用，完成开发者自定义功能，比如：<code>Json</code> 支持、<code>Lua</code> 支持等。</p><h2 id="3-Nginx的请求方式处理"><a href="#3-Nginx的请求方式处理" class="headerlink" title="3. Nginx的请求方式处理"></a>3. Nginx的请求方式处理</h2><p><code>Nginx</code> 是一个 <strong>高性能</strong> 的 <code>Web</code> 服务器，能够同时处理 <strong>大量的并发请求</strong>。它结合 <strong>多进程机制</strong> 和 <strong>异步机制</strong>，异步机制使用的是 <strong>异步非阻塞方式</strong>，接下来就给大家介绍一下  <code>Nginx</code> 的 <strong>多线程机制</strong> 和 <strong>异步非阻塞机制</strong>。 </p><h3 id="3-1-多进程机制"><a href="#3-1-多进程机制" class="headerlink" title="3.1. 多进程机制"></a>3.1. 多进程机制</h3><p>服务器每当收到一个客户端时，就有 <strong>服务器主进程</strong>（<code>master process</code>）生成一个 <strong>子进程</strong>（<code>worker  process</code>）出来和客户端建立连接进行交互，直到连接断开，该子进程就结束了。</p><p>使用 <strong>进程</strong> 的好处是 <strong>各个进程之间相互独立</strong>，<strong>不需要加锁</strong>，减少了使用锁对性能造成影响，同时降低编程的复杂度，降低开发成本。其次，采用独立的进程，可以让 <strong>进程互相之间不会影响</strong>，如果一个进程发生异常退出时，其它进程正常工作，<code>master</code> 进程则很快启动新的 <code>worker</code> 进程，确保服务不会中断，从而将风险降到最低。</p><p>缺点是操作系统生成一个 <strong>子进程</strong> 需要进行 <strong>内存复制</strong> 等操作，在 <strong>资源</strong> 和 <strong>时间</strong> 上会产生一定的开销。当有 <strong>大量请求</strong> 时，会导致 <strong>系统性能下降</strong>。</p><h3 id="3-2-异步非阻塞机制"><a href="#3-2-异步非阻塞机制" class="headerlink" title="3.2. 异步非阻塞机制"></a>3.2. 异步非阻塞机制</h3><p>每个 <strong>工作进程</strong> 使用 <strong>异步非阻塞方式</strong>，可以处理 <strong>多个客户端请求</strong>。</p><p>当某个 <strong>工作进程</strong> 接收到客户端的请求以后，调用 <code>IO</code> 进行处理，如果不能立即得到结果，就去 <strong>处理其他请求</strong>（即为 <strong>非阻塞</strong>）；而 <strong>客户端</strong> 在此期间也 <strong>无需等待响应</strong>，可以去处理其他事情（即为 <strong>异步</strong>）。</p><p>当 <code>IO</code> 返回时，就会通知此 <strong>工作进程</strong>；该进程得到通知，暂时 <strong>挂起</strong> 当前处理的事务去 <strong>响应客户端请求</strong>。</p><h2 id="4-Nginx事件驱动模型"><a href="#4-Nginx事件驱动模型" class="headerlink" title="4. Nginx事件驱动模型"></a>4. Nginx事件驱动模型</h2><p>在 <code>Nginx</code> 的 <strong>异步非阻塞机制</strong> 中，<strong>工作进程</strong> 在调用 <code>IO</code> 后，就去处理其他的请求，当 <code>IO</code> 调用返回后，会 <strong>通知</strong> 该 <strong>工作进程</strong>。对于这样的系统调用，主要使用 <code>Nginx</code> 服务器的 <strong>事件驱动模型</strong> 来实现。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bd23976e0?w=604&amp;h=486&amp;f=webp&amp;s=8094" alt=""></p><p>如上图所示，<code>Nginx</code> 的 <strong>事件驱动模型</strong> 由 <strong>事件收集器</strong>、<strong>事件发送器</strong> 和 <strong>事件处理器</strong> 三部分基本单元组成。</p><ul><li><p>事件收集器：负责收集 <code>worker</code> 进程的各种 <code>IO</code> 请求；</p></li><li><p>事件发送器：负责将 <code>IO</code> 事件发送到 <strong>事件处理器</strong>；</p></li><li><p>事件处理器：负责各种事件的 <strong>响应工作</strong>。</p></li></ul><p><strong>事件发送器</strong> 将每个请求放入一个 <strong>待处理事件列表</strong>，使用非阻塞 <code>I/O</code> 方式调用 <strong>事件处理器</strong> 来处理该请求。其处理方式称为 <strong>“多路 IO 复用方法”</strong>，常见的包括以下三种：<code>select</code> 模型、<code>poll</code> 模型、<code>epoll</code> 模型。</p><h2 id="5-Nginx进程处理模型"><a href="#5-Nginx进程处理模型" class="headerlink" title="5. Nginx进程处理模型"></a>5. Nginx进程处理模型</h2><p><code>Nginx</code> 服务器使用 <code>master/worker</code> <strong>多进程模式</strong>。多线程启动和执行的流程如下：</p><ol><li><p><strong>主程序</strong> <code>Master process</code> 启动后，通过一个 <code>for</code> 循环来 <strong>接收</strong> 和 <strong>处理外部信号</strong>；</p></li><li><p><strong>主进程</strong> 通过 <code>fork()</code> 函数产生 <code>worker</code> <strong>子进程</strong>，每个 <strong>子进程</strong> 执行一个 <code>for</code> 循环来实现 <code>Nginx</code> 服务器 <strong>对事件的接收</strong> 和 <strong>处理</strong>。</p></li></ol><p>一般推荐 <code>worker</code> <strong>进程数</strong> 与 <code>CPU</code> <strong>内核数</strong> 一致，这样一来不存在 <strong>大量的子进程</strong> 生成和管理任务，避免了进程之间 <strong>竞争</strong> <code>CPU</code> <strong>资源</strong> 和 <strong>进程切换</strong> 的开销。而且  <code>Nginx</code> 为了更好的利用 <strong>多核特性</strong>，提供了 <code>CPU</code> <strong>亲缘性</strong> 的绑定选项，我们可以将某 <strong>一个进程绑定在某一个核</strong> 上，这样就不会因为 <strong>进程的切换</strong> 带来 <code>Cache</code> 的失效。</p><p>对于每个请求，有且只有一个 <strong>工作进程</strong> 对其处理。首先，每个 <code>worker</code> 进程都是从 <code>master</code> 进程 <code>fork</code> 过来。在  <code>master</code> 进程里面，先建立好需要 <code>listen</code> 的 <code>socket（listenfd）</code> 之后，然后再 <code>fork</code> 出多个 <code>worker</code> 进程。</p><p>所有 <code>worker</code> 进程的 <code>listenfd</code> 会在 <strong>新连接</strong> 到来时变得 <strong>可读</strong>，为保证只有一个进程处理该连接，所有 <code>worker</code> 进程在注册 <code>listenfd</code> <strong>读事件</strong> 前 <strong>抢占</strong> <code>accept_mutex</code>，抢到 <strong>互斥锁</strong> 的那个进程 <strong>注册</strong> <code>listenfd</code> <strong>读事件</strong>，在 <strong>读事件</strong> 里调用 <code>accept</code> 接受该连接。</p><p>当一个 <code>worker</code> 进程在 <code>accept</code> 这个连接之后，就开始 <strong>读取请求</strong>，<strong>解析请求</strong>，<strong>处理请求</strong>，产生数据后，再 <strong>返回给客户端</strong>，最后才 <strong>断开连接</strong>，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由 <code>worker</code> 进程来处理，而且只在一个 <code>worker</code> 进程中处理。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/16/164a050bd00922f3?w=640&amp;h=458&amp;f=webp&amp;s=9848" alt=""></p><p>在 <code>Nginx</code> 服务器的运行过程中，<strong>主进程</strong> 和 <strong>工作进程</strong> 需要进程交互。交互依赖于 <code>Socket</code> 实现的 <strong>管道</strong> 来实现。</p><h3 id="5-1-主进程与工作进程交互"><a href="#5-1-主进程与工作进程交互" class="headerlink" title="5.1. 主进程与工作进程交互"></a>5.1. 主进程与工作进程交互</h3><p>这条管道与普通的管道不同，它是由 <strong>主进程</strong> 指向 <strong>工作进程</strong> 的 <strong>单向管道</strong>，包含主进程向工作进程发出的 <strong>指令</strong>，<strong>工作进程</strong> <code>ID</code> 等；同时 <strong>主进程</strong> 与外界通过 <strong>信号通信</strong>；每个 <strong>子进程</strong> 具备 <strong>接收信号</strong>，并处理相应的事件的能力。</p><h3 id="5-2-工作进程与工作进程交互"><a href="#5-2-工作进程与工作进程交互" class="headerlink" title="5.2. 工作进程与工作进程交互"></a>5.2. 工作进程与工作进程交互</h3><p>这种交互是和 <strong>主进程-工作进程</strong> 交互是基本一致的，但是会通过 <strong>主进程</strong> 间接完成。<strong>工作进程</strong> 之间是 <strong>相互隔离</strong> 的，所以当工作进程 <code>W1</code> 需要向工作进程 <code>W2</code> 发指令时，首先找到 <code>W2</code> 的 <strong>进程</strong> <code>ID</code>，然后将正确的指令写入指向 <code>W2</code> 的 <strong>通道</strong>。<code>W2</code> 收到信号采取相应的措施。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过这篇文章，我们对 <code>Nginx</code> 服务器的 <strong>整体架构</strong> 有了一个整体的认识。包括其 <strong>模块化的设计</strong>、<strong>多进程</strong> 和 <strong>异步非阻塞</strong> 的请求处理方式、<strong>事件驱动模型</strong> 等。通过这些理论知识，才能更好地领悟  <code>Nginx</code> 的设计思想。对于我们学习 <code>Nginx</code> 来说有很大的帮助。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16494267ed546a0c?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Nginx&lt;/code&gt; 是一个 &lt;strong&gt;免费的&lt;/strong&gt;，&lt;strong&gt;开源的&lt;/strong&gt;，&lt;strong&gt;高性能&lt;/strong&gt; 的 &lt;code&gt;HTTP&lt;/code&gt; 服务器和 &lt;strong&gt;反向代理&lt;/strong&gt;，以及 &lt;code&gt;IMAP&lt;/code&gt;/&lt;code&gt;POP3&lt;/code&gt; 代理服务器。 &lt;code&gt;Nginx&lt;/code&gt; 以其高性能，稳定性，丰富的功能，简单的配置和低资源消耗而闻名。&lt;code&gt;Nginx&lt;/code&gt;是一个 &lt;code&gt;Web&lt;/code&gt; 服务器，也可以用作 &lt;strong&gt;反向代理&lt;/strong&gt;，&lt;strong&gt;负载均衡器&lt;/strong&gt; 和 &lt;code&gt;HTTP&lt;/code&gt; &lt;strong&gt;缓存&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="高并发系统系列" scheme="https://ostenant.coding.me/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Nginx" scheme="https://ostenant.coding.me/tags/Nginx/"/>
    
      <category term="服务器" scheme="https://ostenant.coding.me/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="反向代理" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="负载均衡" scheme="https://ostenant.coding.me/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="高性能" scheme="https://ostenant.coding.me/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>浅谈常见的七种加密算法及实现</title>
    <link href="https://ostenant.coding.me/2018/07/13/%E6%B5%85%E8%B0%88%08%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ostenant.coding.me/2018/07/13/浅谈常见的七种加密算法及实现/</id>
    <published>2018-07-13T12:06:00.000Z</published>
    <updated>2018-07-13T14:02:41.657Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>数字签名</strong>、<strong>信息加密</strong> 是前后端开发都经常需要使用到的技术，应用场景包括了用户登入、交易、信息通讯、<code>oauth</code> 等等，不同的应用场景也会需要使用到不同的签名加密算法，或者需要搭配不一样的 <strong>签名加密算法</strong> 来达到业务目标。这里简单的给大家介绍几种常见的签名加密算法和一些典型场景下的应用。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-数字签名"><a href="#1-数字签名" class="headerlink" title="1. 数字签名"></a>1. 数字签名</h2><p><strong>数字签名</strong>，简单来说就是通过提供 <strong>可鉴别</strong> 的 <strong>数字信息</strong> 验证 <strong>自身身份</strong> 的一种方式。一套 <strong>数字签名</strong> 通常定义两种 <strong>互补</strong> 的运算，一个用于 <strong>签名</strong>，另一个用于 <strong>验证</strong>。分别由 <strong>发送者</strong> 持有能够 <strong>代表自己身份</strong> 的 <strong>私钥</strong> (私钥不可泄露),由 <strong>接受者</strong> 持有与私钥对应的 <strong>公钥</strong> ，能够在 <strong>接受</strong> 到来自发送者信息时用于 <strong>验证</strong> 其身份。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa18df72?w=1024&amp;h=768&amp;f=png&amp;s=77151" alt=""></p><blockquote><p><strong>注意</strong>：图中 <strong>加密过程</strong> 有别于 <strong>公钥加密</strong>，更多 <a href="https://www.zhihu.com/question/25912483" target="_blank" rel="noopener">介绍戳这里</a>。<strong>签名</strong> 最根本的用途是要能够唯一 <strong>证明发送方的身份</strong>，防止 <strong>中间人攻击</strong>、<code>CSRF</code> <strong>跨域身份伪造</strong>。基于这一点在诸如 <strong>设备认证</strong>、<strong>用户认证</strong>、<strong>第三方认证</strong> 等认证体系中都会使用到 <strong>签名算法</strong> (彼此的实现方式可能会有差异)。</p></blockquote><h2 id="2-加密和解密"><a href="#2-加密和解密" class="headerlink" title="2. 加密和解密"></a>2. 加密和解密</h2><h3 id="2-1-加密"><a href="#2-1-加密" class="headerlink" title="2.1. 加密"></a>2.1. 加密</h3><p><strong>数据加密</strong> 的基本过程，就是对原来为 <strong>明文</strong> 的文件或数据按 <strong>某种算法</strong> 进行处理，使其成为 <strong>不可读</strong> 的一段代码，通常称为 <strong>“密文”</strong>。通过这样的途径，来达到 <strong>保护数据</strong> 不被 <strong>非法人窃取</strong>、阅读的目的。</p><h3 id="2-2-解密"><a href="#2-2-解密" class="headerlink" title="2.2. 解密"></a>2.2. 解密</h3><p><strong>加密</strong> 的 <strong>逆过程</strong> 为 <strong>解密</strong>，即将该 <strong>编码信息</strong> 转化为其 <strong>原来数据</strong> 的过程。</p><h2 id="3-对称加密和非对称加密"><a href="#3-对称加密和非对称加密" class="headerlink" title="3. 对称加密和非对称加密"></a>3. 对称加密和非对称加密</h2><p>加密算法分 <strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密 <strong>密钥相同</strong>，非对称加密算法的加密密钥与解密 <strong>密钥不同</strong>，此外，还有一类 <strong>不需要密钥</strong> 的 <strong>散列算法</strong>。</p><blockquote><p>常见的 <strong>对称加密</strong> 算法主要有 <code>DES</code>、<code>3DES</code>、<code>AES</code> 等，常见的 <strong>非对称算法</strong> 主要有 <code>RSA</code>、<code>DSA</code> 等，<strong>散列算法</strong> 主要有 <code>SHA-1</code>、<code>MD5</code> 等。</p></blockquote><h3 id="3-1-对称加密"><a href="#3-1-对称加密" class="headerlink" title="3.1. 对称加密"></a>3.1. 对称加密</h3><p><strong>对称加密算法</strong> 是应用较早的加密算法，又称为 <strong>共享密钥加密算法</strong>。在 <strong>对称加密算法</strong> 中，使用的密钥只有一个，<strong>发送</strong> 和 <strong>接收</strong> 双方都使用这个密钥对数据进行 <strong>加密</strong> 和 <strong>解密</strong>。这就要求加密和解密方事先都必须知道加密的密钥。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa02dbcd?w=727&amp;h=244&amp;f=png&amp;s=36256" alt=""></p><ol><li><p>数据加密过程：在对称加密算法中，<strong>数据发送方</strong> 将 <strong>明文</strong> (原始数据) 和 <strong>加密密钥</strong> 一起经过特殊 <strong>加密处理</strong>，生成复杂的 <strong>加密密文</strong> 进行发送。</p></li><li><p>数据解密过程：<strong>数据接收方</strong> 收到密文后，若想读取原数据，则需要使用 <strong>加密使用的密钥</strong> 及相同算法的 <strong>逆算法</strong> 对加密的密文进行解密，才能使其恢复成 <strong>可读明文</strong>。</p></li></ol><h3 id="3-2-非对称加密"><a href="#3-2-非对称加密" class="headerlink" title="3.2. 非对称加密"></a>3.2. 非对称加密</h3><p><strong>非对称加密算法</strong>，又称为 <strong>公开密钥加密算法</strong>。它需要两个密钥，一个称为 <strong>公开密钥</strong> (<code>public key</code>)，即 <strong>公钥</strong>，另一个称为 <strong>私有密钥</strong> (<code>private key</code>)，即 <strong>私钥</strong>。</p><p>因为 <strong>加密</strong> 和 <strong>解密</strong> 使用的是两个不同的密钥，所以这种算法称为 <strong>非对称加密算法</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa06e955?w=736&amp;h=214&amp;f=png&amp;s=37513" alt=""></p><ol><li><p>如果使用 <strong>公钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>私钥</strong> 才能 <strong>进行解密</strong>。</p></li><li><p>如果使用 <strong>私钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>公钥</strong> 才能 <strong>进行解密</strong>。</p></li></ol><blockquote><p><strong>例子</strong>：甲方生成 <strong>一对密钥</strong> 并将其中的一把作为 <strong>公钥</strong> 向其它人公开，得到该公钥的 <strong>乙方</strong> 使用该密钥对机密信息 <strong>进行加密</strong> 后再发送给甲方，甲方再使用自己保存的另一把 <strong>专用密钥</strong> (<strong>私钥</strong>)，对 <strong>加密</strong> 后的信息 <strong>进行解密</strong>。</p></blockquote><h2 id="4-常见的签名加密算法"><a href="#4-常见的签名加密算法" class="headerlink" title="4. 常见的签名加密算法"></a>4. 常见的签名加密算法</h2><h3 id="4-1-MD5算法"><a href="#4-1-MD5算法" class="headerlink" title="4.1. MD5算法"></a>4.1. MD5算法</h3><p><code>MD5</code> 用的是 <strong>哈希函数</strong>，它的典型应用是对一段信息产生 <strong>信息摘要</strong>，以 <strong>防止被篡改</strong>。严格来说，<code>MD5</code> 不是一种 <strong>加密算法</strong> 而是 <strong>摘要算法</strong>。无论是多长的输入，<code>MD5</code> 都会输出长度为 <code>128bits</code> 的一个串 (通常用 <code>16</code> <strong>进制</strong> 表示为 <code>32</code> 个字符)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] computeMD5(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageDigest md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        <span class="keyword">return</span> md5.digest(content);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-SHA1算法"><a href="#4-2-SHA1算法" class="headerlink" title="4.2. SHA1算法"></a>4.2. SHA1算法</h3><p><code>SHA1</code> 是和 <code>MD5</code> 一样流行的 <strong>消息摘要算法</strong>，然而 <code>SHA1</code> 比 <code>MD5</code> 的 <strong>安全性更强</strong>。对于长度小于 <code>2 ^ 64</code> 位的消息，<code>SHA1</code> 会产生一个 <code>160</code> 位的 <strong>消息摘要</strong>。基于 <code>MD5</code>、<code>SHA1</code> 的信息摘要特性以及 <strong>不可逆</strong> (一般而言)，可以被应用在检查 <strong>文件完整性</strong> 以及 <strong>数字签名</strong> 等场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] computeSHA1(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageDigest sha1 = MessageDigest.getInstance(<span class="string">"SHA1"</span>);</span><br><span class="line">        <span class="keyword">return</span> sha1.digest(content);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-HMAC算法"><a href="#4-3-HMAC算法" class="headerlink" title="4.3. HMAC算法"></a>4.3. HMAC算法</h3><p><code>HMAC</code> 是密钥相关的 <strong>哈希运算消息认证码</strong>（Hash-based Message Authentication Code），<code>HMAC</code> 运算利用 <strong>哈希算法</strong> (<code>MD5</code>、<code>SHA1</code> 等)，以 <strong>一个密钥</strong> 和 <strong>一个消息</strong> 为输入，生成一个 <strong>消息摘要</strong> 作为 <strong>输出</strong>。</p><p><code>HMAC</code> <strong>发送方</strong> 和 <strong>接收方</strong> 都有的 <code>key</code> 进行计算，而没有这把 <code>key</code> 的第三方，则是 <strong>无法计算</strong> 出正确的 <strong>散列值</strong>的，这样就可以 <strong>防止数据被篡改</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.pocrd.util;</span><br><span class="line"><span class="keyword">import</span> net.pocrd.annotation.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> net.pocrd.define.ConstField;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Mac;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HMacHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HMacHelper.class);</span><br><span class="line">    <span class="keyword">private</span> Mac mac;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MAC算法可选以下多种算法</span></span><br><span class="line"><span class="comment">     * HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_MAC = <span class="string">"HmacMD5"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HMacHelper</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecretKey secretKey = <span class="keyword">new</span> SecretKeySpec(key.getBytes(ConstField.UTF8), KEY_MAC);</span><br><span class="line">            mac = Mac.getInstance(secretKey.getAlgorithm());</span><br><span class="line">            mac.init(secretKey);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"create hmac helper failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">return</span> mac.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] signature, <span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = mac.doFinal(content);</span><br><span class="line">            <span class="keyword">return</span> Arrays.equals(signature, result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"verify sig failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>测试结论</strong>：<code>HMAC</code> 算法实例在 <strong>多线程环境</strong> 下是 <strong>不安全的</strong>。但是需要在 <strong>多线程访问</strong> 时，进行同步的辅助类，使用 <code>ThreadLocal</code> 为 <strong>每个线程缓存</strong> 一个实例可以避免进行锁操作。</p></blockquote><h3 id="4-4-AES-DES-3DES算法"><a href="#4-4-AES-DES-3DES算法" class="headerlink" title="4.4. AES/DES/3DES算法"></a>4.4. AES/DES/3DES算法</h3><p><code>AES</code>、<code>DES</code>、<code>3DES</code> 都是 <strong>对称</strong> 的 <strong>块加密算法</strong>，<strong>加解密</strong> 的过程是 <strong>可逆的</strong>。常用的有 <code>AES128</code>、<code>AES192</code>、<code>AES256</code> (默认安装的 <code>JDK</code> 尚不支持 <code>AES256</code>，需要安装对应的 <code>jce</code> 补丁进行升级 <code>jce1.7</code>，<code>jce1.8</code>)。</p><h4 id="4-4-1-DES算法"><a href="#4-4-1-DES算法" class="headerlink" title="4.4.1. DES算法"></a>4.4.1. DES算法</h4><p><code>DES</code> 加密算法是一种 <strong>分组密码</strong>，以 <code>64</code> 位为 <strong>分组对数据</strong> 加密，它的 <strong>密钥长度</strong> 是 <code>56</code> 位，<strong>加密解密</strong> 用 <strong>同一算法</strong>。</p><p><code>DES</code> 加密算法是对 <strong>密钥</strong> 进行保密，而 <strong>公开算法</strong>，包括加密和解密算法。这样，只有掌握了和发送方 <strong>相同密钥</strong> 的人才能解读由 <code>DES</code>加密算法加密的密文数据。因此，破译 <code>DES</code> 加密算法实际上就是 <strong>搜索密钥的编码</strong>。对于 <code>56</code> 位长度的 <strong>密钥</strong> 来说，如果用 <strong>穷举法</strong> 来进行搜索的话，其运算次数为 <code>2 ^ 56</code> 次。</p><h4 id="4-4-2-3DES算法"><a href="#4-4-2-3DES算法" class="headerlink" title="4.4.2. 3DES算法"></a>4.4.2. 3DES算法</h4><p>是基于 <code>DES</code> 的 <strong>对称算法</strong>，对 <strong>一块数据</strong> 用 <strong>三个不同的密钥</strong> 进行 <strong>三次加密</strong>，<strong>强度更高</strong>。</p><h4 id="4-4-3-AES算法"><a href="#4-4-3-AES算法" class="headerlink" title="4.4.3. AES算法"></a>4.4.3. AES算法</h4><p><code>AES</code> 加密算法是密码学中的 <strong>高级加密标准</strong>，该加密算法采用 <strong>对称分组密码体制</strong>，密钥长度的最少支持为 <code>128</code> 位、 <code>192</code> 位、<code>256</code> 位，分组长度 <code>128</code> 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的 <strong>区块加密标准</strong>。</p><p><code>AES</code> 本身就是为了取代 <code>DES</code> 的，<code>AES</code> 具有更好的 <strong>安全性</strong>、<strong>效率</strong> 和 <strong>灵活性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.pocrd.annotation.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AesHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SecretKeySpec keySpec;</span><br><span class="line">    <span class="keyword">private</span> IvParameterSpec iv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AesHelper</span><span class="params">(<span class="keyword">byte</span>[] aesKey, <span class="keyword">byte</span>[] iv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (aesKey == <span class="keyword">null</span> || aesKey.length &lt; <span class="number">16</span> || (iv != <span class="keyword">null</span> &amp;&amp; iv.length &lt; <span class="number">16</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"错误的初始密钥"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iv == <span class="keyword">null</span>) &#123;</span><br><span class="line">            iv = Md5Util.compute(aesKey);</span><br><span class="line">        &#125;</span><br><span class="line">        keySpec = <span class="keyword">new</span> SecretKeySpec(aesKey, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">this</span>.iv = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AesHelper</span><span class="params">(<span class="keyword">byte</span>[] aesKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (aesKey == <span class="keyword">null</span> || aesKey.length &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"错误的初始密钥"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        keySpec = <span class="keyword">new</span> SecretKeySpec(aesKey, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">this</span>.iv = <span class="keyword">new</span> IvParameterSpec(Md5Util.compute(aesKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">null</span>;</span><br><span class="line">        Cipher cipher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cipher = Cipher.getInstance(<span class="string">"AES/CFB/NoPadding"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);</span><br><span class="line">            result = cipher.doFinal(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] secret) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">null</span>;</span><br><span class="line">        Cipher cipher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cipher = Cipher.getInstance(<span class="string">"AES/CFB/NoPadding"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);</span><br><span class="line">            result = cipher.doFinal(secret);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] randomKey(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyGenerator gen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">            gen.init(size, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">            result = gen.generateKey().getEncoded();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-RSA算法"><a href="#4-5-RSA算法" class="headerlink" title="4.5. RSA算法"></a>4.5. RSA算法</h3><p><code>RSA</code> 加密算法是目前最有影响力的 <strong>公钥加密算法</strong>，并且被普遍认为是目前 <strong>最优秀的公钥方案</strong> 之一。<code>RSA</code> 是第一个能同时用于 <strong>加密</strong> 和 <strong>数字签名</strong> 的算法，它能够 <strong>抵抗</strong> 到目前为止已知的 <strong>所有密码攻击</strong>，已被 <code>ISO</code> 推荐为公钥数据加密标准。</p><blockquote><p><code>RSA</code> <strong>加密算法</strong> 基于一个十分简单的数论事实：将两个大 <strong>素数</strong> 相乘十分容易，但想要对其乘积进行 <strong>因式分解</strong> 却极其困难，因此可以将 <strong>乘积</strong> 公开作为 <strong>加密密钥</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.pocrd.annotation.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"><span class="keyword">import</span> java.security.Signature;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.RSAPrivateCrtKey;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.RSAPublicKey;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RsaHelper.class);</span><br><span class="line">    <span class="keyword">private</span> RSAPublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> RSAPrivateCrtKey privateKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider()); <span class="comment">//使用bouncycastle作为加密算法实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RsaHelper</span><span class="params">(String publicKey, String privateKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Base64Util.decode(publicKey), Base64Util.decode(privateKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RsaHelper</span><span class="params">(<span class="keyword">byte</span>[] publicKey, <span class="keyword">byte</span>[] privateKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">            <span class="keyword">if</span> (publicKey != <span class="keyword">null</span> &amp;&amp; publicKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.publicKey = (RSAPublicKey)keyFactory.generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(publicKey));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (privateKey != <span class="keyword">null</span> &amp;&amp; privateKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.privateKey = (RSAPrivateCrtKey)keyFactory.generatePrivate(<span class="keyword">new</span> PKCS8EncodedKeySpec(privateKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RsaHelper</span><span class="params">(String publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Base64Util.decode(publicKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RsaHelper</span><span class="params">(<span class="keyword">byte</span>[] publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">            <span class="keyword">if</span> (publicKey != <span class="keyword">null</span> &amp;&amp; publicKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.publicKey = (RSAPublicKey)keyFactory.generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(publicKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"public key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"RSA/ECB/PKCS1Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            <span class="keyword">int</span> size = publicKey.getModulus().bitLength() / <span class="number">8</span> - <span class="number">11</span>;</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream((content.length + size - <span class="number">1</span>) / size * (size + <span class="number">11</span>));</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; content.length; ) &#123;</span><br><span class="line">                left = content.length - i;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; size) &#123;</span><br><span class="line">                    cipher.update(content, i, size);</span><br><span class="line">                    i += size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cipher.update(content, i, left);</span><br><span class="line">                    i += left;</span><br><span class="line">                &#125;</span><br><span class="line">                baos.write(cipher.doFinal());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] secret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (privateKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"private key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (secret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"RSA/ECB/PKCS1Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            <span class="keyword">int</span> size = privateKey.getModulus().bitLength() / <span class="number">8</span>;</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream((secret.length + size - <span class="number">12</span>) / (size - <span class="number">11</span>) * size);</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length; ) &#123;</span><br><span class="line">                left = secret.length - i;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; size) &#123;</span><br><span class="line">                    cipher.update(secret, i, size);</span><br><span class="line">                    i += size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cipher.update(secret, i, left);</span><br><span class="line">                    i += left;</span><br><span class="line">                &#125;</span><br><span class="line">                baos.write(cipher.doFinal());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"rsa decrypt failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">if</span> (privateKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"private key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Signature signature = Signature.getInstance(<span class="string">"SHA1WithRSA"</span>);</span><br><span class="line">            signature.initSign(privateKey);</span><br><span class="line">            signature.update(content);</span><br><span class="line">            <span class="keyword">return</span> signature.sign();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] sign, <span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (publicKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"public key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="keyword">null</span> || content == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Signature signature = Signature.getInstance(<span class="string">"SHA1WithRSA"</span>);</span><br><span class="line">            signature.initVerify(publicKey);</span><br><span class="line">            signature.update(content);</span><br><span class="line">            <span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"rsa verify failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-ECC算法"><a href="#4-6-ECC算法" class="headerlink" title="4.6. ECC算法"></a>4.6. ECC算法</h3><p><code>ECC</code> 也是一种 <strong>非对称加密算法</strong>，主要优势是在某些情况下，它比其他的方法使用 <strong>更小的密钥</strong>，比如 <code>RSA</code> <strong>加密算法</strong>，提供 <strong>相当的或更高等级</strong> 的安全级别。不过一个缺点是 <strong>加密和解密操作</strong> 的实现比其他机制 <strong>时间长</strong> (相比 <code>RSA</code> 算法，该算法对 <code>CPU</code> 消耗严重)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.pocrd.annotation.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"><span class="keyword">import</span> java.security.Signature;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EccHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(EccHelper.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="keyword">private</span> BCECPublicKey  publicKey;</span><br><span class="line">    <span class="keyword">private</span> BCECPrivateKey privateKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EccHelper</span><span class="params">(String publicKey, String privateKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Base64Util.decode(publicKey), Base64Util.decode(privateKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EccHelper</span><span class="params">(<span class="keyword">byte</span>[] publicKey, <span class="keyword">byte</span>[] privateKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"EC"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            <span class="keyword">if</span> (publicKey != <span class="keyword">null</span> &amp;&amp; publicKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.publicKey = (BCECPublicKey)keyFactory.generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(publicKey));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (privateKey != <span class="keyword">null</span> &amp;&amp; privateKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.privateKey = (BCECPrivateKey)keyFactory.generatePrivate(<span class="keyword">new</span> PKCS8EncodedKeySpec(privateKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EccHelper</span><span class="params">(String publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Base64Util.decode(publicKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EccHelper</span><span class="params">(<span class="keyword">byte</span>[] publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"EC"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            <span class="keyword">if</span> (publicKey != <span class="keyword">null</span> &amp;&amp; publicKey.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.publicKey = (BCECPublicKey)keyFactory.generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(publicKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"public key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"ECIES"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            <span class="keyword">int</span> size = SIZE;</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream((content.length + size - <span class="number">1</span>) / size * (size + <span class="number">45</span>));</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; content.length; ) &#123;</span><br><span class="line">                left = content.length - i;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; size) &#123;</span><br><span class="line">                    cipher.update(content, i, size);</span><br><span class="line">                    i += size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cipher.update(content, i, left);</span><br><span class="line">                    i += left;</span><br><span class="line">                &#125;</span><br><span class="line">                baos.write(cipher.doFinal());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] secret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (privateKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"private key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"ECIES"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            <span class="keyword">int</span> size = SIZE + <span class="number">45</span>;</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream((secret.length + size + <span class="number">44</span>) / (size + <span class="number">45</span>) * size);</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length; ) &#123;</span><br><span class="line">                left = secret.length - i;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; size) &#123;</span><br><span class="line">                    cipher.update(secret, i, size);</span><br><span class="line">                    i += size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cipher.update(secret, i, left);</span><br><span class="line">                    i += left;</span><br><span class="line">                &#125;</span><br><span class="line">                baos.write(cipher.doFinal());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"ecc decrypt failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">        <span class="keyword">if</span> (privateKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"private key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Signature signature = Signature.getInstance(<span class="string">"SHA1withECDSA"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            signature.initSign(privateKey);</span><br><span class="line">            signature.update(content);</span><br><span class="line">            <span class="keyword">return</span> signature.sign();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] sign, <span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (publicKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"public key is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Signature signature = Signature.getInstance(<span class="string">"SHA1withECDSA"</span>, <span class="string">"BC"</span>);</span><br><span class="line">            signature.initVerify(publicKey);</span><br><span class="line">            signature.update(content);</span><br><span class="line">            <span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"ecc verify failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-各种加密算法对比"><a href="#5-各种加密算法对比" class="headerlink" title="5. 各种加密算法对比"></a>5. 各种加密算法对比</h2><h3 id="5-1-散列算法比较"><a href="#5-1-散列算法比较" class="headerlink" title="5.1. 散列算法比较"></a>5.1. 散列算法比较</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">安全性</th><th style="text-align:left">速度</th></tr></thead><tbody><tr><td style="text-align:left">SHA-1</td><td style="text-align:left">高</td><td style="text-align:left">慢</td></tr><tr><td style="text-align:left">MD5</td><td style="text-align:left">中</td><td style="text-align:left">快</td></tr></tbody></table><h3 id="5-2-对称加密算法比较"><a href="#5-2-对称加密算法比较" class="headerlink" title="5.2. 对称加密算法比较"></a>5.2. 对称加密算法比较</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">密钥名称</th><th style="text-align:left">运行速度</th><th style="text-align:left">安全性</th><th style="text-align:left">资源消耗</th></tr></thead><tbody><tr><td style="text-align:left">DES</td><td style="text-align:left">56位</td><td style="text-align:left">较快</td><td style="text-align:left">低</td><td style="text-align:left">中</td></tr><tr><td style="text-align:left">3DES</td><td style="text-align:left">112位或168位</td><td style="text-align:left">慢</td><td style="text-align:left">中</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">AES</td><td style="text-align:left">128、192、256位</td><td style="text-align:left">快</td><td style="text-align:left">高</td><td style="text-align:left">低</td></tr></tbody></table><h3 id="5-3-非对称加密算法比较"><a href="#5-3-非对称加密算法比较" class="headerlink" title="5.3. 非对称加密算法比较"></a>5.3. 非对称加密算法比较</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">成熟度</th><th style="text-align:left">安全性</th><th style="text-align:left">运算速度</th><th style="text-align:left">资源消耗</th></tr></thead><tbody><tr><td style="text-align:left">RSA</td><td style="text-align:left">高</td><td style="text-align:left">高</td><td style="text-align:left">中</td><td style="text-align:left">中</td></tr><tr><td style="text-align:left">ECC</td><td style="text-align:left">高</td><td style="text-align:left">高</td><td style="text-align:left">慢</td><td style="text-align:left">高</td></tr></tbody></table><h3 id="5-4-对称算法与非对称加密算法"><a href="#5-4-对称算法与非对称加密算法" class="headerlink" title="5.4. 对称算法与非对称加密算法"></a>5.4. 对称算法与非对称加密算法</h3><h4 id="5-4-1-对称算法"><a href="#5-4-1-对称算法" class="headerlink" title="5.4.1. 对称算法"></a>5.4.1. 对称算法</h4><ol><li><p><strong>密钥管理</strong>：比较难，不适合互联网，一般用于内部系统</p></li><li><p><strong>安全性</strong>：中</p></li><li><p><strong>加密速度</strong>：快好 <strong>几个数量级</strong> (软件加解密速度至少快 <code>100</code> 倍，每秒可以加解密数 <code>M</code> <strong>比特</strong> 数据)，适合大数据量的加解密处理</p></li></ol><h4 id="5-4-2-非对称算法"><a href="#5-4-2-非对称算法" class="headerlink" title="5.4.2. 非对称算法"></a>5.4.2. 非对称算法</h4><ol><li><p><strong>密钥管理</strong>：密钥容易管理</p></li><li><p><strong>安全性</strong>：高</p></li><li><p><strong>加密速度</strong>：比较慢，适合 <strong>小数据量</strong> 加解密或数据签名</p></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了 <strong>数字签名</strong>，<strong>加密和解密</strong>，<strong>对称加密和非对称加密</strong>，然后详细介绍了 <code>MD5</code>，<code>SHA-1</code>，<code>HMAC</code>，<code>DES/AES</code>，<code>RSA</code> 和 <code>ECC</code> 这几种加密算法和代码示例。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5dcc40392?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;数字签名&lt;/strong&gt;、&lt;strong&gt;信息加密&lt;/strong&gt; 是前后端开发都经常需要使用到的技术，应用场景包括了用户登入、交易、信息通讯、&lt;code&gt;oauth&lt;/code&gt; 等等，不同的应用场景也会需要使用到不同的签名加密算法，或者需要搭配不一样的 &lt;strong&gt;签名加密算法&lt;/strong&gt; 来达到业务目标。这里简单的给大家介绍几种常见的签名加密算法和一些典型场景下的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="加密算法系列" scheme="https://ostenant.coding.me/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MD5" scheme="https://ostenant.coding.me/tags/MD5/"/>
    
      <category term="SHA1" scheme="https://ostenant.coding.me/tags/SHA1/"/>
    
      <category term="DES" scheme="https://ostenant.coding.me/tags/DES/"/>
    
      <category term="AES" scheme="https://ostenant.coding.me/tags/AES/"/>
    
      <category term="RSA" scheme="https://ostenant.coding.me/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>浅谈消息队列及常见的消息中间件</title>
    <link href="https://ostenant.coding.me/2018/07/07/%E6%B5%85%E8%B0%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://ostenant.coding.me/2018/07/07/浅谈消息队列及常见的消息中间件/</id>
    <published>2018-07-07T15:27:00.000Z</published>
    <updated>2018-07-19T09:52:38.717Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>消息队列</strong> 已经逐渐成为企业应用系统 <strong>内部通信</strong> 的核心手段。它具有 <strong>低耦合</strong>、<strong>可靠投递</strong>、<strong>广播</strong>、<strong>流量控制</strong>、<strong>最终一致性</strong> 等一系列功能。</p><p>当前使用较多的 <strong>消息队列</strong> 有 <code>RabbitMQ</code>、<code>RocketMQ</code>、<code>ActiveMQ</code>、<code>Kafka</code>、<code>ZeroMQ</code>、<code>MetaMQ</code> 等，而部分 <strong>数据库</strong> 如 <code>Redis</code>、<code>MySQL</code> 以及 <code>phxsql</code> 也可实现消息队列的功能。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ed095ffed?w=989&amp;h=290&amp;f=webp&amp;s=10430" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-消息队列概述"><a href="#1-消息队列概述" class="headerlink" title="1. 消息队列概述"></a>1. 消息队列概述</h2><p><strong>消息队列</strong> 是指利用 <strong>高效可靠</strong> 的 <strong>消息传递机制</strong> 进行与平台无关的 <strong>数据交流</strong>，并基于 <strong>数据通信</strong> 来进行分布式系统的集成。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7c77109d?w=623&amp;h=242&amp;f=webp&amp;s=6046" alt=""></p><p>通过提供 <strong>消息传递</strong> 和 <strong>消息排队</strong> 模型，它可以在 <strong>分布式环境</strong> 下提供 <strong>应用解耦</strong>、<strong>弹性伸缩</strong>、<strong>冗余存储</strong>、<strong>流量削峰</strong>、<strong>异步通信</strong>、<strong>数据同步</strong> 等等功能，其作为 <strong>分布式系统架构</strong> 中的一个重要组件，有着举足轻重的地位。</p><h2 id="2-消息队列的特点"><a href="#2-消息队列的特点" class="headerlink" title="2. 消息队列的特点"></a>2. 消息队列的特点</h2><h3 id="2-1-采用异步处理模式"><a href="#2-1-采用异步处理模式" class="headerlink" title="2.1. 采用异步处理模式"></a>2.1. 采用异步处理模式</h3><p><strong>消息发送者</strong> 可以发送一个消息而无须等待响应。<strong>消息发送者</strong> 将消息发送到一条 <strong>虚拟的通道</strong>（<strong>主题</strong> 或 <strong>队列</strong>）上，<strong>消息接收者</strong> 则 <strong>订阅</strong> 或是 <strong>监听</strong> 该通道。一条信息可能最终转发给 <strong>一个或多个</strong> 消息接收者，这些接收者都无需对 <strong>消息发送者</strong> 做出 <strong>同步回应</strong>。整个过程都是 <strong>异步的</strong>。</p><h3 id="2-2-应用系统之间解耦合"><a href="#2-2-应用系统之间解耦合" class="headerlink" title="2.2. 应用系统之间解耦合"></a>2.2. 应用系统之间解耦合</h3><p>主要体现在如下两点：</p><ol><li><p>发送者和接受者不必了解对方、只需要 <strong>确认消息</strong>；</p></li><li><p>发送者和接受者 <strong>不必同时在线</strong>。</p></li></ol><p>比如在线交易系统为了保证数据的 <strong>最终一致</strong>，在 <strong>支付系统</strong> 处理完成后会把 <strong>支付结果</strong> 放到 <strong>消息中间件</strong> 里，通知 <strong>订单系统</strong> 修改 <strong>订单支付状态</strong>。两个系统是通过消息中间件解耦的。</p><h2 id="3-消息队列的传递服务模型"><a href="#3-消息队列的传递服务模型" class="headerlink" title="3. 消息队列的传递服务模型"></a>3. 消息队列的传递服务模型</h2><p>消息队列的 <strong>传递服务模型</strong> 如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7c831340?w=653&amp;h=406&amp;f=jpeg&amp;s=51288" alt=""></p><h2 id="4-消息队列的的传输模式"><a href="#4-消息队列的的传输模式" class="headerlink" title="4. 消息队列的的传输模式"></a>4. 消息队列的的传输模式</h2><h3 id="4-1-点对点模型"><a href="#4-1-点对点模型" class="headerlink" title="4.1. 点对点模型"></a>4.1. 点对点模型</h3><p><strong>点对点模型</strong> 用于 <strong>消息生产者</strong> 和 <strong>消息消费者</strong> 之间 <strong>点到点</strong> 的通信。消息生产者将消息发送到由某个名字标识的特定消费者。这个名字实际上对于消费服务中的一个 <strong>队列</strong>（<code>Queue</code>），在消息传递给消费者之前它被 <strong>存储</strong> 在这个队列中。<strong>队列消息</strong> 可以放在 <strong>内存</strong> 中也可以 <strong>持久化</strong>，以保证在消息服务出现故障时仍然能够传递消息。</p><p>传统的点对点消息中间件通常由 <strong>消息队列服务</strong>、<strong>消息传递服务</strong>、<strong>消息队列</strong> 和 <strong>消息应用程序接口</strong> <code>API</code> 组成，其典型的结构如下图所示。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7c97b0c3?w=910&amp;h=408&amp;f=jpeg&amp;s=68819" alt=""></p><p><strong>特点：</strong></p><ol><li>每个消息只用一个消费者；</li><li>发送者和接受者没有时间依赖；</li><li>接受者确认消息接受和处理成功。</li></ol><p><strong>示意图如下所示：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7c89962f?w=832&amp;h=126&amp;f=jpeg&amp;s=14475" alt=""></p><h3 id="4-2-发布-订阅模型（Pub-Sub）"><a href="#4-2-发布-订阅模型（Pub-Sub）" class="headerlink" title="4.2. 发布/订阅模型（Pub/Sub）"></a>4.2. 发布/订阅模型（Pub/Sub）</h3><p><strong>发布者/订阅者</strong> 模型支持向一个特定的 <strong>消息主题</strong> 生产消息。<code>0</code> 或 <strong>多个订阅者</strong> 可能对接收来自 <strong>特定消息主题</strong> 的消息感兴趣。</p><p>在这种模型下，发布者和订阅者彼此不知道对方，就好比是匿名公告板。这种模式被概况为：多个消费者可以获得消息，在 <strong>发布者</strong> 和 <strong>订阅者</strong> 之间存在 <strong>时间依赖性</strong>。发布者需要建立一个 <strong>订阅</strong>（<code>subscription</code>），以便能够消费者订阅。<strong>订阅者</strong> 必须保持 <strong>持续的活动状态</strong> 并 <strong>接收消息</strong>。</p><p>在这种情况下，在订阅者 <strong>未连接时</strong>，发布的消息将在订阅者 <strong>重新连接</strong> 时 <strong>重新发布</strong>，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e7faf60a5?w=492&amp;h=268&amp;f=jpeg&amp;s=16077" alt=""></p><p><strong>特性：</strong></p><ol><li>每个消息可以有多个订阅者；</li><li>客户端只有订阅后才能接收到消息；</li><li>持久订阅和非持久订阅。</li></ol><blockquote><p>注意：</p><ol><li>发布者和订阅者有时间依赖：接受者和发布者只有建立订阅关系才能收到消息；</li><li>持久订阅：订阅关系建立后，消息就不会消失，不管订阅者是否都在线；</li><li>非持久订阅：订阅者为了接受消息，必须一直在线。<br>当只有一个订阅者时约等于点对点模式</li></ol></blockquote><h2 id="5-消息队列应用场景"><a href="#5-消息队列应用场景" class="headerlink" title="5. 消息队列应用场景"></a>5. 消息队列应用场景</h2><p>当你需要使用 <strong>消息队列</strong> 时，首先需要考虑它的必要性。可以使用消息队列的场景有很多，最常用的几种，是做 <strong>应用程序松耦合</strong>、<strong>异步处理模式</strong>、<strong>发布与订阅</strong>、<strong>最终一致性</strong>、<strong>错峰流控</strong> 和 <strong>日志缓冲</strong> 等。反之，如果需要 <strong>强一致性</strong>，关注业务逻辑的处理结果，则使用 <code>RPC</code> 显得更为合适。</p><h3 id="5-1-异步处理"><a href="#5-1-异步处理" class="headerlink" title="5.1. 异步处理"></a>5.1. 异步处理</h3><p><strong>非核心</strong> 流程 <strong>异步化</strong>，减少系统 <strong>响应时间</strong>，提高 <strong>吞吐量</strong>。例如：<strong>短信通知</strong>、<strong>终端状态推送</strong>、<code>App</code> <strong>推送</strong>、<strong>用户注册</strong> 等。</p><p><strong>消息队列</strong> 一般都内置了 <strong>高效的通信机制</strong>，因此也可以用于单纯的消息通讯，比如实现 <strong>点对点消息队列</strong> 或者 <strong>聊天室</strong> 等。</p><h4 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h4><p>网站用户注册，注册成功后会过一会发送邮件确认或者短息。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8e800ce905?w=541&amp;h=300&amp;f=jpeg&amp;s=16288" alt=""></p><h3 id="5-2-系统解耦"><a href="#5-2-系统解耦" class="headerlink" title="5.2. 系统解耦"></a>5.2. 系统解耦</h3><ul><li><p>系统之间不是 <strong>强耦合的</strong>，<strong>消息接受者</strong> 可以随意增加，而不需要修改 <strong>消息发送者的代码</strong>。<strong>消息发送者</strong> 的成功不依赖 <strong>消息接受者</strong>（比如：有些银行接口不稳定，但调用方并不需要依赖这些接口）。</p></li><li><p><strong>不强依赖</strong> 于非本系统的核心流程，对于 <strong>非核心流程</strong>，可以放到消息队列中让 <strong>消息消费者</strong> 去按需消费，而 <strong>不影响核心主流程</strong>。</p></li></ul><h3 id="5-3-最终一致性"><a href="#5-3-最终一致性" class="headerlink" title="5.3. 最终一致性"></a>5.3. 最终一致性</h3><p><strong>最终一致性</strong> 不是 <strong>消息队列</strong> 的必备特性，但确实可以依靠 <strong>消息队列</strong> 来做 <strong>最终一致性</strong> 的事情。</p><ul><li><p><strong>先写消息再操作</strong>，确保操作完成后再修改消息状态。<strong>定时任务补偿机制</strong> 实现消息 <strong>可靠发送接收</strong>、业务操作的可靠执行，要注意 <strong>消息重复</strong> 与 <strong>幂等设计</strong>。</p></li><li><p>所有不保证 <code>100%</code> <strong>不丢消息</strong> 的消息队列，理论上无法实现 <strong>最终一致性</strong>。</p></li></ul><blockquote><p>像 <code>Kafka</code> 一类的设计，在设计层面上就有 <strong>丢消息</strong> 的可能（比如 <strong>定时刷盘</strong>，如果掉电就会丢消息）。哪怕只丢千分之一的消息，业务也必须用其他的手段来保证结果正确。</p></blockquote><h3 id="5-4-广播"><a href="#5-4-广播" class="headerlink" title="5.4. 广播"></a>5.4. 广播</h3><p><strong>生产者/消费者</strong> 模式，只需要关心消息是否 <strong>送达队列</strong>，至于谁希望订阅和需要消费，是 <strong>下游</strong> 的事情，无疑极大地减少了开发和联调的工作量。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea267f536?w=595&amp;h=346&amp;f=webp&amp;s=10596" alt=""></p><h3 id="5-5-流量削峰和流控"><a href="#5-5-流量削峰和流控" class="headerlink" title="5.5. 流量削峰和流控"></a>5.5. 流量削峰和流控</h3><p>当 <strong>上下游系统</strong> 处理能力存在差距的时候，利用 <strong>消息队列</strong> 做一个通用的 <strong>“漏斗”</strong>，进行 <strong>限流控制</strong>。在下游有能力处理的时候，再进行分发。</p><blockquote><p>举个例子：用户在支付系统成功结账后，订单系统会通过短信系统向用户推送扣费通知。<br><strong>短信系统</strong> 可能由于 <strong>短板效应</strong>，速度卡在 <strong>网关</strong> 上（每秒几百次请求），跟 <strong>前端的并发量</strong> 不是一个数量级。<br>于是，就造成 <strong>支付系统</strong> 和 <strong>短信系统</strong> 的处理能力出现差异化。</p></blockquote><p>然而用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过 <strong>协商</strong>、<strong>滑动窗口</strong> 等复杂的方案也不是说不能实现。但 <strong>系统复杂性</strong> 指数级增长，势必在 <strong>上游</strong> 或者 <strong>下游</strong> 做 <strong>存储</strong>，并且要处理 <strong>定时</strong>、<strong>拥塞</strong> 等一系列问题。而且每当有 <strong>处理能力有差距</strong> 的时候，都需要 <strong>单独</strong> 开发一套逻辑来维护这套逻辑。</p><p>所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。</p><h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h4><ol><li>把消息队列当成可靠的 <strong>消息暂存地</strong>，进行一定程度的 <strong>消息堆积</strong>；</li><li>定时进行消息投递，比如模拟 <strong>用户秒杀</strong> 访问，进行 <strong>系统性能压测</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea3e6231a?w=587&amp;h=401&amp;f=jpeg&amp;s=24739" alt=""></p><h3 id="5-6-日志处理"><a href="#5-6-日志处理" class="headerlink" title="5.6. 日志处理"></a>5.6. 日志处理</h3><p>将消息队列用在 <strong>日志处理</strong> 中，比如 <code>Kafka</code> 的应用，解决 <strong>海量日志</strong> 传输和缓冲的问题。</p><h4 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a>应用案例</h4><p>把日志进行集中收集，用于计算 <code>PV</code>、<strong>用户行为分析</strong> 等等。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea41e864b?w=648&amp;h=247&amp;f=jpeg&amp;s=18958" alt=""></p><h3 id="5-7-消息通讯"><a href="#5-7-消息通讯" class="headerlink" title="5.7. 消息通讯"></a>5.7. 消息通讯</h3><p>消息队列一般都内置了 <strong>高效的通信机制</strong>，因此也可以用于单纯的 <strong>消息通讯</strong>，比如实现 <strong>点对点消息队列</strong> 或者 <strong>聊天室</strong> 等。</p><h2 id="6-消息队列的推拉模型"><a href="#6-消息队列的推拉模型" class="headerlink" title="6. 消息队列的推拉模型"></a>6. 消息队列的推拉模型</h2><h3 id="6-1-Push推消息模型"><a href="#6-1-Push推消息模型" class="headerlink" title="6.1. Push推消息模型"></a>6.1. Push推消息模型</h3><p><strong>消息生产者</strong> 将消息发送给 <strong>消息队列</strong>，<strong>消息队列</strong> 又将消息推给 <strong>消息消费者</strong>。</p><h3 id="6-2-Pull拉消息模型"><a href="#6-2-Pull拉消息模型" class="headerlink" title="6.2. Pull拉消息模型"></a>6.2. Pull拉消息模型</h3><p><strong>消费者</strong> 请求 <strong>消息队列</strong> 接受消息，<strong>消息生产者</strong> 从 <strong>消息队列</strong> 中拉该消息。</p><h3 id="6-3-两种类型的区别"><a href="#6-3-两种类型的区别" class="headerlink" title="6.3. 两种类型的区别"></a>6.3. 两种类型的区别</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea4b19ea9?w=581&amp;h=574&amp;f=jpeg&amp;s=120422" alt=""></p><h2 id="7-消息队列技术对比"><a href="#7-消息队列技术对比" class="headerlink" title="7. 消息队列技术对比"></a>7. 消息队列技术对比</h2><p>本部分主要介绍四种常用的消息队列（<code>ActiveMQ</code> / <code>RabbitMQ</code> / <code>RocketMQ</code> / <code>Kafka</code>）的主要特性、优点、缺点。</p><h3 id="7-1-ActiveMQ"><a href="#7-1-ActiveMQ" class="headerlink" title="7.1. ActiveMQ"></a>7.1. ActiveMQ</h3><p><code>ActiveMQ</code> 是由 <code>Apache</code> 出品，<code>ActiveMQ</code> 是一个完全支持<code>JMS1.1</code> 和 <code>J2EE 1.4</code> 规范的 <code>JMS Provider</code> 实现。它非常快速，支持 <strong>多种语言的客户端</strong> 和 <strong>协议</strong>，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ea7cdc2c0?w=568&amp;h=552&amp;f=png&amp;s=41834" alt=""></p><h4 id="a-主要特性"><a href="#a-主要特性" class="headerlink" title="(a) 主要特性"></a>(a) 主要特性</h4><ol><li><p><strong>服从JMS规范</strong>：<code>JMS</code> 规范提供了良好的标准和保证，包括：<strong>同步</strong> 或 <strong>异步</strong> 的消息分发，一次和仅一次的消息分发，<strong>消息接收</strong> 和 <strong>订阅</strong> 等等。遵从 <code>JMS</code> 规范的好处在于，不论使用什么 <code>JMS</code> 实现提供者，这些基础特性都是可用的；</p></li><li><p><strong>连接灵活性</strong>：<code>ActiveMQ</code> 提供了广泛的 <strong>连接协议</strong>，支持的协议有：<code>HTTP/S</code>，<code>IP</code> <strong>多播</strong>，<code>SSL</code>，<code>TCP</code>，<code>UDP</code> 等等。对众多协议的支持让 <code>ActiveMQ</code> 拥有了很好的灵活性；</p></li><li><p><strong>支持的协议种类多</strong>：<code>OpenWire</code>、<code>STOMP</code>、<code>REST</code>、<code>XMPP</code>、<code>AMQP</code>；</p></li><li><p><strong>持久化插件和安全插件</strong>：<code>ActiveMQ</code> 提供了 <strong>多种持久化</strong> 选择。而且，<code>ActiveMQ</code> 的安全性也可以完全依据用户需求进行 <strong>自定义鉴权</strong> 和 <strong>授权</strong>；</p></li><li><p><strong>支持的客户端语言种类多</strong>：除了 <code>Java</code> 之外，还有：<code>C/C++</code>，<code>.NET</code>，<code>Perl</code>，<code>PHP</code>，<code>Python</code>，<code>Ruby</code>；</p></li><li><p><strong>代理集群</strong>：多个 <code>ActiveMQ</code> <strong>代理</strong> 可以组成一个 <strong>集群</strong> 来提供服务；</p></li><li><p><strong>异常简单的管理</strong>：<code>ActiveMQ</code> 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以 <strong>监控</strong> <code>ActiveMQ</code> 不同层面的数据，包括使用在 <code>JConsole</code> 或者在 <code>ActiveMQ</code> 的 <code>Web Console</code> 中使用 <code>JMX</code>。通过处理 <code>JMX</code> 的告警消息，通过使用 <strong>命令行脚本</strong>，甚至可以通过监控各种类型的 <strong>日志</strong>。</p></li></ol><h4 id="b-部署环境"><a href="#b-部署环境" class="headerlink" title="(b) 部署环境"></a>(b) 部署环境</h4><p><code>ActiveMQ</code> 可以运行在 <code>Java</code> 语言所支持的平台之上。使用 <code>ActiveMQ</code> 需要：</p><ul><li><code>Java JDK</code></li><li><code>ActiveMQ</code> 安装包</li></ul><h4 id="c-优点"><a href="#c-优点" class="headerlink" title="(c) 优点"></a>(c) 优点</h4><ol><li><p><strong>跨平台</strong> (<code>JAVA</code> 编写与平台无关，<code>ActiveMQ</code> 几乎可以运行在任何的 <code>JVM</code> 上)；</p></li><li><p>可以用 <code>JDBC</code>：可以将 <strong>数据持久化</strong> 到数据库。虽然使用 <code>JDBC</code> 会降低 <code>ActiveMQ</code> 的性能，但是数据库一直都是开发人员最熟悉的存储介质；</p></li><li><p>支持 <code>JMS</code> 规范：支持 <code>JMS</code> 规范提供的 <strong>统一接口</strong>;</p></li><li><p>支持 <strong>自动重连</strong> 和 <strong>错误重试机制</strong>；</p></li><li><p>有安全机制：支持基于 <code>shiro</code>，<code>jaas</code> 等多种 <strong>安全配置机制</strong>，可以对 <code>Queue/Topic</code> 进行 <strong>认证和授权</strong>；</p></li><li><p>监控完善：拥有完善的 <strong>监控</strong>，包括 <code>Web Console</code>，<code>JMX</code>，<code>Shell</code> 命令行，<code>Jolokia</code> 的 <code>RESTful API</code>；</p></li><li><p>界面友善：提供的 <code>Web Console</code> 可以满足大部分情况，还有很多 <strong>第三方的组件</strong> 可以使用，比如 <code>hawtio</code>；</p></li></ol><h4 id="d-缺点"><a href="#d-缺点" class="headerlink" title="(d) 缺点"></a>(d) 缺点</h4><ol><li><p>社区活跃度不及 <code>RabbitMQ</code> 高；</p></li><li><p>根据其他用户反馈，会出莫名其妙的问题，会 <strong>丢失消息</strong>；</p></li><li><p>目前重心放到 <code>activemq 6.0</code> 产品 <code>Apollo</code>，对 <code>5.x</code> 的维护较少；</p></li><li><p>不适合用于 <strong>上千个队列</strong> 的应用场景；</p></li></ol><h3 id="7-2-RabbitMQ"><a href="#7-2-RabbitMQ" class="headerlink" title="7.2. RabbitMQ"></a>7.2. RabbitMQ</h3><p><code>RabbitMQ</code> 于 <code>2007</code> 年发布，是一个在 <code>AMQP</code> (<strong>高级消息队列协议</strong>)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ece3b5d7a?w=635&amp;h=298&amp;f=png&amp;s=36428" alt=""></p><h4 id="a-主要特性-1"><a href="#a-主要特性-1" class="headerlink" title="(a) 主要特性"></a>(a) 主要特性</h4><ol><li><p><strong>可靠性</strong>：提供了多种技术可以让你在 <strong>性能</strong> 和 <strong>可靠性</strong> 之间进行 <strong>权衡</strong>。这些技术包括 <strong>持久性机制</strong>、<strong>投递确认</strong>、<strong>发布者证实</strong> 和 <strong>高可用性机制</strong>；</p></li><li><p><strong>灵活的路由</strong>：消息在到达队列前是通过 <strong>交换机</strong> 进行 <strong>路由</strong> 的。<code>RabbitMQ</code> 为典型的路由逻辑提供了 <strong>多种内置交换机</strong> 类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做 <code>RabbitMQ</code> 的 <strong>插件</strong> 来使用；</p></li><li><p><strong>消息集群</strong>：在相同局域网中的多个 <code>RabbitMQ</code> 服务器可以 <strong>聚合</strong> 在一起，作为一个独立的逻辑代理来使用；</p></li><li><p><strong>队列高可用</strong>：队列可以在集群中的机器上 <strong>进行镜像</strong>，以确保在硬件问题下还保证 <strong>消息安全</strong>；</p></li><li><p><strong>支持多种协议</strong>：支持 <strong>多种消息队列协议</strong>；</p></li><li><p><strong>支持多种语言</strong>：用 <code>Erlang</code> 语言编写，支持只要是你能想到的 <strong>所有编程语言</strong>；</p></li><li><p><strong>管理界面</strong>： <code>RabbitMQ</code> 有一个易用的 <strong>用户界面</strong>，使得用户可以 <strong>监控</strong> 和 <strong>管理</strong> 消息 <code>Broker</code> 的许多方面；</p></li><li><p><strong>跟踪机制</strong>：如果 <strong>消息异常</strong>，<code>RabbitMQ</code> 提供消息跟踪机制，使用者可以找出发生了什么；</p></li><li><p><strong>插件机制</strong>：提供了许多 <strong>插件</strong>，来从多方面进行扩展，也可以编写自己的插件。</p></li></ol><h4 id="b-部署环境-1"><a href="#b-部署环境-1" class="headerlink" title="(b) 部署环境"></a>(b) 部署环境</h4><p><code>RabbitMQ</code> 可以运行在 <code>Erlang</code> 语言所支持的平台之上，包括 <code>Solaris</code>，<code>BSD</code>，<code>Linux</code>，<code>MacOSX</code>，<code>TRU64</code>，<code>Windows</code> 等。使用 <code>RabbitMQ</code> 需要：</p><ul><li><code>ErLang</code> 语言包</li><li><code>RabbitMQ</code> 安装包</li></ul><h4 id="c-优点-1"><a href="#c-优点-1" class="headerlink" title="(c) 优点"></a>(c) 优点</h4><ol><li><p>由于 <code>Erlang</code> 语言的特性，消息队列性能较好，支持 <strong>高并发</strong>；</p></li><li><p>健壮、稳定、易用、<strong>跨平台</strong>、支持 <strong>多种语言</strong>、文档齐全；</p></li><li><p>有消息 <strong>确认机制</strong> 和 <strong>持久化机制</strong>，可靠性高；</p></li><li><p>高度可定制的 <strong>路由</strong>；</p></li><li><p><strong>管理界面</strong> 较丰富，在互联网公司也有较大规模的应用，社区活跃度高。</p></li></ol><h4 id="d-缺点-1"><a href="#d-缺点-1" class="headerlink" title="(d) 缺点"></a>(d) 缺点</h4><ol><li><p>尽管结合 <code>Erlang</code> 语言本身的并发优势，性能较好，但是不利于做 <strong>二次开发和维护</strong>；</p></li><li><p>实现了 <strong>代理架构</strong>，意味着消息在发送到客户端之前可以在 <strong>中央节点</strong> 上排队。此特性使得 <code>RabbitMQ</code> 易于使用和部署，但是使得其 <strong>运行速度较慢</strong>，因为中央节点 <strong>增加了延迟</strong>，<strong>消息封装后</strong> 也比较大；</p></li><li><p>需要学习 <strong>比较复杂</strong> 的 <strong>接口和协议</strong>，学习和维护成本较高。</p></li></ol><h3 id="7-3-RocketMQ"><a href="#7-3-RocketMQ" class="headerlink" title="7.3. RocketMQ"></a>7.3. RocketMQ</h3><p><code>RocketMQ</code> 出自 <strong>阿里</strong> 的开源产品，用 <code>Java</code> 语言实现，在设计时参考了 <code>Kafka</code>，并做出了自己的一些改进，<strong>消息可靠性上</strong> 比 <code>Kafka</code> 更好。<code>RocketMQ</code> 在阿里内部被广泛应用在 <strong>订单</strong>，<strong>交易</strong>，<strong>充值</strong>，<strong>流计算</strong>，<strong>消息推送</strong>，<strong>日志流式处理</strong>，<code>binglog</code> <strong>分发</strong> 等场景。</p><h4 id="a-主要特性-2"><a href="#a-主要特性-2" class="headerlink" title="(a) 主要特性"></a>(a) 主要特性</h4><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ec333c809" alt=""></p><ol><li><p>基于 <strong>队列模型</strong>：具有 <strong>高性能</strong>、<strong>高可靠</strong>、<strong>高实时</strong>、<strong>分布式</strong> 等特点；</p></li><li><p><code>Producer</code>、<code>Consumer</code>、<strong>队列</strong> 都支持 <strong>分布式</strong>；</p></li><li><p><code>Producer</code> 向一些队列轮流发送消息，<strong>队列集合</strong> 称为 <code>Topic</code>。<code>Consumer</code> 如果做 <strong>广播消费</strong>，则一个 <code>Consumer</code> 实例消费这个 <code>Topic</code> 对应的 <strong>所有队列</strong>；如果做 <strong>集群消费</strong>，则 <strong>多个</strong> <code>Consumer</code> 实例 <strong>平均消费</strong> 这个 <code>Topic</code> 对应的队列集合；</p></li><li><p>能够保证 <strong>严格的消息顺序</strong>；</p></li><li><p>提供丰富的 <strong>消息拉取模式</strong>；</p></li><li><p>高效的订阅者 <strong>水平扩展</strong>能力；</p></li><li><p><strong>实时</strong> 的 <strong>消息订阅机制</strong>；</p></li><li><p>亿级 <strong>消息堆积</strong> 能力；</p></li><li><p>较少的外部依赖。</p></li></ol><h4 id="b-部署环境-2"><a href="#b-部署环境-2" class="headerlink" title="(b) 部署环境"></a>(b) 部署环境</h4><p><code>RocketMQ</code> 可以运行在 <code>Java</code> 语言所支持的平台之上。使用 <code>RocketMQ</code> 需要：</p><ul><li><code>Java JDK</code></li><li>安装 <code>git</code>、<code>Maven</code></li><li><code>RocketMQ</code> 安装包</li></ul><h4 id="c-优点-2"><a href="#c-优点-2" class="headerlink" title="(c) 优点"></a>(c) 优点</h4><ol><li><p><strong>单机</strong> 支持 <code>1</code> 万以上 <strong>持久化队列</strong>；</p></li><li><p><code>RocketMQ</code> 的所有消息都是 <strong>持久化的</strong>，先写入系统  <code>PAGECACHE</code>，然后 <strong>刷盘</strong>，可以保证 <strong>内存</strong> 与 <strong>磁盘</strong> 都有一份数据，而 <strong>访问</strong> 时，直接 <strong>从内存读取</strong>。</p></li><li><p>模型简单，接口易用（<code>JMS</code> 的接口很多场合并不太实用）；</p></li><li><p><strong>性能非常好</strong>，可以允许 <strong>大量堆积消息</strong> 在 <code>Broker</code> 中；</p></li><li><p>支持 <strong>多种消费模式</strong>，包括 <strong>集群消费</strong>、<strong>广播消费</strong>等；</p></li><li><p>各个环节 <strong>分布式扩展设计</strong>，支持 <strong>主从</strong> 和 <strong>高可用</strong>；</p></li><li><p>开发度较活跃，版本更新很快。</p></li></ol><h4 id="d-缺点-2"><a href="#d-缺点-2" class="headerlink" title="(d) 缺点"></a>(d) 缺点</h4><ol><li><p>支持的 <strong>客户端语言</strong> 不多，目前是 <code>Java</code> 及 <code>C++</code>，其中 <code>C++</code> 还不成熟；</p></li><li><p><code>RocketMQ</code> 社区关注度及成熟度也不及前两者；</p></li><li><p>没有 <code>Web</code> 管理界面，提供了一个 <code>CLI</code> (命令行界面) 管理工具带来 <strong>查询</strong>、<strong>管理</strong> 和 <strong>诊断各种问题</strong>；</p></li><li><p>没有在 <code>MQ</code> 核心里实现 <code>JMS</code> 等接口；</p></li></ol><h3 id="7-4-Kafka"><a href="#7-4-Kafka" class="headerlink" title="7.4. Kafka"></a>7.4. Kafka</h3><p><code>Apache Kafka</code> 是一个 <strong>分布式消息发布订阅</strong> 系统。它最初由 <code>LinkedIn</code> 公司基于独特的设计实现为一个 <strong>分布式的日志提交系统</strong> (<code>a distributed commit log</code>)，之后成为 <code>Apache</code> 项目的一部分。<code>Kafka</code> <strong>性能高效</strong>、<strong>可扩展良好</strong> 并且 <strong>可持久化</strong>。它的 <strong>分区特性</strong>，<strong>可复制</strong> 和 <strong>可容错</strong> 都是其不错的特性。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ec4ba760a?w=708&amp;h=364&amp;f=png&amp;s=55959" alt=""></p><h4 id="a-主要特性-3"><a href="#a-主要特性-3" class="headerlink" title="(a) 主要特性"></a>(a) 主要特性</h4><ol><li><p><strong>快速持久化</strong>：可以在 <code>O(1)</code> 的系统开销下进行 <strong>消息持久化</strong>；</p></li><li><p><strong>高吞吐</strong>：在一台普通的服务器上既可以达到 <code>10W/s</code> 的 <strong>吞吐速率</strong>；</p></li><li><p><strong>完全的分布式系统</strong>：<code>Broker</code>、<code>Producer</code> 和 <code>Consumer</code> 都原生自动支持 <strong>分布式</strong>，自动实现 <strong>负载均衡</strong>；</p></li><li><p>支持 <strong>同步</strong> 和 <strong>异步</strong> 复制两种 <strong>高可用机制</strong>；</p></li><li><p>支持 <strong>数据批量发送</strong> 和 <strong>拉取</strong>；</p></li><li><p><strong>零拷贝技术(zero-copy)</strong>：减少 <code>IO</code> 操作步骤，提高 <strong>系统吞吐量</strong>；</p></li><li><p><strong>数据迁移</strong>、<strong>扩容</strong> 对用户透明；</p></li><li><p><strong>无需停机</strong> 即可扩展机器；</p></li><li><p><strong>其他特性</strong>：丰富的 <strong>消息拉取模型</strong>、高效 <strong>订阅者水平扩展</strong>、实时的 <strong>消息订阅</strong>、亿级的 <strong>消息堆积能力</strong>、定期删除机制；</p></li></ol><h4 id="b-部署环境-3"><a href="#b-部署环境-3" class="headerlink" title="(b) 部署环境"></a>(b) 部署环境</h4><p>使用 <code>Kafka</code> 需要：</p><ul><li><code>Java JDK</code></li><li><code>Kafka</code> 安装包</li></ul><h4 id="c-优点-3"><a href="#c-优点-3" class="headerlink" title="(c) 优点"></a>(c) 优点</h4><ol><li><p><strong>客户端语言丰富</strong>：支持 <code>Java</code>、<code>.Net</code>、<code>PHP</code>、<code>Ruby</code>、<code>Python</code>、<code>Go</code> 等多种语言；</p></li><li><p><strong>高性能</strong>：单机写入 <code>TPS</code> 约在 <code>100</code> 万条/秒，消息大小 <code>10</code> 个字节；</p></li><li><p>提供 <strong>完全分布式架构</strong>，并有 <code>replica</code> 机制，拥有较高的 <strong>可用性</strong> 和 <strong>可靠性</strong>，理论上支持 <strong>消息无限堆积</strong>；</p></li><li><p>支持批量操作；</p></li><li><p><strong>消费者</strong> 采用 <code>Pull</code> 方式获取消息。<strong>消息有序</strong>，<strong>通过控制</strong> 能够保证所有消息被消费且仅被消费 <strong>一次</strong>；</p></li><li><p>有优秀的第三方 <code>Kafka Web</code> 管理界面 <code>Kafka-Manager</code>；</p></li><li><p>在 <strong>日志领域</strong> 比较成熟，被多家公司和多个开源项目使用。</p></li></ol><h4 id="d-缺点-3"><a href="#d-缺点-3" class="headerlink" title="(d) 缺点"></a>(d) 缺点</h4><ol><li><p><code>Kafka</code> 单机超过 <code>64</code> 个 <strong>队列/分区</strong> 时，<code>Load</code> 时会发生明显的飙高现象。<strong>队列</strong> 越多，<strong>负载</strong> 越高，发送消息 <strong>响应时间变长</strong>；</p></li><li><p>使用 <strong>短轮询方式</strong>，<strong>实时性</strong> 取决于 <strong>轮询间隔时间</strong>；</p></li><li><p>消费失败 <strong>不支持重试</strong>；</p></li><li><p>支持 <strong>消息顺序</strong>，但是 <strong>一台代理宕机</strong> 后，就会产生 <strong>消息乱序</strong>；</p></li><li><p>社区更新较慢。</p></li></ol><h3 id="7-5-几种消息队列对比"><a href="#7-5-几种消息队列对比" class="headerlink" title="7.5. 几种消息队列对比"></a>7.5. 几种消息队列对比</h3><p>这里列举了上述四种消息队列的差异对比：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16479c8ecf7ad3ef?w=793&amp;h=812&amp;f=png&amp;s=61730" alt=""></p><p><code>Kafka</code> 在于 <strong>分布式架构</strong>，<code>RabbitMQ</code> 基于 <code>AMQP</code> <strong>协议</strong> 来实现，<code>RocketMQ</code> 的思路来源于 <code>Kafka</code>，改成了 <strong>主从结构</strong>，在 <strong>事务性</strong> 和 <strong>可靠性</strong> 方面做了优化。广泛来说，<strong>电商</strong>、<strong>金融</strong> 等对 <strong>事务一致性</strong> 要求很高的，可以考虑 <code>RabbitMQ</code> 和 <code>RocketMQ</code>，对 <strong>性能要求高</strong> 的可考虑 <code>Kafka</code>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了消息队列的特点，消息队列的 <strong>传递服务模型</strong>，消息的 <strong>传输方式</strong>，消息的 <strong>推拉模式</strong>。然后介绍了 <code>ActiveMQ</code>，<code>RabbitMQ</code>，<code>RocketMQ</code> 和 <code>Kafka</code> 几种常见的消息队列，阐述了 <strong>各种消息队列</strong> 的 <strong>主要特点</strong> 和 <strong>优缺点</strong>。通过本文，对于消息队列及相关技术选型，相信你会有了更深入的理解和认识。更多细节和原理性的东西，还需在实践中见真知！</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5dcc40392?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt; 已经逐渐成为企业应用系统 &lt;strong&gt;内部通信&lt;/strong&gt; 的核心手段。它具有 &lt;strong&gt;低耦合&lt;/strong&gt;、&lt;strong&gt;可靠投递&lt;/strong&gt;、&lt;strong&gt;广播&lt;/strong&gt;、&lt;strong&gt;流量控制&lt;/strong&gt;、&lt;strong&gt;最终一致性&lt;/strong&gt; 等一系列功能。&lt;/p&gt;
&lt;p&gt;当前使用较多的 &lt;strong&gt;消息队列&lt;/strong&gt; 有 &lt;code&gt;RabbitMQ&lt;/code&gt;、&lt;code&gt;RocketMQ&lt;/code&gt;、&lt;code&gt;ActiveMQ&lt;/code&gt;、&lt;code&gt;Kafka&lt;/code&gt;、&lt;code&gt;ZeroMQ&lt;/code&gt;、&lt;code&gt;MetaMQ&lt;/code&gt; 等，而部分 &lt;strong&gt;数据库&lt;/strong&gt; 如 &lt;code&gt;Redis&lt;/code&gt;、&lt;code&gt;MySQL&lt;/code&gt; 以及 &lt;code&gt;phxsql&lt;/code&gt; 也可实现消息队列的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="消息队列系列" scheme="https://ostenant.coding.me/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="消息队列" scheme="https://ostenant.coding.me/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="ActiveMQ" scheme="https://ostenant.coding.me/tags/ActiveMQ/"/>
    
      <category term="RabbitMQ" scheme="https://ostenant.coding.me/tags/RabbitMQ/"/>
    
      <category term="RocketMQ" scheme="https://ostenant.coding.me/tags/RocketMQ/"/>
    
      <category term="Kafka" scheme="https://ostenant.coding.me/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>浅谈SAML, OAuth, OpenID和SSO, JWT和Session</title>
    <link href="https://ostenant.coding.me/2018/07/05/%E6%B5%85%E8%B0%88SAML,%20OAuth,%20OpenID%E5%92%8CSSO,%20JWT%E5%92%8CSession/"/>
    <id>https://ostenant.coding.me/2018/07/05/浅谈SAML, OAuth, OpenID和SSO, JWT和Session/</id>
    <published>2018-07-05T05:50:00.000Z</published>
    <updated>2018-07-05T14:27:53.562Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常为了弄清楚一个概念，我们需要掌握十个概念。在判断 <code>JWT(JsonWebToken)</code> 是否能代替 <code>session</code> 管理之前，我们要了解什么是 <code>token</code>，以及 <code>access token</code> 和 <code>refresh token</code> 的区别。</p><a id="more"></a><p>了解什么是 <code>OAuth</code>，什么是 <code>SSO</code>，<code>SSO</code> 下不同策略 <code>OAuth</code> 和 <code>SAML</code> 的不同，以及 <code>OAuth</code> 与 <code>OpenID</code> 的不同，更重要的是区分 <code>authorisation</code> 和 <code>authentication</code>。</p><p>最后我们引出 <code>JSON WEB TOKEN</code>，聊聊 <code>JWT</code> 在 <code>Session</code> 管理方面的优势和劣势，同时尝试解决这些劣势，看看成本和代价有多少。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/OAuth_logo.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文关于 <code>OAuth</code> <strong>授权</strong> 和 <code>API</code> 调用实例都来自 <code>Google API</code>。</p><h2 id="关于Token"><a href="#关于Token" class="headerlink" title="关于Token"></a>关于Token</h2><p><code>Token</code> 即使是在计算机领域中也有不同的定义，这里我们说的 <code>token</code>，是指 <strong>访问资源</strong> 的凭据。例如当你调用 <code>Google API</code> 时，需要带上有效 <code>token</code> 来表明你请求的 <strong>合法性</strong>。这个 <code>Token</code> 是 <code>Google</code> 给你的，这代表 <code>Google</code> 给你的 <strong>授权</strong> 使得你有能力访问 <code>API</code> 背后的 <strong>资源</strong>。</p><p>请求 <code>API</code> 时携带 <code>token</code> 的方式也有很多种，通过 <code>HTTP Header</code> 或者 <code>url</code> 参数或者 <code>google</code> 提供的类库都可以：</p><ul><li><strong>HTTP Header</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /drive/v2/files HTTP/1.1</span><br><span class="line"></span><br><span class="line">Authorization: Bearer &lt;token&gt;</span><br><span class="line">Host: www.googleapis.com/</span><br></pre></td></tr></table></figure><ul><li><strong>URL参数</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://www.googleapis.com/drive/v2/files?token=&lt;token&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>Python函数库</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> googleapiclient.discovery <span class="keyword">import</span> build</span><br><span class="line">drive = build(<span class="string">'drive'</span>, <span class="string">'v2'</span>, credentials=credentials)</span><br></pre></td></tr></table></figure><p>更具体的说，上面用于调用 <code>API</code> 的 <code>token</code>，我们称为细分为 <code>access token</code>。通常 <code>access token</code> 是有 <strong>有效期限</strong> 的，如果 <strong>过期</strong> 就需要 <strong>重新获取</strong>。那么如何重新获取？先看看第一次获取 <code>token</code> 的流程是怎样的:</p><ol><li><p>首先需要向 <code>Google API</code> 注册一个应用程序，注册完毕之后就会拿到 <strong>认证信息</strong>（<code>credentials</code>）包括 <code>ID</code> 和 <code>secret</code>。不是所有的程序类型都有 <code>secret</code>。</p></li><li><p>接下来就要向 <code>Google</code> 请求 <code>access token</code>。这里先忽略一些细节，例如请求参数（当然需要上面申请到的 <code>secret</code>）。重要的是，如果你想访问的是 <strong>用户资源</strong>，这里就会提醒用户进行 <strong>授权</strong>。</p></li><li><p>如果 <strong>用户授权</strong> 完毕。<code>Google</code> 就会返回 <code>access token</code>。又或者是返回 <strong>授权代码</strong>（<code>authorization code</code>），再通过代码取得 <code>access token</code>。</p></li></ol><p><code>token</code> 获取到之后，就能够带上 <code>token</code> 访问 <code>API</code> 了。</p><p>流程如下图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Token_flow.webp" alt=""></p><blockquote><p>注意：在第三步通过 <code>authorization code</code> 兑换 <code>access token</code> 的过程中，<code>Google</code> 并不会仅仅返回 <code>access token</code>，还会返回额外的信息，这其中和之后更新相关的就是 <code>refresh token</code>。</p></blockquote><p>一旦 <code>access token</code> 过期，你就可以通过 <code>refresh token</code> 再次请求 <code>access token</code>。</p><p>以上只是大致的流程，并且故意省略了一些额外的概念。比如更新 <code>access token</code> 当然也可以不需要 <code>refresh token</code>，这要根据你的 <strong>请求方式</strong> 和访问的 <strong>资源类型</strong> 而定。</p><p>这里又会引起另外的两个问题：</p><ol><li><p>如果 <code>refesh token</code> 也过期了怎么办？这时就需要用户 <strong>重新登陆授权</strong>。</p></li><li><p>为什么要区分 <code>refresh token</code> 和 <code>access token</code>？如果合并成一个 <code>token</code> 然后把 <strong>过期时间</strong> 调整的 <strong>更长</strong>，并且每次 <strong>失效</strong> 之后用户 <strong>重新登陆授权</strong> 就好了？这个问题会和后面谈的相关概念有关，后面会给予解释说明。</p></li></ol><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>从获取 <code>token</code> 到使用 <code>token</code> 访问接口。这其实是标准的 <code>OAuth2.0</code> 机制下访问 <code>API</code> 的流程。这里介绍一下 <code>OAuth</code> 里外相关的概念，更深入的理解 <code>token</code> 的作用。</p><h3 id="SSO-Single-sign-on"><a href="#SSO-Single-sign-on" class="headerlink" title="SSO (Single sign-on)"></a>SSO (Single sign-on)</h3><p>通常公司内部会有非常多的平台供大家使用，比如人力资源，代码管理，日志监控，预算申请等等。如果每一个平台都实现自己的用户体系的话无疑是巨大的浪费，所以公司内部会有一套 <strong>公用的用户体系</strong>，用户只要登陆之后，就能够 <strong>访问所有的系统</strong>。这就是 <strong>单点登录</strong>。</p><p><code>SSO</code> 是一类 <strong>解决方案</strong> 的统称，而在具体的实施方面，我们有两种策略可供选择：</p><ul><li><p><strong>SAML 2.0</strong></p></li><li><p><strong>OAuth 2.0</strong></p></li></ul><p>接下来我们区别这 <strong>两种授权方式</strong> 有什么不同。但是在描述 <strong>不同的策略</strong> 之前，我们先叙述几个 <strong>共有的特性</strong>，并且相当重要的概念。</p><h4 id="Authentication-VS-Authorisation"><a href="#Authentication-VS-Authorisation" class="headerlink" title="Authentication VS Authorisation"></a>Authentication VS Authorisation</h4><ul><li><p><strong>Authentication:</strong> 身份鉴别，以下简称 <strong>认证</strong>；</p></li><li><p><strong>Authorisation:</strong> 资源访问 <strong>授权</strong>。</p></li></ul><p><strong>认证</strong> 的作用在于 <strong>认可</strong> 你能够访问系统，用于 <strong>鉴别访问者</strong> 是否是 <strong>合法用户</strong>；而 <strong>授权</strong> 用于决定你有访问 <strong>哪些资源的权限</strong>。</p><p>大多数人不会区分这两者的区别，因为站在用户的立场上。而作为系统的设计者来说，这两者是有差别的，这是不同的两个工作职责。我们可以只需要 <strong>认证功能</strong>，而不需要 <strong>授权功能</strong>，甚至不需要自己实现 <strong>认证功能</strong>。而借助 <code>Google</code> 的认证系统，即用户可以用 <code>Google</code> 的账号进行登陆。</p><h4 id="Authorization-Server-Identity-Provider-IdP"><a href="#Authorization-Server-Identity-Provider-IdP" class="headerlink" title="Authorization Server/Identity Provider(IdP)"></a>Authorization Server/Identity Provider(IdP)</h4><p>把负责 <strong>认证的服务</strong> 称为 <code>AuthorizationServer</code> 或者 <code>IdentityProvider</code>，以下简称 <code>IDP</code>。</p><h4 id="Service-Provider-SP-Resource-Server"><a href="#Service-Provider-SP-Resource-Server" class="headerlink" title="Service Provider(SP)/Resource Server"></a>Service Provider(SP)/Resource Server</h4><p>把负责 <strong>提供资源</strong>（<code>API</code> 调用）的服务称为 <code>ResourceServer</code> 或者 <code>ServiceProvider</code>，以下简称 <code>SP</code>。</p><h3 id="SAML-2-0"><a href="#SAML-2-0" class="headerlink" title="SAML 2.0"></a>SAML 2.0</h3><p>下图是 <code>SAML2.0</code> 的流程图，看图说话：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/SAML_2" alt=""></p><ol><li><p>还 <strong>未登陆</strong> 的用户 <strong>打开浏览器</strong> 访问你的网站（<code>SP</code>），网站 <strong>提供服务</strong> 但是并 <strong>不负责用户认证</strong>。</p></li><li><p>于是 <code>SP</code> 向 <code>IDP</code> 发送了一个 <code>SAML</code> 认证请求，同时 <code>SP</code> 将 <strong>用户浏览器</strong> 重定向到 <code>IDP</code>。</p></li><li><p><code>IDP</code> 在验证完来自 <code>SP</code> 的 <strong>请求无误</strong> 之后，在浏览器中呈现 <strong>登陆表单</strong> 让用户填写 <strong>用户名</strong> 和 <strong>密码</strong> 进行登陆。</p></li><li><p>一旦用户登陆成功， <code>IDP</code> 会生成一个包含 <strong>用户信息</strong>（<strong>用户名</strong> 或者 <strong>密码</strong>）的 <code>SAML token</code>（<code>SAML token</code> 又称为 <code>SAML Assertion</code>，本质上是 <code>XML</code> 节点）。<code>IDP</code> 向 <code>SP</code> 返回 <code>token</code>，并且将 <strong>用户重定向</strong> 到 <code>SP</code> (<code>token</code> 的返回是在 <strong>重定向步骤</strong> 中实现的，下面会详细说明)。</p></li><li><p><code>SP</code> 对拿到的 <code>token</code> 进行验证，并从中解析出 <strong>用户信息</strong>，例如 <strong>用户是谁</strong> 以及 <strong>用户的权限</strong> 有哪些。此时就能够根据这些信息允许用户访问我们网站的内容。</p></li></ol><p>当用户在 <code>IDP</code> 登陆成功之后，<code>IDP</code> 需要将用户 <strong>再次重定向</strong> 到 <code>SP</code> 站点，这一步通常有两个办法：</p><ul><li><p><code>HTTP</code> 重定向：这并不推荐，因为 <strong>重定向</strong> 的 <code>URL</code> 长度 <strong>有限制</strong>，无法携带更长的信息，比如 <code>SAML Token</code>。</p></li><li><p><code>HTTP POST</code> 请求：这个是更常规的做法，当用户登陆完毕之后渲染出一个表单，用户点击后向 <code>SP</code> 提交 <code>POST</code> 请求。又或者可以使用 <code>JavaScript</code> 向 <code>SP</code> 发出一个 <code>POST</code> 请求。</p></li></ul><p>如果你的应用是基于 <code>Web</code>，那么以上的方案没有任何问题。但如果你开发的是一个 <code>iOS</code> 或者 <code>Android</code> 的手机应用，那么问题就来了：</p><ol><li><p>用户在 <code>iPhone</code> 上打开应用，此时用户需要通过 <code>IDP</code> 进行认证。</p></li><li><p>应用跳转至 <code>Safari</code> 浏览器，在登陆认证完毕之后，需要通过 <code>HTTP POST</code> 的形式将 <code>token</code> 返回至 <strong>手机应用</strong>。</p></li></ol><p>虽然 <code>POST</code> 的 <code>url</code> 可以 <strong>拉起应用</strong>，但是 <strong>手机应用</strong> 无法解析 <code>POST</code> 的内容，我们也就无法读取 <code>SAML Token</code>。</p><blockquote><p>当然还是有办法的，比如在 <code>IDP</code> <strong>授权阶段</strong> 不跳转至系统的 <code>Safari</code> 浏览器，在 <strong>内嵌</strong> 的 <code>Webview</code> 中解决，在想方设法从 <code>Webview</code> 中提取 <code>token</code>，或者利用 <strong>代理服务器</strong>。</p></blockquote><p>无论如何，<code>SAML 2.0</code> 并 <strong>不适用</strong> 于当下 <strong>跨平台</strong> 的场景，这也许与它产生的年代也有关系，它诞生于 <code>2005</code> 年，在那个时刻 <code>HTTP POST</code> 确实是最好的选择方案。</p><h3 id="OAuth-2-0-1"><a href="#OAuth-2-0-1" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>我们先简单了解 <code>SSO</code> 下的 <code>OAuth2.0</code> 的流程。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Oauth_process" alt=""></p><ol><li><p>用户通过 <strong>客户端</strong>（可以是 <strong>浏览器</strong> 也可以是 <strong>手机应用</strong>）想要访问 <code>SP</code> 上的资源，但是 <code>SP</code> 告诉用户需要进行 <strong>认证</strong>，将用户 <strong>重定向</strong> 至 <code>IDP</code>。</p></li><li><p><code>IDP</code> 向 <strong>用户</strong> 询问 <code>SP</code> 是否可以访问 <strong>用户信息</strong>。如果用户同意，<code>IDP</code> 向 <strong>客户端</strong> 返回 <code>authorization code</code>。</p></li><li><p>客户端拿到 <code>authorization code</code> 向 <code>IDP</code> 交换 <code>access token</code>，并拿着 <code>access token</code> 向 <code>SP</code> 请求资源。</p></li><li><p><code>SP</code> 接受到请求之后，拿着附带的 <code>token</code> 向 <code>IDP</code> 验证 <strong>用户的身份</strong>。确认身份无误后，<code>SP</code> 向 <strong>客户端</strong> 发放相关资源。</p></li></ol><p>那么 <code>OAuth</code> 是如何避免 <code>SAML</code> 流程下 <strong>无法解析</strong> <code>POST</code> 内容的信息的呢？</p><ul><li><p>一方面是用户从 <code>IDP</code> 返回 <strong>客户端</strong> 的方式，也是通过 <code>URL</code> 重定向，这里的 <code>URL</code> 允许 <strong>自定义</strong> <code>schema</code>，所以即使在 <strong>手机</strong> 上也能 <strong>拉起应用</strong>；</p></li><li><p>另一方面因为 <code>IDP</code> 向 <strong>客户端</strong> 传递的是 <code>authorization code</code>，而不是 <code>XML</code> 信息，所以 <code>code</code> 可以很轻易的附着在 <strong>重定向</strong> <code>URL</code> 上进行传递。</p></li></ul><p>但以上的 <code>SSO</code> 流程体现不出 <code>OAuth</code> 的本意。<code>OAuth</code> 的本意是 <strong>一个应用</strong> 允许 <strong>另一个应用</strong> 在 <strong>用户授权</strong> 的情况下 <strong>访问自己的数据</strong>。</p><p><code>OAuth</code> 的设计本意更倾向于 <strong>授权而非认证</strong>（当然授权用户信息就间接实现了认证），虽然 <code>Google</code> 的 <code>OAuth 2.0 API</code> 同时支持 <strong>授权</strong> 和 <strong>认证</strong>。所以你在使用 <code>Facebook</code> 或者 <code>Gmail</code> 账号登陆第三方站点时，会出现 <strong>授权对话框</strong>，告诉你 <strong>第三方站点</strong> 可以访问你的哪些信息，需要征得你的同意。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Google_gmail" alt=""></p><p>在上面 <code>SSO</code> 的 <code>OAuth</code> 流程中涉及三方角色: <code>SP</code>, <code>IDP</code> 以及 <code>Client</code>。但在实际工作中 <code>Client</code> 可以是不存在的，例如你编写了一个 <strong>后端程序</strong> 定时的通过 <code>Google API</code> 从 <code>Youtube</code> 拉取最新的节目数据，那么你的 <strong>后端程序</strong> 需要得到 <code>Youtube</code> 的 <code>OAuth</code> <strong>授权</strong> 即可。</p><h3 id="OAuth-VS-OpenId"><a href="#OAuth-VS-OpenId" class="headerlink" title="OAuth VS OpenId"></a>OAuth VS OpenId</h3><p>如果你有留心的话，你会在某些站点看到允许以 <code>OpenID</code> 的方式登陆，其实也就是以 <code>Facebook</code> 账号或者 <code>Google</code> 账号登陆站点：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/OpenID" alt=""></p><p><code>OpenID</code> 和 <code>OAuth</code> 很像。但本质上来说它们是截然不同的两个东西：</p><ul><li><p><strong>OpenID:</strong> 只用于 <strong>身份认证</strong>（<code>Authentication</code>），允许你以 <strong>同一个账户</strong> 在 <strong>多个网站登陆</strong>。它仅仅是为你的 <strong>合法身份</strong> 背书，当你以 <code>Facebook</code> 账号登陆某个站点之后，该站点 <strong>无权访问</strong> 你的在 <code>Facebook</code> 上的 <strong>数据</strong>。</p></li><li><p><strong>OAuth:</strong> 用于 <strong>授权</strong>（<code>Authorisation</code>），允许 <strong>被授权方</strong> 访问 <strong>授权方</strong> 的 <strong>用户数据</strong>。</p></li></ul><h4 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h4><p>现在可以回答上面的问题了，为什么我们需要 <code>refresh token</code>？</p><p>这样的处理是为了 <strong>职责的分离</strong>：</p><ul><li><p><strong>refresh token:</strong> 负责 <strong>身份认证</strong>；</p></li><li><p><strong>access token:</strong> 负责 <strong>请求资源</strong>。</p></li></ul><p>虽然 <code>refresh token</code> 和 <code>access token</code> 都由 <code>IDP</code> 发出，但是 <code>access token</code> 还要和 <code>SP</code> 进行 <strong>数据交换</strong>，如果 <strong>公用的话</strong> 这样就会有 <strong>身份泄露</strong> 的可能。并且 <code>IDP</code> 和 <code>SP</code> 可能是 <strong>完全不同</strong> 的 <strong>服务提供</strong> 的。而在上文，我们之所以没有这样的顾虑是因为 <code>IDP</code> 和 <code>SP</code> 都是 <code>Google</code>。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><h4 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h4><p>本质上来说 <code>JWT</code> 也是 <code>token</code>，正如我们在上文提到的，它是 <strong>访问资源</strong> 的 <strong>凭证</strong>。</p><p><code>Google</code> 的一些 <code>API</code> 诸如 <code>Prediction API</code> 或者 <code>Google Cloud Storage</code>，是不需要 <strong>访问</strong> 用户的 <strong>个人数据</strong> 的。因而不需要经过 <strong>用户的授权</strong> 这一步骤，应用程序可以直接访问。就像上面 <code>OAuth</code> 中没有 <code>Client</code> 没有参与的流程类似。这就要借助 <code>JWT</code> 完成访问了, 具体流程如下：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Auth_Resource" alt=""></p><ol><li><p>首先需要在 <code>Google API</code> 上创建一个服务账号（<code>service account</code>）。</p></li><li><p>获取 <strong>服务账号</strong> 的 <strong>认证信息</strong>（<code>credential</code>），包括 <strong>邮箱地址</strong>，<code>client ID</code>，以及一对 <strong>公钥/私钥</strong>。</p></li><li><p>使用 <code>Client ID</code> 和 <strong>私钥</strong> 创一个 <strong>签名</strong> 的 <code>JWT</code>，然后将这个 <code>JWT</code> 发送给 <code>Google</code> 交换 <code>access token</code>。</p></li><li><p><code>Google</code> 返回 <code>access token</code>。</p></li><li><p>程序通过 <code>access token</code> 访问 <code>API</code>。</p></li></ol><p>甚至你可以不需要向 <code>Google</code> 索要 <code>access token</code>，而是携带 <code>JWT</code> 作为 <code>HTTP header</code> 里的 <code>bearer token</code> 直接访问 <code>API</code> 也是可以的。这才是 <code>JWT</code> 的最大魅力。</p><h4 id="理性认识"><a href="#理性认识" class="headerlink" title="理性认识"></a>理性认识</h4><p><code>JWT</code> 顾名思义，它是 <code>JSON</code> 结构的 <code>token</code>，由三部分组成：</p><ul><li><p><strong>header</strong></p></li><li><p><strong>payload</strong></p></li><li><p><strong>signature</strong></p></li></ul><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p><code>header</code> 用于描述 <strong>元信息</strong>，例如产生 <code>signature</code> 的算法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">    <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>alg</code> 关键字就指定了使用哪一种 <strong>哈希算法</strong> 来创建 <code>signature</code>。</p><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p><code>payload</code> 用于携带你希望 <strong>向服务端传递</strong> 的信息。你既可以往里添加 <strong>官方字段</strong>，例如：<code>iss(Issuer)</code>, <code>sub(Subject)</code>, <code>exp(Expirationtime)</code>，也可以塞入 <strong>自定义的字段</strong>，比如 <code>userId</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p><code>signature</code> 译为 <strong>签名</strong>，创建签名要分以下几个步骤：</p><ol><li><p>从 <strong>接口服务端</strong> 拿到 <strong>密钥</strong>，假设为 <code>secret</code>。</p></li><li><p>对 <code>header</code> 进行 <code>base64</code> 编码，假设结果为 <code>headerStr</code>。</p></li><li><p>将 <code>payload</code> 进行 <code>base64</code> 编码，假设结果为 <code>payloadStr</code>。</p></li><li><p>将 <code>headerStr</code> 和 <code>payloadStr</code> 用 <code>.</code> <strong>字符</strong> 拼装起来成为字符 <code>data</code>。</p></li><li><p>以 <code>data</code> 和 <code>secret</code> 作为参数，使用 <strong>哈希算法</strong> 计算出 <strong>签名</strong>。</p></li></ol><p>如果上述描述还不直观，用 <strong>伪代码</strong> 表示就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Signature algorithm</span><br><span class="line">data = base64urlEncode( header ) + “.” + base64urlEncode( payload )</span><br><span class="line">signature = Hash( data, secret );</span><br></pre></td></tr></table></figure><p>假设我们的原始 <code>JSON</code> 结构是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Header</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">    <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Payload</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <strong>密钥</strong> 是字符串 <code>secret</code> 的话，那么最终 <code>JWT</code> 的结果就是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM</span><br></pre></td></tr></table></figure><blockquote><p>可以在 <code>jwt.io</code> 上 <strong>验证</strong> 这个结果。</p></blockquote><h3 id="JWT究竟带来了什么"><a href="#JWT究竟带来了什么" class="headerlink" title="JWT究竟带来了什么"></a>JWT究竟带来了什么</h3><h4 id="确保数据完整性"><a href="#确保数据完整性" class="headerlink" title="确保数据完整性"></a>确保数据完整性</h4><p><code>JWT</code> 的目的不是为了 <strong>隐藏</strong> 或者 <strong>保密数据</strong>，而是为了确保 <strong>数据</strong> 确实来自被 <strong>授权的人</strong> 创建的，以防止 <strong>中途篡改</strong>。</p><p>回想一下，当你拿到 <code>JWT</code> 时候，你完全可以在没有 <code>secret</code> 的情况下解码出 <code>header</code> 和 <code>payload</code>，因为 <code>header</code> 和 <code>payload</code> 只是经过了 <code>base64</code> 编码（<code>encode</code>）而已，编码的目的在于 <strong>利于数据结构的传输</strong>。</p><p>虽然创建 <code>signature</code> 的过程近似于 <strong>加密</strong> (<code>encrypt</code>)，但本质其实是一种 <strong>签名</strong> (<code>sign</code>) 的行为，用于保证 <strong>数据的完整性</strong>，实际上也并且并 <strong>没有加密任何数据</strong>。</p><h4 id="用于接口调用"><a href="#用于接口调用" class="headerlink" title="用于接口调用"></a>用于接口调用</h4><p>接下来在 <code>API</code> 调用中就可以附上 <code>JWT</code>（通常是在 <code>HTTP Header</code> 中）。又因为 <code>SP</code> 会与程序 <strong>共享</strong> 一个 <code>secret</code>，所以 <strong>程序</strong> 可以通过 <code>header</code> 提供的相同的 <code>hash</code> 算法来 <strong>验证签名</strong> 是否正确，从而判断应用是否有权力调用 <code>API</code>。</p><h3 id="有状态的对话Session"><a href="#有状态的对话Session" class="headerlink" title="有状态的对话Session"></a>有状态的对话Session</h3><p>因为 <code>HTTP</code> 是 <strong>无状态</strong> 的，所以 <strong>客户端</strong> 和 <strong>服务端</strong> 需要解决的问题是，如何让它们之间的对话变得有状态。例如只有是 <strong>登陆状态</strong> 的 <strong>用户</strong> 才有权限调用某些接口，那么在 <strong>用户登陆</strong> 之后，需要记住该用户是 <strong>已经登陆</strong> 的状态。常见的方法是使用 <code>session</code> 机制。</p><p>常见的 <code>session</code> 模型是这样工作的：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Session_Flow" alt=""></p><ol><li><p>用户在浏览器 <strong>登陆</strong> 之后，服务端为用户生成 <strong>唯一</strong> 的 <code>session id</code>，存储在 <strong>服务端</strong> 的 <strong>存储服务</strong>（例如 <code>MySQL</code>, <code>Redis</code>）中。</p></li><li><p>该 <code>session id</code> 也同时 <strong>返回给浏览器</strong>，以 <code>SESSION_ID</code> 为 <code>KEY</code> 存储在浏览器的 <code>cookie</code> 中。</p></li><li><p>如果用户再次访问该网站，<code>cookie</code> 里的 <code>SESSION_ID</code> 会随着 <strong>请求</strong> 一同发往 <strong>服务端</strong>。</p></li><li><p>服务端通过判断 <code>SESSION_ID</code> 是否已经在 <code>Redis</code> 中判断用户是否处于 <strong>登陆状态</strong>。</p></li></ol><p>相信你已经察觉了，理论上来说，<code>JWT</code> 机制可以取代 <code>session</code> 机制。用户不需要提前进行登陆，后端也不需要 <code>Redis</code> 记录用户的登陆信息。客户端的本地保存一份合法的 <code>JWT</code>，当用户需要调用接口时，附带上该合法的 <code>JWT</code>，每一次调用接口，后端都使用请求中附带的 <code>JWT</code> 做一次 <strong>合法性的验证</strong>。这样也间接达到了 <strong>认证用户</strong> 的目的。</p><p>然而 <code>JWT</code> 真的能取代 <code>session</code> 机制吗？这么做有哪些好处和坏处？这些问题将留在下一篇再讨论。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通常为了弄清楚一个概念，我们需要掌握十个概念。在判断 &lt;code&gt;JWT(JsonWebToken)&lt;/code&gt; 是否能代替 &lt;code&gt;session&lt;/code&gt; 管理之前，我们要了解什么是 &lt;code&gt;token&lt;/code&gt;，以及 &lt;code&gt;access token&lt;/code&gt; 和 &lt;code&gt;refresh token&lt;/code&gt; 的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="认证与授权系列" scheme="https://ostenant.coding.me/categories/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SAML" scheme="https://ostenant.coding.me/tags/SAML/"/>
    
      <category term="OAuth" scheme="https://ostenant.coding.me/tags/OAuth/"/>
    
      <category term="SSO" scheme="https://ostenant.coding.me/tags/SSO/"/>
    
      <category term="JWT" scheme="https://ostenant.coding.me/tags/JWT/"/>
    
      <category term="Session" scheme="https://ostenant.coding.me/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>浅谈分布式存储系统的数据分布算法</title>
    <link href="https://ostenant.coding.me/2018/07/01/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%08%E6%8D%AE%E5%88%86%E5%B8%83%E7%AE%97%E6%B3%95/"/>
    <id>https://ostenant.coding.me/2018/07/01/浅谈分布式存储系统的数据分布算法/</id>
    <published>2018-07-01T09:43:00.000Z</published>
    <updated>2018-07-01T13:01:25.154Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>分布式存储系统</strong> 面临着的首要问题，就是如何将 <strong>大量的数据</strong> 分布在 <strong>不同的存储节点</strong> 上。无论上层接口是 <code>KV</code> <strong>存储</strong>、<strong>对象存储</strong>、<strong>块存储</strong>、亦或是 <strong>列存储</strong>，在这个问题上大体是一致的。本文将介绍如何 <strong>分布式存储系统</strong> 中 <strong>做数据分布目标</strong> 及可选的 <strong>方案</strong>，并试着总结和权衡他们之间的关系及。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一-指标"><a href="#一-指标" class="headerlink" title="(一) 指标"></a>(一) 指标</h2><p>这里假设 <strong>目标数据</strong> 是以 <code>key</code> 标识的 <strong>数据块</strong> 或 <strong>对象</strong>。在一个包含 <strong>多个存储节点</strong> 的集群中，<strong>数据分布算法</strong> 需要为每一个给定的 <code>key</code> 指定 <strong>一个</strong> 或 <strong>多个</strong> 对应的 <strong>存储节点</strong> 负责，<strong>数据分布算法</strong> 有两个基本目标：</p><ul><li><p><strong>均匀性(Uniformity)</strong>：不同存储节点的 <strong>负载</strong> 应该 <strong>均衡</strong>；</p></li><li><p><strong>稳定性(Consistency)</strong>：每次一个 <code>key</code> 通过 <strong>数据分布算法</strong> 得到的 <strong>分布结果</strong> 应该保持 <strong>基本稳定</strong>，即使再有存储节点发生变化的情况下。</p></li></ul><p>可以看出，这两个目标在一定程度上是 <strong>相互矛盾</strong> 的。当有 <strong>存储节点增加或删除</strong> 时，为了保持稳定应该 <strong>尽量少</strong> 的进行 <strong>数据的移动</strong> 和 <strong>重新分配</strong>，而这样又势必会带来 <strong>负载不均衡</strong>。同样追求 <strong>极致均匀</strong> 也会导致较多的 <strong>数据迁移</strong>。</p><p>所以我们希望在这两个极端之间，找到一个点以获得合适的均匀性和稳定性。除了上述两个基本目标外，工程中还需要从以下几个方面考虑数据分布算法的优劣：</p><ol><li><p><strong>性能可扩展性</strong>：这个主要考虑的是算法相对于 <strong>存储节点规模</strong> 的 <strong>时间复杂度</strong>。为了整个系统的可扩展性，数据分布算法不应该在集群规模扩大后显著的增加运行时间。</p></li><li><p><strong>考虑节点异构</strong>：实际工程中，不同 <strong>存储节点</strong> 之间可能会有很大的 <strong>性能</strong> 或 <strong>容量差异</strong>，好的数据分布算法应该能很好的应对这种 <strong>异构</strong>，提供 <strong>加权的数据均匀</strong>。</p></li><li><p><strong>隔离故障域</strong>：为了 <strong>数据的高可用</strong>，数据分布算法应该为每个 <code>key</code> 找到 <strong>一组存储节点</strong>，这些节点可能提供的是 <strong>数据的镜像副本</strong>，也可能是类似 <strong>擦除码</strong> 的副本方式。数据分布算法应该尽量 <strong>隔离</strong> 这些副本的故障域，如 <strong>不同机房</strong>、<strong>不同机架</strong>、<strong>不同交换机</strong>、<strong>不同机器</strong>。</p></li></ol><h2 id="二-演进"><a href="#二-演进" class="headerlink" title="(二) 演进"></a>(二) 演进</h2><p>看完算法的评价指标后，接下来介绍一些可能的方案演进，并分析他们的优劣。这里假设 <code>key</code> 的值足够分散。</p><h3 id="1-Hash"><a href="#1-Hash" class="headerlink" title="1. Hash"></a>1. Hash</h3><p>一个简单直观的想法是直接用 <code>Hash</code> 来计算，简单的以 <code>Key</code> 做 <strong>哈希</strong> 后 <strong>对节点数取模</strong>。可以看出，在 <code>key</code> 足够分散的情况下，<strong>均匀性</strong> 可以获得，但一旦有 <strong>节点加入</strong> 或 <strong>退出</strong> 时，所有的原有节点都会受到影响。<strong>稳定性</strong> 无从谈起。</p><h3 id="2-一致性Hash"><a href="#2-一致性Hash" class="headerlink" title="2. 一致性Hash"></a>2. 一致性Hash</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b670a4be?w=576&amp;h=412&amp;f=png&amp;s=38351" alt=""></p><p>一致性 <code>Hash</code> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在收尾相接的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到先遇到的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。但这有带来 <strong>均匀性</strong> 的问题，即使可以将存储节点等距排列，也会在 <strong>存储节点个数</strong> 变化时带来 <strong>数据的不均匀</strong>。而这种可能 <strong>成倍数的不均匀</strong> 在实际工程中是不可接受的。</p><h3 id="3-带负载上限的一致性Hash"><a href="#3-带负载上限的一致性Hash" class="headerlink" title="3. 带负载上限的一致性Hash"></a>3. 带负载上限的一致性Hash</h3><p>一致性 <code>Hash</code> 有 <strong>节点变化时不均匀</strong>的问题。<code>Google</code> 在 <code>2017</code> 年提出了 Consistent Hashing with Bounded Loads 来控制这种 <strong>不均匀的程度</strong>。简单的说，该算法给 <code>Hash</code> 环上的每个节点一个 <strong>负载上限</strong> 为 <code>1 + e</code> 倍的 <strong>平均负载</strong>，这个 <code>e</code>可以自定义。当 <code>key</code> 在 <code>Hash</code> 环上 <strong>顺时针</strong> 找到合适的节点后，会判断这个节点的 <strong>负载</strong> 是否已经 <strong>到达上限</strong>，如果 <strong>已达上限</strong>，则需要继续找 <strong>之后的节点</strong> 进行分配。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b6ac1b85?w=431&amp;h=397&amp;f=png&amp;s=46890" alt=""></p><p>如上图所示，假设每个桶 <strong>当前上限</strong> 是 <code>2</code>，红色的小球按序号访问，当编号为 <code>6</code> 的红色小球到达时，发现顺时针首先遇到的 <code>B（3，4）</code>，<code>C（1，5）</code>都已经 <strong>达到上限</strong>，因此最终放置在桶 <code>A</code> 里。</p><p>这个算法最吸引人的地方在于 <strong>当有节点变化</strong> 时，需要迁移的数据量是 <code>1/e^2</code> 相关，而与 <strong>节点数</strong> 或 <strong>数据数量</strong> 均无关。</p><p>也就是说当 <strong>集群规模扩大</strong> 时，<strong>数据迁移量</strong> 并不会随着显著增加。另外，使用者可以通过调整 <code>e</code> 的值来控制 <strong>均匀性</strong> 和 <strong>稳定性</strong> 之间的权衡，就是一种 <strong>以时间换空间</strong> 的算法。总体来说，无论是 <strong>一致性</strong> <code>Hash</code> 还是 <strong>带负载限制</strong> 的 <strong>一致性</strong> <code>Hash</code>，都无法解决 <strong>节点异构</strong> 的问题。</p><h3 id="4-带虚拟节点的一致性Hash"><a href="#4-带虚拟节点的一致性Hash" class="headerlink" title="4. 带虚拟节点的一致性Hash"></a>4. 带虚拟节点的一致性Hash</h3><p>为了解决 <strong>负载不均匀</strong> 和 <strong>异构</strong> 的问题，可以在 <strong>一致性</strong> <code>Hash</code> 的基础上引入 <strong>虚拟节点</strong>。即 <code>hash</code> 环上的 <strong>每个节点</strong> 并不是 <strong>实际</strong> 的 <strong>存储节点</strong>，而是一个 <strong>虚拟节点</strong>。实际的 <strong>存储节点</strong> 根据其 <strong>不同的权重</strong>，对应 <strong>一个</strong> 或 <strong>多个虚拟节点</strong>，所有落到相应虚拟节点上的 <code>key</code> 都由该 <strong>存储节点负责</strong>。</p><p>如下图所示，存储节点 <code>A</code> 负责 <code>(1,3]</code>，<code>(4,8]</code>，<code>(10, 14]</code>，存储节点 <code>B</code> 负责 <code>(14,1]</code>，<code>(8,10]</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b6940588?w=700&amp;h=338&amp;f=png&amp;s=64488" alt=""></p><p>这个算法的问题在于，一个 <strong>实际存储节点</strong> 的 <strong>加入</strong> 或 <strong>退出</strong>，会影响 <strong>多个虚拟节点</strong>的重新分配，进而引起 <strong>很多节点</strong> 参与到 <strong>数据迁移</strong> 中来。</p><p>另外，实践中将一个 <strong>虚拟节点</strong> 重新分配给 <strong>新的实际节点</strong> 时，需要将这部分数据 <strong>遍历</strong> 出来 <strong>发送给新节点</strong>。我们需要一个更合适的 <strong>虚拟节点切分</strong> 和 <strong>分配方式</strong>，那就是 <strong>分片</strong>。</p><h3 id="5-分片"><a href="#5-分片" class="headerlink" title="5. 分片"></a>5. 分片</h3><p><strong>分片</strong> 将 <strong>哈希环</strong> 切割为 <strong>相同大小的分片</strong>，然后将这些 <strong>分片</strong> 交给 <strong>不同的节点</strong> 负责。</p><p>注意这里跟上面提到的 <strong>虚拟节点</strong> 有着很 <strong>本质的区别</strong>：<strong>分片的划分和分片的分配被解耦</strong>。</p><p>一个 <strong>节点退出</strong> 时，其所负责的 <strong>分片</strong> 并不需要 <strong>顺时针合并</strong> 给之后节点，而是可以更灵活的 <strong>将整个分片</strong> 作为一个 <strong>整体</strong> 交给 <strong>任意节点</strong>。在实践中，一个 <strong>分片</strong> 多作为 <strong>最小的数据迁移</strong> 和 <strong>备份单位</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b68eee2d?w=546&amp;h=462&amp;f=png&amp;s=34445" alt=""></p><p>而也正是由于上面提到的 <strong>解耦</strong>，相当于将原先的 <code>key</code> 到 <strong>节点</strong> 的 <strong>映射</strong> 拆成了两层。需要一个 <strong>新的机制</strong> 来进行 <strong>分片</strong> 到 <strong>存储节点</strong> 的 <strong>映射</strong>。由于 <strong>分片数</strong> 相对 <code>key</code> 空间已经很小并且 <strong>数量确定</strong>，可以更精确地初始设置，并引入 <strong>中心目录服务</strong> 来根据 <strong>节点存活</strong> 修改 <strong>分片的映射关系</strong>。同时将这个 <strong>映射信息</strong> 通知给所有的 <strong>存储节点</strong> 和 <strong>客户端</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b9a03c5b?w=700&amp;h=388&amp;f=png&amp;s=49049" alt=""></p><p>上图是 <strong>分布式KV存储</strong> <code>Zeppelin</code>中的 <strong>分片方式</strong>，<code>Key Space</code> 通过 <code>Hash</code> 到 <strong>分片</strong>，<strong>分片及其副本</strong> 又通过一层映射到 <strong>最终的存储节点</strong> <code>Node Server</code>。</p><h3 id="6-CRUSH算法"><a href="#6-CRUSH算法" class="headerlink" title="6. CRUSH算法"></a>6. CRUSH算法</h3><p><code>CRUSH</code> 算法本质上也是一种 <strong>基于分片</strong> 的数据分布方式，其试图在以下几个方面进行优化：</p><ul><li><p><strong>分片映射信息量</strong>：避免 <strong>中心目录服务</strong> 和 <strong>存储节点</strong> 及 <strong>客户端之间</strong> 交互大量的 <strong>分片映射信息</strong>，而改由 <strong>存储节点</strong> 或 <strong>客户端</strong> 自己根据 <strong>少量</strong> 且 <strong>稳定</strong> 的集群节点拓扑和确定的规则自己计算分片映射。</p></li><li><p><strong>完善的故障域划分</strong>：支持 <strong>层级</strong> 的 <strong>故障域控制</strong>，将 <strong>同一分片</strong> 的 <strong>不同副本</strong> 按照配置划分到 <strong>不同层级</strong> 的 <strong>故障域中</strong>。</p></li></ul><p><strong>客户端</strong> 或 <strong>存储节点</strong> 利用 <code>key</code>、<strong>存储节点</strong> 的 <strong>拓扑结构</strong> 和 <strong>分配算法</strong>，独立的进行 <strong>分片位置</strong> 的计算，得到一组负责对应 <strong>分片</strong> 及 <strong>副本</strong> 的 <strong>存储位置</strong>。</p><p>如图所示是 <strong>一次定位</strong> 的过程，最终选择了一个 <code>row</code> 下的 <code>cab21</code>，<code>cab23</code>，<code>cab24</code> 三个机柜下的三个存储节点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5b6abde68?w=700&amp;h=254&amp;f=png&amp;s=72421" alt=""></p><p>当 <strong>节点变化</strong> 时，由于 <strong>节点拓扑</strong> 的变化，会影响 <strong>少量分片</strong> 数据进行迁移，如下图是加入 <strong>新节点</strong> 引起的 <strong>数据迁移</strong>。通过良好的 <strong>分配算法</strong>，可以得到很好的 <strong>负载均衡</strong> 和 <strong>稳定性</strong>，<code>CRUSH</code> 提供了 <code>Uniform</code>、<code>List</code>、<code>Tree</code>、<code>Straw</code> 四种分配算法。</p><h2 id="三-应用案例"><a href="#三-应用案例" class="headerlink" title="(三) 应用案例"></a>(三) 应用案例</h2><p>常见的 <strong>分布式存储系统</strong> 大多采用类似于 <strong>分片</strong> 的 <strong>数据分布和定位方式</strong>：</p><ol><li><p><strong>Cassandra/Dynamo</strong>：采用 <strong>分片</strong> 的方式并通过 <code>Gossip</code> 协议在对等节点间通信；</p></li><li><p><strong>Redis Cluster</strong>：将 <code>key Space</code> 划分为 <code>slots</code>，同样利用 <code>Gossip</code> 协议通信；</p></li><li><p><strong>Zeppelin</strong>：将数据分片为 <code>Partition</code>，通过 <code>Meta</code> 集群提供 <strong>中心目录服务</strong>；</p></li><li><p><strong>Bigtable</strong>：将数据切割为 <code>Tablet</code>，类似于可变的分片，<code>Tablet Server</code> 可以进行分片的切割，最终分片信息记录在 <code>Chubby</code> 中；</p></li><li><p><strong>Ceph</strong>：采用 <code>CRUSH</code> 方式，由 <strong>中心集群</strong> <code>Monitor</code> 提供并维护 <strong>集群拓扑</strong> 的变化。</p></li></ol><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/1/16455ec5dcc40392?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分布式存储系统&lt;/strong&gt; 面临着的首要问题，就是如何将 &lt;strong&gt;大量的数据&lt;/strong&gt; 分布在 &lt;strong&gt;不同的存储节点&lt;/strong&gt; 上。无论上层接口是 &lt;code&gt;KV&lt;/code&gt; &lt;strong&gt;存储&lt;/strong&gt;、&lt;strong&gt;对象存储&lt;/strong&gt;、&lt;strong&gt;块存储&lt;/strong&gt;、亦或是 &lt;strong&gt;列存储&lt;/strong&gt;，在这个问题上大体是一致的。本文将介绍如何 &lt;strong&gt;分布式存储系统&lt;/strong&gt; 中 &lt;strong&gt;做数据分布目标&lt;/strong&gt; 及可选的 &lt;strong&gt;方案&lt;/strong&gt;，并试着总结和权衡他们之间的关系及。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系列" scheme="https://ostenant.coding.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="分布式存储" scheme="https://ostenant.coding.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="一致性哈希" scheme="https://ostenant.coding.me/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
      <category term="分片" scheme="https://ostenant.coding.me/tags/%E5%88%86%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习Quartz任务调度框架</title>
    <link href="https://ostenant.coding.me/2018/06/27/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Quartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/"/>
    <id>https://ostenant.coding.me/2018/06/27/从零开始学习Quartz任务调度框架/</id>
    <published>2018-06-27T04:17:00.000Z</published>
    <updated>2018-06-29T04:50:45.047Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Quartz</code> 是个 <strong>任务调度工具</strong>，就是 <strong>定时</strong> 执行指定的任务。<code>Quartz</code> 提供了极为广泛的特性如 <strong>持久化任务</strong>，<strong>集群</strong> 和 <strong>分布式任务</strong> 等。<code>Quartz</code> 是用 <code>Java</code> 构建的，与 <code>Spring</code> 集成方便，<strong>伸缩性</strong>，<strong>负载均衡</strong>，<strong>高可用性</strong>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/Quartz_Logo_large.jpg" alt=""></p><p>本文只关注基于 <strong>数据库</strong> 的 <code>Quartz</code> 集群，基于 <code>Quartz 2.2.x</code> 来说明。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Quartz的核心组件"><a href="#Quartz的核心组件" class="headerlink" title="Quartz的核心组件"></a>Quartz的核心组件</h2><p><code>Quartz</code> 大致有三个核心的组件：</p><h3 id="1-调度器Scheduler"><a href="#1-调度器Scheduler" class="headerlink" title="1. 调度器Scheduler"></a>1. 调度器Scheduler</h3><p>一个 <strong>计划调度器容器</strong>，容器里面可以装载众多的 <code>JobDetail</code> 和 <code>Trigger</code>。当容器启动后，里面的每个 <code>JobDetail</code> 都会根据 <code>Trigger</code> 按部就班地 <strong>自动</strong> 去执行.</p><h3 id="2-任务Job"><a href="#2-任务Job" class="headerlink" title="2. 任务Job"></a>2. 任务Job</h3><p><code>Job</code> 表示要执行的 <strong>具体内容</strong>。<code>JobDetail</code> 表示具体的、可执行的调度程序，包含了这个任务的 <strong>调度方案</strong> 和 <strong>策略</strong>。</p><h3 id="3-触发器Trigger"><a href="#3-触发器Trigger" class="headerlink" title="3. 触发器Trigger"></a>3. 触发器Trigger</h3><p><strong>调度参数</strong> 的配置，配置任务执行触发的 <strong>时间间隔</strong>。</p><blockquote><p>几者的关系：<strong>调度器</strong> 就相当于一个 <strong>容器</strong>，装载着 <strong>任务</strong> 和 <strong>触发器</strong>。任务和触发器又是绑定在一起的，然而一个任务可以对应多个触发器，但一个触发器却只能对应一个任务。当 <code>JobDetail</code> 和 <code>Trigger</code> 在 <code>Scheduler</code> 容器上 <strong>注册</strong> 后，形成了装配好的 <strong>任务作业</strong>（<code>JobDetail</code> 和 <code>Trigger</code> 所组成的一对），伴随 <strong>容器启动</strong> 而调度执行。</p></blockquote><h2 id="Quartz的核心类"><a href="#Quartz的核心类" class="headerlink" title="Quartz的核心类"></a>Quartz的核心类</h2><h3 id="1-Scheduler"><a href="#1-Scheduler" class="headerlink" title="1. Scheduler"></a>1. Scheduler</h3><p><code>Quartz</code> 中 <strong>独立运行</strong> 的容器，<code>Trigger</code> 和 <code>JobDetail</code> 可以注册到 <code>Scheduler</code> 上。<code>Scheduler</code> 定义了多个 <strong>接口方法</strong>，允许外部通过 <strong>组及名称</strong> 访问和控制 <strong>容器</strong> 中 <code>Trigger</code> 和 <code>JobDetail</code>。</p><h3 id="2-Job"><a href="#2-Job" class="headerlink" title="2. Job"></a>2. Job</h3><p>任务接口，<strong>任务类</strong> 代表要调度执行的 <strong>业务逻辑实现</strong>，<strong>任务</strong> 必须实现该接口。</p><p>如果任务不允许 <strong>并发执行</strong>，则 <strong>任务类</strong> 必须添加注解 <code>@DisallowConcurrentExecution</code>。</p><p>该接口只定义了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException</span>;</span><br></pre></td></tr></table></figure><p>通过 <code>context</code> 可以访问配置给任务的 <strong>数据</strong> <code>context.getJobDetail().getJobDataMap()</code>，如果这个 <code>JobDataMap</code> 需要在修改后 <strong>持久化</strong> 到 <strong>数据库</strong> 里，则需要给 <strong>任务类</strong> 加上注解 <code>@PersistJobDataAfterExecution</code>。<code>Quartz</code> 在下次调度执行这个任务时，会把 <strong>持久化</strong> 的数据 <strong>反序列化</strong> 成 <code>JobDataMap</code> 供应用使用。</p><blockquote><p>不建议通过 <code>Quartz</code> 的这个机制 <strong>持久化</strong> 任何与 <strong>业务有关</strong> 的数据。因为 <strong>业务数据</strong> 应该由 <strong>应用</strong> 来存储，<code>Quartz</code> 只关注于调度执行。</p></blockquote><h3 id="3-JobDetail"><a href="#3-JobDetail" class="headerlink" title="3. JobDetail"></a>3. JobDetail</h3><p>任务在 <strong>内存</strong> 的标示。表示 <strong>任务详细信息</strong> 的接口，如 <code>Job</code> <strong>名字</strong>、<strong>描述信息</strong>、<strong>关联监听器</strong> 等信息。任务用调度器名称、任务名称和任务所归属的组名来作为 <strong>唯一标识</strong>。</p><h3 id="4-Trigger"><a href="#4-Trigger" class="headerlink" title="4. Trigger"></a>4. Trigger</h3><p><strong>触发器</strong>，用调度器名称、触发器名称和触发器所归属的组名来做 <strong>唯一标识</strong>。用于定义在什么情况、什么时间点执行任务。最常用的触发器类型就是基于 <code>cron</code> <strong>表达式</strong> 的触发器。</p><h3 id="5-JobStore"><a href="#5-JobStore" class="headerlink" title="5. JobStore"></a>5. JobStore</h3><p><strong>数据存储抽象</strong>，该接口定义了 <strong>任务</strong>、<strong>触发器</strong> 的 <strong>存储</strong>、<strong>检索</strong>、<strong>更新</strong> 的钩子函数，该接口还定义了任务执行完成后的 <strong>回调方法</strong>。</p><p><code>Quartz</code> 内建支持把 <strong>任务</strong>、<strong>触发器</strong> 等数据存储在 <code>JVM</code> <strong>内存</strong>、<strong>文件</strong>、<strong>数据库</strong> 中。通过这个接口，就隔离了 <strong>底层存储机制</strong> 的差异。可以在配置文件里通过 <code>org.quartz.JobStore.class</code> 属性来指定该接口的实现，比如基于 <code>Redis</code> 做 <strong>数据存储</strong> 的实现。</p><h4 id="5-1-RAMJobStore"><a href="#5-1-RAMJobStore" class="headerlink" title="5.1. RAMJobStore"></a>5.1. RAMJobStore</h4><ul><li><strong>优点</strong>：不依赖 <strong>外部数据库</strong>，配置容易，运行速度快。</li><li><strong>缺点</strong>：程序停止运行时，所有 <strong>调度信息</strong> 丢失。调度信息的 <strong>存储容量</strong> 也会被限制。</li></ul><h4 id="5-2-JDBCJobStore"><a href="#5-2-JDBCJobStore" class="headerlink" title="5.2. JDBCJobStore"></a>5.2. JDBCJobStore</h4><ul><li><strong>优点</strong>：支持 <strong>集群模式</strong>，所有的任务信息都会保存到 <strong>数据库</strong> 中。</li><li><strong>缺点</strong>：配置复杂。运行速度的快慢，取决于连接数据库的快慢。</li></ul><h3 id="6-JobFactory"><a href="#6-JobFactory" class="headerlink" title="6. JobFactory"></a>6. JobFactory</h3><p><strong>任务工厂</strong>，接口抽象了如何生成 <strong>任务实例</strong>，以便让应用来决定如何实例化任务类。</p><h3 id="7-JobStoreSupport"><a href="#7-JobStoreSupport" class="headerlink" title="7. JobStoreSupport"></a>7. JobStoreSupport</h3><p>提供了 <strong>基于数据库</strong> 的 <code>JobStore</code> 实现，通过 <code>MisfireHandler</code> 来检查错过发射的 <strong>触发器</strong>。如果是以 <strong>集群方式部署</strong>，还会通过内部类 <code>ClusterManager</code> 提供 <strong>集群健康检查</strong> 与 <strong>恢复</strong>。</p><h3 id="8-MisfireHandler"><a href="#8-MisfireHandler" class="headerlink" title="8. MisfireHandler"></a>8. MisfireHandler</h3><p><code>JobStoreSupport</code> 有个内部类 <code>MisfireHandler</code>，用于检查是否有 <strong>触发器</strong> 错过发射，它是用 <strong>单独的线程</strong> 执行。</p><p>但检测到有触发器 <strong>错过发射</strong> 时，该处理器只是 <strong>更新</strong> 触发器的状态为 <code>WAITING</code>，然后通知 <strong>监听器</strong>、通知 <strong>调度器</strong> 去处理。</p><h3 id="9-ClusterManager"><a href="#9-ClusterManager" class="headerlink" title="9. ClusterManager"></a>9. ClusterManager</h3><p>用于 <strong>管理集群</strong> 的 <strong>线程</strong>。<code>JobStoreSupport</code> 有个 <strong>内部类</strong> <code>ClusterManager</code> 用于进行 <strong>集群管理</strong>，它也是用 <strong>单独的线程</strong> 来执行，以防止 <strong>任务阻塞</strong>，其核心逻辑有：</p><ol><li>签入，向其他节点传达它所在的 <strong>调度器实例</strong> 还处于存活状态。</li><li>检查失败的节点，进行 <strong>恢复</strong>。<code>Quartz</code> 认为在一定时间后 <strong>没有签入</strong> 的节点是失败的，需要恢复。</li></ol><h3 id="10-Calendar"><a href="#10-Calendar" class="headerlink" title="10. Calendar"></a>10. Calendar</h3><p><code>org.quartz.Calendar</code> 和 <code>java.util.Calendar</code> 不同，它是一些 <strong>特定时间点</strong> 的 <strong>集合</strong>。一个 <code>Trigger</code> 可以和 <strong>多个</strong> <code>Calendar</code> 关联，以便 <strong>排除</strong> 或包含 <strong>某些时间点</strong>。</p><blockquote><p><code>Quartz</code> 在 <code>org.quartz.impl.calendar</code> 包下提供了若干个 <code>Calendar</code> 的 <strong>实现类</strong>，比如: <code>AnnualCalendar</code>、<code>MonthlyCalendar</code>、<code>WeeklyCalendar</code> 分别针对每年、每月和每周进行定义。</p></blockquote><h3 id="11-工作线程池"><a href="#11-工作线程池" class="headerlink" title="11. 工作线程池"></a>11. 工作线程池</h3><p><code>Quartz</code> 可以配置一个 <strong>线程池</strong> 来执行任务，线程池里的 <strong>线程用完</strong> 后，后续到期需要执行的任务就会 <strong>被阻塞</strong>。</p><h3 id="12-调度器线程"><a href="#12-调度器线程" class="headerlink" title="12. 调度器线程"></a>12. 调度器线程</h3><p>每个 <strong>调度器</strong> 都有自己的名称，对应一个 <code>org.quartz.core.QuartzSchedulerThread</code> <strong>调度器线程实例</strong>，调度逻辑就在这个线程类的 <code>run()</code> 方法里。</p><h2 id="Quartz的核心表"><a href="#Quartz的核心表" class="headerlink" title="Quartz的核心表"></a>Quartz的核心表</h2><h3 id="1-job-details"><a href="#1-job-details" class="headerlink" title="1. job_details"></a>1. job_details</h3><p>存储 <strong>任务</strong> 的信息，每一条记录表示一个任务。</p><h3 id="2-triggers"><a href="#2-triggers" class="headerlink" title="2. triggers"></a>2. triggers</h3><p>存储 <strong>触发器</strong> 的信息，<code>TRIGGER_STATE</code> 字段表示 <strong>触发器状态</strong>，用来控制这个 <strong>触发器</strong> 能不能被调度器 <strong>处理</strong>。</p><h3 id="3-fired-triggers"><a href="#3-fired-triggers" class="headerlink" title="3. fired_triggers"></a>3. fired_triggers</h3><p><strong>已发射触发器</strong> 的记录表，<code>STATE</code> 列用来表示任务的 <strong>执行状态</strong>。该表的作用是 <strong>跟踪任务</strong> 的 <strong>执行进度</strong>，用于 <strong>失败处理</strong>。</p><h3 id="4-locks"><a href="#4-locks" class="headerlink" title="4. locks"></a>4. locks</h3><p><code>locks</code> 表里的每条记录作为一个 <strong>悲观锁</strong>，要 <strong>加锁</strong> 时，用 <code>for update</code> 语句锁住对应的记录。</p><h3 id="5-scheduler-state"><a href="#5-scheduler-state" class="headerlink" title="5. scheduler_state"></a>5. scheduler_state</h3><p><strong>调度器状态表</strong>，集群的节点通过这个表来检查 <strong>其他节点</strong> 是否存活。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Quartz&lt;/code&gt; 是个 &lt;strong&gt;任务调度工具&lt;/strong&gt;，就是 &lt;strong&gt;定时&lt;/strong&gt; 执行指定的任务。&lt;code&gt;Quartz&lt;/code&gt; 提供了极为广泛的特性如 &lt;strong&gt;持久化任务&lt;/strong&gt;，&lt;strong&gt;集群&lt;/strong&gt; 和 &lt;strong&gt;分布式任务&lt;/strong&gt; 等。&lt;code&gt;Quartz&lt;/code&gt; 是用 &lt;code&gt;Java&lt;/code&gt; 构建的，与 &lt;code&gt;Spring&lt;/code&gt; 集成方便，&lt;strong&gt;伸缩性&lt;/strong&gt;，&lt;strong&gt;负载均衡&lt;/strong&gt;，&lt;strong&gt;高可用性&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="任务调度框架系列" scheme="https://ostenant.coding.me/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Quartz" scheme="https://ostenant.coding.me/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(六) - 单机定时任务的几种实现</title>
    <link href="https://ostenant.coding.me/2018/06/25/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E5%85%AD)%20-%20%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ostenant.coding.me/2018/06/25/实战Spring Boot 2.0系列(六) - 单机定时任务的几种实现/</id>
    <published>2018-06-25T10:20:00.000Z</published>
    <updated>2018-06-26T06:09:32.482Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>定时任务</strong> 一般会存在 <strong>中大型企业级</strong> 项目中，为了减少 <strong>服务器</strong>、<strong>数据库</strong> 的压力，往往会以 <strong>定时任务</strong> 的方式去完成某些业务逻辑。</p><a id="more"></a><p>常见的就是 <strong>金融服务系统</strong> 推送回调，一般支付系统订单在没有收到成功的回调返回内容时会 <strong>持续性的回调</strong>，这种回调一般都是 <strong>定时任务</strong> 来完成。</p><p>还有就是 <strong>报表的生成</strong>，我们一般会在客户 <strong>访问量小</strong> 时完成这个操作，也可以采用 <strong>定时任务</strong> 来完成。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413255f98b30e7?w=620&amp;h=595&amp;f=png&amp;s=81732" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="定时任务的几种方式"><a href="#定时任务的几种方式" class="headerlink" title="定时任务的几种方式"></a>定时任务的几种方式</h2><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>这是 <code>Java</code> 自带的 <code>java.util.Timer</code> 类，这个类允许调度一个名为 <code>java.util.TimerTask</code> 任务。使用这种方式可以让你的程序按照某一个 <strong>频度</strong> 执行，但不能在 <strong>指定时间</strong> 运行。现在一般用的较少。</p><h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h4><p><code>JDK</code> 自带的一个类，是基于 <strong>线程池</strong> 设计的定时任务类，每个 <strong>调度任务</strong> 都会分配到 <strong>线程池</strong> 中的一个 <strong>线程</strong> 去执行。也就是说，任务是 <strong>并发执行</strong>，互不影响的。</p><h4 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h4><p><code>Spring 3.0</code> 以后自带的 <code>Task</code>，支持 <strong>多线程</strong> 调度，可以将它看成一个 <strong>轻量级</strong> 的 <code>Quartz</code>，而且使用起来比 <code>Quartz</code> 简单许多，但是适用于 <strong>单节点</strong> 的 <strong>定时任务调度</strong>。</p><h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>这是一个 <strong>功能比较强大</strong> 的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来 <strong>稍显复杂</strong>。<code>Quartz</code> 功能强大，可以结合 <strong>数据库</strong> 做 <strong>持久化</strong>，进行 <strong>分布式</strong> 的 <strong>任务延时调度</strong>。</p><h2 id="Cron表达式简介"><a href="#Cron表达式简介" class="headerlink" title="Cron表达式简介"></a>Cron表达式简介</h2><p><code>Cron</code> 表达式是一个字符串，字符串以 <code>5</code> 或 <code>6</code> 个 <strong>空格</strong> 隔开，分为 <code>6</code> 或 <code>7</code> 个 <strong>域</strong>，每一个域代表一个含义，<code>Cron</code> 有如下两种语法格式：</p><blockquote><ol><li>Seconds Minutes Hours DayofMonth Month DayofWeek Year</li><li>Seconds Minutes Hours DayofMonth Month DayofWeek</li></ol></blockquote><p>每个域对应的含义、域值范围和特殊表示符，从左到右依次如下：</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">允许值</th><th style="text-align:left">允许的特殊字符</th></tr></thead><tbody><tr><td style="text-align:left">秒</td><td style="text-align:left">0-59</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">分</td><td style="text-align:left">0-59</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">小时</td><td style="text-align:left">0-23</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">日期</td><td style="text-align:left">1-31</td><td style="text-align:left">, - * / L W C</td></tr><tr><td style="text-align:left">月份</td><td style="text-align:left">1-12 或者 JAN-DEC</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">星期</td><td style="text-align:left">1-7 或者 SUN-SAT</td><td style="text-align:left">, - * / L C #</td></tr><tr><td style="text-align:left">年（可选）</td><td style="text-align:left">留空, 1970-2099</td><td style="text-align:left">, - * /</td></tr></tbody></table><p>如上面的表达式所示:</p><ul><li><p><strong>“”字符:</strong> 被用来指定所有的值。如：在分钟的字段域里表示”每分钟”。</p></li><li><p><strong>“-“字符:</strong> 被用来指定一个范围。如：”10-12” 在小时域意味着 “10点、11点、12点”。</p></li><li><p><strong>“,”字符:</strong> 被用来指定另外的值。如：”MON,WED,FRI” 在星期域里表示 “星期一、星期三、星期五”。</p></li><li><p><strong>“?”字符:</strong> 只在日期域和星期域中使用。它被用来指定”非明确的值”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。</p></li><li><p><strong>“L”字符:</strong> 指定在月或者星期中的某天（最后一天）。即 “Last” 的缩写。但是在星期和月中 “Ｌ” 表示不同的意思，如：在月子段中 “L” 指月份的最后一天 - 1月31日，2月28日。</p><ul><li>如果在星期字段中则简单的表示为 “7” 或者 “SAT” 字符。</li><li>如果在星期字段中在某个 value 值得后面，则表示 “某月的最后一个星期value”，如 “6L” 表示某月的最后一个星期五。</li></ul></li><li><p><strong>“W”字符:</strong> 只能用在月份字段中，该字段指定了离指定日期最近的那个星期日。</p></li><li><p><strong>“#”字符:</strong> 只能用在星期字段，该字段指定了第几个星期 value 在某月中</p></li></ul><p>每一个元素都可以显式地规定一个值（如 <code>6</code>），一个区间（如 <code>9-12</code>），一个列表（如 <code>9，11，13</code>）或一个通配符（如 <code>*</code>）。<strong>“月份中的日期”</strong> 和 <strong>“星期中的日期”</strong> 这两个元素是 <strong>互斥的</strong>，因此应该通过设置一个 <strong>问号</strong>（<code>?</code>）来表明你不想设置的那个字段。下表显示了一些 <code>cron</code> 表达式的 <strong>例子</strong> 和它们的意义：</p><table><thead><tr><th>表达式</th><th>意义</th></tr></thead><tbody><tr><td>“0 0 12 <em> </em> ?”</td><td>每天中午12点触发</td></tr><tr><td>“0 15 10 ? <em> </em>“</td><td>每天上午10:15触发</td></tr><tr><td>“0 15 10 <em> </em> ?”</td><td>每天上午10:15触发</td></tr><tr><td>“0 15 10 <em> </em> ? *”</td><td>每天上午10:15触发</td></tr><tr><td>“0 15 10 <em> </em> ? 2005”</td><td>2005年的每天上午10:15触发</td></tr><tr><td>“0 <em> 14 </em> * ?”</td><td>在每天下午2点到下午2:59期间的每1分钟触发</td></tr><tr><td>“0 0/5 14 <em> </em> ?”</td><td>在每天下午2点到下午2:55期间的每5分钟触发</td></tr><tr><td>“0 0/5 14,18 <em> </em> ?”</td><td>在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</td></tr><tr><td>“0 0-5 14 <em> </em> ?”</td><td>在每天下午2点到下午2:05期间的每1分钟触发</td></tr><tr><td>“0 10,44 14 ? 3 WED”</td><td>每年三月的星期三的下午2:10和2:44触发</td></tr><tr><td>“0 15 10 ? * MON-FRI”</td><td>周一至周五的上午10:15触发</td></tr><tr><td>“0 15 10 15 * ?”</td><td>每月15日上午10:15触发</td></tr><tr><td>“0 15 10 L * ?”</td><td>每月最后一日的上午10:15触发</td></tr><tr><td>“0 15 10 ? * 6L”</td><td>每月的最后一个星期五上午10:15触发</td></tr><tr><td>“0 15 10 ? * 6L 2002-2005”</td><td>2002年至2005年的每月的最后一个星期五上午10:15触发</td></tr><tr><td>“0 15 10 ? * 6#3”</td><td>每月的第三个星期五上午10:15触发</td></tr><tr><td>0 6 <em> </em> *</td><td>每天早上6点</td></tr><tr><td>0 /2 <em> </em></td><td>每两个小时</td></tr><tr><td>0 23-7/2，8 <em> </em> *</td><td>晚上11点到早上8点之间每两个小时，早上八点</td></tr><tr><td>0 11 4 * 1-3</td><td>每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点</td></tr><tr><td>0 4 1 1 *</td><td>1月1日早上4点</td></tr></tbody></table><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="配置gradle依赖"><a href="#配置gradle依赖" class="headerlink" title="配置gradle依赖"></a>配置gradle依赖</h3><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-scheduler-task-management</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter'</span>)</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Spring Boot</code> 入口类上配置 <code>@EnableScheduling</code> 注解开启 <code>Spring</code> 自带的定时处理功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置Timer任务"><a href="#配置Timer任务" class="headerlink" title="配置Timer任务"></a>配置Timer任务</h2><p>这个 <code>API</code> 目前在项目中很少用，直接给出示例代码。具体的介绍可以查看 <code>API</code>。<code>Timer</code> 的内部只有 <strong>一个线程</strong>，如果有 <strong>多个任务</strong> 的话就会 <strong>顺序执行</strong>，这样任务的 <strong>延迟时间</strong> 和 <strong>循环时间</strong> 就会出现问题。</p><p>TimerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TimerService.class);</span><br><span class="line">    <span class="keyword">private</span> AtomicLong counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">                LOGGER.info(<span class="string">"Schedule timerTask &#123;&#125; times"</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000L</span>, <span class="number">10</span> * <span class="number">1000L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个 <code>TimerTask</code>，在 <code>TimerTask</code> 中累加 <strong>执行次数</strong>，并通过 <code>slf4j</code> 进行打印 (自带执行时间)。然后通过 <code>Timer</code> 调度工具类调度 <code>TimerTask</code> 任务，设置 <strong>初始化延迟时间</strong> 为 <code>1s</code>，<strong>定时执行间隔</strong> 为 <code>10s</code>，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TimerService timerService = <span class="keyword">new</span> TimerService();</span><br><span class="line">    timerService.schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察测试结果，能够发现 <code>TimerTask</code> 配置的任务每隔 <code>10s</code> 被执行了一次，执行线程默认都是 <code>Timer-0</code> 这个线程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17:48:18.731 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 1 <span class="built_in">times</span></span><br><span class="line">17:48:28.730 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 2 <span class="built_in">times</span></span><br><span class="line">17:48:38.736 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 3 <span class="built_in">times</span></span><br><span class="line">17:48:48.738 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 4 <span class="built_in">times</span></span><br><span class="line">17:48:58.743 [Timer-0] INFO io.ostenant.springboot.sample.timer.TimerService - Schedule timerTask 5 <span class="built_in">times</span></span><br></pre></td></tr></table></figure><h2 id="配置ScheduledExecutorService任务"><a href="#配置ScheduledExecutorService任务" class="headerlink" title="配置ScheduledExecutorService任务"></a>配置ScheduledExecutorService任务</h2><p><code>ScheduledExecutorService</code> 是 <strong>延时执行</strong> 的线程池，对于 <strong>多线程</strong> 环境下的 <strong>定时任务</strong>，推荐用 <code>ScheduledExecutorService</code> 代替 <code>Timer</code> 定时器。</p><p>创建一个线程数量为 <code>4</code> 的 <strong>任务线程池</strong>，同一时刻并向它提交 <code>4</code> 个定时任务，用于测试延时任务的 <strong>并发处理</strong>。执行 <code>ScheduledExecutorService</code> 的 <code>scheduleWithFixedDelay()</code> 方法，设置任务线程池的 <strong>初始任务延迟时间</strong> 为 <code>2</code> 秒，并在上一次 <strong>执行完毕时间点</strong> 之后 <code>10</code> 秒再执行下一次任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        scheduledExecutor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">            LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">        &#125;, <span class="number">2000L</span>, <span class="number">10</span> * <span class="number">1000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">"Start to schedule"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下，我们可以发现每隔 <code>20</code> 秒的时间间隔，就会有 <code>4</code> 个定时任务同时执行。因为在任务线程池初始化时，我们同时向线程池提交了 <code>4</code> 个任务，这 <strong>四个任务</strong> 会完全利用线程池中的 <code>4</code> 个线程进行任务执行。</p><p><code>20</code> 秒是怎么来的？首先每个任务的 <strong>时间间隔</strong> 设置为 <code>10</code> 秒。其次因为采用的是 <code>withFixedDelay</code> 策略，即当前任务执行的 <strong>结束时间</strong>，作为下次延时任务的 <strong>开始计时节点</strong>，并且每个任务在执行过程中睡眠了 <code>10</code> 秒的时间，累计起来就是 <code>20</code> 秒的时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">19:42:02.444 [main] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Start to schedule</span><br><span class="line">19:42:14.449 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 3 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:14.449 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 1 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:14.449 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 2 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:14.449 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 4 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 7 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 5 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 8 <span class="built_in">times</span> with fixed delay</span><br><span class="line">19:42:34.458 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 6 <span class="built_in">times</span> with fixed delay</span><br></pre></td></tr></table></figure><p>创建一个线程数量为 <code>4</code> 的 <strong>任务线程池</strong>，同一时刻并向它提交 <code>4</code> 个定时任务，用于测试延时任务的 <strong>并发处理</strong>。每个任务分别执行 <code>ScheduledExecutorService</code> 的 <code>scheduleAtFixedRate()</code> 方法，设置任务线程池的 <strong>初始任务延迟时间</strong> 为 <code>2</code> 秒，并在上一次 <strong>开始执行时间点</strong> 之后 <code>10</code> 秒再执行下一次任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        scheduledExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">            LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times at fixed rate"</span>, count);</span><br><span class="line">        &#125;, <span class="number">2000L</span>, <span class="number">10</span> * <span class="number">1000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">"Start to schedule"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下，我们可以发现每隔 <code>10</code> 秒的时间间隔，就会有 <code>4</code> 个定时任务同时执行，因为在任务线程池初始化时，我们同时向线程池提交了 <code>4</code> 个任务，这 <strong>四个任务</strong> 会完全利用线程池中的 <code>4</code> 个线程进行任务执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">19:31:46.837 [main] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Start to schedule</span><br><span class="line">19:31:48.840 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 1 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:48.840 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 3 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:48.840 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 2 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:48.840 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 4 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.839 [pool-1-thread-2] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 6 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.840 [pool-1-thread-4] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 8 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.839 [pool-1-thread-3] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 7 <span class="built_in">times</span> at fixed rate</span><br><span class="line">19:31:58.839 [pool-1-thread-1] INFO io.ostenant.springboot.sample.executor.ScheduledExecutorsService - Schedule executor 5 <span class="built_in">times</span> at fixed rate</span><br></pre></td></tr></table></figure><h2 id="配置Spring-Task任务"><a href="#配置Spring-Task任务" class="headerlink" title="配置Spring Task任务"></a>配置Spring Task任务</h2><p><code>Spring</code> 提供了 <code>@Scheduled</code> 注解来实现 <strong>定时任务</strong>，<code>@Scheduled</code> 参数可以接受 <strong>两种</strong> 定时的设置，一种是我们常用的 <strong>格林时间表达式</strong> <code>cron = &quot;*/10 * * * * *&quot;</code>，另一种是 <code>fixedRate = 10 * 1000L</code>，两种都表示每隔 <code>10</code> 秒执行一次目标任务。</p><p>参数说明：</p><ul><li>@Scheduled(fixedRate = 10 * 1000L)：上一次 <strong>开始执行时间点</strong> 之后 <code>10</code> 秒再执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times at fixed rate"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Scheduled(fixedDelay = 10 * 1000L)：上一次 <strong>执行完毕时间点</strong> 之后 <code>10</code> 秒再执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Scheduled(initialDelay = 2000L, fixedRate = 10 * 1000L)：第一次延迟 <code>2</code> 秒后执行，之后按 <code>fixedRate</code> 的规则每 <code>10</code> 秒执行一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(initialDelay = <span class="number">2000L</span>, fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithinitialDelayAndFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Scheduled(cron = “0/10 <em> </em> <em> </em> *”)：根据 <code>cron</code> 表达式定义，每隔 <code>10</code> 秒执行一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/10 * * * * *"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithCronExpression</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">    LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with "</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><p>SpringTaskService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTaskService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SpringTaskService.class);</span><br><span class="line">    <span class="keyword">private</span> AtomicLong counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(initialDelay = <span class="number">2000L</span>, fixedDelay = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithinitialDelayAndFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with fixed delay"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times at fixed rate"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/10 * * * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleWithCronExpression</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = counter.incrementAndGet();</span><br><span class="line">        LOGGER.info(<span class="string">"Schedule executor &#123;&#125; times with "</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看日志，任务每 <code>20</code> 秒的时间间隔执行一次。每次定时任务在上次 <strong>执行完毕时间点</strong> 之后 <code>10</code> 秒再执行，在任务中设置 <strong>睡眠时间</strong> 为 <code>10</code> 秒。这里只验证了 @Scheduled(initialDelay = 2000L, fixedDelay = 10 * 1000L)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-06-25 18:00:53.051  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 1 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:01:13.056  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 2 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:01:33.061  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 3 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:01:53.071  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 4 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-25 18:02:13.079  INFO 5190 --- [pool-1-thread-1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 5 <span class="built_in">times</span> with fixed delay</span><br></pre></td></tr></table></figure><h3 id="配置任务线程池"><a href="#配置任务线程池" class="headerlink" title="配置任务线程池"></a>配置任务线程池</h3><p>上述配置都是基于 <strong>单线程</strong> 的任务调度，如何引入 <strong>多线程</strong> 提高 <strong>延时任务</strong> 的 <strong>并发处理</strong> 能力？</p><p><code>Spring Boot</code> 提供了一个 <code>SchedulingConfigurer</code> 配置接口。我们通过 <code>ScheduleConfig</code> 配置文件实现 <code>ScheduleConfiguration</code> 接口，并重写 <code>configureTasks()</code> 方法，向 <code>ScheduledTaskRegistrar</code> 注册一个 <code>ThreadPoolTaskScheduler</code> 任务线程对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleConfiguration</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ScheduleConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        taskRegistrar.setTaskScheduler(taskScheduler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">taskScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskScheduler taskScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">        taskScheduler.setPoolSize(<span class="number">4</span>);</span><br><span class="line">        taskScheduler.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(<span class="string">"schedule"</span>);</span><br><span class="line">        taskScheduler.setRemoveOnCancelPolicy(<span class="keyword">true</span>);</span><br><span class="line">        taskScheduler.setErrorHandler(t -&gt; LOGGER.error(<span class="string">"Error occurs"</span>, t));</span><br><span class="line">        <span class="keyword">return</span> taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 引用，上面 <code>SpringTaskService</code> 配置的 <code>4</code> 个定时任务会同时生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2018-06-20 20:37:50.746  INFO 8142 --- [      schedule1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 1 <span class="built_in">times</span> at fixed rate</span><br><span class="line">2018-06-20 20:38:00.001  INFO 8142 --- [      schedule3] i.o.s.sample.spring.SpringTaskService    : Schedule executor 2 <span class="built_in">times</span> with </span><br><span class="line">2018-06-20 20:38:00.751  INFO 8142 --- [      schedule1] i.o.s.sample.spring.SpringTaskService    : Schedule executor 3 <span class="built_in">times</span> at fixed rate</span><br><span class="line">2018-06-20 20:38:02.748  INFO 8142 --- [      schedule2] i.o.s.sample.spring.SpringTaskService    : Schedule executor 4 <span class="built_in">times</span> with fixed delay</span><br><span class="line">2018-06-20 20:38:10.005  INFO 8142 --- [      schedule4] i.o.s.sample.spring.SpringTaskService    : Schedule executor 5 <span class="built_in">times</span> with </span><br><span class="line">2018-06-20 20:38:10.747  INFO 8142 --- [      schedule3] i.o.s.sample.spring.SpringTaskService    : Schedule executor 6 <span class="built_in">times</span> at fixed rate</span><br><span class="line">2018-06-20 20:38:20.002  INFO 8142 --- [      schedule2] i.o.s.sample.spring.SpringTaskService    : Schedule executor 7 <span class="built_in">times</span> with </span><br><span class="line">2018-06-20 20:38:20.747  INFO 8142 --- [      schedule4] i.o.s.sample.spring.SpringTaskService    : Schedule executor 8 <span class="built_in">times</span> at fixed rate</span><br></pre></td></tr></table></figure><p>观察日志，<strong>线程名前缀</strong> 为 <code>schedule</code>，可以发现 <code>Spring Task</code> 将 <code>@Scheduled</code> 注解配置的 <code>4</code> 个任务，分发给我们配置的 <code>ThreadPoolTaskScheduler</code> 中的 <code>4</code> 个线程并发执行。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了基于单节点的定时任务调度及实现，包括 <code>JDK</code> 原生的 <code>Timer</code> 和 <code>ScheduledExecutorService</code>，以及 <code>Spring 3.0</code> 以后自带的基于注解的 <code>Spring Task</code> 任务调度方式。除此之外，重点阐述了基于 <strong>固定延时</strong>、<strong>固定频率</strong> 和 <code>cron</code> <strong>表达式</strong> 的不同之处，并对 <code>ScheduledExecutorService</code> 和 <code>Spring Scheduler</code> 的 <strong>线程池并发处理</strong> 进行了测试。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/1640df3c27eedf87?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定时任务&lt;/strong&gt; 一般会存在 &lt;strong&gt;中大型企业级&lt;/strong&gt; 项目中，为了减少 &lt;strong&gt;服务器&lt;/strong&gt;、&lt;strong&gt;数据库&lt;/strong&gt; 的压力，往往会以 &lt;strong&gt;定时任务&lt;/strong&gt; 的方式去完成某些业务逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Quartz" scheme="https://ostenant.coding.me/tags/Quartz/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
      <category term="定时任务" scheme="https://ostenant.coding.me/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="Spring Task" scheme="https://ostenant.coding.me/tags/Spring-Task/"/>
    
      <category term="Timer" scheme="https://ostenant.coding.me/tags/Timer/"/>
    
      <category term="ScheduledExecutorService" scheme="https://ostenant.coding.me/tags/ScheduledExecutorService/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(五) - Listener, Servlet和Filter, Controller和Interceptor</title>
    <link href="https://ostenant.coding.me/2018/06/20/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%BA%94)%20-%20Listener,%20Servlet%E5%92%8CFilter,%20Controller%E5%92%8CInterceptor/"/>
    <id>https://ostenant.coding.me/2018/06/20/实战Spring Boot 2.0系列(五) - Listener, Servlet和Filter, Controller和Interceptor/</id>
    <published>2018-06-20T11:20:00.000Z</published>
    <updated>2018-07-05T12:46:15.992Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用户认证授权、日志记录 <code>MDC</code>、编码解码、<code>UA</code> 检查、多端对应等都需要通过 <strong>拦截请求</strong> 来进行处理。这时就需要 <code>Servlet</code>、<code>Filter</code>、<code>Listener</code>、<code>Interceptor</code> 这几种组件。而把非 <code>Spring Boot</code> 项目转换成 <code>Spring Boot</code> 项目，需要沿用以前的这些代码，所以有必要了解这它们的 <strong>用法</strong> 和 <strong>生命周期</strong>。 </p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413255f98b30e7?w=620&amp;h=595&amp;f=png&amp;s=81732" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-几种组件介绍"><a href="#1-几种组件介绍" class="headerlink" title="1. 几种组件介绍"></a>1. 几种组件介绍</h2><h3 id="1-1-监听器Listener"><a href="#1-1-监听器Listener" class="headerlink" title="1.1. 监听器Listener"></a>1.1. 监听器Listener</h3><p><code>Listener</code> 可以监听 <code>web</code> 服务器中某一个 <strong>事件操作</strong>，并触发注册的 <strong>回调函数</strong>。通俗的语言就是在 <code>application</code>，<code>session</code>，<code>request</code> 三个对象 <strong>创建/消亡</strong> 或者 <strong>增删改</strong> 属性时，自动执行代码的功能组件。</p><h3 id="1-2-Servlet"><a href="#1-2-Servlet" class="headerlink" title="1.2. Servlet"></a>1.2. Servlet</h3><p><code>Servlet</code> 是一种运行 <strong>服务器端</strong> 的 <code>java</code> 应用程序，具有 <strong>独立于平台和协议</strong> 的特性，并且可以动态的生成 <code>web</code> 页面，它工作在 <strong>客户端请求</strong> 与 <strong>服务器响应</strong> 的中间层。</p><h3 id="1-3-过滤器Filter"><a href="#1-3-过滤器Filter" class="headerlink" title="1.3. 过滤器Filter"></a>1.3. 过滤器Filter</h3><p><code>Filter</code> 对 <strong>用户请求</strong> 进行 <strong>预处理</strong>，接着将请求交给 <code>Servlet</code> 进行 <strong>处理</strong> 并 <strong>生成响应</strong>，最后 <code>Filter</code> 再对 <strong>服务器响应</strong> 进行 <strong>后处理</strong>。<code>Filter</code> 是可以复用的代码片段，常用来转换 <code>HTTP</code> <strong>请求</strong>、<strong>响应</strong> 和 <strong>头信息</strong>。<code>Filter</code> 不像 <code>Servlet</code>，它不能产生 <strong>响应</strong>，而是只 <strong>修改</strong> 对某一资源的 <strong>请求</strong> 或者 <strong>响应</strong>。</p><h3 id="1-4-拦截器Interceptor"><a href="#1-4-拦截器Interceptor" class="headerlink" title="1.4. 拦截器Interceptor"></a>1.4. 拦截器Interceptor</h3><p>类似 <strong>面向切面编程</strong> 中的 <strong>切面</strong> 和 <strong>通知</strong>，我们通过 <strong>动态代理</strong> 对一个 <code>service()</code> 方法添加 <strong>通知</strong> 进行功能增强。比如说在方法执行前进行 <strong>初始化处理</strong>，在方法执行后进行 <strong>后置处理</strong>。<strong>拦截器</strong> 的思想和 <code>AOP</code> 类似，区别就是 <strong>拦截器</strong> 只能对 <code>Controller</code> 的 <code>HTTP</code> 请求进行拦截。</p><h2 id="2-过滤器-VS-拦截器"><a href="#2-过滤器-VS-拦截器" class="headerlink" title="2. 过滤器 VS 拦截器"></a>2. 过滤器 VS 拦截器</h2><h3 id="2-1-两者的区别"><a href="#2-1-两者的区别" class="headerlink" title="2.1. 两者的区别"></a>2.1. 两者的区别</h3><ol><li><p><code>Filter</code> 是基于 <strong>函数回调</strong>的，而 <code>Interceptor</code> 则是基于 <code>Java</code> <strong>反射</strong> 和 <strong>动态代理</strong>。</p></li><li><p><code>Filter</code> 依赖于 <code>Servlet</code> 容器，而 <code>Interceptor</code> 不依赖于 <code>Servlet</code> 容器。</p></li><li><p><code>Filter</code> 对几乎 <strong>所有的请求</strong> 起作用，而 <code>Interceptor</code> 只对 <code>Controller</code> 对请求起作用。</p></li></ol><h3 id="2-2-执行顺序"><a href="#2-2-执行顺序" class="headerlink" title="2.2. 执行顺序"></a>2.2. 执行顺序</h3><p>对于自定义 <code>Servlet</code> 对请求分发流程：</p><ol><li><code>Filter</code> 过滤请求处理；</li><li><code>Servlet</code> 处理请求；</li><li><code>Filter</code> 过滤响应处理。</li></ol><p>对于自定义 <code>Controller</code> 的请求分发流程：</p><ol><li><code>Filter</code> 过滤请求处理；</li><li><code>Interceptor</code> 拦截请求处理；</li><li>对应的 <code>HandlerAdapter</code> 处理请求；</li><li><code>Interceptor</code> 拦截响应处理；</li><li><code>Interceptor</code> 的最终处理；</li><li><code>Filter</code> 过滤响应处理。</li></ol><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3. 环境准备"></a>3. 环境准备</h2><h3 id="配置gradle依赖"><a href="#配置gradle依赖" class="headerlink" title="配置gradle依赖"></a>配置gradle依赖</h3><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-web-async-task</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置启动入口类"><a href="#配置启动入口类" class="headerlink" title="配置启动入口类"></a>配置启动入口类</h3><p>配置一个 <code>Spring Boot</code> 启动入口类，这里需要配置两个注解。</p><ul><li><p>@ServletComponentScan: 允许 <code>Spring Boot</code> 扫描和装载当前 <strong>包路径</strong> 和 <strong>子路径</strong> 下配置的 <code>Servlet</code>。</p></li><li><p>@EnableWvc: 允许 <code>Spring Boot</code> 配置 <code>Spring MVC</code> 相关自定义的属性，比如：拦截器、资源处理器、消息转换器等。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-配置监听器Listener"><a href="#4-配置监听器Listener" class="headerlink" title="4. 配置监听器Listener"></a>4. 配置监听器Listener</h2><p>配置一个 <code>ServletContext</code> 监听器，使用 <code>@WebListener</code> 标示即可。在 <code>Servlet</code> 容器 <strong>初始化</strong> 过程中，<code>contextInitialized()</code> 方法会被调用，在容器 <strong>销毁</strong> 时会调用 <code>contextDestroyed()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexServletContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(IndexServletContextListener.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INITIAL_CONTENT = <span class="string">"Content created in servlet Context"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Start to initialize servlet context"</span>);</span><br><span class="line">        ServletContext servletContext = sce.getServletContext();</span><br><span class="line">        servletContext.setAttribute(<span class="string">"content"</span>, INITIAL_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Destroy servlet context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在容器初始化时，往 <code>ServletContext</code> 上下文设置了参数名称为 <code>INITIAL_CONTENT</code>，可以全局直接访问。</p><h2 id="5-配置Servlet"><a href="#5-配置Servlet" class="headerlink" title="5. 配置Servlet"></a>5. 配置Servlet</h2><p>配置 <code>IndexHttpServlet</code>，重写 <code>HttpServlet</code> 的 <code>doGet()</code> 方法，直接输出 <code>IndexHttpServlet</code> 定义的 <strong>初始化参数</strong> 和在 <code>IndexServletContextListener</code> 设置的 <code>ServletContext</code> 上下文参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"IndexHttpServlet"</span>,</span><br><span class="line">        displayName = <span class="string">"indexHttpServlet"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"/index/IndexHttpServlet"</span>&#125;,</span><br><span class="line">        initParams = &#123;</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"createdBy"</span>, value = <span class="string">"Icarus"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"createdOn"</span>, value = <span class="string">"2018-06-20"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexHttpServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        resp.getWriter().println(format(<span class="string">"Created by %s"</span>, getInitParameter(<span class="string">"createdBy"</span>)));</span><br><span class="line">        resp.getWriter().println(format(<span class="string">"Created on %s"</span>, getInitParameter(<span class="string">"createdOn"</span>)));</span><br><span class="line">        resp.getWriter().println(format(<span class="string">"Servlet context param: %s"</span>,</span><br><span class="line">                req.getServletContext().getAttribute(<span class="string">"content"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 <code>@WebServlet</code> 注解用于注册这个 <code>Servlet</code>，<code>@WebServlet</code> 注解的 <strong>各个参数</strong> 分别对应 <code>web.xml</code> 中的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>IndexHttpServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index/IndexHttpServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>IndexHttpServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>io.ostenant.springboot.sample.servlet.IndexHttpServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>createdBy<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Icarus<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>createdOn<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2018-06-20<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-配置过滤器Filter"><a href="#6-配置过滤器Filter" class="headerlink" title="6. 配置过滤器Filter"></a>6. 配置过滤器Filter</h2><p>一个 <code>Servlet</code> 请求可以经由多个 <code>Filter</code> 进行过滤，最终由 <code>Servlet</code> 处理并响应客户端。这里配置两个过滤器示例：</p><p>FirstIndexFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"firstIndexFilter"</span>,</span><br><span class="line">        displayName = <span class="string">"firstIndexFilter"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"/index/*"</span>&#125;,</span><br><span class="line">        initParams = <span class="meta">@WebInitParam</span>(</span><br><span class="line">                name = <span class="string">"firstIndexFilterInitParam"</span>,</span><br><span class="line">                value = <span class="string">"io.ostenant.springboot.sample.filter.FirstIndexFilter"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstIndexFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FirstIndexFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Register a new filter &#123;&#125;"</span>, filterConfig.getFilterName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexFilter pre filter the request"</span>);</span><br><span class="line">        String filter = request.getParameter(<span class="string">"filter1"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(filter)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by firstIndexFilter, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"filter1\""</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexFilter post filter the response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Destroy filter &#123;&#125;"</span>, getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 <code>@WebFilter</code> 相关的配置属性，对应于 <code>web.xml</code> 的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>firstIndexFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>io.ostenant.springboot.sample.filter.FirstIndexFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>firstIndexFilterInitParam<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>io.ostenant.springboot.sample.filter.FirstIndexFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 <code>FirstIndexFilter</code>，使用 <code>@WebFilter</code> 注解进行标示。当 <code>FirstIndexFilter</code> 初始化时，会执行 <code>init()</code> 方法。每次请求路径匹配 <code>urlPatterns</code> 配置的路径时，就会进入 <code>doFilter()</code> 方法进行具体的 <strong>请求</strong> 和 <strong>响应过滤</strong>。</p><p>当 <code>HTTP</code> 请求携带 <code>filter1</code> 参数时，请求会被放行；否则，直接 <strong>过滤中断</strong>，结束请求处理。</p><p>SecondIndexFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"secondIndexFilter"</span>,</span><br><span class="line">        displayName = <span class="string">"secondIndexFilter"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"/index/*"</span>&#125;,</span><br><span class="line">        initParams = <span class="meta">@WebInitParam</span>(</span><br><span class="line">                name = <span class="string">"secondIndexFilterInitParam"</span>,</span><br><span class="line">                value = <span class="string">"io.ostenant.springboot.sample.filter.SecondIndexFilter"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondIndexFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SecondIndexFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Register a new filter &#123;&#125;"</span>, filterConfig.getFilterName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexFilter pre filter the request"</span>);</span><br><span class="line">        String filter = request.getParameter(<span class="string">"filter2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(filter)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by firstIndexFilter, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"filter2\""</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexFilter post filter the response"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Destroy filter &#123;&#125;"</span>, getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 <code>@WebFilter</code> 相关的配置属性，对应于 <code>web.xml</code> 的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>secondIndexFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>io.ostenant.springboot.sample.filter.SecondIndexFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>secondIndexFilterInitParam<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>io.ostenant.springboot.sample.filter.SecondIndexFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 <code>SecondIndexFilter</code>，使用 <code>@WebFilter</code> 注解进行标示。当 <code>SecondIndexFilter</code> 初始化时，会执行 <code>init()</code> 方法。每次请求路径匹配 <code>urlPatterns</code> 配置的路径时，就会进入 <code>doFilter()</code> 方法进行具体的 <strong>请求</strong> 和 <strong>响应过滤</strong>。</p><p>当 <code>HTTP</code> 请求携带 <code>filter2</code> 参数时，请求会被放行；否则，直接 <strong>过滤中断</strong>，结束请求处理。</p><p>来看看 <code>doFilter()</code> 最核心的三个参数：</p><ul><li>ServletRequest: 未到达 <code>Servlet</code> 的 <code>HTTP</code> 请求； </li><li>ServletResponse: 由 <code>Servlet</code> 处理并生成的 <code>HTTP</code> 响应；</li><li>FilterChain: <strong>过滤器链</strong> 对象，可以按顺序注册多个 <strong>过滤器</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterChain.doFilter(request, response);</span><br></pre></td></tr></table></figure><blockquote><p><strong>解释：</strong> 一个 <strong>过滤器链</strong> 对象可以按顺序注册多个 <strong>过滤器</strong>。符合当前过滤器过滤条件，即请求 <strong>过滤成功</strong> 直接放行，则交由下一个 <strong>过滤器</strong> 进行处理。所有请求过滤完成以后，由 <code>IndexHttpServlet</code> 处理并生成 <strong>响应</strong>，然后在 <strong>过滤器链</strong> 以相反的方向对 <strong>响应</strong> 进行后置过滤处理。</p></blockquote><h3 id="配置控制器Controller"><a href="#配置控制器Controller" class="headerlink" title="配置控制器Controller"></a>配置控制器Controller</h3><p>配置 <code>IndexController</code>，用于测试 <code>/index/IndexController</code> 路径是否会被 <code>Filter</code> 过滤和 <code>Interceptor</code> 拦截，并验证两者的先后顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"IndexController"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"IndexController"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-配置拦截器Interceptor"><a href="#7-配置拦截器Interceptor" class="headerlink" title="7. 配置拦截器Interceptor"></a>7. 配置拦截器Interceptor</h2><p>拦截器 <code>Interceptor</code> 只对 <code>Handler</code> 生效。<code>Spring MVC</code> 会为 <code>Controller</code> 中的每个 <strong>请求方法</strong> 实例化为一个 <code>Handler</code>对象，由 <code>HandlerMapping</code> 对象路由请求到具体的 <code>Handler</code>，然后由 <code>HandlerAdapter</code> 通过反射进行请求 <strong>处理</strong> 和 <strong>响应</strong>，这中间就穿插着 <strong>拦截处理</strong>。</p><h4 id="编写拦截器"><a href="#编写拦截器" class="headerlink" title="编写拦截器"></a>编写拦截器</h4><p>为了区分日志，下面同样对 <code>IndexController</code> 配置两个拦截器类：</p><p>FirstIndexInterceptor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstIndexInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FirstIndexInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexInterceptor pre intercepted the request"</span>);</span><br><span class="line">        String interceptor = request.getParameter(<span class="string">"interceptor1"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(interceptor)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by FirstIndexFilter, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"interceptor1\""</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexInterceptor post intercepted the response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"FirstIndexInterceptor do something after request completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecondIndexInterceptor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondIndexInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SecondIndexInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexInterceptor pre intercepted the request"</span>);</span><br><span class="line">        String interceptor = request.getParameter(<span class="string">"interceptor2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(interceptor)) &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"Filtered by SecondIndexInterceptor, "</span> +</span><br><span class="line">                    <span class="string">"please set request parameter \"interceptor2\""</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexInterceptor post intercepted the response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"SecondIndexInterceptor do something after request completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h4><p>在 <code>Spring Boot</code> 中 <strong>配置拦截器</strong> 很简单，只需要实现 <code>WebMvcConfigurer</code> 接口，在 <code>addInterceptors()</code> 方法中通过 <code>InterceptorRegistry</code> 添加 <strong>拦截器</strong> 和 <strong>匹配路径</strong> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(WebConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> FirstIndexInterceptor()).addPathPatterns(<span class="string">"/index/**"</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> SecondIndexInterceptor()).addPathPatterns(<span class="string">"/index/**"</span>);</span><br><span class="line">        LOGGER.info(<span class="string">"Register FirstIndexInterceptor and SecondIndexInterceptor onto InterceptorRegistry"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>Spring XML</code> 配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"firstIndexInterceptor"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"io.ostenant.springboot.sample.interceptor.FirstIndexInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"secondIndexInterceptor"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"io.ostenant.springboot.sample.interceptor.SecondIndexInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/index/**"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"firstIndexInterceptor"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/index/**"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"secondIndexInterceptor"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h4><p>我们通过实现 <code>HandlerInterceptor</code> 接口来开发一个 <strong>拦截器</strong>，来看看 <code>HandlerInterceptor</code> 接口的三个重要的方法：</p><ul><li><p>preHandle(): 在 <code>controller</code> 接收请求、处理 <code>request</code> 之前执行，返回值为 <code>boolean</code>，返回值为 <code>true</code> 时接着执行 <code>postHandle()</code> 和 <code>afterCompletion()</code> 方法；如果返回 <code>false</code> 则 <strong>中断</strong> 执行。</p></li><li><p>postHandle(): 在 <code>controller</code> 处理请求之后， <code>ModelAndView</code> 处理前执行，可以对 <strong>响应结果</strong> 进行修改。</p></li><li><p>afterCompletion(): 在 <code>DispatchServlet</code> 对本次请求处理完成，即生成 <code>ModelAndView</code> 之后执行。</p></li></ul><p>下面简单的看一下 <code>Spring MVC</code> 中心调度器 <code>DispatcherServlet</code> 的 <code>doDispatch()</code> 方法的原理，重点关注 <strong>拦截器</strong> 的以上三个方法的执行顺序。</p><ul><li>doDispatch(): <code>DispatchServlet</code> 处理请求分发的核心方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 按从前往后的顺序调用各个拦截器preHandle()方法</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. HandlerAdapter开始真正的请求处理并生产响应视图对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 按照从后往前的顺序依次调用各个拦截器的postHandle()方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 4. 最终会调用拦截器的afterCompletion()方法</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        <span class="comment">// 4. 最终会调用拦截器的afterCompletion()方法</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面注释的几个 <code>HandlerExecutionChain</code> 的方法: <code>applyPreHandle()</code>、<code>applyPostHandle()</code> 和 <code>triggerAfterCompletion()</code>。 </p></blockquote><ul><li>applyPreHandle(): 按 <strong>从前往后</strong> 的顺序调用各个拦截器的 <code>preHandle()</code> 方法。任意一个 <code>HandlerInterceptor</code> 拦截返回 <code>false</code> ，则 <code>preHandle()</code> 返回 <code>false</code>，记录拦截器的位置 <code>interceptorIndex</code>，然后中断拦截处理，最终触发 <code>AfterCompletion()</code> 方法并返回 <code>false</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</span><br><span class="line">                triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.interceptorIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>applyPostHandle(): 按照 <strong>从后往前</strong> 的顺序依次调用各个拦截器的 <code>postHandle()</code> 方法。只有当所有 <code>HandlerInterceptor</code> 的 <code>preHandle()</code> 方法返回 <code>true</code> 时，才有机会执行到 <code>applyPostHandle()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>triggerAfterCompletion: <code>triggerAfterCompletion()</code> 只在 <code>preHandle()</code> 方法返回 <code>false</code> 和 <strong>程序抛出异常</strong> 时执行。在 <code>preHandle()</code> 方法中，通过 <code>interceptorIndex</code> 记录了返回 <code>false</code> 的 <strong>拦截器索引</strong>。一旦 <code>applyPreHandle()</code> 方法返回 <code>false</code>，则从当前返回 <code>false</code> 的拦截器 <strong>从后往前</strong> 的执行 <code>afterCompletion()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interceptor.afterCompletion(request, response, <span class="keyword">this</span>.handler, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">"HandlerInterceptor.afterCompletion threw exception"</span>, ex2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-开始测试"><a href="#8-开始测试" class="headerlink" title="8. 开始测试"></a>8. 开始测试</h2><h3 id="生命周期测试"><a href="#生命周期测试" class="headerlink" title="生命周期测试"></a>生命周期测试</h3><p>启动 <code>Spring Boot</code> 应用程序，观察启动时的程序日志，下面我按照 <strong>顺序</strong> 来分析启动过程中完成了哪些事情。</p><ul><li>注册 <code>Spring MVC</code> 的 <code>dispatcherServlet</code> 和自定义的 <code>IndexHttpServlet</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.400  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Servlet dispatcherServlet mapped to [/]</span><br><span class="line">2018-06-23 09:39:55.404  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Servlet IndexHttpServlet mapped to [/index/IndexHttpServlet]</span><br></pre></td></tr></table></figure><blockquote><p>注意: <code>dispatcherServlet</code> 的 <code>load-up-onstartup</code> 为 <code>1</code>，会优先于其他 <code>Servlet</code> 进行加载。</p></blockquote><ul><li>按照先后顺序，将所有的过滤器 <code>Filter</code> 对象与路径进行映射，其中 <code>characterEncodingFilter</code> 是 <code>Spring MVC</code> 自带的解决乱码的 <code>Filter</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.408  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: <span class="string">'characterEncodingFilter'</span> to: [/*]</span><br><span class="line">2018-06-23 09:39:55.409  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: <span class="string">'firstIndexFilter'</span> to urls: [/index/*]</span><br><span class="line">2018-06-23 09:39:55.409  INFO 12301 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: <span class="string">'secondIndexFilter'</span> to urls: [/index/*]</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>IndexServletContextListener</code>，并执行 <code>contextInitialized()</code> 方法进行上下文初始化操作。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.429  INFO 12301 --- [ost-startStop-1] i.o.s.s.l.IndexServletContextListener    : Start to initialize servlet context</span><br></pre></td></tr></table></figure><ul><li>依次执行 <code>Filter</code> 的 <code>init()</code> 方法进行初始化处理。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.432  INFO 12301 --- [ost-startStop-1] i.o.s.sample.filter.SecondIndexFilter     : Register a new filter secondIndexFilter</span><br><span class="line">2018-06-23 09:39:55.434  INFO 12301 --- [ost-startStop-1] i.o.s.sample.filter.FirstIndexFilter      : Register a new filter firstIndexFilter</span><br></pre></td></tr></table></figure><ul><li>创建、初始化拦截器，并统一注册到 <code>InterceptorRegistry</code> 上。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.502  INFO 13150 --- [           main] i.o.s.s.interceptor.WebConfiguration     : Register FirstIndexInterceptor and SecondIndexInterceptor onto InterceptorRegistry</span><br></pre></td></tr></table></figure><ul><li>对 <code>IndexController</code> 进行处理，把 <strong>请求</strong> <code>URI</code> 和 <strong>处理方法</strong> 映射到 <code>HandlerMapping</code> 上并进行缓存。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 09:39:55.541  INFO 12301 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped <span class="string">"&#123;[/index/IndexController],methods=[GET]&#125;"</span> onto public java.lang.String io.ostenant.springboot.sample.controller.IndexController.index() throws java.lang.Exception</span><br></pre></td></tr></table></figure><p>关闭 <code>Spring Boot</code> 应用程序时，观察输出日志如下: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 10:07:03.294  INFO 12301 --- [ost-startStop-2] i.o.s.sample.filter.FirstIndexFilter     : Destroy filter io.ostenant.springboot.sample.filter.SecondIndexFilter</span><br><span class="line">2018-06-23 10:07:03.294  INFO 12301 --- [ost-startStop-2] i.o.s.sample.filter.FirstIndexFilter     : Destroy filter io.ostenant.springboot.sample.filter.FirstIndexFilter</span><br><span class="line">2018-06-23 10:07:03.294  INFO 12301 --- [ost-startStop-2] i.o.s.s.l.IndexServletContextListener    : Destroy servlet context</span><br></pre></td></tr></table></figure><p>可以看到上面配置的过滤器的 <code>destroy()</code> 方法和 <code>IndexServletContextListener</code> 的 <code>contextDestroyed()</code> 方法都被调用了。</p><h3 id="访问控制测试"><a href="#访问控制测试" class="headerlink" title="访问控制测试"></a>访问控制测试</h3><h4 id="Servlet测试"><a href="#Servlet测试" class="headerlink" title="Servlet测试"></a>Servlet测试</h4><p>访问 <a href="http://localhost:8080/index/IndexHttpServlet" target="_blank" rel="noopener">http://localhost:8080/index/IndexHttpServlet</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b22951f75288?w=2056&amp;h=132&amp;f=png&amp;s=36514" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexHttpServlet?filter1=filter1" target="_blank" rel="noopener">http://localhost:8080/index/IndexHttpServlet?filter1=filter1</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b2294f07adf2?w=2052&amp;h=130&amp;f=png&amp;s=38121" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexHttpServlet?filter1=filter1&amp;filter2=filter2" target="_blank" rel="noopener">http://localhost:8080/index/IndexHttpServlet?filter1=filter1&amp;filter2=filter2</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b22951104958?w=2048&amp;h=196&amp;f=png&amp;s=52106" alt=""></p><p>观察控制台输出日志，验证 <strong>过滤器</strong> 的过滤顺序正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter post filter the response</span><br><span class="line">2018-06-23 10:19:47.944  INFO 13150 --- [nio-8080-exec-1] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter post filter the response</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong> 自定义的 <strong>过滤器</strong> 对 <code>IndexHttpServlet</code> 生效， 而 <strong>自定义</strong> 的拦截器生效。</p></blockquote><h4 id="controller测试"><a href="#controller测试" class="headerlink" title="controller测试"></a>controller测试</h4><p>访问 <a href="http://localhost:8080/index/IndexController" target="_blank" rel="noopener">http://localhost:8080/index/IndexController</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b2294fc8a36c?w=2052&amp;h=132&amp;f=png&amp;s=35303" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b2294fecf208?w=2042&amp;h=138&amp;f=png&amp;s=37551" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b229509d83f4?w=2052&amp;h=144&amp;f=png&amp;s=40857" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b229770dcdc4?w=2048&amp;h=142&amp;f=png&amp;s=45156" alt=""></p><p>访问 <a href="http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1&amp;interceptor2=interceptor2" target="_blank" rel="noopener">http://localhost:8080/index/IndexController?filter1=filter1&amp;filter2=filter2&amp;interceptor1=interceptor1&amp;interceptor2=interceptor2</a>，响应页面内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642b22976f450d8?w=2050&amp;h=144&amp;f=png&amp;s=36973" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-06-23 10:21:42.533  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:21:42.533  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter pre filter the request</span><br><span class="line">2018-06-23 10:21:42.534  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.FirstIndexInterceptor          : FirstIndexInterceptor pre intercepted the request</span><br><span class="line">2018-06-23 10:21:42.534  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.SecondIndexInterceptor         : SecondIndexInterceptor pre intercepted the request</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.SecondIndexInterceptor         : SecondIndexInterceptor post intercepted the response</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.FirstIndexInterceptor          : FirstIndexInterceptor post intercepted the response</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.SecondIndexInterceptor         : SecondIndexInterceptor <span class="keyword">do</span> something after request completed</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.s.i.FirstIndexInterceptor          : FirstIndexInterceptor <span class="keyword">do</span> something after request completed</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.SecondIndexFilter    : SecondIndexFilter post filter the response</span><br><span class="line">2018-06-23 10:21:42.535  INFO 13150 --- [nio-8080-exec-4] i.o.s.sample.filter.FirstIndexFilter     : FirstIndexFilter post filter the response</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong> 自定义的 <strong>过滤器</strong> 和 <strong>拦截器</strong> 对 <strong>控制器</strong> <code>Controller</code> 生效。而 <strong>过滤器</strong> 的优先级高于 <strong>拦截器</strong>。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文详细介绍了 <code>Listener</code>，<code>Servlet</code>，<code>Filter</code>，<code>Controller</code> 和 <code>Interceptor</code> 等 <code>Web</code> 多种组件的功能、方法、顺序、作用域和生命周期。给出了详细的示例代码，结合 <strong>源码</strong> 分析了流程，结合 <strong>测试</strong> 验证了结论。长篇大论，希望大家对 <code>Servlet</code> 组件和 <code>Spring MVC</code> 的框架组件有了更清晰的认识。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/1640df3c27eedf87?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;用户认证授权、日志记录 &lt;code&gt;MDC&lt;/code&gt;、编码解码、&lt;code&gt;UA&lt;/code&gt; 检查、多端对应等都需要通过 &lt;strong&gt;拦截请求&lt;/strong&gt; 来进行处理。这时就需要 &lt;code&gt;Servlet&lt;/code&gt;、&lt;code&gt;Filter&lt;/code&gt;、&lt;code&gt;Listener&lt;/code&gt;、&lt;code&gt;Interceptor&lt;/code&gt; 这几种组件。而把非 &lt;code&gt;Spring Boot&lt;/code&gt; 项目转换成 &lt;code&gt;Spring Boot&lt;/code&gt; 项目，需要沿用以前的这些代码，所以有必要了解这它们的 &lt;strong&gt;用法&lt;/strong&gt; 和 &lt;strong&gt;生命周期&lt;/strong&gt;。 &lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
      <category term="Listener" scheme="https://ostenant.coding.me/tags/Listener/"/>
    
      <category term="Servlet" scheme="https://ostenant.coding.me/tags/Servlet/"/>
    
      <category term="Filter" scheme="https://ostenant.coding.me/tags/Filter/"/>
    
      <category term="Interceptor" scheme="https://ostenant.coding.me/tags/Interceptor/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(四) - 使用WebAsyncTask处理异步任务</title>
    <link href="https://ostenant.coding.me/2018/06/18/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E5%9B%9B)%20-%20%E4%BD%BF%E7%94%A8WebAsyncTask%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>https://ostenant.coding.me/2018/06/18/实战Spring Boot 2.0系列(四) - 使用WebAsyncTask处理异步任务/</id>
    <published>2018-06-18T00:20:00.000Z</published>
    <updated>2018-06-18T14:08:49.695Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文介绍了基于 <code>@Async</code> 注解的 <strong>异步调用编程</strong>，本文将继续引入 <code>Spring Boot</code> 的 <code>WebAsyncTask</code> 进行更灵活异步任务处理，包括 <strong>异步回调</strong>，<strong>超时处理</strong> 和 <strong>异常处理</strong>。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413255f98b30e7?w=620&amp;h=595&amp;f=png&amp;s=81732" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-处理线程和异步线程"><a href="#1-处理线程和异步线程" class="headerlink" title="1. 处理线程和异步线程"></a>1. 处理线程和异步线程</h2><p>在开始下面的讲解之前，在这里先区别下两个概念：</p><ol><li><p>处理线程：<strong>处理线程</strong> 属于 <code>web</code> 服务器线程，负责 <strong>处理用户请求</strong>，采用 <strong>线程池</strong> 管理。</p></li><li><p>异步线程：<strong>异步线程</strong> 属于 <strong>用户自定义的线程</strong>，可采用 <strong>线程池管理</strong>。</p></li></ol><p><code>Spring</code> 提供了对 <strong>异步任务</strong> <code>API</code>，采用 <code>WebAsyncTask</code> 类即可实现 <strong>异步任务</strong>。对异步任务设置相应的 <strong>回调处理</strong>，如当 <strong>任务超时</strong>、<strong>异常抛出</strong> 等。异步任务通常非常实用，比如：当一笔订单支付完成之后，开启异步任务查询订单的支付结果。</p><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h2><h3 id="配置gradle依赖"><a href="#配置gradle依赖" class="headerlink" title="配置gradle依赖"></a>配置gradle依赖</h3><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-web-async-task</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置服务类"><a href="#配置服务类" class="headerlink" title="配置服务类"></a>配置服务类</h3><p>配置一个用于异步任务调度的 <code>Mock</code>   服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置异步处理控制器并注入以上服务 <code>Bean</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAsyncController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebAsyncService asyncService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ERROR_MESSAGE = <span class="string">"Task error"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TIME_MESSAGE = <span class="string">"Task timeout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebAsyncController</span><span class="params">(WebAsyncService asyncService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.asyncService = asyncService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-正常异步任务"><a href="#3-正常异步任务" class="headerlink" title="3. 正常异步任务"></a>3. 正常异步任务</h2><p>配置一个正常的 <code>WebAsyncTask</code> 任务对象，设置任务 <strong>超时时间</strong> 为 <code>10s</code>。异步任务执行采用 <code>Thread.sleep(long)</code> 模拟，这里设置 <strong>异步线程</strong> 睡眠时间为 <code>5s</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/completion"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印处理线程名</span></span><br><span class="line">    out.println(format(<span class="string">"请求处理线程：%s"</span>, currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟开启一个异步任务，超时时间为10s</span></span><br><span class="line">    WebAsyncTask&lt;String&gt; asyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, () -&gt; &#123;</span><br><span class="line">        out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">        <span class="comment">// 任务处理时间5s，不超时</span></span><br><span class="line">        sleep(<span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">return</span> asyncService.generateUUID();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行完成时调用该方法</span></span><br><span class="line">    asyncTask.onCompletion(() -&gt; out.println(<span class="string">"任务执行完成"</span>));</span><br><span class="line">    out.println(<span class="string">"继续处理其他事情"</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 项目，访问 <a href="http://localhost:8080/completion" target="_blank" rel="noopener">http://localhost:8080/completion</a> ，发起 <strong>正常</strong> 的异步任务请求。</p><p>观察控制台输出，可以验证 <code>WebAsyncTask</code> 的异步处理流程正常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求处理线程：http-nio-8080-exec-2</span><br><span class="line">继续处理其他事情</span><br><span class="line">异步工作线程：MvcAsync1</span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure><p><code>Web</code> 页面正常响应，页面响应消息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413283f62bb949?w=2052&amp;h=152&amp;f=png&amp;s=32271" alt=""></p><blockquote><p>注意：WebAsyncTask.onCompletion(Runnable) ：在当前任务执行结束以后，无论是执行成功还是异常中止，onCompletion的回调最终都会被调用。</p></blockquote><h2 id="4-抛出异常异步任务"><a href="#4-抛出异常异步任务" class="headerlink" title="4. 抛出异常异步任务"></a>4. 抛出异常异步任务</h2><p>配置一个 <strong>错误</strong> 的 <code>WebAsyncTask</code> 任务对象，设置任务 <strong>超时时间</strong> 为 <code>10s</code>。在异步任务执行方法中 <strong>抛出异常</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/exception"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印处理线程名</span></span><br><span class="line">    out.println(format(<span class="string">"请求处理线程：%s"</span>, currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟开启一个异步任务，超时时间为10s</span></span><br><span class="line">    WebAsyncTask&lt;String&gt; asyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, () -&gt; &#123;</span><br><span class="line">        out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">        <span class="comment">// 任务处理时间5s，不超时</span></span><br><span class="line">        sleep(<span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(ERROR_MESSAGE);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行完成时调用该方法</span></span><br><span class="line">    asyncTask.onCompletion(() -&gt; out.println(<span class="string">"任务执行完成"</span>));</span><br><span class="line">    asyncTask.onError(() -&gt; &#123;</span><br><span class="line">        out.println(<span class="string">"任务执行异常"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR_MESSAGE;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">"继续处理其他事情"</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 项目，访问 <a href="http://localhost:8080/exception" target="_blank" rel="noopener">http://localhost:8080/exception</a> ，发起 <strong>异常</strong> 的异步任务请求。</p><p><code>Web</code> 页面响应异常信息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413283fa3d4c0d?w=2050&amp;h=370&amp;f=png&amp;s=80643" alt=""></p><p>观察控制台输出，可以验证 <code>WebAsyncTask</code> 对于 <strong>异常请求</strong> 的异步处理过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">请求处理线程：http-nio-8080-exec-1</span><br><span class="line">继续处理其他事情</span><br><span class="line">异步工作线程：MvcAsync2</span><br><span class="line">2018-06-18 21:12:10.110 ERROR 89875 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] threw exception</span><br><span class="line"></span><br><span class="line">java.lang.Exception: Task error</span><br><span class="line">at io.ostenant.springboot.sample.controller.WebAsyncController.lambda<span class="variable">$asyncTaskException</span><span class="variable">$2</span>(WebAsyncController.java:55) ~[classes/:na]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.lambda<span class="variable">$startCallableProcessing</span><span class="variable">$4</span>(WebAsyncManager.java:317) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511) ~[na:1.8.0_172]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_172]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]</span><br><span class="line"></span><br><span class="line">2018-06-18 21:12:10.111 ERROR 89875 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] <span class="keyword">in</span> context with path [] threw exception [Request processing failed; nested exception is java.lang.Exception: Task error] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.Exception: Task error</span><br><span class="line">at io.ostenant.springboot.sample.controller.WebAsyncController.lambda<span class="variable">$asyncTaskException</span><span class="variable">$2</span>(WebAsyncController.java:55) ~[classes/:na]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.lambda<span class="variable">$startCallableProcessing</span><span class="variable">$4</span>(WebAsyncManager.java:317) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511) ~[na:1.8.0_172]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_172]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]</span><br><span class="line"></span><br><span class="line">任务执行异常</span><br><span class="line">2018-06-18 21:12:10.144  WARN 89875 --- [nio-8080-exec-2] o.apache.catalina.core.AsyncContextImpl  : onError() failed <span class="keyword">for</span> listener of <span class="built_in">type</span> [org.apache.catalina.core.AsyncListenerWrapper]</span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException: Cannot dispatch without an AsyncContext</span><br><span class="line">at org.springframework.util.Assert.notNull(Assert.java:193) ~[spring-core-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.dispatch(StandardServletAsyncWebRequest.java:131) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.setConcurrentResultAndDispatch(WebAsyncManager.java:353) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.WebAsyncManager.lambda<span class="variable">$startCallableProcessing</span><span class="variable">$2</span>(WebAsyncManager.java:304) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.lambda<span class="variable">$onError</span><span class="variable">$0</span>(StandardServletAsyncWebRequest.java:146) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at java.util.ArrayList.forEach(ArrayList.java:1257) ~[na:1.8.0_172]</span><br><span class="line">at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.onError(StandardServletAsyncWebRequest.java:146) ~[spring-web-5.0.7.RELEASE.jar:5.0.7.RELEASE]</span><br><span class="line">at org.apache.catalina.core.AsyncListenerWrapper.fireOnError(AsyncListenerWrapper.java:49) ~[tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.catalina.core.AsyncContextImpl.setErrorState(AsyncContextImpl.java:397) ~[tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:239) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.coyote.AbstractProcessor.dispatch(AbstractProcessor.java:232) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:53) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.coyote.AbstractProtocol<span class="variable">$ConnectionHandler</span>.process(AbstractProtocol.java:790) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint<span class="variable">$SocketProcessor</span>.doRun(NioEndpoint.java:1468) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_172]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624) [na:1.8.0_172]</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread<span class="variable">$WrappingRunnable</span>.run(TaskThread.java:61) [tomcat-embed-core-8.5.31.jar:8.5.31]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_172]</span><br><span class="line"></span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure><blockquote><p>注意：WebAsyncTask.onError(Callable&lt;?&gt;) ：当异步任务抛出异常的时候，onError()方法即会被调用。</p></blockquote><h2 id="5-超时异步任务"><a href="#5-超时异步任务" class="headerlink" title="5. 超时异步任务"></a>5. 超时异步任务</h2><p>配置一个正常的 <code>WebAsyncTask</code> 任务对象，设置任务 <strong>超时时间</strong> 为 <code>10s</code>。异步任务执行采用 <code>Thread.sleep(long)</code> 模拟，这里设置 <strong>异步线程</strong> 睡眠时间为 <code>15s</code>，引发异步任务超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/timeout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印处理线程名</span></span><br><span class="line">    out.println(format(<span class="string">"请求处理线程：%s"</span>, currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟开启一个异步任务，超时时间为10s</span></span><br><span class="line">    WebAsyncTask&lt;String&gt; asyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, () -&gt; &#123;</span><br><span class="line">        out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">        <span class="comment">// 任务处理时间5s，不超时</span></span><br><span class="line">        sleep(<span class="number">15</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">return</span> TIME_MESSAGE;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行完成时调用该方法</span></span><br><span class="line">    asyncTask.onCompletion(() -&gt; out.println(<span class="string">"任务执行完成"</span>));</span><br><span class="line">    asyncTask.onTimeout(() -&gt; &#123;</span><br><span class="line">        out.println(<span class="string">"任务执行超时"</span>);</span><br><span class="line">        <span class="keyword">return</span> TIME_MESSAGE;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">"继续处理其他事情"</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>Spring Boot</code> 项目，访问 <a href="http://localhost:8080/timeout" target="_blank" rel="noopener">http://localhost:8080/timeout</a> ，发起 <strong>超时</strong> 的异步任务请求。</p><p>观察控制台输出，可以验证 <code>WebAsyncTask</code> 的异步超时处理的过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求处理线程：http-nio-8080-exec-1</span><br><span class="line">继续处理其他事情</span><br><span class="line">异步工作线程：MvcAsync3</span><br><span class="line">任务执行超时</span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure><p><code>Web</code> 页面常响应超时提示信息，页面响应消息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16413283fdc0eed4?w=2052&amp;h=150&amp;f=png&amp;s=25521" alt=""></p><blockquote><p>注意：WebAsyncTask.onTimeout(Callable&lt;?&gt;) ：当异步任务发生超时的时候，onTimeout()方法即会被调用。</p></blockquote><h2 id="6-线程池异步任务"><a href="#6-线程池异步任务" class="headerlink" title="6. 线程池异步任务"></a>6. 线程池异步任务</h2><p>上面的三种情况中的 <strong>异步任务</strong> 默认不是采用 <strong>线程池机制</strong> 进行管理的。</p><p>也就是说，一个请求进来，虽然释放了处理线程，但是系统依旧会为每个请求创建一个 <strong>异步任务线程</strong>，也就是上面看到的 <code>MvcAsync</code> 开头的 <strong>异步任务线程</strong>。</p><p>后果就是开销严重，所以通常采用 <strong>线程池</strong> 进行统一的管理，直接在 <code>WebAsyncTask</code> 类构造器传入一个 <code>ThreadPoolTaskExecutor</code> 对象实例即可。</p><p>构造一个线程池 <code>Bean</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">"asyncTask"</span>);</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器中注入 <code>ThreadPoolTaskExecutor</code> 对象，重新配置基于 <strong>线程池</strong> 的 <strong>异步任务处理</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/threadPool"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTaskThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">10</span> * <span class="number">1000L</span>, executor,</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                out.println(format(<span class="string">"异步工作线程：%s"</span>, currentThread().getName()));</span><br><span class="line">                <span class="keyword">return</span> asyncService.generateUUID();</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发地请求 <a href="http://localhost:8080/threadPool" target="_blank" rel="noopener">http://localhost:8080/threadPool</a> ，观察控制台输出的 <strong>异步线程</strong> 信息，可以发现 <strong>异步任务</strong> 直接从 <strong>线程池</strong> 中获取 <strong>异步线程</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">异步工作线程：asyncTask1</span><br><span class="line">异步工作线程：asyncTask2</span><br><span class="line">异步工作线程：asyncTask3</span><br><span class="line">异步工作线程：asyncTask4</span><br><span class="line">异步工作线程：asyncTask5</span><br><span class="line">异步工作线程：asyncTask1</span><br><span class="line">异步工作线程：asyncTask2</span><br><span class="line">异步工作线程：asyncTask3</span><br><span class="line">异步工作线程：asyncTask4</span><br><span class="line">异步工作线程：asyncTask5</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了 <code>Spring Boot</code> 提供的 <code>WebAsyncTask</code> 的异步编程 <code>API</code>。相比上问介绍的 <code>@Async</code> 注解，<code>WebAsyncTask</code> 提供更加健全的 <strong>超时处理</strong> 和 <strong>异常处理</strong> 支持。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/17/1640df3c27eedf87?w=258&amp;h=258&amp;f=jpeg&amp;s=16109" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上文介绍了基于 &lt;code&gt;@Async&lt;/code&gt; 注解的 &lt;strong&gt;异步调用编程&lt;/strong&gt;，本文将继续引入 &lt;code&gt;Spring Boot&lt;/code&gt; 的 &lt;code&gt;WebAsyncTask&lt;/code&gt; 进行更灵活异步任务处理，包括 &lt;strong&gt;异步回调&lt;/strong&gt;，&lt;strong&gt;超时处理&lt;/strong&gt; 和 &lt;strong&gt;异常处理&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="异步" scheme="https://ostenant.coding.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(三) - 使用@Async进行异步调用详解</title>
    <link href="https://ostenant.coding.me/2018/06/17/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%B8%89)%20-%20%E4%BD%BF%E7%94%A8@Async%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ostenant.coding.me/2018/06/17/实战Spring Boot 2.0系列(三) - 使用@Async进行异步调用详解/</id>
    <published>2018-06-17T01:40:00.000Z</published>
    <updated>2018-06-18T01:57:16.309Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>异步调用</strong> 对应的是 <strong>同步调用</strong>，<strong>同步调用</strong> 指程序按照 <strong>定义顺序</strong> 依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行；<strong>异步调用</strong> 指程序在顺序执行时，<strong>不等待</strong> 异步调用的语句 <strong>返回结果</strong> 就执行后面的程序。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBootAll.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-async-task</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    compileOnly(<span class="string">'org.projectlombok:lombok'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Spring Boot</code> 入口类上配置 <code>@EnableAsync</code> 注解开启异步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建任务抽象类 <code>AbstractTask</code>，并分别配置三个任务方法 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.println(<span class="string">"开始做任务一"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"完成任务一，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.println(<span class="string">"开始做任务二"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"完成任务二，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.println(<span class="string">"开始做任务三"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"完成任务三，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-同步调用"><a href="#2-同步调用" class="headerlink" title="2. 同步调用"></a>2. 同步调用</h2><p>下面通过一个简单示例来直观的理解什么是同步调用：</p><ul><li>定义 <code>Task</code> 类，继承 <code>AbstractTask</code>，三个处理函数分别模拟三个执行任务的操作，操作消耗时间随机取（<code>10</code> 秒内）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>Task</code> 对象，并在测试用例中执行 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Task task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSyncTasks</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        task.doTaskOne();</span><br><span class="line">        task.doTaskTwo();</span><br><span class="line">        task.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行单元测试，可以看到类似如下输出：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">完成任务一，耗时：4059毫秒</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：6316毫秒</span><br><span class="line">开始做任务三</span><br><span class="line">完成任务三，耗时：1973毫秒</span><br></pre></td></tr></table></figure><p>任务一、任务二、任务三顺序的执行完了，换言之 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法顺序的执行完成。</p><h2 id="3-异步调用"><a href="#3-异步调用" class="headerlink" title="3. 异步调用"></a>3. 异步调用</h2><p>上述的 <strong>同步调用</strong> 虽然顺利的执行完了三个任务，但是可以看到 <strong>执行时间比较长</strong>，若这三个任务本身之间 <strong>不存在依赖关系</strong>，可以 <strong>并发执行</strong> 的话，同步调用在 <strong>执行效率</strong> 方面就比较差，可以考虑通过 <strong>异步调用</strong> 的方式来 <strong>并发执行</strong>。</p><ul><li>创建 <code>AsyncTask</code>类，分别在方法上配置 <code>@Async</code> 注解，将原来的 <strong>同步方法</strong> 变为 <strong>异步方法</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskTwo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>AsyncTask</code> 对象，并在测试用例中执行 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTask task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncTasks</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        task.doTaskOne();</span><br><span class="line">        task.doTaskTwo();</span><br><span class="line">        task.doTaskThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行单元测试，可以看到类似如下输出：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始做任务三</span><br><span class="line">开始做任务一</span><br><span class="line">开始做任务二</span><br></pre></td></tr></table></figure><p>如果反复执行单元测试，可能会遇到各种不同的结果，比如：</p><ol><li>没有任何任务相关的输出</li><li>有部分任务相关的输出</li><li>乱序的任务相关的输出</li></ol><p>原因是目前 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 这三个方法已经 <strong>异步执行</strong> 了。主程序在 <strong>异步调用</strong> 之后，主程序并不会理会这三个函数是否执行完成了，由于没有其他需要执行的内容，所以程序就 <strong>自动结束</strong> 了，导致了 <strong>不完整</strong> 或是 <strong>没有输出任务</strong> 相关内容的情况。</p><blockquote><p>注意：@Async所修饰的函数不要定义为static类型，这样异步调用不会生效。</p></blockquote><h3 id="4-异步回调"><a href="#4-异步回调" class="headerlink" title="4. 异步回调"></a>4. 异步回调</h3><p>为了让 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 能正常结束，假设我们需要统计一下三个任务 <strong>并发执行</strong> 共耗时多少，这就需要等到上述三个函数都完成动用之后记录时间，并计算结果。</p><p>那么我们如何判断上述三个 <strong>异步调用</strong> 是否已经执行完成呢？我们需要使用 <code>Future&lt;T&gt;</code> 来返回 <strong>异步调用</strong> 的 <strong>结果</strong>。</p><ul><li>创建 <code>AsyncCallBackTask</code> 类，声明 <code>doTaskOneCallback()</code>，<code>doTaskTwoCallback()</code>，<code>doTaskThreeCallback()</code> 三个方法，对原有的三个方法进行包装。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCallBackTask</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">doTaskOneCallback</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskOne();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务一完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">doTaskTwoCallback</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskTwo();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务二完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">doTaskThreeCallback</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskThree();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务三完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>AsyncCallBackTask</code> 对象，并在测试用例中执行 <code>doTaskOneCallback()</code>，<code>doTaskTwoCallback()</code>，<code>doTaskThreeCallback()</code> 三个方法。循环调用 <code>Future</code> 的 <code>isDone()</code> 方法等待三个 <strong>并发任务</strong> 执行完成，记录最终执行时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCallBackTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncCallBackTask task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncCallbackTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = currentTimeMillis();</span><br><span class="line">        Future&lt;String&gt; task1 = task.doTaskOneCallback();</span><br><span class="line">        Future&lt;String&gt; task2 = task.doTaskTwoCallback();</span><br><span class="line">        Future&lt;String&gt; task3 = task.doTaskThreeCallback();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三个任务都调用完成，退出循环等待</span></span><br><span class="line">        <span class="keyword">while</span> (!task1.isDone() || !task2.isDone() || !task3.isDone()) &#123;</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = currentTimeMillis();</span><br><span class="line">        out.println(<span class="string">"任务全部完成，总耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看都做了哪些改变：</p><ul><li>在测试用例一开始记录开始时间；</li><li>在调用三个异步函数的时候，返回Future<string>类型的结果对象；</string></li><li>在调用完三个异步函数之后，开启一个循环，根据返回的Future<string>对象来判断三个异步函数是否都结束了。若都结束，就结束循环；若没有都结束，就等1秒后再判断。</string></li><li>跳出循环之后，根据结束时间 - 开始时间，计算出三个任务并发执行的总耗时。</li></ul><p>执行一下上述的单元测试，可以看到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">开始做任务三</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：4882毫秒</span><br><span class="line">完成任务三，耗时：6484毫秒</span><br><span class="line">完成任务一，耗时：8748毫秒</span><br><span class="line">任务全部完成，总耗时：9043毫秒</span><br></pre></td></tr></table></figure><p>可以看到，通过 <strong>异步调用</strong>，让任务一、任务二、任务三 <strong>并发执行</strong>，有效的 <strong>减少</strong> 了程序的 <strong>运行总时间</strong>。</p><h2 id="5-定义线程池"><a href="#5-定义线程池" class="headerlink" title="5. 定义线程池"></a>5. 定义线程池</h2><p>在上述操作中，创建一个 <strong>线程池配置类</strong> <code>TaskConfiguration</code> ，并配置一个 <strong>任务线程池对象</strong> <code>taskExecutor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"taskExecutor-"</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们通过使用 <code>ThreadPoolTaskExecutor</code> 创建了一个 <strong>线程池</strong>，同时设置了以下这些参数：</p><table><thead><tr><th style="text-align:left">线程池属性</th><th style="text-align:left">属性的作用</th><th style="text-align:center">设置初始值</th></tr></thead><tbody><tr><td style="text-align:left">核心线程数</td><td style="text-align:left">线程池创建时候初始化的线程数</td><td style="text-align:center">10</td></tr><tr><td style="text-align:left">最大线程数</td><td style="text-align:left">线程池最大的线程数，只有在缓冲队列满了之后，才会申请超过核心线程数的线程</td><td style="text-align:center">20</td></tr><tr><td style="text-align:left">缓冲队列</td><td style="text-align:left">用来缓冲执行任务的队列</td><td style="text-align:center">200</td></tr><tr><td style="text-align:left">允许线程的空闲时间</td><td style="text-align:left">当超过了核心线程之外的线程，在空闲时间到达之后会被销毁</td><td style="text-align:center">60秒</td></tr><tr><td style="text-align:left">线程池名的前缀</td><td style="text-align:left">可以用于定位处理任务所在的线程池</td><td style="text-align:center">taskExecutor-</td></tr><tr><td style="text-align:left">线程池对拒绝任务的处理策略</td><td style="text-align:left">这里采用CallerRunsPolicy策略，当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务</td><td style="text-align:center">CallerRunsPolicy</td></tr></tbody></table><ul><li>创建 <code>AsyncExecutorTask</code>类，三个任务的配置和 <code>AsyncTask</code> 一样，不同的是 <code>@Async</code> 注解需要指定前面配置的 <strong>线程池的名称</strong> <code>taskExecutor</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExecutorTask</span> <span class="keyword">extends</span> <span class="title">AbstractTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskOne();</span><br><span class="line">        out.println(<span class="string">"任务一，当前线程："</span> + currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskTwo();</span><br><span class="line">        out.println(<span class="string">"任务二，当前线程："</span> + currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTaskThree</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doTaskThree();</span><br><span class="line">        out.println(<span class="string">"任务三，当前线程："</span> + currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <strong>单元测试</strong> 用例中，注入 <code>AsyncExecutorTask</code> 对象，并在测试用例中执行 <code>doTaskOne()</code>，<code>doTaskTwo()</code>，<code>doTaskThree()</code> 三个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExecutorTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncExecutorTask task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncExecutorTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        task.doTaskOne();</span><br><span class="line">        task.doTaskTwo();</span><br><span class="line">        task.doTaskThree();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">30</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下上述的 <strong>单元测试</strong>，可以看到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">开始做任务三</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：3905毫秒</span><br><span class="line">任务二，当前线程：taskExecutor-2</span><br><span class="line">完成任务一，耗时：6184毫秒</span><br><span class="line">任务一，当前线程：taskExecutor-1</span><br><span class="line">完成任务三，耗时：9737毫秒</span><br><span class="line">任务三，当前线程：taskExecutor-3</span><br></pre></td></tr></table></figure><p>执行上面的单元测试，观察到 <strong>任务线程池</strong> 的 <strong>线程池名的前缀</strong> 被打印，说明 <strong>线程池</strong> 成功执行 <strong>异步任务</strong>！</p><h2 id="6-优雅地关闭线程池"><a href="#6-优雅地关闭线程池" class="headerlink" title="6. 优雅地关闭线程池"></a>6. 优雅地关闭线程池</h2><blockquote><p>由于在应用关闭的时候异步任务还在执行，导致类似 <strong>数据库连接池</strong> 这样的对象一并被 <strong>销毁了</strong>，当 <strong>异步任务</strong> 中对 <strong>数据库</strong> 进行操作就会出错。</p></blockquote><p>解决方案如下，重新设置线程池配置对象，新增线程池 <code>setWaitForTasksToCompleteOnShutdown()</code> 和 <code>setAwaitTerminationSeconds()</code> 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadPoolTaskScheduler executor = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">    executor.setPoolSize(<span class="number">20</span>);</span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">"taskExecutor-"</span>);</span><br><span class="line">    executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">    executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>setWaitForTasksToCompleteOnShutdown(true):</strong> 该方法用来设置 <strong>线程池关闭</strong> 的时候 <strong>等待</strong> 所有任务都完成后，再继续 <strong>销毁</strong> 其他的 <code>Bean</code>，这样这些 <strong>异步任务</strong> 的 <strong>销毁</strong> 就会先于 <strong>数据库连接池对象</strong> 的销毁。</p></li><li><p><strong>setAwaitTerminationSeconds(60):</strong> 该方法用来设置线程池中 <strong>任务的等待时间</strong>，如果超过这个时间还没有销毁就 <strong>强制销毁</strong>，以确保应用最后能够被关闭，而不是阻塞住。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了在 <code>Spring Boot</code> 中如何使用 <code>@Async</code> 注解配置 <strong>异步任务</strong>、<strong>异步回调任务</strong>，包括结合 <strong>任务线程池</strong> 的使用，以及如何 <strong>正确</strong> 并 <strong>优雅</strong> 地关闭 <strong>任务线程池</strong>。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;异步调用&lt;/strong&gt; 对应的是 &lt;strong&gt;同步调用&lt;/strong&gt;，&lt;strong&gt;同步调用&lt;/strong&gt; 指程序按照 &lt;strong&gt;定义顺序&lt;/strong&gt; 依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行；&lt;strong&gt;异步调用&lt;/strong&gt; 指程序在顺序执行时，&lt;strong&gt;不等待&lt;/strong&gt; 异步调用的语句 &lt;strong&gt;返回结果&lt;/strong&gt; 就执行后面的程序。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="异步" scheme="https://ostenant.coding.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(二) - 全局异常处理和测试</title>
    <link href="https://ostenant.coding.me/2018/06/16/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%BA%8C)%20-%20%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%92%8C%E6%B5%8B%E8%AF%95/"/>
    <id>https://ostenant.coding.me/2018/06/16/实战Spring Boot 2.0系列(二) - 全局异常处理和测试/</id>
    <published>2018-06-16T07:35:00.000Z</published>
    <updated>2018-06-18T01:57:50.010Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常 <code>web</code> 开发中发生了异常，往往需要通过一个统一的 <strong>异常处理</strong>，来保证客户端能够收到友好的提示。本文将会介绍 <code>Spring Boot</code> 中的 <strong>全局统一异常处理</strong>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBootAll.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-global-exception-handle</code>，创建时添加相关依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    compile(<span class="string">'org.projectlombok:lombok'</span>)</span><br><span class="line">    compile(<span class="string">'org.apache.commons:commons-lang3:3.1'</span>)</span><br><span class="line">    compile(<span class="string">'com.google.guava:guava:19.0'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-配置入口类"><a href="#2-配置入口类" class="headerlink" title="2. 配置入口类"></a>2. 配置入口类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-配置实体类"><a href="#3-配置实体类" class="headerlink" title="3. 配置实体类"></a>3. 配置实体类</h2><p>首先安装 <code>Intellij Idea</code> 的 <code>lombok</code> 插件，这里不做详细的介绍。切记，需要在设置中将 <code>Enable annotation processing</code> 勾选上，否则 <strong>测试代码</strong> 在 <strong>编译时</strong> 会无法对 <code>lombok</code> 插件配置的 <strong>注解</strong> 进行处理。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Annotation_Process.png" alt=""></p><p>使用 <code>lombok</code> 工具提供的 <strong>注解</strong> 配置一个实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String accountName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-配置异常响应实体"><a href="#4-配置异常响应实体" class="headerlink" title="4. 配置异常响应实体"></a>4. 配置异常响应实体</h2><p><code>ErrorMessage</code> 实体用于记录具体的 <strong>异常信息</strong>，并响应 <strong>客户端</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorMessage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer OK = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ERROR = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-配置相关异常类"><a href="#5-配置相关异常类" class="headerlink" title="5. 配置相关异常类"></a>5. 配置相关异常类</h2><p>SessionNotFoundException.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionNotFoundException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionNotFoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setMessage(<span class="string">"Session is not found!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionNotFoundException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NullOrEmptyException.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullOrEmptyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullOrEmptyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setMessage(<span class="string">"Parameter is null or empty!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullOrEmptyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IllegalPropertiesException.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IllegalPropertiesException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalPropertiesException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setMessage(<span class="string">"Prop is illegal!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalPropertiesException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        setMessage(String.format(<span class="string">"Prop: %s is illegal!"</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-配置全局异常通知"><a href="#6-配置全局异常通知" class="headerlink" title="6. 配置全局异常通知"></a>6. 配置全局异常通知</h2><p>从 <code>spring 3.2</code> 开始，新增了 <code>@ControllerAdvice</code> 注解，可以用于定义 <code>@ExceptionHandler</code>，并应用到配置了 <code>@RequestMapping</code> 的控制器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(SessionNotFoundException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">sessionNotFoundExceptionHandler</span><span class="params">(HttpServletRequest request, SessionNotFoundException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullOrEmptyException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">nullOrEmptyExceptionHandler</span><span class="params">(HttpServletRequest request, NullOrEmptyException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(IllegalPropertiesException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">illegalPropExceptionHandler</span><span class="params">(HttpServletRequest request, IllegalPropertiesException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorMessage&lt;String&gt; <span class="title">exceptionHandler</span><span class="params">(HttpServletRequest request, Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleErrorInfo(request, exception.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ErrorMessage&lt;String&gt; <span class="title">handleErrorInfo</span><span class="params">(HttpServletRequest request, String message, Exception exception)</span> </span>&#123;</span><br><span class="line">        ErrorMessage&lt;String&gt; errorMessage = <span class="keyword">new</span> ErrorMessage&lt;&gt;();</span><br><span class="line">        errorMessage.setMessage(message);</span><br><span class="line">        errorMessage.setCode(ErrorMessage.ERROR);</span><br><span class="line">        errorMessage.setData(message);</span><br><span class="line">        errorMessage.setUrl(request.getRequestURL().toString());</span><br><span class="line">        <span class="keyword">return</span> errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码指定了 <code>3</code> 个 <strong>特定</strong> 的异常处理器和 <code>1</code> 个 <strong>默认</strong> 的异常处理器。当请求处理出现异常时，会根据 <strong>异常处理器</strong> 的 <strong>配置顺序</strong> 依次尝试 <strong>异常匹配</strong> 和 <strong>处理</strong>。</p><p>当异常不在 SessionNotFoundException、NullOrEmptyException、IllegalPropertiesException 中时，<code>Spring</code> 会委托 <strong>默认</strong> 的 <code>exceptionHandler</code> 进行处理。</p><h2 id="7-配置控制器"><a href="#7-配置控制器" class="headerlink" title="7. 配置控制器"></a>7. 配置控制器</h2><p>根据请求数据的差异，控制器能覆盖以上 <code>3</code> 种异常处理路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; save(HttpServletRequest request, HttpSession session) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String sessionId = (String) session.getAttribute(<span class="string">"sessionId"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sessionId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SessionNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String userPlainText = request.getParameter(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(userPlainText) || StringUtils.equalsIgnoreCase(<span class="string">"&#123;&#125;"</span>, userPlainText)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullOrEmptyException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        User user = objectMapper.readValue(userPlainText, User.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalPropertiesException(<span class="string">"username"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getAccountName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalPropertiesException(<span class="string">"accountName"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">"Successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-配置Mock测试类"><a href="#8-配置Mock测试类" class="headerlink" title="8. 配置Mock测试类"></a>8. 配置Mock测试类</h2><p><code>Spring Mock</code> 的相关配置这里就不详细介绍了，以下测试类覆盖了 <code>UserController</code> 的所有执行路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"UserControllerTester"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    <span class="keyword">private</span> MockHttpSession session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImmutableMap&lt;Long, Pair&lt;String, String&gt;&gt; map = <span class="keyword">new</span> ImmutableMap.Builder&lt;Long, Pair&lt;String, String&gt;&gt;()</span><br><span class="line">            .put(<span class="number">0x00001L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">""</span>))</span><br><span class="line">            .put(<span class="number">0x00002L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;&#125;"</span>))</span><br><span class="line">            .put(<span class="number">0x00003L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;\"username\": \"\", \"accountName\": \"\"&#125;"</span>))</span><br><span class="line">            .put(<span class="number">0x00004L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;\"username\": \"Harrison\", \"accountName\": \"\"&#125;"</span>))</span><br><span class="line">            .put(<span class="number">0x00005L</span>, Pair.of(<span class="string">"user"</span>, <span class="string">"&#123;\"username\": \"Harrison\", \"accountName\": \"ostenant\"&#125;"</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> singleRunner = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (singleRunner) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mockMvc = MockMvcBuilders.standaloneSetup(userController).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">        &#125;</span><br><span class="line">        session = <span class="keyword">new</span> MockHttpSession();</span><br><span class="line">        session.setAttribute(<span class="string">"sessionId"</span>, StringUtils.replace(UUID.randomUUID().toString(), <span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">        log.debug(<span class="string">"sessionId: &#123;&#125;"</span>, session.getAttribute(<span class="string">"sessionId"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试SessionNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSessionNotFoundException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        session.clearAttributes();</span><br><span class="line">        <span class="comment">// 模拟发送请求</span></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00005L</span>).getKey(), map.get(<span class="number">0x00005L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试NullOrEmptyException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNullOrEmptyException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00001L</span>).getKey(), map.get(<span class="number">0x00001L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00002L</span>).getKey(), map.get(<span class="number">0x00002L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试IllegalPropException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIllegalPropException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00003L</span>).getKey(), map.get(<span class="number">0x00003L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00004L</span>).getKey(), map.get(<span class="number">0x00004L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试正常运行的情况</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNormal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">                MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">                        .param(map.get(<span class="number">0x00005L</span>).getKey(), map.get(<span class="number">0x00005L</span>).getValue())</span><br><span class="line">                        .session(session))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().handlerType(UserController.class))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.handler().methodName((<span class="string">"save"</span>)))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-测试结果"><a href="#9-测试结果" class="headerlink" title="9. 测试结果"></a>9. 测试结果</h2><p>批量运行测试，测试结果如下，所有的测试用例全部通过。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Spring_Boot_Exception_Handler_Result.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>使用 <code>@ControllerAdvice</code> 处理异常也有一定的 <strong>局限性</strong>。只有进入 <code>Controller</code> 层的错误，才会由 <code>@ControllerAdvice</code> 处理。<strong>拦截器</strong> 抛出的错误，以及 <strong>访问错误地址</strong> 的情况 <code>@ControllerAdvice</code> 处理不了，由 <code>Spring Boot</code> 默认的 <strong>异常处理机制</strong> 处理。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在日常 &lt;code&gt;web&lt;/code&gt; 开发中发生了异常，往往需要通过一个统一的 &lt;strong&gt;异常处理&lt;/strong&gt;，来保证客户端能够收到友好的提示。本文将会介绍 &lt;code&gt;Spring Boot&lt;/code&gt; 中的 &lt;strong&gt;全局统一异常处理&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
  </entry>
  
  <entry>
    <title>实战Spring Boot 2.0系列(一) - 使用Gradle构建Docker镜像</title>
    <link href="https://ostenant.coding.me/2018/06/14/%E5%AE%9E%E6%88%98Spring%20Boot%202.0%E7%B3%BB%E5%88%97(%E4%B8%80)%20-%20%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F/"/>
    <id>https://ostenant.coding.me/2018/06/14/实战Spring Boot 2.0系列(一) - 使用Gradle构建Docker镜像/</id>
    <published>2018-06-14T11:35:00.000Z</published>
    <updated>2018-06-21T05:42:28.292Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常我们使用 <code>Dockerfile</code> 来构建项目的 <code>Docker</code> 镜像。但是也有使用 <code>gradle</code> 在编译项目的时候一起把镜像给 <strong>构建</strong> 并 <strong>上传</strong> 的需求。本文将会讲解如何使用 <code>gradle</code> 编写并配置 <code>Dockerfile</code> 并生成 <strong>镜像</strong>。</p><a id="more"></a><p><img src="http://ols3fdyll.bkt.clouddn.com/SpringBootAll.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>利用 <code>Spring Initializer</code> 创建一个 <code>gradle</code> 项目  <code>spring-boot-gradle-for-docker</code>，创建时添加一个 <code>web</code> 依赖。得到的初始 <code>build.gradle</code> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'1.0'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-配置入口类"><a href="#2-配置入口类" class="headerlink" title="2. 配置入口类"></a>2. 配置入口类</h2><p>为了方便容器部署的测试，在 <code>Spring Boot</code> 启动类上配置一个控制器，响应当前的系统时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd hh:mm:ss"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">retrieveTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-添加插件"><a href="#3-添加插件" class="headerlink" title="3. 添加插件"></a>3. 添加插件</h2><p>这里使用 <a href="https://github.com/Transmode/gradle-docker" target="_blank" rel="noopener"><code>gradle-docker</code></a> <strong>插件</strong> 来实现 <code>docker</code> 镜像构建。这样，我们就可以直接在 <code>Gradle</code> 的脚本里配置 <code>Dockerfile</code> 达到 <strong>构建镜像</strong> 功能的目的。</p><p><code>gradle-docker</code> 插件已经被上传到 <code>jCenter</code> 和 <code>MavenCentral</code> 上。所以只需要在 <code>dependencies</code> 添加依赖 <code>se.transmode.gradle:gradle-docker:1.2</code> 就能使用 <code>docker</code> 插件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">        classpath(<span class="string">"se.transmode.gradle:gradle-docker:1.2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-应用插件"><a href="#4-应用插件" class="headerlink" title="4. 应用插件"></a>4. 应用插件</h2><p>添加以下代码到 <code>build.gradle</code>中</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'docker'</span></span><br></pre></td></tr></table></figure><p>如果添加了 <code>application</code> 插件的话，默认 <code>gradle-docker</code> 插件会添加一个 <code>distDocker</code> 的 <code>gradle task</code>，用来构建一个 <strong>包含所有程序文件</strong> 的 <code>docker</code> 镜像。</p><h2 id="5-配置镜像构建信息"><a href="#5-配置镜像构建信息" class="headerlink" title="5. 配置镜像构建信息"></a>5. 配置镜像构建信息</h2><h3 id="5-1-配置group"><a href="#5-1-配置group" class="headerlink" title="5.1. 配置group"></a>5.1. 配置group</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br></pre></td></tr></table></figure><h3 id="5-2-配置镜像名称和版本号"><a href="#5-2-配置镜像名称和版本号" class="headerlink" title="5.2. 配置镜像名称和版本号"></a>5.2. 配置镜像名称和版本号</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    baseName = <span class="string">"spring-boot-gradle-for-docker"</span></span><br><span class="line">    version = <span class="number">1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中镜像的 <code>tag</code> 默认的构成为：<strong>项目组/应用名称:版本号</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag = <span class="string">"$&#123;project.group&#125;/$&#123;applicationName&#125;:$&#123;tagVersion&#125;"</span></span><br></pre></td></tr></table></figure><ul><li><p>project.group：标准的 <code>gradle</code> 属性，如果不进行定义，插件默认会 <strong>省略</strong> <code>${project.group}</code> 这个属性。</p></li><li><p>applicationName：应用被容器化时的 <strong>名称</strong>。</p></li><li><p>tagVersion：可选属性，会作为镜像的 <strong>标签</strong>。默认值为 <code>project.version</code>，如果未指定 <code>project.version</code>，则使用 <code>latest</code> 作为标记。</p></li></ul><h3 id="5-3-配置docker构建基础信息"><a href="#5-3-配置docker构建基础信息" class="headerlink" title="5.3. 配置docker构建基础信息"></a>5.3. 配置docker构建基础信息</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">distDocker &#123;</span><br><span class="line">    baseImage = <span class="string">"openjdk"</span></span><br><span class="line">    maintainer = <span class="string">"harrison"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>baseImage</code> 相当于 <code>Dockerfile</code> 中声明的 <code>FROM</code>。声明了在 <strong>构建镜像</strong> 是基于的 <code>Image</code>，<code>maintainer</code> 相当于 <code>MAINTAINER</code> ，声明了 <strong>镜像作者</strong>。如果声明了 <code>registry</code> 地址，插件在 <strong>镜像射生成后</strong> 可以自动 <code>push</code> 到该地址。其他的配置还包括 <code>docker hub</code> 的 <strong>地址</strong>、<strong>用户名</strong> 和 <strong>密码</strong>。</p><p>更详细的配置案例如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker &#123;</span><br><span class="line">    baseImage <span class="string">'openjdk'</span></span><br><span class="line">    maintainer <span class="string">'harrison'</span></span><br><span class="line">    useApi <span class="literal">true</span></span><br><span class="line">    hostUrl <span class="string">'http://myserver:4243'</span></span><br><span class="line">    apiUsername <span class="string">'user'</span></span><br><span class="line">    apiPassword <span class="string">'password'</span></span><br><span class="line">    apiEmail <span class="string">'me@mycompany.com'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-添加task任务"><a href="#6-添加task任务" class="headerlink" title="6. 添加task任务"></a>6. 添加task任务</h2><p>完成了基本的配置，我们还需要添加一个 <code>task</code> 用来在 <code>gradle</code> 编译的时候 <strong>执行镜像构建</strong>。</p><p>插件提供了一些 <strong>转换方法</strong>，用来指代 <code>Dockerfile</code> 中的 <strong>关键词语法</strong>，如下表，可以按照需求对照着来：</p><table><thead><tr><th style="text-align:left">Dockerfile关键词</th><th style="text-align:left">gradle task方法</th></tr></thead><tbody><tr><td style="text-align:left">ADD</td><td style="text-align:left">addFile(Closure copySpec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">addFile(String source, String dest)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">addFile(File source, String dest)</td></tr><tr><td style="text-align:left">CMD</td><td style="text-align:left">defaultCommand(List cmd)</td></tr><tr><td style="text-align:left">ENTRYPOINT</td><td style="text-align:left">entryPoint(List entryPoint)</td></tr><tr><td style="text-align:left">ENV</td><td style="text-align:left">setEnvironment(String key, String val)</td></tr><tr><td style="text-align:left">EXPOSE</td><td style="text-align:left">exposePort(Integer port)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">exposePort(String port)</td></tr><tr><td style="text-align:left">RUN</td><td style="text-align:left">runCommand(String cmd)</td></tr><tr><td style="text-align:left">USER</td><td style="text-align:left">switchUser(String userNameOrUid)</td></tr><tr><td style="text-align:left">VOLUME</td><td style="text-align:left">volume(String… paths)</td></tr><tr><td style="text-align:left">WORKDIR</td><td style="text-align:left">workingDir(String dir)</td></tr></tbody></table><p>下面是本项目的 <code>taskBuilder</code> 的任务配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task dockerBuilder(<span class="string">type:</span> Docker) &#123;</span><br><span class="line">    applicationName = jar.baseName</span><br><span class="line">    tagVersion = jar.version</span><br><span class="line">    volume(<span class="string">'/tmp'</span>)</span><br><span class="line">    addFile(<span class="string">"$&#123;jar.baseName&#125;-$&#123;jar.version&#125;.jar"</span>, <span class="string">"app.jar"</span>)</span><br><span class="line">    entryPoint([<span class="string">"java"</span>, <span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>, <span class="string">"-jar"</span>, <span class="string">'app.jar'</span>])</span><br><span class="line">    exposePort(<span class="number">8080</span>)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from jar</span><br><span class="line">            into stageDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建完成y以后，项目根目录的 <code>build/docker</code> 文件夹下面会出现 <code>Dockerfile</code> 和 <code>spring-boot-gradle-for-docker-1.0.jar</code> 文件。其中，以上的 <code>task</code> 等同于以下的 <code>Dockerfile</code>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> aglover/java8-pier</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/tmp"</span>]</span></span><br><span class="line"><span class="bash">ADD spring-boot-gradle-for-docker-1.0.jar app.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>, <span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>, <span class="string">"-jar"</span>, <span class="string">"app.jar"</span>]</span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br></pre></td></tr></table></figure><p>如果觉的在 <code>task</code> 中编写 <code>Dockerfile</code> <strong>替换脚本</strong> 非常别扭，也可以直接在 <code>task</code> 中指定 <code>Dockfile</code> 的 <strong>文件路径</strong>，直接使用已有的文件来生成镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task buildDocker(type: Docker) &#123;</span><br><span class="line">    applicationName = jar.baseName</span><br><span class="line">    tagVersion = jar.version</span><br><span class="line">    dockerfile = file(<span class="string">'Dockerfile'</span>)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        <span class="keyword">copy</span><span class="bash"> &#123;</span></span><br><span class="line"><span class="bash">            from jar</span></span><br><span class="line"><span class="bash">            into stageDir</span></span><br><span class="line"><span class="bash">        &#125;</span></span><br><span class="line"><span class="bash">    &#125;</span></span><br><span class="line"><span class="bash">&#125;</span></span><br></pre></td></tr></table></figure><p>通过 <code>file()</code> 指定 <code>task</code> 使用位于 <strong>项目根目录</strong> 的 <code>Dockerfile</code> 来生产镜像。</p><h2 id="7-编译并构建Docker镜像"><a href="#7-编译并构建Docker镜像" class="headerlink" title="7. 编译并构建Docker镜像"></a>7. 编译并构建Docker镜像</h2><p>进入项目根目录，运行 <code>gradle</code> 命令进行打包构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew clean build dockerBuilder --info</span><br></pre></td></tr></table></figure><p><code>gradle</code> 首先会运行 <strong>本地测试</strong>，然后进行 <strong>项目打包</strong>，进一步根据 <code>docker-gradle</code> 插件进行 <strong>镜像构建</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/gradle_build_docker_image_2.png" alt=""></p><p>等待出现 <code>BUILD SUCCESSFUL</code> 就表明任务运行成功。可以观察到镜像的名称为</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.ostenant.springboot.sample/spring-boot-gradle-<span class="keyword">for</span>-<span class="string">docker:</span><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>运行 <code>docker images</code> 查看本地镜像，进一步验证镜像构建成功。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/gradle_bulld_docker_images.png" alt=""></p><p>下面给出 <code>build.gradle</code> <strong>完整的</strong> 配置文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">        classpath(<span class="string">"se.transmode.gradle:gradle-docker:1.2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'docker'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group = <span class="string">'io.ostenant.springboot.sample'</span></span><br><span class="line">version = <span class="string">'1.0'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line">targetCompatibility = <span class="number">1.8</span></span><br><span class="line">mainClassName = <span class="string">"io.ostenant.springboot.sample.Application"</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">    testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    baseName <span class="string">'spring-boot-gradle-for-docker'</span></span><br><span class="line">    version <span class="string">'1.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">distDocker &#123;</span><br><span class="line">    baseImage <span class="string">'openjdk'</span></span><br><span class="line">    maintainer <span class="string">'harrison'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task dockerBuilder(<span class="string">type:</span> Docker) &#123;</span><br><span class="line">    applicationName = jar.baseName</span><br><span class="line">    tagVersion = jar.version</span><br><span class="line">    volume(<span class="string">'/tmp'</span>)</span><br><span class="line">    addFile(<span class="string">"$&#123;jar.baseName&#125;-$&#123;jar.version&#125;.jar"</span>, <span class="string">"app.jar"</span>)</span><br><span class="line">    entryPoint([<span class="string">"java"</span>, <span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>, <span class="string">"-jar"</span>, <span class="string">'app.jar'</span>])</span><br><span class="line">    exposePort(<span class="number">8080</span>)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from jar</span><br><span class="line">            into stageDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-使用镜像启动容器"><a href="#8-使用镜像启动容器" class="headerlink" title="8. 使用镜像启动容器"></a>8. 使用镜像启动容器</h2><p>运行如下命令，根据镜像启动容器，对外暴露 <code>8080</code> 访问端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name gradle-boot -p 8080:8080 io.ostenant.springboot.sample/spring-boot-gradle-for-docker:1.0</span><br></pre></td></tr></table></figure><p>访问 <code>http://127.0.0.1:8080/</code> ，页面会输出当前系统时间，如图所示：</p><p><img src="http://ols3fdyll.bkt.clouddn.com/gradle_build_docker_image_2_web.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>gradle-docker</code> 插件还提供了配置 <strong>镜像仓库地址</strong>、配置使用 <code>Docker Remote Api</code> 和 <code>Docker Hub</code> 等用法，可以参考该项目的 <code>GitHub</code> 地址来进行配置使用：<br><a href="https://github.com/Transmode/gradle-docker" target="_blank" rel="noopener">https://github.com/Transmode/gradle-docker</a>。</p><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通常我们使用 &lt;code&gt;Dockerfile&lt;/code&gt; 来构建项目的 &lt;code&gt;Docker&lt;/code&gt; 镜像。但是也有使用 &lt;code&gt;gradle&lt;/code&gt; 在编译项目的时候一起把镜像给 &lt;strong&gt;构建&lt;/strong&gt; 并 &lt;strong&gt;上传&lt;/strong&gt; 的需求。本文将会讲解如何使用 &lt;code&gt;gradle&lt;/code&gt; 编写并配置 &lt;code&gt;Dockerfile&lt;/code&gt; 并生成 &lt;strong&gt;镜像&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Spring Boot 2.0系列" scheme="https://ostenant.coding.me/categories/%E5%AE%9E%E6%88%98Spring-Boot-2-0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Spring Boot 2.0" scheme="https://ostenant.coding.me/tags/Spring-Boot-2-0/"/>
    
      <category term="Gradle" scheme="https://ostenant.coding.me/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>微服务的反模式和陷阱(三) - 共享反模式</title>
    <link href="https://ostenant.coding.me/2018/06/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%99%B7%E9%98%B1(%E4%B8%89)%20-%20%E5%85%B1%E4%BA%AB%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ostenant.coding.me/2018/06/12/微服务的反模式和陷阱(三) - 共享反模式/</id>
    <published>2018-06-12T11:40:00.000Z</published>
    <updated>2018-06-18T01:58:34.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微服务是一种 <strong>无共享的架构</strong>，另一层意思是 <strong>“尽量不共享”</strong> 模式(<code>share-as-little-as-possible</code>)， 因为总有一些 <strong>代码</strong> 会在微服务之间共享。然后如果太过频繁的使用 <strong>共享代码</strong> 最终会出现 <strong>依赖噩梦</strong>，这就是共享反模式。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="共享反模式"><a href="#共享反模式" class="headerlink" title="共享反模式"></a>共享反模式</h2><p>微服务是一种 <strong>无共享的架构</strong>，另一层意思是 <strong>“尽量不共享”</strong> 模式(<code>share-as-little-as-possible</code>)， 因为总有一些 <strong>代码</strong> 会在微服务之间共享。比如 <strong>不提供一个身份验证的微服务</strong>，而是将身份验证的代码打包成一个 <code>jar</code> 文件：<code>security.jar</code>，保证其它服务都能使用。如果安全检查是 <strong>服务级别</strong> 的功能，每个服务接收到请求都会检查安全性，这种方式可以很好的提高性能。</p><p>然后如果太过频繁的使用最终会出现 <strong>依赖噩梦</strong>，如图 <code>1-1</code> 所示，其中每个服务都依赖于 <strong>多个自定义共享库</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Non_Share1.png" alt=""></p><p>这种共享级别不仅破坏了每个 <strong>服务的限界上下文</strong>，而且还引入了几个问题，包括整体 <strong>可靠性</strong>、<strong>变更控制</strong>、<strong>可测试性</strong> 和 <strong>部署能力</strong>。</p><h3 id="1-过多依赖"><a href="#1-过多依赖" class="headerlink" title="1. 过多依赖"></a>1. 过多依赖</h3><p>在面向对象的软件开发过程中，经常会遇到 <strong>共享</strong> 的问题，特别是从 <strong>单一分层</strong> 结构迁移到 <strong>微服务结构</strong> 时，图 <code>1-2</code> 展示 <strong>抽象类和共享</strong>，它们最终在多数单块分层体系结构中共享。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Non_Share2.png" alt=""></p><p><strong>微服务架构</strong> 的主要目标就是共享要尽可能的少，这有助于维护服务的 <strong>限界上下文</strong>，使我们能够快速的 <strong>测试</strong> 和 <strong>布署</strong>。服务之间 <strong>依赖越强</strong>，<strong>服务隔离</strong> 也就 <strong>越困难</strong>，因此也就越难单独进行 <strong>测试</strong> 和 <strong>布署</strong>。</p><p>创建 <strong>抽象类</strong> 和 <strong>接口</strong> 是 <strong>面向对象编程</strong> 的最重要做法，那我们如何来处理数百个服务共享的代码？</p><h3 id="2-共享代码的技术"><a href="#2-共享代码的技术" class="headerlink" title="2. 共享代码的技术"></a>2. 共享代码的技术</h3><p>要避免这个 <strong>反模式</strong> 的最好办法就是 <strong>代码不共享</strong>，但是实际工作中总会有一些代码需要进行共享，那这些共享代码应该放到哪里呢？</p><p>图 <code>1-3</code> 给了四个最基本的技术：</p><ul><li>共享项目</li><li>共享库</li><li>复制</li><li>服务合并</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Non_Share3.png" alt=""></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="">微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</a></li><li><a href="">微服务的反模式和陷阱(二) - 超时反模式</a></li><li><a href="">微服务的反模式和陷阱(三) - 共享反模式</a></li><li><a href="">微服务的反模式和陷阱(四) - 到达报告反模式</a></li><li><a href="">微服务的反模式和陷阱(五) - 沙粒陷阱</a></li><li><a href="">微服务的反模式和陷阱(六) - 无因的开发者陷阱</a></li><li><a href="">微服务的反模式和陷阱(七) - 随大流陷阱</a></li><li><a href="">微服务的反模式和陷阱(八) - 其它架构模式</a></li><li><a href="">微服务的反模式和陷阱(九) - 静态契约陷阱</a></li><li><a href="">微服务的反模式和陷阱(十) - 通信协议使用的陷阱</a></li></ol><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;微服务是一种 &lt;strong&gt;无共享的架构&lt;/strong&gt;，另一层意思是 &lt;strong&gt;“尽量不共享”&lt;/strong&gt; 模式(&lt;code&gt;share-as-little-as-possible&lt;/code&gt;)， 因为总有一些 &lt;strong&gt;代码&lt;/strong&gt; 会在微服务之间共享。然后如果太过频繁的使用 &lt;strong&gt;共享代码&lt;/strong&gt; 最终会出现 &lt;strong&gt;依赖噩梦&lt;/strong&gt;，这就是共享反模式。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="微服务" scheme="https://ostenant.coding.me/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="反模式" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微服务的反模式和陷阱(二) - 超时反模式</title>
    <link href="https://ostenant.coding.me/2018/06/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%99%B7%E9%98%B1(%E4%BA%8C)%20-%20%E8%B6%85%E6%97%B6%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ostenant.coding.me/2018/06/11/微服务的反模式和陷阱(二) - 超时反模式/</id>
    <published>2018-06-11T11:40:00.000Z</published>
    <updated>2018-07-05T12:46:16.012Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分布式应用的挑战之一就是如何管理 <strong>远程服务</strong> 的 <strong>可用性</strong> 和它们的 <strong>响应</strong>。虽然服务可用性和服务响应都涉及到服务的通信，但它们是两个完全不同的东西。<strong>服务可用性</strong> 是服务消费者 <strong>连接服务</strong> 并能够 <strong>发送请求</strong> 的能力，<strong>服务响应</strong> 则关注服务的 <strong>响应时间</strong>。这里就涉及微服务中的 <strong>超时反模式</strong>。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="超时反模式"><a href="#超时反模式" class="headerlink" title="超时反模式"></a>超时反模式</h2><p>微服务是一种 <strong>分布式的架构</strong>，它所有的组件（也就是服务）会被部署为单独的应用程序，并通过某种 <strong>远程访问协议</strong> 进行通讯。分布式应用的挑战之一就是如何管理 <strong>远程服务</strong> 的 <strong>可用性</strong> 和它们的 <strong>响应</strong>。虽然服务可用性和服务响应都涉及到服务的通信，但它们是两个完全不同的东西。<strong>服务可用性</strong> 是服务消费者 <strong>连接服务</strong> 并能够 <strong>发送请求</strong> 的能力，<strong>服务响应</strong> 则关注服务的 <strong>响应时间</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_Timeout1.png" alt="图1-1"></p><p>如图 <code>1-1</code> 的所示，如果此时服务消费者 <strong>无法连接</strong> 到服务提供者的时候，通过会在毫秒级的时间里得到通知和反馈。这时候 <strong>服务消费者</strong> 可以选择是 <strong>直接返回错误信息</strong> 还是 <strong>进行重试</strong>。但是如果服务提供者接收了请求却 <strong>不进行响应</strong> 该怎么办？在这种情况下服务消费者可以选择 <strong>无限期等待</strong> 或者 <strong>设置超时时间</strong>，使用超时时间看起来是个好办法，但是它会导致 <strong>超时反模式</strong>。</p><h3 id="1-使用超时"><a href="#1-使用超时" class="headerlink" title="1. 使用超时"></a>1. 使用超时</h3><p>你可能感觉非常困惑，难道设置一个超时时间不是一件好事吗？在大部分的情况下超时时间的错误设置都会带来问题。比如当你上网购物的时候，你提交了订单，服务一直在处理没有返回，你在超时的时候再提交订单，显然服务器需要更复杂的逻辑来处理重复提交订单的问题。</p><p>那么超时时间设置多少合适呢？</p><ul><li>第一种是基于 <strong>数据库的超时</strong> 来计算服务的超时时间。</li><li>第二种是计算 <strong>负载下最长的处理时间</strong>，把它乘以 <code>2</code> 作为 <strong>超时时间</strong>。</li></ul><p>在图 <code>2-2</code> 中，通常的情况下 <strong>平均响应时间</strong> 是 <code>2</code> 秒，在 <strong>高并发</strong> 的情况下 <strong>最长时间</strong> 是 <code>5</code> 秒，因为可以使用加倍技术服务的超时时间设置为 <code>10</code> 秒。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_timeout2.png" alt="图1-2"></p><p>图 <code>1-2</code> 的解决方案似乎看起来很完美，它使每一个服务消费者必须等待 <code>10</code> 秒，其实只是为了 <strong>判断服务没有响应</strong>。在大多数情况下，用户在等待提交按钮或放弃和关闭屏幕之前不会等待超过 <code>2</code> 到 <code>3</code> 秒。那就必须要有更好的办法来解决。</p><h2 id="2-使用断路器模式"><a href="#2-使用断路器模式" class="headerlink" title="2. 使用断路器模式"></a>2. 使用断路器模式</h2><p>与上面 <strong>超时</strong> 的方法相比，使用 <strong>断路器</strong> 的方式更为稳妥。这种设计模式就像家里的电器的保险丝一样，当负载过大，或者电路发生故障或异常时，电流会不断升高，为防止升高的电流有可能损坏电路中的某些重要器件或贵重器件，烧毁电路甚至造成火灾。保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，从而起到保护电路安全运行的作用。</p><p>图 <code>1-3</code> 说明了 <strong>断路器模式</strong> 是如何工作的。当服务保持响应时，断路器将关闭，允许通过请求。如果远程服务突然变得不能响应，断路器就会打开，从而阻止请求通过，直到服务再次响应。当然这并不像你家中的保险丝，<strong>断路器</strong> 本身可以 <strong>持续监测服务</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Micro_Service_timeout3.png" alt="图1-3"></p><p><strong>断路器模式</strong> 相比 <strong>设置超时</strong> 的优点是，使用者可以 <strong>立即</strong> 知道服务已变得不响应，而不必等待超时，使用者将在 <strong>毫秒内</strong> 服务不响应，而不是等待 <code>10</code> 秒获得相同的信息。</p><p>另外断路器可以通过几种方式进行 <strong>监控</strong>。最简单的方法是 <strong>对远程服务</strong> 进行简单的 <strong>心跳检查</strong>，这种方式只是告诉断路器服务是活的，但是要想获取服务存活的详细信息，就需要 <strong>定期</strong>（比如 <code>10</code> 秒）获取一次服务的详细信息。还有一种方式是 <strong>实时用户监控</strong>，这种方式可以 <strong>动态调整</strong>，一旦达到 <strong>阈值</strong>，断路器可以进入 <strong>半开放状态</strong>，可以设置 <strong>一定数量的请求是通过</strong>（说 <code>10</code> 个请求中有 <code>8</code> 个通过）。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="">微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</a></li><li><a href="">微服务的反模式和陷阱(二) - 超时反模式</a></li><li><a href="">微服务的反模式和陷阱(三) - 共享反模式</a></li><li><a href="">微服务的反模式和陷阱(四) - 到达报告反模式</a></li><li><a href="">微服务的反模式和陷阱(五) - 沙粒陷阱</a></li><li><a href="">微服务的反模式和陷阱(六) - 无因的开发者陷阱</a></li><li><a href="">微服务的反模式和陷阱(七) - 随大流陷阱</a></li><li><a href="">微服务的反模式和陷阱(八) - 其它架构模式</a></li><li><a href="">微服务的反模式和陷阱(九) - 静态契约陷阱</a></li><li><a href="">微服务的反模式和陷阱(十) - 通信协议使用的陷阱</a></li></ol><hr><p>欢迎关注技术公众号： <strong>零壹技术栈</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;分布式应用的挑战之一就是如何管理 &lt;strong&gt;远程服务&lt;/strong&gt; 的 &lt;strong&gt;可用性&lt;/strong&gt; 和它们的 &lt;strong&gt;响应&lt;/strong&gt;。虽然服务可用性和服务响应都涉及到服务的通信，但它们是两个完全不同的东西。&lt;strong&gt;服务可用性&lt;/strong&gt; 是服务消费者 &lt;strong&gt;连接服务&lt;/strong&gt; 并能够 &lt;strong&gt;发送请求&lt;/strong&gt; 的能力，&lt;strong&gt;服务响应&lt;/strong&gt; 则关注服务的 &lt;strong&gt;响应时间&lt;/strong&gt;。这里就涉及微服务中的 &lt;strong&gt;超时反模式&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="微服务" scheme="https://ostenant.coding.me/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="反模式" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</title>
    <link href="https://ostenant.coding.me/2018/06/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%99%B7%E9%98%B1(%E4%B8%80)%20-%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%BF%81%E7%A7%BB%E5%8F%8D%E6%A8%A1%E5%BC%8F%08/"/>
    <id>https://ostenant.coding.me/2018/06/10/微服务的反模式和陷阱(一) - 数据驱动的迁移反模式/</id>
    <published>2018-06-10T10:20:00.000Z</published>
    <updated>2018-06-18T01:58:16.876Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>采用 <strong>数据驱动迁移反模式</strong> 主要发生在当你从一个 <strong>单体应用</strong> 向 <strong>微服务架构</strong> 做迁移的时候。之所以称之为反模式主要原因是，刚开始我们觉得创建微服务是一个不错的主意，<strong>服务和相应的数据</strong> 都独立成 <strong>微服务</strong>，但这可能会将你带向一个错误的道路上，导致高风险、过剩成本和额外的迁移工作。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="数据驱动的迁移反模式"><a href="#数据驱动的迁移反模式" class="headerlink" title="数据驱动的迁移反模式"></a>数据驱动的迁移反模式</h2><p>微服务会创建 <strong>大量小的</strong>、<strong>分布式的</strong>、<strong>单一用途</strong> 的服务，每个服务拥有自己的数据。这种 <strong>服务和数据耦合</strong> 支持一个 <strong>有界的上下文</strong> 和 <strong>一个无共享数据</strong> 的架构。其中，每个服务及其对应的数据是独立一块，完全独立于所有其他服务。服务只暴露了一个明确的接口（服务契约）。有界的上下文可以允许开发者以最小的依赖快速轻松地开发，测试和部署。</p><p>采用 <strong>数据驱动迁移反模式</strong> 主要发生在当你从一个 <strong>单体应用</strong> 向 <strong>微服务架构</strong> 做迁移的时候。我们之所以称之为反模式主要原因是，刚开始我们觉得创建微服务是一个不错的主意，<strong>服务和相应的数据</strong> 都独立成 <strong>微服务</strong>，但这可能会将你带向一个错误的道路上，导致高风险、过剩成本和额外的迁移工作。</p><p>单体应用迁移到微服务架构有两个主要目标：</p><ol><li><p>第一个目标是单体应用程序的 <strong>功能</strong> 分割成 <strong>小的</strong>，<strong>单一用途</strong> 的服务。</p></li><li><p>第二个目标是单体应用的 <strong>数据</strong> 迁移到每个服务自己 <strong>独占的小数据库</strong>（或独立的服务）。</p></li></ol><p>下图展示了一个典型的迁移，看起来像服务代码和相应的数据同时进行迁移。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/data_driven_back_pattern.png" alt="图1-1"></p><p>上图中有三个服务是从单体应用中划分而来，并且还划分独立的三个数据库，这是一个自然演变的过程，因为在每个 <strong>服务</strong> 和 <strong>数据库</strong> 之间都使用了最为关键的 <strong>限界上下文</strong>，然而我们遇到的问题也正是基于这一过程将带领我们进入 <strong>数据迁移的反模式</strong>。</p><h3 id="1-太多的数据迁移"><a href="#1-太多的数据迁移" class="headerlink" title="1. 太多的数据迁移"></a>1. 太多的数据迁移</h3><p>这种迁移路径的主要问题是，我们很难在一次就能够划分清楚每个服务的粒度。从一个 <strong>更粗粒度</strong> 的服务开始着手，一步步的进行 <strong>细化工作</strong>，并且要多了解相关业务知识，不断的 <strong>对服务的粒度进行调整</strong>。</p><p>我们来看图 <code>1-1</code> 发现最左边的 <strong>服务粒度太粗</strong>，需要再 <strong>拆分</strong> 成二个小的服务，或者你发现左边的二个 <strong>服务粒度划分的太细</strong>，需要进行 <strong>合并</strong>。而 <strong>数据迁移</strong> 要比 <strong>源代码迁移</strong> 更复杂，更容易出错，我们最好只为数据进行一次迁移工作，因为数据迁移是一个 <strong>高风险</strong> 的工作。</p><p>我们的微服务划分也就是应用代码的迁移和数据的迁移。如图 <code>1-2</code> 所示。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/data_drive_back_pattern2.png" alt="图1-2"></p><h3 id="2-功能分割优先，数据迁移最后"><a href="#2-功能分割优先，数据迁移最后" class="headerlink" title="2. 功能分割优先，数据迁移最后"></a>2. 功能分割优先，数据迁移最后</h3><p>此模式主要采用的是一种避免的手段，以 <strong>迁移服务的功能</strong> 为第一，同时也需要注意服务和数据之间的 <strong>限界上下文</strong>。我们可以通过 <strong>合并</strong> 与 <strong>拆分</strong> 的手段对服务进行调整直到满意为止，这时候就可以进行 <strong>数据迁移</strong>。</p><p>如图 <code>1-3</code> 所示，左边所有三个服务都已经进行了 <strong>迁移</strong> 和 <strong>拆分</strong>，但是所有服务仍然使用的是 <strong>同一个数据库</strong>。如果这是一个临时中间方案还可以作为一个选择，这时候我们就需要更多的了解服务如何使用，以及接受什么类型的请求数据等。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/data_driven_back_pattern3.png" alt=""></p><p>在图 <code>1-3</code> 中，我们要注意最左边的服务是如何发现 <strong>粒度太粗</strong> 而 <strong>拆分</strong> 成两个服务的。服务粒度最终确定完成之后，下一步就开始 <strong>迁移数据</strong> 了，采用这种方式可以避免重复的数据迁移。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="">微服务的反模式和陷阱(一) - 数据驱动的迁移反模式</a></li><li><a href="">微服务的反模式和陷阱(二) - 超时反模式</a></li><li><a href="">微服务的反模式和陷阱(三) - 共享反模式</a></li><li><a href="">微服务的反模式和陷阱(四) - 到达报告反模式</a></li><li><a href="">微服务的反模式和陷阱(五) - 沙粒陷阱</a></li><li><a href="">微服务的反模式和陷阱(六) - 无因的开发者陷阱</a></li><li><a href="">微服务的反模式和陷阱(七) - 随大流陷阱</a></li><li><a href="">微服务的反模式和陷阱(八) - 其它架构模式</a></li><li><a href="">微服务的反模式和陷阱(九) - 静态契约陷阱</a></li><li><a href="">微服务的反模式和陷阱(十) - 通信协议使用的陷阱</a></li></ol><hr><p>欢迎关注技术公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;采用 &lt;strong&gt;数据驱动迁移反模式&lt;/strong&gt; 主要发生在当你从一个 &lt;strong&gt;单体应用&lt;/strong&gt; 向 &lt;strong&gt;微服务架构&lt;/strong&gt; 做迁移的时候。之所以称之为反模式主要原因是，刚开始我们觉得创建微服务是一个不错的主意，&lt;strong&gt;服务和相应的数据&lt;/strong&gt; 都独立成 &lt;strong&gt;微服务&lt;/strong&gt;，但这可能会将你带向一个错误的道路上，导致高风险、过剩成本和额外的迁移工作。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务系列" scheme="https://ostenant.coding.me/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="微服务" scheme="https://ostenant.coding.me/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="反模式" scheme="https://ostenant.coding.me/tags/%E5%8F%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose搭建MySQL主从复制集群</title>
    <link href="https://ostenant.coding.me/2018/06/10/Docker%20Compose%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/"/>
    <id>https://ostenant.coding.me/2018/06/10/Docker Compose搭建MySQL主从集群/</id>
    <published>2018-06-10T02:33:00.000Z</published>
    <updated>2018-06-18T01:46:07.184Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着应用业务数据不断的增大，应用的 <strong>响应速度不断下降</strong>，在检测过程中我们不难发现大多数的请求都是 <strong>查询操作</strong>。此时，我们可以将数据库扩展成 <strong>主从复制模式</strong>，将 <strong>读操作</strong> 和 <strong>写操作</strong> 分离开来，多台数据库 <strong>分摊请求</strong>，从而 <strong>减少单库</strong> 的 <strong>访问压力</strong>，进而应用得到优化。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="主从复制的方式"><a href="#主从复制的方式" class="headerlink" title="主从复制的方式"></a>主从复制的方式</h2><p><code>MySQL 5.6</code> 开始主从复制有两种方式：<strong>基于日志</strong>（<code>binlog</code>）和 <strong>基于</strong> <code>GTID</code>（<strong>全局事务标示符</strong>）。 </p><p>本文只涉及基于日志 <code>binlog</code> 的 <strong>主从配置</strong>。</p><h2 id="主从复制的流程"><a href="#主从复制的流程" class="headerlink" title="主从复制的流程"></a>主从复制的流程</h2><p><img src="http://ols3fdyll.bkt.clouddn.com/MySQL_Master_Slave.png" alt=""></p><p><code>MySQL</code> 同步操作通过 <code>3</code> 个线程实现，其基本步骤如下：</p><ol><li><p><strong>主服务器</strong> 将数据的更新记录到 <strong>二进制日志</strong>（<code>Binary log</code>）中，用于记录二进制日志事件，这一步由 <strong>主库线程</strong> 完成；</p></li><li><p><strong>从库</strong> 将 <strong>主库</strong> 的 <strong>二进制日志</strong> 复制到本地的 <strong>中继日志</strong>（<code>Relay log</code>），这一步由 <strong>从库</strong> <code>I/O</code> <strong>线程</strong> 完成；</p></li><li><p><strong>从库</strong> 读取 <strong>中继日志</strong> 中的 <strong>事件</strong>，将其重放到数据中，这一步由 <strong>从库</strong> <code>SQL</code> <strong>线程</strong> 完成。</p></li></ol><h2 id="主从模式的优点"><a href="#主从模式的优点" class="headerlink" title="主从模式的优点"></a>主从模式的优点</h2><h4 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1. 负载均衡"></a>1. 负载均衡</h4><p>通常情况下，会使用 <strong>主服务器</strong> 对数据进行 <strong>更新</strong>、<strong>删除</strong> 和 <strong>新建</strong> 等操作，而将 <strong>查询</strong> 工作落到 <strong>从库</strong> 头上。</p><h4 id="2-异地容灾备份"><a href="#2-异地容灾备份" class="headerlink" title="2. 异地容灾备份"></a>2. 异地容灾备份</h4><p>可以将主服务器上的数据同步到 <strong>异地从服务器</strong> 上，极大地提高了 <strong>数据安全性</strong>。</p><h4 id="3-高可用"><a href="#3-高可用" class="headerlink" title="3. 高可用"></a>3. 高可用</h4><p>数据库的复制功能实现了 <strong>主服务器</strong> 与 <strong>从服务器间</strong> 的数据同步，一旦主服务器出了 <strong>故障</strong>，从服务器立即担当起主服务器的角色，保障系统持续稳定运作。</p><h4 id="4-高扩展性"><a href="#4-高扩展性" class="headerlink" title="4. 高扩展性"></a>4. 高扩展性</h4><p><strong>主从复制</strong> 模式支持 <code>2</code> 种扩展方式: </p><ul><li><strong>scale-up</strong></li></ul><p>向上扩展或者 <strong>纵向扩展</strong>，主要是提供比现在服务器 <strong>性能更好</strong> 的服务器，比如 <strong>增加</strong> <code>CPU</code> 和 <strong>内存</strong> 以及 <strong>磁盘阵列</strong>等，因为有多台服务器，所以可扩展性比单台更大。</p><ul><li><strong>scale-out</strong></li></ul><p>向外扩展或者 <strong>横向扩展</strong>，是指增加 <strong>服务器数量</strong> 的扩展，这样主要能分散各个服务器的压力。</p><h2 id="主从模式的缺点"><a href="#主从模式的缺点" class="headerlink" title="主从模式的缺点"></a>主从模式的缺点</h2><h4 id="1-成本增加"><a href="#1-成本增加" class="headerlink" title="1. 成本增加"></a>1. 成本增加</h4><p>搭建主从肯定会增加成本，毕竟一台服务器和两台服务器的成本完全不同，另外由于主从必须要开启 <strong>二进制日志</strong>，所以也会造成额外的 <strong>性能消耗</strong>。</p><h4 id="2-数据延迟"><a href="#2-数据延迟" class="headerlink" title="2. 数据延迟"></a>2. 数据延迟</h4><p><strong>从库</strong> 从 <strong>主库</strong> 复制数据肯定是会有一定的 <strong>数据延迟</strong> 的。所以当刚插入就出现查询的情况，可能查询不出来。当然如果是插入者自己查询，那么可以直接从 <strong>主库</strong> 中查询出来，当然这个也是需要用代码来控制的。</p><h4 id="3-写入更慢"><a href="#3-写入更慢" class="headerlink" title="3. 写入更慢"></a>3. 写入更慢</h4><p><strong>主从复制</strong> 主要是针对 <strong>读远大于写</strong> 或者对 <strong>数据备份实时性</strong> 要求较高的系统中。因为 <strong>主服务器</strong> 在写中需要更多操作，而且 <strong>只有一台</strong> 可以写入的 <strong>主库</strong>，所以写入的压力并不能被分散。</p><h2 id="主从复制的前提条件"><a href="#主从复制的前提条件" class="headerlink" title="主从复制的前提条件"></a>主从复制的前提条件</h2><ol><li><p>主从服务器 <strong>操作系统版本</strong> 和 <strong>位数</strong> 一致。</p></li><li><p>主数据库和从数据库的 <strong>版本</strong> 要一致。</p></li><li><p>主数据库和从数据库中的 <strong>数据</strong> 要一致。</p></li><li><p><strong>主数据库</strong> 开启 <strong>二进制日志</strong>，主数据库和从数据库的 <code>server_id</code> 在局域网内必须 <strong>唯一</strong>。</p></li></ol><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">版本号</th></tr></thead><tbody><tr><td style="text-align:left">Docker</td><td style="text-align:left">18.03.1-ce</td></tr><tr><td style="text-align:left">Docker Compose</td><td style="text-align:left">1.21.1</td></tr><tr><td style="text-align:left">MySQL</td><td style="text-align:left">5.7.17</td></tr></tbody></table><h3 id="2-配置docker-compose-yml"><a href="#2-配置docker-compose-yml" class="headerlink" title="2. 配置docker-compose.yml"></a>2. 配置docker-compose.yml</h3><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  mysql-master:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">master/Dockerfile</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql-slave</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"33065:3306"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">mysql-master</span></span><br><span class="line"><span class="attr">  mysql-slave:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">slave/Dockerfile</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"33066:3306"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">mysql-slave</span></span><br></pre></td></tr></table></figure><h3 id="3-主数据库配置"><a href="#3-主数据库配置" class="headerlink" title="3. 主数据库配置"></a>3. 主数据库配置</h3><h4 id="3-1-配置Dockerfile"><a href="#3-1-配置Dockerfile" class="headerlink" title="3.1. 配置Dockerfile"></a>3.1. 配置Dockerfile</h4><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> harrison</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./master/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure><h4 id="3-2-配置my-cnf文件"><a href="#3-2-配置my-cnf文件" class="headerlink" title="3.2. 配置my.cnf文件"></a>3.2. 配置my.cnf文件</h4><p>my.cnf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，一般设置为IP，注意要唯一</span></span><br><span class="line">server_id=100  </span><br><span class="line"><span class="comment">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）</span></span><br><span class="line"><span class="built_in">log</span>-bin=replicas-mysql-bin  </span><br><span class="line"><span class="comment">## 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="comment">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure><h3 id="4-从数据库配置"><a href="#4-从数据库配置" class="headerlink" title="4. 从数据库配置"></a>4. 从数据库配置</h3><h4 id="4-1-配置Dockerfile"><a href="#4-1-配置Dockerfile" class="headerlink" title="4.1. 配置Dockerfile"></a>4.1. 配置Dockerfile</h4><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> harrison</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./slave/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure><h4 id="4-2-配置my-cnf文件"><a href="#4-2-配置my-cnf文件" class="headerlink" title="4.2. 配置my.cnf文件"></a>4.2. 配置my.cnf文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，一般设置为IP，注意要唯一</span></span><br><span class="line">server_id=101  </span><br><span class="line"><span class="comment">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span></span><br><span class="line"><span class="built_in">log</span>-bin=replicas-mysql-slave1-bin  </span><br><span class="line"><span class="comment">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="comment">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line"><span class="comment">## relay_log配置中继日志</span></span><br><span class="line">relay_log=replicas-mysql-relay-bin  </span><br><span class="line"><span class="comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span><br><span class="line">log_slave_updates=1  </span><br><span class="line"><span class="comment">## 防止改变数据(除了特殊的线程)</span></span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure><h3 id="5-创建容器"><a href="#5-创建容器" class="headerlink" title="5. 创建容器"></a>5. 创建容器</h3><p>进入 <code>docker</code> 目录，运行 <code>docker-compose</code> 启动命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure><p>如图所示，<code>MySQL</code> <strong>主数据库</strong> 和 <strong>从数据库</strong> 的容器创建成功。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Docker_Compose_MySQL.png" alt=""></p><p>分别配置 <strong>主数据库</strong> 和 <strong>从数据库</strong> 的连接信息如下：</p><ul><li>主数据库</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/MySQL_Master.png" alt=""></p><ul><li>从数据库</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/MySQL_Slave.png" alt=""><br></p><h3 id="6-配置从数据库"><a href="#6-配置从数据库" class="headerlink" title="6. 配置从数据库"></a>6. 配置从数据库</h3><h4 id="检查从库的起始状态"><a href="#检查从库的起始状态" class="headerlink" title="检查从库的起始状态"></a>检查从库的起始状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show master status;</span><br></pre></td></tr></table></figure><p>如图所示，从数据库处于 <strong>未同步复制状态</strong>。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Slave_Status.png" alt=""></p><h4 id="检查主库的状态"><a href="#检查主库的状态" class="headerlink" title="检查主库的状态"></a>检查主库的状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show master status;</span><br></pre></td></tr></table></figure><p>记录 <strong>主数据库</strong> <code>binary-log</code> 的 <strong>文件名称</strong> 和 <strong>数据同步起始位置</strong>。</p><ul><li>File: replicas-mysql-bin.000003</li><li>Position: 154</li></ul><p><img src="http://ols3fdyll.bkt.clouddn.com/Master_Status.png" alt=""></p><h4 id="从库配置主库信息"><a href="#从库配置主库信息" class="headerlink" title="从库配置主库信息"></a>从库配置主库信息</h4><p>在 <strong>从数据库</strong> 上运行 <strong>主数据库</strong> 的相关配置 <code>sql</code> 进行主从关联</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">    MASTER_HOST=<span class="string">'mysql-master'</span>,</span><br><span class="line">    MASTER_USER=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_PASSWORD=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_LOG_FILE=<span class="string">'replicas-mysql-bin.000003'</span>,</span><br><span class="line">    MASTER_LOG_POS=<span class="number">154</span>;</span><br></pre></td></tr></table></figure><p>重新启动 <code>slave</code> 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ stop slave</span><br><span class="line">$ start slave</span><br></pre></td></tr></table></figure><p>进一步检查 <strong>从数据库</strong> 的状态信息，两者已经进行 <strong>数据同步</strong> 关联。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Slave_Status3.png" alt=""></p><h3 id="7-创建目标表"><a href="#7-创建目标表" class="headerlink" title="7. 创建目标表"></a>7. 创建目标表</h3><p>在 <strong>主数据库</strong> 中创建一张测试数据表 <code>course</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for course</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`course`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lesson_period`</span> <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span> <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p><strong>主数据库</strong> 和 <strong>从数据库</strong> 的 数据处于 <strong>同步状态</strong>，主从复制集群搭建完成。</p><p><img src="http://ols3fdyll.bkt.clouddn.com/Master_Slave_Sync.png" alt=""></p><h2 id="MySQL的复制类型"><a href="#MySQL的复制类型" class="headerlink" title="MySQL的复制类型"></a>MySQL的复制类型</h2><h3 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h3><p>主服务器上面执行的语句在从服务器上面再执行一遍，在 <code>MySQL-3.23</code> 版本以后支持。</p><blockquote><p>问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户。</p></blockquote><h3 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h3><p>把主服务器上面改变后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在 <code>MySQL-5.0</code> 版本以后引入。</p><blockquote><p>问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。</p></blockquote><h3 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h3><p><code>MySQL</code> 默认使用 <strong>基于语句的复制</strong>，当 <strong>基于语句的复制</strong> 会引发问题的时候就会使用 <strong>基于行的复制</strong>，<code>MySQL</code> 会自动进行选择。</p><hr><p>欢迎关注公众号： 零壹技术栈</p><p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零壹技术栈"></p><p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着应用业务数据不断的增大，应用的 &lt;strong&gt;响应速度不断下降&lt;/strong&gt;，在检测过程中我们不难发现大多数的请求都是 &lt;strong&gt;查询操作&lt;/strong&gt;。此时，我们可以将数据库扩展成 &lt;strong&gt;主从复制模式&lt;/strong&gt;，将 &lt;strong&gt;读操作&lt;/strong&gt; 和 &lt;strong&gt;写操作&lt;/strong&gt; 分离开来，多台数据库 &lt;strong&gt;分摊请求&lt;/strong&gt;，从而 &lt;strong&gt;减少单库&lt;/strong&gt; 的 &lt;strong&gt;访问压力&lt;/strong&gt;，进而应用得到优化。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL学习系列" scheme="https://ostenant.coding.me/categories/MySQL%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="https://ostenant.coding.me/tags/Docker/"/>
    
      <category term="Docker Compose" scheme="https://ostenant.coding.me/tags/Docker-Compose/"/>
    
      <category term="MySQL" scheme="https://ostenant.coding.me/tags/MySQL/"/>
    
      <category term="主从复制" scheme="https://ostenant.coding.me/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
</feed>
