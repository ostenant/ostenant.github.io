
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java NIO系列(三) - Channel | Coding | Harrison&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="baidu-site-verification" content="0aFfZiB4tV" />
  
  
  <meta name="description" content="前言上文讲到Java NIO一些基本概念。在标准的IO中，都是基于字节流/字符流进行数据操作的，而在NIO中则是是基于Channel和Buffer进行操作，其中的Channel的虽然模拟了流的概念，实则大不相同。 本文将详细阐述NIO中的通道Channel的概念和具体的用法。">
<meta name="keywords" content="NIO">
<meta property="og:type" content="article">
<meta property="og:title" content="Java NIO系列(三) - Channel">
<meta property="og:url" content="https://ostenant.coding.me/2017/12/27/Java NIO系列(三) - Channel/index.html">
<meta property="og:site_name" content="Coding | Harrison&#39;s Blog">
<meta property="og:description" content="前言上文讲到Java NIO一些基本概念。在标准的IO中，都是基于字节流/字符流进行数据操作的，而在NIO中则是是基于Channel和Buffer进行操作，其中的Channel的虽然模拟了流的概念，实则大不相同。 本文将详细阐述NIO中的通道Channel的概念和具体的用法。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ols3fdyll.bkt.clouddn.com/Java_NIO_Channel_Buffer.png">
<meta property="og:image" content="http://ols3fdyll.bkt.clouddn.com/filechannel_test_result.png">
<meta property="og:image" content="http://ols3fdyll.bkt.clouddn.com/serversocket_channel_blocking_result.png">
<meta property="og:image" content="http://ols3fdyll.bkt.clouddn.com/serversocket_channel_non_blocking_result.png">
<meta property="og:image" content="http://ols3fdyll.bkt.clouddn.com/blocking_socketchannel_write_test.png">
<meta property="og:image" content="http://ols3fdyll.bkt.clouddn.com/nonblocking_socketchannel_write_test.png">
<meta property="og:image" content="http://ols3fdyll.bkt.clouddn.com/datagramchannel_sender.png">
<meta property="og:image" content="http://ols3fdyll.bkt.clouddn.com/datagramchannel_recevirer.png">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-05-08T02:49:46.091Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java NIO系列(三) - Channel">
<meta name="twitter:description" content="前言上文讲到Java NIO一些基本概念。在标准的IO中，都是基于字节流/字符流进行数据操作的，而在NIO中则是是基于Channel和Buffer进行操作，其中的Channel的虽然模拟了流的概念，实则大不相同。 本文将详细阐述NIO中的通道Channel的概念和具体的用法。">
<meta name="twitter:image" content="http://ols3fdyll.bkt.clouddn.com/Java_NIO_Channel_Buffer.png">
  
    <link rel="alternative" href="/atom.xml" title="Coding | Harrison&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
 
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Coding | Harrison&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">上善若水任方猿</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="https://github.com/ostenant">Github</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="ostenant.coding.me">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-Java NIO系列(三) - Channel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/27/Java NIO系列(三) - Channel/" class="article-date">
  <time datetime="2017-12-27T07:22:00.000Z" itemprop="datePublished">2017-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java编程进阶系列/">Java编程进阶系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java NIO系列(三) - Channel
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文讲到<code>Java NIO</code>一些基本概念。在标准的<code>IO</code>中，都是基于<strong>字节流/字符流</strong>进行数据操作的，而在<code>NIO</code>中则是是基于<code>Channel</code>和<code>Buffer</code>进行操作，其中的<code>Channel</code>的虽然模拟了<strong>流</strong>的概念，实则大不相同。</p>
<p>本文将详细阐述<code>NIO</code>中的<strong>通道</strong><code>Channel</code>的概念和具体的用法。</p>
<a id="more"></a>
<h2 id="Channel和Stream的区别"><a href="#Channel和Stream的区别" class="headerlink" title="Channel和Stream的区别"></a>Channel和Stream的区别</h2><table>
<thead>
<tr>
<th>区别</th>
<th>Stream</th>
<th>Channel</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否支持异步</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>是否支持双向数据传输</td>
<td>不支持，只能单向</td>
<td>支持，既可以从通道读取数据，也可以向通道写入数据</td>
</tr>
<tr>
<td>是否结合Buffer使用</td>
<td>不</td>
<td>必须结合Buffer使用</td>
</tr>
<tr>
<td>性能</td>
<td>较低</td>
<td>较高</td>
</tr>
</tbody>
</table>
<p><code>Channel</code>用于在<strong>字节缓冲区</strong>和位于通道另一侧的服务（通常是<strong>文件</strong>或者<strong>套接字</strong>）之间以便有效的进行<strong>数据传输</strong>。借助通道，可以用最小的总开销来访问操作系统本身的<code>I/O</code>服务。</p>
<p><img src="http://ols3fdyll.bkt.clouddn.com/Java_NIO_Channel_Buffer.png" alt=""></p>
<blockquote>
<p>需要注意的是Channel必须结合Buffer使用，应用程序不能直接向通道中读/写数据，也就是缓冲区充当着应用程序和通道数据流动的转换的角色。</p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Channel的源码"><a href="#Channel的源码" class="headerlink" title="Channel的源码"></a>Channel的源码</h2><p>查看<code>Channel</code>的源码。所有的接口都实现于<code>Channel</code>接口，从接口上来看，所有的通道都有这两种操作：检查通道的<strong>开启状态</strong>和<strong>关闭通道</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Channel的分类"><a href="#Channel的分类" class="headerlink" title="Channel的分类"></a>Channel的分类</h2><p>广义上来说通道可以被分为两类：文件<code>I/O</code>和网络<code>I/O</code>，也就是<strong>文件通道</strong>和<strong>套接字通道</strong>。如果分的更细致一点则是：</p>
<ul>
<li><strong>FileChannel</strong>：从文件读写数据；</li>
<li><strong>SocketChannel</strong>：通过<code>TCP</code>读写网络数据；</li>
<li><strong>ServerSocketChannel</strong>：可以监听新进来的<code>TCP</code>连接，并对每个链接创建对应的<code>SocketChannel</code>；</li>
<li><strong>DatagramChannel</strong>：通过<code>UDP</code>读写网络中的数据。</li>
</ul>
<h2 id="Channel的特性"><a href="#Channel的特性" class="headerlink" title="Channel的特性"></a>Channel的特性</h2><h3 id="单向or双向"><a href="#单向or双向" class="headerlink" title="单向or双向"></a>单向or双向</h3><p><strong>通道既可以是单向的也可以是双向的</strong>。只实现<code>ReadableByteChannel</code>接口中的<code>read()</code>方法或者只实现<code>WriteableByteChannel</code>接口中的<code>write()</code>方法的通道皆为<strong>单向通道</strong>，同时实现<code>ReadableByteChannel</code>和<code>WriteableByteChannel</code>为<strong>双向通道</strong>，比如<code>ByteChannel</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByteChannel</span> <span class="keyword">extends</span> <span class="title">ReadableByteChannel</span>, <span class="title">WritableByteChannel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>Socket</code>通道来说，它们一直是<strong>双向的</strong>，而对于<code>FileChannel</code>来说，它同样实现了<code>ByteChannel</code>，但是通过<code>FileInputStream</code>的<code>getChannel()</code>获取的<code>FileChannel</code>只具有文件的<strong>只读权限</strong>。</p>
<blockquote>
<p>注意：调用FileChannel的write()方法会抛出了NonWriteChannelException异常。</p>
</blockquote>
<h3 id="阻塞or非阻塞"><a href="#阻塞or非阻塞" class="headerlink" title="阻塞or非阻塞"></a>阻塞or非阻塞</h3><p><strong>通道的工作模式有两种：阻塞或非阻塞</strong>。在<strong>非阻塞模式</strong>下，调用的线程不会休眠，请求的操作会立刻返回结果；在<strong>阻塞模式</strong>下，调用的线程会产生休眠。</p>
<p>除<code>FileChannel</code>不能运行在<strong>非阻塞模式</strong>下，其余的通道都可<strong>阻塞</strong>运行也可以以<strong>非阻塞</strong>的方式运行。</p>
<p>另外从<code>SelectableChannel</code>引申出的类可以和支持有条件选择的<code>Selector</code>结合使用，进而充分利用<strong>多路复用</strong>的<code>I/O</code>(<code>Multiplexed I/O</code>)来<strong>提高性能</strong>。</p>
<p><code>SelectableChannel</code>的源码中有以下几个抽象方法，可以看出支持配置两种工作模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectableChannel</span> <span class="keyword">extends</span> <span class="title">AbstractInterruptibleChannel</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置是否为Channel阻塞模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为Channel阻塞模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isBlocking</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取阻塞的锁对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">blockingLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>Socket</code><strong>通道</strong>类来说，通常与<code>Selector</code>共同使用以提高性能。需要注意的是通道<strong>不能被同时使用</strong>，一个<strong>打开的通道</strong>代表着与一个<strong>特定</strong><code>I/O</code>服务进行<strong>连接</strong>并封装了该<strong>连接的状态</strong>，通道一旦<strong>关闭</strong>，该连接便会<strong>断开</strong>。</p>
<p>通道的<code>close()</code>比较特殊，无论在通道时在<strong>阻塞模式</strong>下还是<strong>非阻塞模式</strong>下，由于<code>close()</code>方法的调用而导致<strong>底层</strong><code>I/O</code>的<strong>关闭</strong>都可能会造成线程的<strong>暂时阻塞</strong>。在一个<strong>已关闭</strong>的通道上调用<code>close()</code>并没有任何意义，只会立即返回。</p>
<h2 id="Channel的实战"><a href="#Channel的实战" class="headerlink" title="Channel的实战"></a>Channel的实战</h2><blockquote>
<p>对于Socket通道来说存在直接创建新Socket通道的方法，而对于文件通道来说，升级之后的FileInputStream、FileOutputStream和RandomAccessFile提供了getChannel()方法来获取通道。</p>
</blockquote>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p><code>Java NIO</code>中的<code>FileChannel</code>是一个连接到<strong>文件</strong>的通道，可以通过文件通道读写文件。文件通道总是<strong>阻塞式</strong>的，因此FileChannel无法设置为<strong>非阻塞模式</strong>。</p>
<h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><p><strong>(一). 文件写操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteOnFileChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile randomAccess = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://test.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fileChannel = randomAccess.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> String(<span class="string">"Java Non-blocking IO"</span>).getBytes();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓冲区中的字节写入文件通道中</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">// 强制将通道中未写入磁盘的数据立刻写入到磁盘</span></span><br><span class="line">        fileChannel.force(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 清空缓冲区，释放内存</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(二). 文件读操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReadOnFileChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D://test.txt"</span>));</span><br><span class="line">        FileChannel fileChannel = inputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 不断地写入缓冲区，写一次读一次</span></span><br><span class="line">        <span class="keyword">while</span> (fileChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓冲区从写模式切换为读模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="comment">// 开始读取</span></span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 一个字节一个字节地读取，并向后移动position地位置</span></span><br><span class="line">                System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缓冲区不会被自动覆盖，需要主动调用该方法(实际上还是覆盖)</span></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件读写测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Start to write"</span>);</span><br><span class="line">    <span class="comment">// 通过FileChannel写入数据</span></span><br><span class="line">    testWriteOnFileChannel();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Start to read"</span>);</span><br><span class="line">    <span class="comment">// 通过FileChannel读取数据</span></span><br><span class="line">    testReadOnFileChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果：<br><img src="http://ols3fdyll.bkt.clouddn.com/filechannel_test_result.png" alt=""></p>
<h4 id="transferFrom和transferTo"><a href="#transferFrom和transferTo" class="headerlink" title="transferFrom和transferTo"></a>transferFrom和transferTo</h4><p><strong>(一). transferFrom()的使用</strong></p>
<p><code>FileChannel</code>的<code>transferFrom()</code>方法可以将数据从<strong>源通道</strong>传输到<code>FileChannel</code>中。下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTransferFrom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://file1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line">        RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://file2.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line">        toChannel.transferFrom(fromChannel, position, count);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(二). transferTo()的使用</strong></p>
<p><code>transferTo()</code>方法将数据从<code>FileChannel</code>传输到<strong>目标</strong><code>channel</code>中。下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTransferTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://file1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line">        RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://file3.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line">        fromChannel.transferTo(position, count, toChannel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p><code>Java NIO</code>中的<code>ServerSocketChannel</code>是一个可以<strong>监听</strong>新进来的<strong>TCP连接</strong>的通道。它类似<code>ServerSocket</code>，要注意的是和<code>DatagramChannel</code>和<code>SocketChannel</code>不同，<code>ServerSocketChannel</code>本身<strong>不具备传输数据</strong>的能力，而只是负责<strong>监听</strong>传入的连接和<strong>创建</strong>新的<code>SocketChannel</code>。</p>
<h4 id="ServerSocketChannel的用法"><a href="#ServerSocketChannel的用法" class="headerlink" title="ServerSocketChannel的用法"></a>ServerSocketChannel的用法</h4><p><strong>(一). 创建ServerSocketChannel</strong></p>
<p>通过<code>ServerSocketChannel.open()</code>方法来创建一个新的<code>ServerSocketChannel</code>对象，该对象关联了一个<strong>未绑定</strong><code>ServerSocket</code>的<strong>通道</strong>。通过调用该对象上的<code>socket()</code>方法可以获取与之关联的<code>ServerSocket</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel socketChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>
<p><strong>(二). 为ServerSocketChannel绑定监听端口号</strong></p>
<p>在<code>JDK 1.7</code>之前，<code>ServerSocketChannel</code>没有<code>bind()</code>方法，因此需要通过他关联的的<code>socket</code>对象的<code>socket()</code>来绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.7之前</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">25000</span>));</span><br></pre></td></tr></table></figure>
<p>从<code>JDK1.7</code>及以后，可以直接通过<code>ServerSocketChannel</code>的<code>bind()</code>方法来<strong>绑定端口号</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.7之后</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">25000</span>));</span><br></pre></td></tr></table></figure>
<p> <strong>(三). 设置<code>ServerSocketChannel</code>的工作模式</strong></p>
<p><code>ServerSocketChannel</code>底层默认采用<strong>阻塞</strong>的工作模式，它提供了一个<code>configureBlocking()</code>方法，允许配置<code>ServerSocketChannel</code>以<strong>非阻塞方式</strong>运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>进一步查看<code>configureBlocking</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        <span class="keyword">if</span> (blocking == block)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (block &amp;&amp; haveValidKeys())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">        implConfigureBlocking(block);</span><br><span class="line">        blocking = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Javadoc解释configureBlocking()方法用于调整底层通道的工作模式，即阻塞和非阻塞，默认是阻塞工作模式。</p>
</blockquote>
<p>如果block设置为true，直接返回当前的阻塞式的通道；如果block设置为false，configureBlocking()方法会调用implConfigureBlocking()方法。这里implConfigureBlocking()是由<code>ServerSocketChannelImpl</code>实现，最终调用了IOUtil中的native方法configureBlocking()。</p>
<p><strong>(四). 监听新进来的连接</strong></p>
<p>通过<code>ServerSocketChannel.accept()</code>方法监听新进来的连接，这里需要根据<code>configureBlocking()</code>的配置区分两种工作模式的使用：</p>
<ul>
<li>在<strong>阻塞模式</strong>下，当<code>accept()</code>方法返回的时候，它返回一个包含<strong>新连接</strong>的<code>SocketChannel</code>，否则<code>accept()</code>方法会一直<strong>阻塞到</strong>有新连接到达。</li>
<li>在<strong>非阻塞模式</strong>下，在没有新连接的情况下，<code>accept()</code>会立即返回<code>null</code>，该模式下通常<strong>不会仅仅</strong>监听一个连接，因此需在<code>while</code><strong>循环</strong>中调用<code>accept()</code>方法.</li>
</ul>
<p>阻塞模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">// 新连接没到达之前，后面的程序无法继续执行</span></span><br><span class="line">    InetSocketAddress remoteAddress = (InetSocketAddress) socketChannel.getRemoteAddress();</span><br><span class="line">    <span class="comment">// 其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非阻塞模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">// 新连接没到达之前，后面程序一直循环，直到检测到socketChannel不为null时进入真正的执行逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InetSocketAddress remoteAddress = (InetSocketAddress) socketChannel.getRemoteAddress();</span><br><span class="line">        <span class="comment">// 其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(五). 关闭ServerSocketChannel</strong></p>
<p>通过调用<code>ServerSocketChannel.close()</code>方法来关闭<code>ServerSocketChannel</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure>
<h4 id="ServerSocketChannel的完整示例"><a href="#ServerSocketChannel的完整示例" class="headerlink" title="ServerSocketChannel的完整示例"></a>ServerSocketChannel的完整示例</h4><p><strong>(一). 阻塞模式</strong></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blockingTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">25000</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"ServerSocketChannel listening on 25000..."</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        InetSocketAddress remoteAddress = (InetSocketAddress) socketChannel.getRemoteAddress();</span><br><span class="line">        System.out.println(<span class="string">"Remote address: "</span> + remoteAddress.getHostString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://ols3fdyll.bkt.clouddn.com/serversocket_channel_blocking_result.png" alt=""></p>
<p><strong>(二). 非阻塞模式</strong></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonBlockingTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">25001</span>));</span><br><span class="line">    System.out.println(<span class="string">"ServerSocketChannel listening on 25001..."</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        System.out.println(<span class="string">"SocketChannel： "</span> + socketChannel);</span><br><span class="line">        <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            InetSocketAddress remoteAddress = (InetSocketAddress) socketChannel.getRemoteAddress();</span><br><span class="line">            System.out.println(<span class="string">"Remote address: "</span> + remoteAddress.getHostString());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://ols3fdyll.bkt.clouddn.com/serversocket_channel_non_blocking_result.png" alt=""></p>
<hr>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p><code>Java NIO</code>中的<code>SocketChannel</code>是一个连接到<code>TCP</code><strong>网络套接字</strong>的<strong>通道</strong>，它是<code>Socket</code>类的对等类。</p>
<p>通常<code>SocketChannel</code>在<strong>客户端</strong>向<strong>服务器</strong>发起连接请求，每个<code>SocketChannel</code>对象创建时都关联一个对等的<code>Socket</code>对象。同样<code>SocketChannel</code>也可以运行在<strong>非阻塞模式</strong>下。</p>
<h4 id="SocketChannel的用法"><a href="#SocketChannel的用法" class="headerlink" title="SocketChannel的用法"></a>SocketChannel的用法</h4><p><code>SocketChannel</code>创建的方式有两种：</p>
<ul>
<li>客户端主动创建：客户端打开一个<code>SocketChannel</code>并连接到某台服务器上；</li>
<li>服务端被动创建：一个新连接到达<code>ServerSocketChannel</code>时，服务端会创建一个<code>SocketChannel</code>。</li>
</ul>
<p><strong>(一). 创建SocketChannel</strong></p>
<p>通过<code>SocketChannel</code>的静态方法<code>open()</code>创建<code>SocketChannel</code>对象。此时<strong>通道</strong>虽然打开，但并<strong>未建立连接</strong>。此时如果进行<code>I/O</code>操作会抛出<code>NotYetConnectedException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br></pre></td></tr></table></figure>
<p><strong>(二). 连接指定服务器</strong></p>
<p>通过<code>SocketChannel</code>对象的<code>connect()</code>连接指定地址。该通道一旦连接，将保持连接状态直到被关闭。可通过<code>isConnected()</code>来确定某个<code>SocketChannel</code>当前是否已连接。</p>
<ul>
<li><strong>阻塞模式</strong>：</li>
</ul>
<p>如果在<strong>客户端</strong>的<code>SocketChannel</code>阻塞模式下，即<strong>服务器端</strong>的<code>ServerSocketChannel</code>也为<strong>阻塞模式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">25000</span>));</span><br><span class="line"><span class="comment">// connect()方法调用以后，socketChannel底层的连接创建完成后，才会执行后面的打印语句</span></span><br><span class="line">System.out.println(<span class="string">"连接创建完成..."</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>非阻塞模式</strong>：</li>
</ul>
<blockquote>
<p>两点需要注意：其一，SocketChannel需要通过configureBlocking()设置为非阻塞模式；其二，非阻塞模式下，connect()方法调用后会异步返回，为了确定连接是否建立，需要调用finishConnect()的方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">25001</span>));</span><br><span class="line"><span class="comment">// connect()方法调用以后，异步返回，需要手动调用finishConnect确保连接创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!socketChannel.finishConnect())&#123;</span><br><span class="line">    <span class="comment">// 检测到还未创建成功则睡眠10ms</span></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"连接创建完成..."</span>);</span><br></pre></td></tr></table></figure>
<p><strong>(三). 从SocketChannel读数据</strong></p>
<p>利用<code>SocketChannel</code>对象的<code>read()</code>方法将数据从<code>SocketChannel</code><strong>读取</strong>到<code>Buffer</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞模式下，read()方法在尚未读取到任何数据时可能就返回了，所以需要关注它的int返回值。</span></span><br><span class="line"><span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(四). 向SocketChannel写数据</strong></p>
<p>利用<code>SocketChannel</code>对象的<code>write()</code>将<code>Buffer</code>的数据<strong>写入</strong><code>SocketChannel</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">byteBuffer.put(<span class="string">"Client Blocking SocketChannel"</span>.getBytes());</span><br><span class="line"><span class="comment">// byteBuffer.put("Client Non-Blocking SocketChannel".getBytes());</span></span><br><span class="line">byteBuffer.flip();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()</span></span><br><span class="line"><span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">    socketChannel.write(byteBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保持睡眠，观察控制台输出</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">20000</span>);</span><br><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<p><strong>(五). 关闭SocketChannel</strong></p>
<p>利用<code>SocketChannel</code>对象的<code>close()</code>方法关闭<code>SocketChannel</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<h4 id="SocketChannel的完整示例"><a href="#SocketChannel的完整示例" class="headerlink" title="SocketChannel的完整示例"></a>SocketChannel的完整示例</h4><p><strong>(一). 阻塞模式</strong></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blockingWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">    socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">25000</span>));</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"Client Blocking SocketChannel"</span>.getBytes());</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">20000</span>);</span><br><span class="line">    socketChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端打印结果：</p>
<p><img src="http://ols3fdyll.bkt.clouddn.com/blocking_socketchannel_write_test.png" alt=""></p>
<p><strong>(一). 非阻塞模式</strong></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonBlockingWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">25001</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!socketChannel.finishConnect())&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"Client Non-Blocking SocketChannel"</span>.getBytes());</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">20000</span>);</span><br><span class="line">    socketChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端打印结果：</p>
<p><img src="http://ols3fdyll.bkt.clouddn.com/nonblocking_socketchannel_write_test.png" alt=""></p>
<hr>
<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p><code>Java NIO</code>中的<code>DatagramChannel</code>是一个能收发<code>UDP</code><strong>包</strong>的通道，其底层实现为<code>DatagramSocket + Selector</code>。<code>DatagramChannel</code>可以调用<code>socket()</code>方法获取对等<code>DatagramSocket</code>对象。<br><code>DatagramChannel</code>对象既可以充当<strong>服务端（监听者）</strong>，也可以充当<strong>客户端（发送者）</strong>。如果需要新创建的通道负责监听，那么该通道必须绑定一个端口（或端口组）：</p>
<h4 id="DatagramChannel的完整示例"><a href="#DatagramChannel的完整示例" class="headerlink" title="DatagramChannel的完整示例"></a>DatagramChannel的完整示例</h4><p>数据报发送方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.wrap(<span class="string">"DatagramChannel Sender"</span>.getBytes());</span><br><span class="line">    <span class="keyword">int</span> byteSent = datagramChannel.send(byteBuffer, <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">50020</span>));</span><br><span class="line">    System.out.println(<span class="string">"Byte sent is: "</span> + byteSent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据报接收方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">    datagramChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">50020</span>));</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    datagramChannel.receive(byteBuffer);</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行<code>DatagramChannelReceiveTest</code>，再运行<code>DatagramChannelSendTest</code>，观察控制台输出：</p>
<p>数据报发送方：</p>
<p><img src="http://ols3fdyll.bkt.clouddn.com/datagramchannel_sender.png" alt=""></p>
<p>数据报接收方：</p>
<p><img src="http://ols3fdyll.bkt.clouddn.com/datagramchannel_recevirer.png" alt=""></p>
<hr>
<h2 id="工具类Channels"><a href="#工具类Channels" class="headerlink" title="工具类Channels"></a>工具类Channels</h2><p><code>NIO</code>通道提供了一个便捷的<strong>通道类</strong><code>Channels</code>，其中定义了几种<strong>静态的工厂方法</strong>以简化<strong>通道</strong>和<strong>流</strong>转换。其中常用的方法如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>newChannel(InputStream in)</td>
<td>ReadableByteChannel</td>
<td>返回一个将从给定的输入流读取数据的通道。</td>
</tr>
<tr>
<td>newChannel(OutputStream out)</td>
<td>WritableByteChannel</td>
<td>返回一个将向给定的输出流写入数据的通道。</td>
</tr>
<tr>
<td>newInputStream(ReadableByteChannel ch)</td>
<td>InputStream</td>
<td>返回一个将从给定的通道读取字节的流。</td>
</tr>
<tr>
<td>newOutputStream(WritableByteChannel ch)</td>
<td>OutputStream</td>
<td>返回一个将向给定的通道写入字节的流。</td>
</tr>
<tr>
<td>newReader(ReadableByteChannel ch, CharsetDecoder dec, int minBufferCap)</td>
<td>Reader</td>
<td>返回一个reader，它将从给定的通道读取字节并依据提供的字符集名称对读取到的字节进行解码。</td>
</tr>
<tr>
<td>newReader(ReadableByteChannel ch, String csName)</td>
<td>Reader</td>
<td>返回一个reader，它将从给定的通道读取字节并依据提供的字符集名称将读取到的字节解码成字符。</td>
</tr>
<tr>
<td>newWriter(WritableByteChannel ch, CharsetEncoder dec, int minBufferCap)</td>
<td>Writer</td>
<td>返回一个writer，它将使用提供的字符集名称对字符编码并写到给定的通道中。</td>
</tr>
<tr>
<td>newWriter(WritableByteChannel ch, String csName)</td>
<td>Writer</td>
<td>返回一个writer，它将依据提供的字符集名称对字符编码并写到给定的通道中。</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文针对<code>NIO</code>中的通道的做了详细的介绍，对于<strong>文件通道</strong><code>FileChannel</code>，<strong>网络通道</strong><code>SocketChannel</code>、<code>ServerSocketChannel</code>和<code>DatagramChannel</code>进行了实战演示。</p>
<p>篇幅较长，可见<code>NIO</code>提供的原生的通道<code>API</code>在使用上并不是太容易。</p>
<hr>
<p>欢迎扫码关注我的个人技术公众号： 零壹技术栈</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10548396-035e78bdc34c7525?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>本帐号将持续分享后端技术干货，包括虚拟机基础，多线程编程，高性能框架，异步、缓存和消息中间件，分布式和微服务，架构学习和进阶等学习资料和文章。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://ostenant.coding.me/2017/12/27/Java NIO系列(三) - Channel/" data-id="cjhtxvruu0019fn4u9xfysccn" class="article-share-link" data-share="baidu" data-title="Java NIO系列(三) - Channel">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
	
  
    
<nav id="article-nav">
  
    <a href="/2017/12/31/Java NIO系列(四) - Selector/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          Java NIO系列(四) - Selector
        
      </div>
    </a>
  
  
    <a href="/2017/12/26/Java NIO系列(二) - Buffer/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Java NIO系列(二) - Buffer</div>
    </a>
  
</nav>

  
</article>








</section>
      
      <aside id="sidebar">
  
    
<div class="widget-wrap">
  <h3 class="widget-title">关于我</h3>
  <ul class="widget about-me">
    
    <li><img class="author" title="About me" src="/img/favicon.png" /></li>
    
    
    <li>ostenant@163.com</li>
    
    <li>一枚热爱生活，追逐自由的小技术！</li>
    
  </ul>
</div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习系列/">Docker学习系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ECMAScript基础系列/">ECMAScript基础系列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA编程进阶系列/">JAVA编程进阶系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA虚拟机系列/">JAVA虚拟机系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA设计模式系列/">JAVA设计模式系列</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDK1-8编程系列/">JDK1.8编程系列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java编程基础系列/">Java编程基础系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java编程进阶系列/">Java编程进阶系列</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java虚拟机系列/">Java虚拟机系列</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC通信框架系列/">RPC通信框架系列</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava异步框架系列/">RxJava异步框架系列</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Boot-2-0系列/">Spring Boot 2.0系列</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Boot-2-0系列/Spring-Reactive编程系列/">Spring Reactive编程系列</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Reactive编程系列/">Spring Reactive编程系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式系列/">分布式系列</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务系列/">微服务系列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构学习系列/">架构学习系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议系列/">网络协议系列</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/认证与授权系列/">认证与授权系列</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/2PC/">2PC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/3PC/">3PC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Adapter/">Adapter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache/">Apache</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BASE/">BASE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Builder/">Builder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/">CAP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS/">CentOS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Consul/">Consul</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Consul-template/">Consul-template</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript/">ECMAScript</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/">HTTPS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/">JDK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK1-8/">JDK1.8</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OAuth-2-0/">OAuth 2.0</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prototype/">Prototype</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactive-Streams/">Reactive Streams</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/">Reactor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reference/">Reference</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Registrator/">Registrator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOFA-Boot/">SOFA-Boot</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOFA-RPC/">SOFA-RPC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOFA-RPC/">SOFA_RPC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Singleton/">Singleton</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot-2-0/">Spring Boot 2.0</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-WebFlux/">Spring WebFlux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thrift/">Thrift</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unique-ID/">Unique ID</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步/">异步</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/2PC/" style="font-size: 10px;">2PC</a> <a href="/tags/3PC/" style="font-size: 10px;">3PC</a> <a href="/tags/Adapter/" style="font-size: 10px;">Adapter</a> <a href="/tags/Android/" style="font-size: 13.33px;">Android</a> <a href="/tags/Apache/" style="font-size: 13.33px;">Apache</a> <a href="/tags/BASE/" style="font-size: 10px;">BASE</a> <a href="/tags/Builder/" style="font-size: 10px;">Builder</a> <a href="/tags/CAP/" style="font-size: 10px;">CAP</a> <a href="/tags/CentOS/" style="font-size: 10px;">CentOS</a> <a href="/tags/Consul/" style="font-size: 11.67px;">Consul</a> <a href="/tags/Consul-template/" style="font-size: 10px;">Consul-template</a> <a href="/tags/Docker/" style="font-size: 13.33px;">Docker</a> <a href="/tags/ECMAScript/" style="font-size: 11.67px;">ECMAScript</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/JDK1-8/" style="font-size: 11.67px;">JDK1.8</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Java/" style="font-size: 18.33px;">Java</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/OAuth-2-0/" style="font-size: 10px;">OAuth 2.0</a> <a href="/tags/Prototype/" style="font-size: 10px;">Prototype</a> <a href="/tags/RPC/" style="font-size: 20px;">RPC</a> <a href="/tags/Reactive-Streams/" style="font-size: 11.67px;">Reactive Streams</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/Reference/" style="font-size: 10px;">Reference</a> <a href="/tags/Registrator/" style="font-size: 10px;">Registrator</a> <a href="/tags/RxJava/" style="font-size: 13.33px;">RxJava</a> <a href="/tags/SOFA-Boot/" style="font-size: 13.33px;">SOFA-Boot</a> <a href="/tags/SOFA-RPC/" style="font-size: 11.67px;">SOFA-RPC</a> <a href="/tags/SOFA-RPC/" style="font-size: 11.67px;">SOFA_RPC</a> <a href="/tags/Singleton/" style="font-size: 10px;">Singleton</a> <a href="/tags/Spring-Boot-2-0/" style="font-size: 10px;">Spring Boot 2.0</a> <a href="/tags/Spring-Cloud/" style="font-size: 11.67px;">Spring Cloud</a> <a href="/tags/Spring-WebFlux/" style="font-size: 11.67px;">Spring WebFlux</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Thrift/" style="font-size: 16.67px;">Thrift</a> <a href="/tags/Unique-ID/" style="font-size: 10px;">Unique ID</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/WebSocket/" style="font-size: 10px;">WebSocket</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/异步/" style="font-size: 13.33px;">异步</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/27/实战Spring Boot 2.0 Reactive编程系列(一) - WebFlux初体验/">实战Spring Boot 2.0 Reactive编程系列(一) - WebFlux初体验</a>
          </li>
        
          <li>
            <a href="/2018/05/26/聊聊Spring Reactor反应式编程/">聊聊Spring Reactor反应式编程</a>
          </li>
        
          <li>
            <a href="/2018/05/23/Android异步框架RxJava 1.x系列(三) - 线程调度器Scheduler/">Android异步框架RxJava 1.x系列(三) - 线程调度器Scheduler</a>
          </li>
        
          <li>
            <a href="/2018/05/21/Android异步框架RxJava 1.x系列(二) - 事件及事件序列转换原理/">Android异步框架RxJava 1.x系列(二) - 事件及事件序列转换原理</a>
          </li>
        
          <li>
            <a href="/2018/05/20/Android异步框架RxJava 1.x系列(一) - 观察者模式及实现/">Android异步框架RxJava 1.x系列(一) - 观察者模式及实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://weekly.manong.io/issues" target="_blank">码农周刊</a>
          </li>
        
          <li>
            <a href="https://www.tuicool.com/mags" target="_blank">编程狂人</a>
          </li>
        
          <li>
            <a href="http://ifeve.com" target="_blank">并发编程网</a>
          </li>
        
          <li>
            <a href="https://juejin.im" target="_blank">掘金</a>
          </li>
        
          <li>
            <a href="http://www.jianshu.com" target="_blank">简书</a>
          </li>
        
          <li>
            <a href="https://github.com" target="_blank">Github</a>
          </li>
        
          <li>
            <a href="https://stackoverflow.com" target="_blank">StackoverFlow</a>
          </li>
        
          <li>
            <a href="http://www.infoq.com" target="_blank">Infoq</a>
          </li>
        
          <li>
            <a href="https://segmentfault.com" target="_blank">SegmentFault</a>
          </li>
        
          <li>
            <a href="http://www.importnew.com" target="_blank">ImportNew</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Chen Harrison<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="https://github.com/ostenant" class="mobile-nav-link">Github</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!--

-->



   

<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>



<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/js/script.js"></script>


</div>
</body>
</html>
